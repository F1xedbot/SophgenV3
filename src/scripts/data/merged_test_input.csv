func_name,raw_code,roi,merged_roi_lines,cwe_ids
aio_setup_single_vector_1,"static ssize_t aio_setup_single_vector_1(struct kiocb *kiocb)
static ssize_t aio_setup_single_vector_1(int type, struct file * file, struct kiocb *kiocb)
 {
	int bytes;

	bytes = rw_verify_area(type, file, &kiocb->ki_pos, kiocb->ki_left);
	if (bytes < 0)
		return bytes;

 	kiocb->ki_iovec = &kiocb->ki_inline_vec;
 	kiocb->ki_iovec->iov_base = kiocb->ki_buf;
	kiocb->ki_iovec->iov_len = bytes;
 	kiocb->ki_nr_segs = 1;
 	kiocb->ki_cur_seg = 0;
 	return 0;
}
","1. static ssize_t aio_setup_single_vector_1(int type, struct file * file, struct kiocb *kiocb)
2. bytes = rw_verify_area(type, file, &kiocb->ki_pos, kiocb->ki_left);
if (bytes < 0)
return bytes;
3. kiocb->ki_iovec = &kiocb->ki_inline_vec;
kiocb->ki_iovec->iov_base = kiocb->ki_buf;
kiocb->ki_iovec->iov_len = bytes;
4. kiocb->ki_cur_seg = 0;
return 0;","2
6-8
10-12
14-15","CWE-17,CWE-399,CWE-119"
plot_spectrum_column-252701104198994,"
#define AVFilterLink
#define AVFrame

static int plot_spectrum_column(AVFilterLink *inlink, AVFrame *insamples)
{
    AVFilterContext *ctx = inlink->dst;
    AVFilterLink *outlink = ctx->outputs[0];
    ShowSpectrumContext *s = ctx->priv;
    AVFrame *outpicref = s->outpicref;
    int ret, plane, x, y, z = s->orientation == VERTICAL ? s->h : s->w;

    
    
    clear_combine_buffer(s, z);

    ff_filter_execute(ctx, s->plot_channel, NULL, NULL, s->nb_display_channels);

    for (y = 0; y < z * 3; y++) {
        for (x = 0; x < s->nb_display_channels; x++) {
            s->combine_buffer[y] += s->color_buffer[x][y];
        }
    }

    av_frame_make_writable(s->outpicref);
    
    if (s->orientation == VERTICAL) {
        if (s->sliding == SCROLL) {
            for (plane = 0; plane < 3; plane++) {
                for (y = 0; y < s->h; y++) {
                    uint8_t *p = outpicref->data[plane] + s->start_x +
                                 (y + s->start_y) * outpicref->linesize[plane];
                    memmove(p, p + 1, s->w - 1);
                }
            }
            s->xpos = s->w - 1;
        } else if (s->sliding == RSCROLL) {
            for (plane = 0; plane < 3; plane++) {
                for (y = 0; y < s->h; y++) {
                    uint8_t *p = outpicref->data[plane] + s->start_x +
                                 (y + s->start_y) * outpicref->linesize[plane];
                    memmove(p + 1, p, s->w - 1);
                }
            }
            s->xpos = 0;
        }
        for (plane = 0; plane < 3; plane++) {
            uint8_t *p = outpicref->data[plane] + s->start_x +
                         (outlink->h - 1 - s->start_y) * outpicref->linesize[plane] +
                         s->xpos;
            for (y = 0; y < s->h; y++) {
                *p = lrintf(av_clipf(s->combine_buffer[3 * y + plane], 0, 255));
                p -= outpicref->linesize[plane];
            }
        }
    } else {
        if (s->sliding == SCROLL) {
            for (plane = 0; plane < 3; plane++) {
                for (y = 1; y < s->h; y++) {
                    memmove(outpicref->data[plane] + (y-1 + s->start_y) * outpicref->linesize[plane] + s->start_x,
                            outpicref->data[plane] + (y   + s->start_y) * outpicref->linesize[plane] + s->start_x,
                            s->w);
                }
            }
            s->xpos = s->h - 1;
        } else if (s->sliding == RSCROLL) {
            for (plane = 0; plane < 3; plane++) {
                for (y = s->h - 1; y >= 1; y--) {
                    memmove(outpicref->data[plane] + (y   + s->start_y) * outpicref->linesize[plane] + s->start_x,
                            outpicref->data[plane] + (y-1 + s->start_y) * outpicref->linesize[plane] + s->start_x,
                            s->w);
                }
            }
            s->xpos = 0;
        }
        for (plane = 0; plane < 3; plane++) {
            uint8_t *p = outpicref->data[plane] + s->start_x +
                         (s->xpos + s->start_y) * outpicref->linesize[plane];
            for (x = 0; x < s->w; x++) {
                *p = lrintf(av_clipf(s->combine_buffer[3 * x + plane], 0, 255));
                p++;
            }
        }
    }

    if (s->sliding != FULLFRAME || s->xpos == 0)
        s->pts = outpicref->pts = av_rescale_q(insamples->pts, inlink->time_base, outlink->time_base);

    if (s->sliding == LREPLACE) {
        s->xpos--;
        if (s->orientation == VERTICAL && s->xpos < 0)
            s->xpos = s->w - 1;
        if (s->orientation == HORIZONTAL && s->xpos < 0)
            s->xpos = s->h - 1;
    } else {
        s->xpos++;
        if (s->orientation == VERTICAL && s->xpos >= s->w)
            s->xpos = 0;
        if (s->orientation == HORIZONTAL && s->xpos >= s->h)
            s->xpos = 0;
    }

    if (!s->single_pic && (s->sliding != FULLFRAME || s->xpos == 0)) {
        if (s->old_pts < outpicref->pts) {
            AVFrame *clone;

            if (s->legend) {
                char *units = get_time(ctx, insamples->pts /(float)inlink->sample_rate, x);
                if (!units)
                    return AVERROR(ENOMEM);

                if (s->orientation == VERTICAL) {
                    for (y = 0; y < 10; y++) {
                        memset(s->outpicref->data[0] + outlink->w / 2 - 4 * s->old_len +
                               (outlink->h - s->start_y / 2 - 20 + y) * s->outpicref->linesize[0], 0, 10 * s->old_len);
                    }
                    drawtext(s->outpicref,
                             outlink->w / 2 - 4 * strlen(units),
                             outlink->h - s->start_y / 2 - 20,
                             units, 0);
                } else  {
                    for (y = 0; y < 10 * s->old_len; y++) {
                        memset(s->outpicref->data[0] + s->start_x / 7 + 20 +
                               (outlink->h / 2 - 4 * s->old_len + y) * s->outpicref->linesize[0], 0, 10);
                    }
                    drawtext(s->outpicref,
                             s->start_x / 7 + 20,
                             outlink->h / 2 - 4 * strlen(units),
                             units, 1);
                }
                s->old_len = strlen(units);
                av_free(units);
            }
            s->old_pts = outpicref->pts;
            clone = av_frame_clone(s->outpicref);
            if (!clone)
                return AVERROR(ENOMEM);
            ret = ff_filter_frame(outlink, clone);
            if (ret < 0)
                return ret;
            return 0;
        }
    }

    return 1;
}
","1. clear_combine_buffer(s, z);
2. for (y = 0; y < z * 3; y++) {
3. if (s->orientation == HORIZONTAL && s->xpos >= s->h)
4. if (!units)
5. drawtext(s->outpicref,
6. clone = av_frame_clone(s->outpicref);","15
19
99
109
126
135","CWE-200,CWE-22,CWE-399"
tcp_send_challenge_ack-149168013485365,"static void tcp_send_challenge_ack(struct sock *sk, const struct sk_buff *skb)
{
	
	static u32 challenge_timestamp;
	static unsigned int challenge_count;
	struct tcp_sock *tp = tcp_sk(sk);
	u32 count, now;

	
	if (tcp_oow_rate_limited(sock_net(sk), skb,
				 LINUX_MIB_TCPACKSKIPPEDCHALLENGE,
				 &tp->last_oow_ack_time))
		return;

	
	now = jiffies / HZ;
	if (now != challenge_timestamp) {
		u32 half = (sysctl_tcp_challenge_ack_limit + 1) >> 1;

		challenge_timestamp = now;
		WRITE_ONCE(challenge_count, half +
			   prandom_u32_max(sysctl_tcp_challenge_ack_limit));
	}
	count = READ_ONCE(challenge_count);
	if (count > 0) {
		WRITE_ONCE(challenge_count, count - 1);
		NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPCHALLENGEACK);
		tcp_send_ack(sk);
	}
}
","1. static unsigned int challenge_count;
2. return;
3. tcp_send_ack(sk);","5
13
28","CWE-200,CWE-20,CWE-119"
format_fractional_part_nsecs-212750082725517,"int
format_fractional_part_nsecs(gchar *buf, size_t buflen, guint32 nsecs, const char *decimal_point, int precision)
{
	gchar *ptr;
	size_t remaining;
	int num_bytes;
	gsize decimal_point_len;
	guint32 frac_part;
	gint8 num_buf[CHARS_NANOSECONDS];
	gint8 *num_end = &num_buf[CHARS_NANOSECONDS];
	gint8 *num_ptr;
	size_t num_len;

	ws_assert(precision != 0);

	if (buflen == 0) {
		
		return 0;
	}

	
	if (nsecs >= 1000000000U) {
		num_bytes = snprintf(buf, buflen, ""%s(%u nanoseconds)"",
		    decimal_point, nsecs);
		if ((unsigned int)num_bytes >= buflen) {
			
			return (int)(buflen - 1);
		}
		return num_bytes;
	}

	ptr = buf;
	remaining = buflen;
	num_bytes = 0;

	
	decimal_point_len = g_strlcpy(buf, decimal_point, buflen);
	if (decimal_point_len >= buflen) {
		
		return (int)(buflen - 1);
	}
	ptr += decimal_point_len;
	remaining -= decimal_point_len;
	num_bytes += decimal_point_len;

	
	switch (precision) {

	case 1:
		
		frac_part = nsecs / 100000000U;
		break;

	case 2:
		
		frac_part = nsecs / 10000000U;
		break;

	case 3:
		
		frac_part = nsecs / 1000000U;
		break;

	case 4:
		
		frac_part = nsecs / 100000U;
		break;

	case 5:
		
		frac_part = nsecs / 10000U;
		break;

	case 6:
		
		frac_part = nsecs / 1000U;
		break;

	case 7:
		
		frac_part = nsecs / 100U;
		break;

	case 8:
		
		frac_part = nsecs / 10U;
		break;

	case 9:
		
		frac_part = nsecs;
		break;

	default:
		ws_assert_not_reached();
		break;
	}

	num_ptr = uint_to_str_back_len(num_end, frac_part, precision);

	
	num_len = MIN((size_t)(num_end - num_ptr), remaining - 1);
	if (num_len == 0) {
		
		return num_bytes;
	}

	
	memcpy(ptr, num_ptr, num_len);
	ptr += num_len;
	num_bytes += num_len;

	
	*ptr = '\0';
	return num_bytes;
}
","1. format_fractional_part_nsecs(gchar *buf, size_t buflen, guint32 nsecs, const char *decimal_point, int precision)
2. gchar *ptr;
size_t remaining;
3. gint8 num_buf[CHARS_NANOSECONDS];
4. ws_assert(precision != 0);
5. return 0;
6. if (nsecs >= 1000000000U) {
7. decimal_point, nsecs);
if ((unsigned int)num_bytes >= buflen) {
8. remaining = buflen;
9. if (decimal_point_len >= buflen) {
10. remaining -= decimal_point_len;
11. frac_part = nsecs / 100000U;
12. frac_part = nsecs;","2
4-5
9
14
21
28
30-31
45
52
63
108
143","CWE-200,CWE-59,CWE-399,CWE-119"
do_command-75250744471174,"int
do_command (unsigned char c)
{
	static int dtr_up = 0;
	int newbaud, newflow, newparity, newbits;
	const char *xfr_cmd;
	char *fname;
	int r;

	switch (c) {
	case KEY_EXIT:
		return 1;
	case KEY_QUIT:
		term_set_hupcl(tty_fd, 0);
		term_flush(tty_fd);
		term_apply(tty_fd);
		term_erase(tty_fd);
		return 1;
	case KEY_STATUS:
		show_status(dtr_up);
		break;
	case KEY_PULSE:
		fd_printf(STO, ""\r\n*** pulse DTR ***\r\n"");
		if ( term_pulse_dtr(tty_fd) < 0 )
			fd_printf(STO, ""*** FAILED\r\n"");
		break;
	case KEY_TOGGLE:
		if ( dtr_up )
			r = term_lower_dtr(tty_fd);
		else
			r = term_raise_dtr(tty_fd);
		if ( r >= 0 ) dtr_up = ! dtr_up;
		fd_printf(STO, ""\r\n*** DTR: %s ***\r\n"", 
				  dtr_up ? ""up"" : ""down"");
		break;
	case KEY_BAUD_UP:
	case KEY_BAUD_DN:
		if (c == KEY_BAUD_UP)
			opts.baud = baud_up(opts.baud);
		else 
			opts.baud = baud_down(opts.baud);
		term_set_baudrate(tty_fd, opts.baud);
		tty_q.len = 0; term_flush(tty_fd);
		term_apply(tty_fd);
		newbaud = term_get_baudrate(tty_fd, NULL);
		if ( opts.baud != newbaud ) {
			fd_printf(STO, ""\r\n*** baud: %d (%d) ***\r\n"", 
					  opts.baud, newbaud);
		} else {
			fd_printf(STO, ""\r\n*** baud: %d ***\r\n"", opts.baud);
		}
		set_tty_write_sz(newbaud);
		break;
	case KEY_FLOW:
		opts.flow = flow_next(opts.flow);
		term_set_flowcntrl(tty_fd, opts.flow);
		tty_q.len = 0; term_flush(tty_fd);
		term_apply(tty_fd);
		newflow = term_get_flowcntrl(tty_fd);
		if ( opts.flow != newflow ) {
			fd_printf(STO, ""\r\n*** flow: %s (%s) ***\r\n"", 
					  flow_str[opts.flow], flow_str[newflow]);
		} else {
			fd_printf(STO, ""\r\n*** flow: %s ***\r\n"", 
					  flow_str[opts.flow]);
		}
		break;
	case KEY_PARITY:
		opts.parity = parity_next(opts.parity);
		term_set_parity(tty_fd, opts.parity);
		tty_q.len = 0; term_flush(tty_fd);
		term_apply(tty_fd);
		newparity = term_get_parity(tty_fd);
		if (opts.parity != newparity ) {
			fd_printf(STO, ""\r\n*** parity: %s (%s) ***\r\n"",
					  parity_str[opts.parity], 
					  parity_str[newparity]);
		} else {
			fd_printf(STO, ""\r\n*** parity: %s ***\r\n"", 
					  parity_str[opts.parity]);
		}
		break;
	case KEY_BITS:
		opts.databits = bits_next(opts.databits);
		term_set_databits(tty_fd, opts.databits);
		tty_q.len = 0; term_flush(tty_fd);
		term_apply(tty_fd);
		newbits = term_get_databits(tty_fd);
		if (opts.databits != newbits ) {
			fd_printf(STO, ""\r\n*** databits: %d (%d) ***\r\n"",
					  opts.databits, newbits);
		} else {
			fd_printf(STO, ""\r\n*** databits: %d ***\r\n"", 
					  opts.databits);
		}
		break;
	case KEY_LECHO:
		opts.lecho = ! opts.lecho;
		fd_printf(STO, ""\r\n*** local echo: %s ***\r\n"", 
				  opts.lecho ? ""yes"" : ""no"");
		break;
	case KEY_SEND:
	case KEY_RECEIVE:
		xfr_cmd = (c == KEY_SEND) ? opts.send_cmd : opts.receive_cmd;
		if ( xfr_cmd[0] == '\0' ) {
			fd_printf(STO, ""\r\n*** command disabled ***\r\n"");
			break;
		}
		fname = read_filename();
		if (fname == NULL) {
			fd_printf(STO, ""*** cannot read filename ***\r\n"");
			break;
		}
		run_cmd(tty_fd, xfr_cmd, fname);
		free(fname);
		break;
	case KEY_BREAK:
		term_break(tty_fd);
		fd_printf(STO, ""\r\n*** break sent ***\r\n"");
		break;
	default:
		break;
	}

	return 0;
}
","1. case KEY_QUIT:
2. fd_printf(STO, ""*** FAILED\r\n"");
3. if ( dtr_up )
4. tty_q.len = 0; term_flush(tty_fd);
5. break;
6. case KEY_BREAK:","13
25
28
43
107
117","CWE-89,CWE-20,CWE-125,CWE-119"
Reverb_command_2,"int Reverb_command_2(effect_handle_t  self,
 uint32_t            cmdCode,
 uint32_t            cmdSize,
 void *pCmdData,
 uint32_t *replySize,
 void *pReplyData){
    android::ReverbContext * pContext = (android::ReverbContext *) self;
 int retsize;
    LVREV_ControlParams_st    ActiveParams; 
    LVREV_ReturnStatus_en     LvmStatus=LVREV_SUCCESS; 


 if (pContext == NULL){
        ALOGV(""\tLVM_ERROR : Reverb_command_2 ERROR pContext == NULL"");
 return -EINVAL;
 }


 switch (cmdCode){
 case EFFECT_CMD_INIT:

 if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)){
                ALOGV(""\tLVM_ERROR : Reverb_command_2 cmdCode Case: ""
 ""EFFECT_CMD_INIT: ERROR"");
 return -EINVAL;
 }
 *(int *) pReplyData = 0;
 break;

 case EFFECT_CMD_SET_CONFIG:
 if (pCmdData == NULL || cmdSize != sizeof(effect_config_t) ||
                    pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {
                ALOGV(""\tLVM_ERROR : Reverb_command_2 cmdCode Case: ""
 ""EFFECT_CMD_SET_CONFIG: ERROR"");
 return -EINVAL;
 }
 *(int *) pReplyData = android::Reverb_setConfig(pContext,
 (effect_config_t *) pCmdData);
 break;

 case EFFECT_CMD_GET_CONFIG:
 if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(effect_config_t)) {
                ALOGV(""\tLVM_ERROR : Reverb_command_2 cmdCode Case: ""
 ""EFFECT_CMD_GET_CONFIG: ERROR"");
 return -EINVAL;
 }

            android::Reverb_getConfig(pContext, (effect_config_t *)pReplyData);
 break;

 case EFFECT_CMD_RESET:
 Reverb_setConfig(pContext, &pContext->config);
 break;

 case EFFECT_CMD_GET_PARAM:{

             effect_param_t *p = (effect_param_t *)pCmdData;
            if (SIZE_MAX - sizeof(effect_param_t) < (size_t)p->psize) {
                android_errorWriteLog(0x534e4554, ""26347509"");
                return -EINVAL;
            }
             if (pCmdData == NULL || cmdSize < sizeof(effect_param_t) ||
                     cmdSize < (sizeof(effect_param_t) + p->psize) ||
                     pReplyData == NULL || replySize == NULL ||
 *replySize < (sizeof(effect_param_t) + p->psize)) {
                ALOGV(""\tLVM_ERROR : Reverb_command_2 cmdCode Case: ""
 ""EFFECT_CMD_GET_PARAM: ERROR"");
 return -EINVAL;
 }

            memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + p->psize);

            p = (effect_param_t *)pReplyData;

 int voffset = ((p->psize - 1) / sizeof(int32_t) + 1) * sizeof(int32_t);

            p->status = android::Reverb_getParameter(pContext,
 (void *)p->data,
 (size_t *)&p->vsize,
                                                          p->data + voffset);

 *replySize = sizeof(effect_param_t) + voffset + p->vsize;


 } break;
 case EFFECT_CMD_SET_PARAM:{


 if (pCmdData == NULL || (cmdSize < (sizeof(effect_param_t) + sizeof(int32_t))) ||
                    pReplyData == NULL ||  replySize == NULL || *replySize != sizeof(int32_t)) {
                ALOGV(""\tLVM_ERROR : Reverb_command_2 cmdCode Case: ""
 ""EFFECT_CMD_SET_PARAM: ERROR"");
 return -EINVAL;
 }

 effect_param_t *p = (effect_param_t *) pCmdData;

 if (p->psize != sizeof(int32_t)){
                ALOGV(""\t4LVM_ERROR : Reverb_command_2 cmdCode Case: ""
 ""EFFECT_CMD_SET_PARAM: ERROR, psize is not sizeof(int32_t)"");
 return -EINVAL;
 }


 *(int *)pReplyData = android::Reverb_setParameter(pContext,
 (void *)p->data,
                                                              p->data + p->psize);
 } break;

 case EFFECT_CMD_ENABLE:

 if (pReplyData == NULL || *replySize != sizeof(int)){
                ALOGV(""\tLVM_ERROR : Reverb_command_2 cmdCode Case: ""
 ""EFFECT_CMD_ENABLE: ERROR"");
 return -EINVAL;
 }
 if(pContext->bEnabled == LVM_TRUE){
                 ALOGV(""\tLVM_ERROR : Reverb_command_2 cmdCode Case: ""
 ""EFFECT_CMD_ENABLE: ERROR-Effect is already enabled"");
 return -EINVAL;
 }
 *(int *)pReplyData = 0;
            pContext->bEnabled = LVM_TRUE;
 
 LvmStatus = LVREV_GetControlParameters(pContext->hInstance, &ActiveParams);
            LVM_ERROR_CHECK(LvmStatus, ""LVREV_GetControlParameters"", ""EFFECT_CMD_ENABLE"")
            pContext->SamplesToExitCount =
 (ActiveParams.T60 * pContext->config.inputCfg.samplingRate)/1000;
            pContext->volumeMode = android::REVERB_VOLUME_FLAT;
 break;
 case EFFECT_CMD_DISABLE:

 if (pReplyData == NULL || *replySize != sizeof(int)){
                ALOGV(""\tLVM_ERROR : Reverb_command_2 cmdCode Case: ""
 ""EFFECT_CMD_DISABLE: ERROR"");
 return -EINVAL;
 }
 if(pContext->bEnabled == LVM_FALSE){
                 ALOGV(""\tLVM_ERROR : Reverb_command_2 cmdCode Case: ""
 ""EFFECT_CMD_DISABLE: ERROR-Effect is not yet enabled"");
 return -EINVAL;
 }
 *(int *)pReplyData = 0;
            pContext->bEnabled = LVM_FALSE;
 break;

 case EFFECT_CMD_SET_VOLUME:
 if (pCmdData == NULL ||
                cmdSize != 2 * sizeof(uint32_t)) {
                ALOGV(""\tLVM_ERROR : Reverb_command_2 cmdCode Case: ""
 ""EFFECT_CMD_SET_VOLUME: ERROR"");
 return -EINVAL;
 }


 if (pReplyData != NULL) { 
                pContext->leftVolume = (LVM_INT16)((*(uint32_t *)pCmdData + (1 << 11)) >> 12);
                pContext->rightVolume = (LVM_INT16)((*((uint32_t *)pCmdData + 1) + (1 << 11)) >> 12);
 *(uint32_t *)pReplyData = (1 << 24);
 *((uint32_t *)pReplyData + 1) = (1 << 24);
 if (pContext->volumeMode == android::REVERB_VOLUME_OFF) {
                    pContext->volumeMode = android::REVERB_VOLUME_FLAT;
 }
 } else { 
                pContext->leftVolume = REVERB_UNIT_VOLUME;
                pContext->rightVolume = REVERB_UNIT_VOLUME;
                pContext->volumeMode = android::REVERB_VOLUME_OFF;
 }
            ALOGV(""EFFECT_CMD_SET_VOLUME left %d, right %d mode %d"",
                    pContext->leftVolume, pContext->rightVolume,  pContext->volumeMode);
 break;

 case EFFECT_CMD_SET_DEVICE:
 case EFFECT_CMD_SET_AUDIO_MODE:
 break;

 default:
            ALOGV(""\tLVM_ERROR : Reverb_command_2 cmdCode Case: ""
 ""DEFAULT start %d ERROR"",cmdCode);
 return -EINVAL;
 }

 return 0;
} 
","1. int Reverb_command_2(effect_handle_t  self,
2. uint32_t            cmdSize,
3. LVREV_ReturnStatus_en     LvmStatus=LVREV_SUCCESS;
4. if (pContext == NULL){
ALOGV(""\tLVM_ERROR : Reverb_command_2 ERROR pContext == NULL"");
5. case EFFECT_CMD_INIT:
6. if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)){
7. *(int *) pReplyData = 0;
break;
8. case EFFECT_CMD_SET_CONFIG:
if (pCmdData == NULL || cmdSize != sizeof(effect_config_t) ||
pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {
ALOGV(""\tLVM_ERROR : Reverb_command_2 cmdCode Case: ""
9. break;
10. break;
11. case EFFECT_CMD_GET_PARAM:{
12. effect_param_t *p = (effect_param_t *)pCmdData;
13. android_errorWriteLog(0x534e4554, ""26347509"");
14. memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + p->psize);
15. p->status = android::Reverb_getParameter(pContext,
16. case EFFECT_CMD_SET_PARAM:{
17. ALOGV(""\t4LVM_ERROR : Reverb_command_2 cmdCode Case: ""
18. *(int *)pReplyData = android::Reverb_setParameter(pContext,
19. } break;
20. if (pReplyData == NULL || *replySize != sizeof(int)){
21. return -EINVAL;
22. pContext->bEnabled = LVM_TRUE;
23. LvmStatus = LVREV_GetControlParameters(pContext->hInstance, &ActiveParams);
24. case EFFECT_CMD_DISABLE:
25. if (pReplyData == NULL || *replySize != sizeof(int)){
ALOGV(""\tLVM_ERROR : Reverb_command_2 cmdCode Case: ""
26. *(int *)pReplyData = 0;
27. if (pCmdData == NULL ||
cmdSize != 2 * sizeof(uint32_t)) {
ALOGV(""\tLVM_ERROR : Reverb_command_2 cmdCode Case: ""
28. pContext->leftVolume = (LVM_INT16)((*(uint32_t *)pCmdData + (1 << 11)) >> 12);
29. *((uint32_t *)pReplyData + 1) = (1 << 24);
30. pContext->volumeMode = android::REVERB_VOLUME_FLAT;
31. ALOGV(""EFFECT_CMD_SET_VOLUME left %d, right %d mode %d"",
pContext->leftVolume, pContext->rightVolume,  pContext->volumeMode);
break;
32. ""DEFAULT start %d ERROR"",cmdCode);
33. return 0;","1
3
10
13-14
20
22
27-28
30-33
39
53
55
57
59
71
77
86
99
105
108
112
120
123
125
131
133-134
143
148-150
157
160
162
169-171
179
183","CWE-401,CWE-125,CWE-119"
qedi_dbg_err-122946228132671,"void
qedi_dbg_err(struct qedi_dbg_ctx *qedi, const char *func, u32 line,
	     const char *fmt, ...)
{
	va_list va;
	struct va_format vaf;

	va_start(va, fmt);

	vaf.fmt = fmt;
	vaf.va = &va;

	if (likely(qedi) && likely(qedi->pdev))
		pr_err(""[%s]:[%s:%d]:%d: %pV"", dev_name(&qedi->pdev->dev),
		       func, line, qedi->host_no, &vaf);
	else
		pr_err(""[0000:00:00.0]:[%s:%d]: %pV"", func, line, &vaf);

	va_end(va);
}
","1. void
qedi_dbg_err(struct qedi_dbg_ctx *qedi, const char *func, u32 line,
2. va_list va;
3. va_start(va, fmt);
4. vaf.va = &va;
5. if (likely(qedi) && likely(qedi->pdev))
pr_err(""[%s]:[%s:%d]:%d: %pV"", dev_name(&qedi->pdev->dev),
func, line, qedi->host_no, &vaf);
6. pr_err(""[0000:00:00.0]:[%s:%d]: %pV"", func, line, &vaf);","1-2
5
8
11
13-15
17",CWE-125
read_request," static int read_request(int fd, debugger_request_t* out_request) {
   ucred cr;
   socklen_t len = sizeof(cr);
 int status = getsockopt(fd, SOL_SOCKET, SO_PEERCRED, &cr, &len);
 if (status != 0) {
    ALOGE(""cannot get credentials"");
 return -1;
 }

  ALOGV(""reading tid"");
  fcntl(fd, F_SETFL, O_NONBLOCK);

  pollfd pollfds[1];
  pollfds[0].fd = fd;
  pollfds[0].events = POLLIN;
  pollfds[0].revents = 0;
  status = TEMP_FAILURE_RETRY(poll(pollfds, 1, 3000));
 if (status != 1) {
    ALOGE(""timed out reading tid (from pid=%d uid=%d)\n"", cr.pid, cr.uid);
 return -1;
 }

 debugger_msg_t msg;
  memset(&msg, 0, sizeof(msg));
  status = TEMP_FAILURE_RETRY(read(fd, &msg, sizeof(msg)));
 if (status < 0) {
    ALOGE(""read failure? %s (pid=%d uid=%d)\n"", strerror(errno), cr.pid, cr.uid);
 return -1;
 }
 if (status != sizeof(debugger_msg_t)) {
    ALOGE(""invalid crash request of size %d (from pid=%d uid=%d)\n"", status, cr.pid, cr.uid);
 return -1;
 }

  out_request->action = static_cast<debugger_action_t>(msg.action);
  out_request->tid = msg.tid;
  out_request->pid = cr.pid;
  out_request->uid = cr.uid;
  out_request->gid = cr.gid;
  out_request->abort_msg_address = msg.abort_msg_address;
  out_request->original_si_code = msg.original_si_code;

 
   if (msg.action == DEBUGGER_ACTION_CRASH) {
    
    if (!pid_contains_tid(out_request->pid, out_request->tid)) {
      ALOGE(""tid %d does not exist in pid %d. ignoring debug request\n"", out_request->tid,
            out_request->pid);
       return -1;
     }
  } else if (cr.uid == 0 || (cr.uid == AID_SYSTEM && msg.action == DEBUGGER_ACTION_DUMP_BACKTRACE)) {
     status = get_process_info(out_request->tid, &out_request->pid,
 &out_request->uid, &out_request->gid);
 if (status < 0) {
      ALOGE(""tid %d does not exist. ignoring explicit dump request\n"", out_request->tid);
 return -1;
 }

 if (!selinux_action_allowed(fd, out_request))
 return -1;
 } else {
 return -1;
 }
 return 0;
}
","1. socklen_t len = sizeof(cr);
2. if (status != 0) {
ALOGE(""cannot get credentials"");
3. fcntl(fd, F_SETFL, O_NONBLOCK);
4. pollfds[0].events = POLLIN;
5. status = TEMP_FAILURE_RETRY(poll(pollfds, 1, 3000));
6. status = TEMP_FAILURE_RETRY(read(fd, &msg, sizeof(msg)));
7. ALOGE(""read failure? %s (pid=%d uid=%d)\n"", strerror(errno), cr.pid, cr.uid);
8. out_request->action = static_cast<debugger_action_t>(msg.action);
9. out_request->abort_msg_address = msg.abort_msg_address;
10. } else if (cr.uid == 0 || (cr.uid == AID_SYSTEM && msg.action == DEBUGGER_ACTION_DUMP_BACKTRACE)) {
status = get_process_info(out_request->tid, &out_request->pid,
&out_request->uid, &out_request->gid);
11. return -1;
12. return -1;
13. return 0;","3
5-6
11
15
17
25
27
35
40
51-53
56
62
64","CWE-264,CWE-20,CWE-125,CWE-189"
drdynvc_process_close_request,"
#define Sp

static UINT drdynvc_process_close_request(drdynvcPlugin* drdynvc, int Sp,
        int cbChId, wStream* s)
{
	int value;
 	UINT error;
 	UINT32 ChannelId;
 	wStream* data_out;

	if (Stream_GetRemainingLength(s) < drdynvc_cblen_to_bytes(cbChId))
		return ERROR_INVALID_DATA;

 	ChannelId = drdynvc_read_variable_uint(s, cbChId);
 	WLog_Print(drdynvc->log, WLOG_DEBUG, ""process_close_request: Sp=%d cbChId=%d, ChannelId=%""PRIu32"""",
 	           Sp,
	           cbChId, ChannelId);

	if ((error = dvcman_close_channel(drdynvc->channel_mgr, ChannelId)))
	{
		WLog_Print(drdynvc->log, WLOG_ERROR, ""dvcman_close_channel failed with error %""PRIu32""!"", error);
		return error;
	}

	data_out = Stream_New(NULL, 4);

	if (!data_out)
	{
		WLog_Print(drdynvc->log, WLOG_ERROR, ""Stream_New failed!"");
		return CHANNEL_RC_NO_MEMORY;
	}

	value = (CLOSE_REQUEST_PDU << 4) | (cbChId & 0x03);
	Stream_Write_UINT8(data_out, value);
	drdynvc_write_variable_uint(data_out, ChannelId);
	error = drdynvc_send(drdynvc, data_out);

	if (error)
		WLog_Print(drdynvc->log, WLOG_ERROR, ""VirtualChannelWriteEx failed with %s [%08""PRIX32""]"",
		           WTSErrorToString(error), error);

	return error;
}
","1. UINT error;
UINT32 ChannelId;
2. if (Stream_GetRemainingLength(s) < drdynvc_cblen_to_bytes(cbChId))
3. if ((error = dvcman_close_channel(drdynvc->channel_mgr, ChannelId)))
4. WLog_Print(drdynvc->log, WLOG_ERROR, ""Stream_New failed!"");
return CHANNEL_RC_NO_MEMORY;","8-9
12
20
30-31","CWE-400,CWE-120,CWE-119"
cbs_av1_read_uvlc-181390798584244,"
#define CodedBitstreamContext
#define GetBitContext

static int cbs_av1_read_uvlc(CodedBitstreamContext *ctx, GetBitContext *gbc,
                             const char *name, uint32_t *write_to,
                             uint32_t range_min, uint32_t range_max)
{
    uint32_t zeroes, bits_value, value;
    int position;

    if (ctx->trace_enable)
        position = get_bits_count(gbc);

    zeroes = 0;
    while (1) {
        if (get_bits_left(gbc) < 1) {
            av_log(ctx->log_ctx, AV_LOG_ERROR, ""Invalid uvlc code at ""
                   ""%s: bitstream ended.\n"", name);
            return AVERROR_INVALIDDATA;
        }

        if (get_bits1(gbc))
            break;
        ++zeroes;
    }

    if (zeroes >= 32) {
        value = MAX_UINT_BITS(32);
    } else {
        if (get_bits_left(gbc) < zeroes) {
            av_log(ctx->log_ctx, AV_LOG_ERROR, ""Invalid uvlc code at ""
                   ""%s: bitstream ended.\n"", name);
            return AVERROR_INVALIDDATA;
        }

        bits_value = get_bits_long(gbc, zeroes);
        value = bits_value + (UINT32_C(1) << zeroes) - 1;
    }

    if (ctx->trace_enable) {
        char bits[65];
        int i, j, k;

        if (zeroes >= 32) {
            while (zeroes > 32) {
                k = FFMIN(zeroes - 32, 32);
                for (i = 0; i < k; i++)
                    bits[i] = '0';
                bits[i] = 0;
                ff_cbs_trace_syntax_element(ctx, position, name,
                                            NULL, bits, 0);
                zeroes -= k;
                position += k;
            }
        }

        for (i = 0; i < zeroes; i++)
            bits[i] = '0';
        bits[i++] = '1';

        if (zeroes < 32) {
            for (j = 0; j < zeroes; j++)
                bits[i++] = (bits_value >> (zeroes - j - 1) & 1) ? '1' : '0';
        }

        bits[i] = 0;
        ff_cbs_trace_syntax_element(ctx, position, name,
                                    NULL, bits, value);
    }

    if (value < range_min || value > range_max) {
        av_log(ctx->log_ctx, AV_LOG_ERROR, ""%s out of range: ""
               ""%""PRIu32"", but must be in [%""PRIu32"",%""PRIu32""].\n"",
               name, value, range_min, range_max);
        return AVERROR_INVALIDDATA;
    }

    *write_to = value;
    return 0;
}
","1. av_log(ctx->log_ctx, AV_LOG_ERROR, ""Invalid uvlc code at ""
2. if (get_bits1(gbc))","18
23",CWE-772
xps_init_truetype_font,"xps_init_truetype_font(xps_context_t *ctx, xps_font_t *font)
{
    int code = 0;

    font->font = (void*) gs_alloc_struct(ctx->memory, gs_font_type42, &st_gs_font_type42, ""xps_font type42"");
    if (!font->font)
        return gs_throw(gs_error_VMerror, ""out of memory"");

    
    {
        gs_font_type42 *p42 = (gs_font_type42*) font->font;

        

        p42->next = 0;
        p42->prev = 0;
        p42->memory = ctx->memory;

        p42->dir = ctx->fontdir; 
        p42->base = font->font; 
        p42->is_resource = false;
        gs_notify_init(&p42->notify_list, gs_memory_stable(ctx->memory));
        p42->id = gs_next_ids(ctx->memory, 1);

        p42->client_data = font; 

        
        gs_make_identity(&p42->FontMatrix);
        gs_make_identity(&p42->orig_FontMatrix); 

        p42->FontType = ft_TrueType;
        p42->BitmapWidths = false;
        p42->ExactSize = fbit_use_outlines;
        p42->InBetweenSize = fbit_use_outlines;
        p42->TransformedChar = fbit_use_outlines;
        p42->WMode = 0;
        p42->PaintType = 0;
        p42->StrokeWidth = 0;
        p42->is_cached = 0;

        p42->procs.define_font = gs_no_define_font;
        p42->procs.make_font = gs_no_make_font;
        p42->procs.font_info = gs_type42_font_info;
        p42->procs.same_font = gs_default_same_font;
        p42->procs.encode_char = xps_true_callback_encode_char;
        p42->procs.decode_glyph = xps_true_callback_decode_glyph;
        p42->procs.enumerate_glyph = gs_type42_enumerate_glyph;
        p42->procs.glyph_info = gs_type42_glyph_info;
        p42->procs.glyph_outline = gs_type42_glyph_outline;
        p42->procs.glyph_name = xps_true_callback_glyph_name;
        p42->procs.init_fstack = gs_default_init_fstack;
        p42->procs.next_char_glyph = gs_default_next_char_glyph;
         p42->procs.build_char = xps_true_callback_build_char;
 
         memset(p42->font_name.chars, 0, sizeof(p42->font_name.chars));
        xps_load_sfnt_name(font, (char*)p42->font_name.chars, sizeof(p42->font_name.chars));
         p42->font_name.size = strlen((char*)p42->font_name.chars);
 
         memset(p42->key_name.chars, 0, sizeof(p42->key_name.chars));
        strcpy((char*)p42->key_name.chars, (char*)p42->font_name.chars);
        p42->key_name.size = strlen((char*)p42->key_name.chars);

        

        p42->FontBBox.p.x = 0;
        p42->FontBBox.p.y = 0;
        p42->FontBBox.q.x = 0;
        p42->FontBBox.q.y = 0;

        uid_set_UniqueID(&p42->UID, p42->id);

        p42->encoding_index = ENCODING_INDEX_UNKNOWN;
        p42->nearest_encoding_index = ENCODING_INDEX_ISOLATIN1;

        p42->FAPI = 0;
        p42->FAPI_font_data = 0;

        

        p42->data.string_proc = xps_true_callback_string_proc;
        p42->data.proc_data = font;

        gs_type42_font_init(p42, font->subfontid);
        p42->data.get_glyph_index = xps_true_get_glyph_index;
    }

    if ((code = gs_definefont(ctx->fontdir, font->font)) < 0) {
        return(code);
    }

    code = xps_fapi_passfont (font->font, NULL, NULL, font->data, font->length);
    return code;
}
","1. p42->BitmapWidths = false;
2. p42->procs.glyph_outline = gs_type42_glyph_outline;
3. p42->FontBBox.q.x = 0;","32
49
67","CWE-200,CWE-120,CWE-787,CWE-78"
mobi_decompress_huffman_internal-62179202816072,"
#define MOBIBuffer
#define MOBIHuffCdic

static MOBI_RET mobi_decompress_huffman_internal(MOBIBuffer *buf_out, MOBIBuffer *buf_in, const MOBIHuffCdic *huffcdic, size_t depth) {
    if (depth > MOBI_HUFFMAN_MAXDEPTH) {
        debug_print(""Too many levels of recursion: %zu\n"", depth);
        return MOBI_DATA_CORRUPT;
    }
    MOBI_RET ret = MOBI_SUCCESS;
    int8_t bitcount = 32;
    
    int bitsleft = (int) (buf_in->maxlen * 8);
    uint8_t code_length = 0;
    uint64_t buffer = mobi_buffer_fill64(buf_in);
    while (ret == MOBI_SUCCESS) {
        if (bitcount <= 0) {
            bitcount += 32;
            buffer = mobi_buffer_fill64(buf_in);
        }
        uint32_t code = (buffer >> bitcount) & 0xffffffffU;
        
        uint32_t t1 = huffcdic->table1[code >> 24];
        
        code_length = t1 & 0x1f;
        uint32_t maxcode = (((t1 >> 8) + 1) << (32 - code_length)) - 1;
        
        if (!(t1 & 0x80)) {
            
            while (code < huffcdic->mincode_table[code_length]) {
                if (++code_length >= HUFF_CODETABLE_SIZE) {
                    debug_print(""Wrong offset to mincode table: %hhu\n"", code_length);
                    return MOBI_DATA_CORRUPT;
                }
            }
            maxcode = huffcdic->maxcode_table[code_length];
        }
        bitcount -= code_length;
        bitsleft -= code_length;
        if (bitsleft < 0) {
            break;
        }
        
        uint32_t index = (uint32_t) (maxcode - code) >> (32 - code_length);
        
        uint16_t cdic_index = (uint16_t) ((uint32_t)index >> huffcdic->code_length);
        if (index >= huffcdic->index_count) {
            debug_print(""Wrong symbol offsets index: %u\n"", index);
            return MOBI_DATA_CORRUPT;
        }
        
        uint32_t offset = huffcdic->symbol_offsets[index];
        uint32_t symbol_length = (uint32_t) huffcdic->symbols[cdic_index][offset] << 8 | (uint32_t) huffcdic->symbols[cdic_index][offset + 1];
        
        int is_decompressed = symbol_length >> 15;
        
        symbol_length &= 0x7fff;
        if (is_decompressed) {
            
            mobi_buffer_addraw(buf_out, (huffcdic->symbols[cdic_index] + offset + 2), symbol_length);
            ret = buf_out->error;
        } else {
            
            
            MOBIBuffer buf_sym;
            buf_sym.data = huffcdic->symbols[cdic_index] + offset + 2;
            buf_sym.offset = 0;
            buf_sym.maxlen = symbol_length;
            buf_sym.error = MOBI_SUCCESS;
            ret = mobi_decompress_huffman_internal(buf_out, &buf_sym, huffcdic, depth + 1);
        }
    }
    return ret;
}
","1. static MOBI_RET mobi_decompress_huffman_internal(MOBIBuffer *buf_out, MOBIBuffer *buf_in, const MOBIHuffCdic *huffcdic, size_t depth) {
if (depth > MOBI_HUFFMAN_MAXDEPTH) {
2. return MOBI_DATA_CORRUPT;
3. MOBI_RET ret = MOBI_SUCCESS;
4. int bitsleft = (int) (buf_in->maxlen * 8);
uint8_t code_length = 0;
uint64_t buffer = mobi_buffer_fill64(buf_in);
5. if (bitcount <= 0) {
6. uint32_t t1 = huffcdic->table1[code >> 24];
7. if (!(t1 & 0x80)) {
8. if (++code_length >= HUFF_CODETABLE_SIZE) {
9. break;
10. uint32_t index = (uint32_t) (maxcode - code) >> (32 - code_length);
11. uint16_t cdic_index = (uint16_t) ((uint32_t)index >> huffcdic->code_length);
12. return MOBI_DATA_CORRUPT;
13. uint32_t symbol_length = (uint32_t) huffcdic->symbols[cdic_index][offset] << 8 | (uint32_t) huffcdic->symbols[cdic_index][offset + 1];
14. if (is_decompressed) {
15. ret = buf_out->error;
16. buf_sym.data = huffcdic->symbols[cdic_index] + offset + 2;
17. buf_sym.error = MOBI_SUCCESS;","5-6
8
10
13-15
17
23
28
31
41
44
46
49
53
58
61
66
69","CWE-362,CWE-787,CWE-125,CWE-22"
iowarrior_probe,"static int iowarrior_probe(struct usb_interface *interface,
			   const struct usb_device_id *id)
{
	struct usb_device *udev = interface_to_usbdev(interface);
	struct iowarrior *dev = NULL;
	struct usb_host_interface *iface_desc;
	struct usb_endpoint_descriptor *endpoint;
	int i;
	int retval = -ENOMEM;

	
	dev = kzalloc(sizeof(struct iowarrior), GFP_KERNEL);
	if (dev == NULL) {
		dev_err(&interface->dev, ""Out of memory\n"");
		return retval;
	}

	mutex_init(&dev->mutex);

	atomic_set(&dev->intr_idx, 0);
	atomic_set(&dev->read_idx, 0);
	spin_lock_init(&dev->intr_idx_lock);
	atomic_set(&dev->overflow_flag, 0);
	init_waitqueue_head(&dev->read_wait);
	atomic_set(&dev->write_busy, 0);
	init_waitqueue_head(&dev->write_wait);

	dev->udev = udev;
	dev->interface = interface;

 	iface_desc = interface->cur_altsetting;
 	dev->product_id = le16_to_cpu(udev->descriptor.idProduct);
 
	if (iface_desc->desc.bNumEndpoints < 1) {
		dev_err(&interface->dev, ""Invalid number of endpoints\n"");
		retval = -EINVAL;
		goto error;
	}

 	
 	for (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {
 		endpoint = &iface_desc->endpoint[i].desc;

		if (usb_endpoint_is_int_in(endpoint))
			dev->int_in_endpoint = endpoint;
		if (usb_endpoint_is_int_out(endpoint))
			
			dev->int_out_endpoint = endpoint;
	}
	
	dev->report_size = usb_endpoint_maxp(dev->int_in_endpoint);
	if ((dev->interface->cur_altsetting->desc.bInterfaceNumber == 0) &&
	    (dev->product_id == USB_DEVICE_ID_CODEMERCS_IOW56))
		
		dev->report_size = 7;

	
	dev->int_in_urb = usb_alloc_urb(0, GFP_KERNEL);
	if (!dev->int_in_urb) {
		dev_err(&interface->dev, ""Couldn't allocate interrupt_in_urb\n"");
		goto error;
	}
	dev->int_in_buffer = kmalloc(dev->report_size, GFP_KERNEL);
	if (!dev->int_in_buffer) {
		dev_err(&interface->dev, ""Couldn't allocate int_in_buffer\n"");
		goto error;
	}
	usb_fill_int_urb(dev->int_in_urb, dev->udev,
			 usb_rcvintpipe(dev->udev,
					dev->int_in_endpoint->bEndpointAddress),
			 dev->int_in_buffer, dev->report_size,
			 iowarrior_callback, dev,
			 dev->int_in_endpoint->bInterval);
	
	dev->read_queue =
	    kmalloc(((dev->report_size + 1) * MAX_INTERRUPT_BUFFER),
		    GFP_KERNEL);
	if (!dev->read_queue) {
		dev_err(&interface->dev, ""Couldn't allocate read_queue\n"");
		goto error;
	}
	
	memset(dev->chip_serial, 0x00, sizeof(dev->chip_serial));
	usb_string(udev, udev->descriptor.iSerialNumber, dev->chip_serial,
		   sizeof(dev->chip_serial));
	if (strlen(dev->chip_serial) != 8)
		memset(dev->chip_serial, 0x00, sizeof(dev->chip_serial));

	
	if (dev->interface->cur_altsetting->desc.bInterfaceNumber == 0) {
	    usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
			    0x0A,
			    USB_TYPE_CLASS | USB_RECIP_INTERFACE, 0,
			    0, NULL, 0, USB_CTRL_SET_TIMEOUT);
	}
	
	dev->present = 1;

	
	usb_set_intfdata(interface, dev);

	retval = usb_register_dev(interface, &iowarrior_class);
	if (retval) {
		
		dev_err(&interface->dev, ""Not able to get a minor for this device.\n"");
		usb_set_intfdata(interface, NULL);
		goto error;
	}

	dev->minor = interface->minor;

	
	dev_info(&interface->dev, ""IOWarrior product=0x%x, serial=%s interface=%d ""
		 ""now attached to iowarrior%d\n"", dev->product_id, dev->chip_serial,
		 iface_desc->desc.bInterfaceNumber, dev->minor - IOWARRIOR_MINOR_BASE);
	return retval;

error:
	iowarrior_delete(dev);
	return retval;
}
","1. const struct usb_device_id *id)
2. int i;
3. atomic_set(&dev->intr_idx, 0);
4. atomic_set(&dev->write_busy, 0);
5. dev->udev = udev;
6. iface_desc = interface->cur_altsetting;
7. dev->int_in_endpoint = endpoint;
8. dev_err(&interface->dev, ""Couldn't allocate interrupt_in_urb\n"");
9. dev->int_in_buffer = kmalloc(dev->report_size, GFP_KERNEL);
10. usb_rcvintpipe(dev->udev,
11. if (!dev->read_queue) {
12. sizeof(dev->chip_serial));
13. usb_set_intfdata(interface, dev);
14. goto error;","2
8
20
25
28
31
45
60
63
69
78
85
100
107","CWE-362,CWE-125,CWE-119"
tgs_build_reply-159583076526493,"
#define AuthorizationData
#define KDC_REQ
#define KDC_REQ_BODY

static krb5_error_code
tgs_build_reply(krb5_context context,
		krb5_kdc_configuration *config,
		KDC_REQ *req,
		KDC_REQ_BODY *b,
		hdb_entry_ex *krbtgt,
		krb5_enctype krbtgt_etype,
		const krb5_keyblock *replykey,
		int rk_is_subkey,
		krb5_ticket *ticket,
		krb5_data *reply,
		const char *from,
		const char **e_text,
		AuthorizationData **auth_data,
		const struct sockaddr *from_addr)
{
    krb5_error_code ret;
    krb5_principal cp = NULL, sp = NULL, rsp = NULL, tp = NULL, dp = NULL;
    krb5_principal krbtgt_out_principal = NULL;
    char *spn = NULL, *cpn = NULL, *tpn = NULL, *dpn = NULL, *krbtgt_out_n = NULL;
    hdb_entry_ex *server = NULL, *client = NULL, *s4u2self_impersonated_client = NULL;
    HDB *clientdb, *s4u2self_impersonated_clientdb;
    krb5_realm ref_realm = NULL;
    EncTicketPart *tgt = &ticket->ticket;
    krb5_principals spp = NULL;
    const EncryptionKey *ekey;
    krb5_keyblock sessionkey;
    krb5_kvno kvno;
    krb5_data rspac;
    const char *tgt_realm = 
        krb5_principal_get_realm(context, krbtgt->entry.principal);
    const char *our_realm = 
        krb5_principal_get_comp_string(context, krbtgt->entry.principal, 1);
    char **capath = NULL;
    size_t num_capath = 0;

    hdb_entry_ex *krbtgt_out = NULL;

    METHOD_DATA enc_pa_data;

    PrincipalName *s;
    Realm r;
    EncTicketPart adtkt;
    char opt_str[128];
    int signedpath = 0;

    Key *tkey_check;
    Key *tkey_sign;
    int flags = HDB_F_FOR_TGS_REQ;

    memset(&sessionkey, 0, sizeof(sessionkey));
    memset(&adtkt, 0, sizeof(adtkt));
    krb5_data_zero(&rspac);
    memset(&enc_pa_data, 0, sizeof(enc_pa_data));

    s = b->sname;
    r = b->realm;

    
    flags |= HDB_F_CANON;

    if(b->kdc_options.enc_tkt_in_skey){
	Ticket *t;
	hdb_entry_ex *uu;
	krb5_principal p;
	Key *uukey;
	krb5uint32 second_kvno = 0;
	krb5uint32 *kvno_ptr = NULL;

	if(b->additional_tickets == NULL ||
	   b->additional_tickets->len == 0){
	    ret = KRB5KDC_ERR_BADOPTION; 
	    kdc_log(context, config, 0,
		    ""No second ticket present in request"");
	    goto out;
	}
	t = &b->additional_tickets->val[0];
	if(!get_krbtgt_realm(&t->sname)){
	    kdc_log(context, config, 0,
		    ""Additional ticket is not a ticket-granting ticket"");
	    ret = KRB5KDC_ERR_POLICY;
	    goto out;
	}
	_krb5_principalname2krb5_principal(context, &p, t->sname, t->realm);
	if(t->enc_part.kvno){
	    second_kvno = *t->enc_part.kvno;
	    kvno_ptr = &second_kvno;
	}
	ret = _kdc_db_fetch(context, config, p,
			    HDB_F_GET_KRBTGT, kvno_ptr,
			    NULL, &uu);
	krb5_free_principal(context, p);
	if(ret){
	    if (ret == HDB_ERR_NOENTRY)
		ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;
	    goto out;
	}
	ret = hdb_enctype2key(context, &uu->entry, NULL,
			      t->enc_part.etype, &uukey);
	if(ret){
	    _kdc_free_ent(context, uu);
	    ret = KRB5KDC_ERR_ETYPE_NOSUPP; 
	    goto out;
	}
	ret = krb5_decrypt_ticket(context, t, &uukey->key, &adtkt, 0);
	_kdc_free_ent(context, uu);
	if(ret)
	    goto out;

	ret = verify_flags(context, config, &adtkt, spn);
	if (ret)
	    goto out;

	s = &adtkt.cname;
	r = adtkt.crealm;
    }

    _krb5_principalname2krb5_principal(context, &sp, *s, r);
    ret = krb5_unparse_name(context, sp, &spn);
    if (ret)
	goto out;
    _krb5_principalname2krb5_principal(context, &cp, tgt->cname, tgt->crealm);
    ret = krb5_unparse_name(context, cp, &cpn);
    if (ret)
	goto out;
    unparse_flags (KDCOptions2int(b->kdc_options),
		   asn1_KDCOptions_units(),
		   opt_str, sizeof(opt_str));
    if(*opt_str)
	kdc_log(context, config, 0,
		""TGS-REQ %s from %s for %s [%s]"",
		cpn, from, spn, opt_str);
    else
	kdc_log(context, config, 0,
		""TGS-REQ %s from %s for %s"", cpn, from, spn);

    

server_lookup:
    ret = _kdc_db_fetch(context, config, sp, HDB_F_GET_SERVER | flags,
			NULL, NULL, &server);

    if (ret == HDB_ERR_NOT_FOUND_HERE) {
	kdc_log(context, config, 5, ""target %s does not have secrets at this KDC, need to proxy"", sp);
	goto out;
    } else if (ret == HDB_ERR_WRONG_REALM) {
        free(ref_realm);
	ref_realm = strdup(server->entry.principal->realm);
	if (ref_realm == NULL) {
            ret = krb5_enomem(context);
	    goto out;
	}

	kdc_log(context, config, 5,
		""Returning a referral to realm %s for ""
		""server %s."",
		ref_realm, spn);
	krb5_free_principal(context, sp);
	sp = NULL;
	ret = krb5_make_principal(context, &sp, r, KRB5_TGS_NAME,
				  ref_realm, NULL);
	if (ret)
	    goto out;
	free(spn);
        spn = NULL;
	ret = krb5_unparse_name(context, sp, &spn);
	if (ret)
	    goto out;

	goto server_lookup;
    } else if (ret) {
	const char *new_rlm, *msg;
	Realm req_rlm;
	krb5_realm *realms;

	if ((req_rlm = get_krbtgt_realm(&sp->name)) != NULL) {
            if (capath == NULL) {
                
                ret = _krb5_find_capath(context, tgt->crealm, our_realm,
                                        req_rlm, TRUE, &capath, &num_capath);
                if (ret)
                    goto out;
            }
            new_rlm = num_capath > 0 ? capath[--num_capath] : NULL;
            if (new_rlm) {
                kdc_log(context, config, 5, ""krbtgt from %s via %s for ""
                        ""realm %s not found, trying %s"", tgt->crealm,
                        our_realm, req_rlm, new_rlm);

                free(ref_realm);
                ref_realm = strdup(new_rlm);
                if (ref_realm == NULL) {
                    ret = krb5_enomem(context);
                    goto out;
                }

                krb5_free_principal(context, sp);
                sp = NULL;
                krb5_make_principal(context, &sp, r,
                                    KRB5_TGS_NAME, ref_realm, NULL);
                free(spn);
                spn = NULL;
                ret = krb5_unparse_name(context, sp, &spn);
                if (ret)
                    goto out;
                goto server_lookup;
            }
	} else if (need_referral(context, config, &b->kdc_options, sp, &realms)) {
	    if (strcmp(realms[0], sp->realm) != 0) {
		kdc_log(context, config, 5,
			""Returning a referral to realm %s for ""
			""server %s that was not found"",
			realms[0], spn);
		krb5_free_principal(context, sp);
                sp = NULL;
		krb5_make_principal(context, &sp, r, KRB5_TGS_NAME,
				    realms[0], NULL);
		free(spn);
                spn = NULL;
		ret = krb5_unparse_name(context, sp, &spn);
		if (ret) {
		    krb5_free_host_realm(context, realms);
		    goto out;
		}

                free(ref_realm);
		ref_realm = strdup(realms[0]);

		krb5_free_host_realm(context, realms);
		goto server_lookup;
	    }
	    krb5_free_host_realm(context, realms);
	}
	msg = krb5_get_error_message(context, ret);
	kdc_log(context, config, 0,
		""Server not found in database: %s: %s"", spn, msg);
	krb5_free_error_message(context, msg);
	if (ret == HDB_ERR_NOENTRY)
	    ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;
	goto out;
    }

    

    if (b->kdc_options.canonicalize)
	rsp = server->entry.principal;
    else
	rsp = sp;


    

    {
	krb5_enctype etype;

	if(b->kdc_options.enc_tkt_in_skey) {
	    size_t i;
	    ekey = &adtkt.key;
	    for(i = 0; i < b->etype.len; i++)
		if (b->etype.val[i] == adtkt.key.keytype)
		    break;
	    if(i == b->etype.len) {
		kdc_log(context, config, 0,
			""Addition ticket have not matching etypes"");
		krb5_clear_error_message(context);
		ret = KRB5KDC_ERR_ETYPE_NOSUPP;
		goto out;
	    }
	    etype = b->etype.val[i];
	    kvno = 0;
	} else {
	    Key *skey;

	    ret = _kdc_find_etype(context,
				  krb5_principal_is_krbtgt(context, sp) ?
				  config->tgt_use_strongest_session_key :
				  config->svc_use_strongest_session_key, FALSE,
				  server, b->etype.val, b->etype.len, &etype,
				  NULL);
	    if(ret) {
		kdc_log(context, config, 0,
			""Server (%s) has no support for etypes"", spn);
		goto out;
	    }
	    ret = _kdc_get_preferred_key(context, config, server, spn,
					 NULL, &skey);
	    if(ret) {
		kdc_log(context, config, 0,
			""Server (%s) has no supported etypes"", spn);
		goto out;
	    }
	    ekey = &skey->key;
	    kvno = server->entry.kvno;
	}

	ret = krb5_generate_random_keyblock(context, etype, &sessionkey);
	if (ret)
	    goto out;
    }

    

    

    ret = hdb_enctype2key(context, &krbtgt->entry, NULL, 
			  krbtgt_etype, &tkey_check);
    if(ret) {
	kdc_log(context, config, 0,
		    ""Failed to find key for krbtgt PAC check"");
	goto out;
    }

    
    
    ret = krb5_make_principal(context,
                              &krbtgt_out_principal,
                              our_realm,
                              KRB5_TGS_NAME,
                              our_realm,
                              NULL);
    if (ret) {
        kdc_log(context, config, 0,
                ""Failed to make krbtgt principal name object for ""
                ""authz-data signatures"");
        goto out;
    }
    ret = krb5_unparse_name(context, krbtgt_out_principal, &krbtgt_out_n);
    if (ret) {
        kdc_log(context, config, 0,
                ""Failed to make krbtgt principal name object for ""
                ""authz-data signatures"");
        goto out;
    }

    ret = _kdc_db_fetch(context, config, krbtgt_out_principal,
			HDB_F_GET_KRBTGT, NULL, NULL, &krbtgt_out);
    if (ret) {
	char *ktpn = NULL;
	ret = krb5_unparse_name(context, krbtgt->entry.principal, &ktpn);
	kdc_log(context, config, 0,
		""No such principal %s (needed for authz-data signature keys) ""
		""while processing TGS-REQ for service %s with krbtg %s"",
		krbtgt_out_n, spn, (ret == 0) ? ktpn : ""<unknown>"");
	free(ktpn);
	ret = KRB5KRB_AP_ERR_NOT_US;
	goto out;
    }

    
    if (strcmp(krb5_principal_get_realm(context, server->entry.principal),
	       krb5_principal_get_realm(context, krbtgt_out->entry.principal)) != 0) {
	char *ktpn;
	ret = krb5_unparse_name(context, krbtgt_out->entry.principal, &ktpn);
	kdc_log(context, config, 0,
		""Request with wrong krbtgt: %s"",
		(ret == 0) ? ktpn : ""<unknown>"");
	if(ret == 0)
	    free(ktpn);
	ret = KRB5KRB_AP_ERR_NOT_US;
	goto out;
    }

    ret = _kdc_get_preferred_key(context, config, krbtgt_out, krbtgt_out_n,
				 NULL, &tkey_sign);
    if (ret) {
	kdc_log(context, config, 0,
		    ""Failed to find key for krbtgt PAC signature"");
	goto out;
    }
    ret = hdb_enctype2key(context, &krbtgt_out->entry, NULL,
			  tkey_sign->key.keytype, &tkey_sign);
    if(ret) {
	kdc_log(context, config, 0,
		    ""Failed to find key for krbtgt PAC signature"");
	goto out;
    }

    ret = _kdc_db_fetch(context, config, cp, HDB_F_GET_CLIENT | flags,
			NULL, &clientdb, &client);
    if(ret == HDB_ERR_NOT_FOUND_HERE) {
	
    } else if(ret){
	const char *krbtgt_realm, *msg;

	

	krbtgt_realm = krb5_principal_get_realm(context, krbtgt_out->entry.principal);

	if(strcmp(krb5_principal_get_realm(context, cp), krbtgt_realm) == 0) {
	    if (ret == HDB_ERR_NOENTRY)
		ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;
	    kdc_log(context, config, 1, ""Client no longer in database: %s"",
		    cpn);
	    goto out;
	}

	msg = krb5_get_error_message(context, ret);
	kdc_log(context, config, 1, ""Client not found in database: %s"", msg);
	krb5_free_error_message(context, msg);
    }

    ret = check_PAC(context, config, cp, NULL,
		    client, server, krbtgt,
		    &tkey_check->key,
		    ekey, &tkey_sign->key,
		    tgt, &rspac, &signedpath);
    if (ret) {
	const char *msg = krb5_get_error_message(context, ret);
	kdc_log(context, config, 0,
		""Verify PAC failed for %s (%s) from %s with %s"",
		spn, cpn, from, msg);
	krb5_free_error_message(context, msg);
	goto out;
    }

    
    ret = check_KRB5SignedPath(context,
			       config,
			       krbtgt,
			       cp,
			       tgt,
			       &spp,
			       &signedpath);
    if (ret) {
	const char *msg = krb5_get_error_message(context, ret);
	kdc_log(context, config, 0,
		""KRB5SignedPath check failed for %s (%s) from %s with %s"",
		spn, cpn, from, msg);
	krb5_free_error_message(context, msg);
	goto out;
    }

    

    
    tp = cp;
    tpn = cpn;

    if (client) {
	const PA_DATA *sdata;
	int i = 0;

	sdata = _kdc_find_padata(req, &i, KRB5_PADATA_FOR_USER);
	if (sdata) {
	    krb5_crypto crypto;
	    krb5_data datack;
	    PA_S4U2Self self;
	    const char *str;

	    ret = decode_PA_S4U2Self(sdata->padata_value.data,
				     sdata->padata_value.length,
				     &self, NULL);
	    if (ret) {
		kdc_log(context, config, 0, ""Failed to decode PA-S4U2Self"");
		goto out;
	    }

	    ret = _krb5_s4u2self_to_checksumdata(context, &self, &datack);
	    if (ret)
		goto out;

	    ret = krb5_crypto_init(context, &tgt->key, 0, &crypto);
	    if (ret) {
		const char *msg = krb5_get_error_message(context, ret);
		free_PA_S4U2Self(&self);
		krb5_data_free(&datack);
		kdc_log(context, config, 0, ""krb5_crypto_init failed: %s"", msg);
		krb5_free_error_message(context, msg);
		goto out;
	    }

	    ret = krb5_verify_checksum(context,
				       crypto,
				       KRB5_KU_OTHER_CKSUM,
				       datack.data,
				       datack.length,
				       &self.cksum);
	    krb5_data_free(&datack);
	    krb5_crypto_destroy(context, crypto);
	    if (ret) {
		const char *msg = krb5_get_error_message(context, ret);
		free_PA_S4U2Self(&self);
		kdc_log(context, config, 0,
			""krb5_verify_checksum failed for S4U2Self: %s"", msg);
		krb5_free_error_message(context, msg);
		goto out;
	    }

	    ret = _krb5_principalname2krb5_principal(context,
						     &tp,
						     self.name,
						     self.realm);
	    free_PA_S4U2Self(&self);
	    if (ret)
		goto out;

	    ret = krb5_unparse_name(context, tp, &tpn);
	    if (ret)
		goto out;

	    
	    if(rspac.data) {
		krb5_pac p = NULL;
		krb5_data_free(&rspac);
		ret = _kdc_db_fetch(context, config, tp, HDB_F_GET_CLIENT | flags,
				    NULL, &s4u2self_impersonated_clientdb, &s4u2self_impersonated_client);
		if (ret) {
		    const char *msg;

		    

		    if (ret == HDB_ERR_NOENTRY)
			ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;
		    msg = krb5_get_error_message(context, ret);
		    kdc_log(context, config, 1,
			    ""S2U4Self principal to impersonate %s not found in database: %s"",
			    tpn, msg);
		    krb5_free_error_message(context, msg);
		    goto out;
		}
		ret = _kdc_pac_generate(context, s4u2self_impersonated_client, &p);
		if (ret) {
		    kdc_log(context, config, 0, ""PAC generation failed for -- %s"",
			    tpn);
		    goto out;
		}
		if (p != NULL) {
		    ret = _krb5_pac_sign(context, p, ticket->ticket.authtime,
					 s4u2self_impersonated_client->entry.principal,
					 ekey, &tkey_sign->key,
					 &rspac);
		    krb5_pac_free(context, p);
		    if (ret) {
			kdc_log(context, config, 0, ""PAC signing failed for -- %s"",
				tpn);
			goto out;
		    }
		}
	    }

	    
	    ret = check_s4u2self(context, config, clientdb, client, sp);
	    if (ret) {
		kdc_log(context, config, 0, ""S4U2Self: %s is not allowed ""
			""to impersonate to service ""
			""(tried for user %s to service %s)"",
			cpn, tpn, spn);
		goto out;
	    }

	    

	    if (client->entry.flags.trusted_for_delegation) {
		str = ""[forwardable]"";
	    } else {
		b->kdc_options.forwardable = 0;
		str = """";
	    }
	    kdc_log(context, config, 0, ""s4u2self %s impersonating %s to ""
		    ""service %s %s"", cpn, tpn, spn, str);
	}
    }

    

    if (client != NULL
	&& b->additional_tickets != NULL
	&& b->additional_tickets->len != 0
	&& b->kdc_options.enc_tkt_in_skey == 0)
    {
	int ad_signedpath = 0;
	Key *clientkey;
	Ticket *t;

	
	if (!signedpath) {
	    ret = KRB5KDC_ERR_BADOPTION;
	    kdc_log(context, config, 0,
		    ""Constrained delegation done on service ticket %s/%s"",
		    cpn, spn);
	    goto out;
	}

	t = &b->additional_tickets->val[0];

	ret = hdb_enctype2key(context, &client->entry,
			      hdb_kvno2keys(context, &client->entry,
					    t->enc_part.kvno ? * t->enc_part.kvno : 0),
			      t->enc_part.etype, &clientkey);
	if(ret){
	    ret = KRB5KDC_ERR_ETYPE_NOSUPP; 
	    goto out;
	}

	ret = krb5_decrypt_ticket(context, t, &clientkey->key, &adtkt, 0);
	if (ret) {
	    kdc_log(context, config, 0,
		    ""failed to decrypt ticket for ""
		    ""constrained delegation from %s to %s "", cpn, spn);
	    goto out;
	}

	ret = _krb5_principalname2krb5_principal(context,
						 &tp,
						 adtkt.cname,
						 adtkt.crealm);
	if (ret)
	    goto out;

	ret = krb5_unparse_name(context, tp, &tpn);
	if (ret)
	    goto out;

	ret = _krb5_principalname2krb5_principal(context,
						 &dp,
						 t->sname,
						 t->realm);
	if (ret)
	    goto out;

	ret = krb5_unparse_name(context, dp, &dpn);
	if (ret)
	    goto out;

	
	if (adtkt.flags.forwardable == 0) {
	    kdc_log(context, config, 0,
		    ""Missing forwardable flag on ticket for ""
		    ""constrained delegation from %s (%s) as %s to %s "",
		    cpn, dpn, tpn, spn);
	    ret = KRB5KDC_ERR_BADOPTION;
	    goto out;
	}

	ret = check_constrained_delegation(context, config, clientdb,
					   client, server, sp);
	if (ret) {
	    kdc_log(context, config, 0,
		    ""constrained delegation from %s (%s) as %s to %s not allowed"",
		    cpn, dpn, tpn, spn);
	    goto out;
	}

	ret = verify_flags(context, config, &adtkt, tpn);
	if (ret) {
	    goto out;
	}

	krb5_data_free(&rspac);

	
	ret = check_PAC(context, config, tp, dp,
			client, server, krbtgt,
			&clientkey->key,
			ekey, &tkey_sign->key,
			&adtkt, &rspac, &ad_signedpath);
	if (ret) {
	    const char *msg = krb5_get_error_message(context, ret);
	    kdc_log(context, config, 0,
		    ""Verify delegated PAC failed to %s for client""
		    ""%s (%s) as %s from %s with %s"",
		    spn, cpn, dpn, tpn, from, msg);
	    krb5_free_error_message(context, msg);
	    goto out;
	}

	
	ret = check_KRB5SignedPath(context,
				   config,
				   krbtgt,
				   cp,
				   &adtkt,
				   NULL,
				   &ad_signedpath);
	if (ret) {
	    const char *msg = krb5_get_error_message(context, ret);
	    kdc_log(context, config, 0,
		    ""KRB5SignedPath check from service %s failed ""
		    ""for delegation to %s for client %s (%s)""
		    ""from %s failed with %s"",
		    spn, tpn, dpn, cpn, from, msg);
	    krb5_free_error_message(context, msg);
	    goto out;
	}

	if (!ad_signedpath) {
	    ret = KRB5KDC_ERR_BADOPTION;
	    kdc_log(context, config, 0,
		    ""Ticket not signed with PAC nor SignedPath service %s failed ""
		    ""for delegation to %s for client %s (%s)""
		    ""from %s"",
		    spn, tpn, dpn, cpn, from);
	    goto out;
	}

	kdc_log(context, config, 0, ""constrained delegation for %s ""
		""from %s (%s) to %s"", tpn, cpn, dpn, spn);
    }

    

    ret = kdc_check_flags(context, config,
			  client, cpn,
			  server, spn,
			  FALSE);
    if(ret)
	goto out;

    if((b->kdc_options.validate || b->kdc_options.renew) &&
       !krb5_principal_compare(context,
			       krbtgt->entry.principal,
			       server->entry.principal)){
	kdc_log(context, config, 0, ""Inconsistent request."");
	ret = KRB5KDC_ERR_SERVER_NOMATCH;
	goto out;
    }

    
    if(!_kdc_check_addresses(context, config, tgt->caddr, from_addr)) {
	ret = KRB5KRB_AP_ERR_BADADDR;
	kdc_log(context, config, 0, ""Request from wrong address"");
	goto out;
    }

    
    if (ref_realm) {
	PA_DATA pa;
	krb5_crypto crypto;

	kdc_log(context, config, 0,
		""Adding server referral to %s"", ref_realm);

	ret = krb5_crypto_init(context, &sessionkey, 0, &crypto);
	if (ret)
	    goto out;

	ret = build_server_referral(context, config, crypto, ref_realm,
				    NULL, s, &pa.padata_value);
	krb5_crypto_destroy(context, crypto);
	if (ret) {
	    kdc_log(context, config, 0,
		    ""Failed building server referral"");
	    goto out;
	}
	pa.padata_type = KRB5_PADATA_SERVER_REFERRAL;

	ret = add_METHOD_DATA(&enc_pa_data, &pa);
	krb5_data_free(&pa.padata_value);
	if (ret) {
	    kdc_log(context, config, 0,
		    ""Add server referral METHOD-DATA failed"");
	    goto out;
	}
    }

    

    ret = tgs_make_reply(context,
			 config,
			 b,
			 tp,
			 tgt,
			 replykey,
			 rk_is_subkey,
			 ekey,
			 &sessionkey,
			 kvno,
			 *auth_data,
			 server,
			 rsp,
			 spn,
			 client,
			 cp,
                         tgt_realm,
			 krbtgt_out,
			 tkey_sign->key.keytype,
			 spp,
			 &rspac,
			 &enc_pa_data,
			 e_text,
			 reply);

out:
    if (tpn != cpn)
	    free(tpn);
    free(spn);
    free(cpn);
    free(dpn);
    free(krbtgt_out_n);
    _krb5_free_capath(context, capath);

    krb5_data_free(&rspac);
    krb5_free_keyblock_contents(context, &sessionkey);
    if(krbtgt_out)
	_kdc_free_ent(context, krbtgt_out);
    if(server)
	_kdc_free_ent(context, server);
    if(client)
	_kdc_free_ent(context, client);
    if(s4u2self_impersonated_client)
	_kdc_free_ent(context, s4u2self_impersonated_client);

    if (tp && tp != cp)
	krb5_free_principal(context, tp);
    krb5_free_principal(context, cp);
    krb5_free_principal(context, dp);
    krb5_free_principal(context, sp);
    krb5_free_principal(context, krbtgt_out_principal);
    free(ref_realm);
    free_METHOD_DATA(&enc_pa_data);

    free_EncTicketPart(&adtkt);

    return ret;
}
","1. ret = krb5_decrypt_ticket(context, t, &uukey->key, &adtkt, 0);
2. if (ref_realm == NULL) {
3. goto out;
4. NULL, &s4u2self_impersonated_clientdb, &s4u2self_impersonated_client);
5. client, server, sp);
6. client,","112
158
249
545
690
840","CWE-362,CWE-295,CWE-18,CWE-116"
_gd2GetHeader-95452967570381,"static int _gd2GetHeader(gdIOCtxPtr in, int *sx, int *sy, int *cs, int *vers, int *fmt, int *ncx, int *ncy, t_chunk_info ** chunkIdx)
{
	int i;
	int ch;
	char id[5];
	t_chunk_info *cidx;
	int sidx;
	int nc;

	GD2_DBG(php_gd_error(""Reading gd2 header info""));

	for (i = 0; i < 4; i++) {
		ch = gdGetC(in);
		if (ch == EOF) {
			goto fail1;
		}
		id[i] = ch;
	}
	id[4] = 0;

	GD2_DBG(php_gd_error(""Got file code: %s"", id));

	
	if (strcmp(id, GD2_ID) != 0) {
		GD2_DBG(php_gd_error(""Not a valid gd2 file""));
		goto fail1;
	}

	
	if (gdGetWord(vers, in) != 1) {
		goto fail1;
	}
	GD2_DBG(php_gd_error(""Version: %d"", *vers));

	if ((*vers != 1) && (*vers != 2)) {
		GD2_DBG(php_gd_error(""Bad version: %d"", *vers));
		goto fail1;
	}

	
	if (!gdGetWord(sx, in)) {
		GD2_DBG(php_gd_error(""Could not get x-size""));
		goto fail1;
	}
	if (!gdGetWord(sy, in)) {
		GD2_DBG(php_gd_error(""Could not get y-size""));
		goto fail1;
	}
	GD2_DBG(php_gd_error(""Image is %dx%d"", *sx, *sy));

	
	if (gdGetWord(cs, in) != 1) {
		goto fail1;
	}
	GD2_DBG(php_gd_error(""ChunkSize: %d"", *cs));

	if ((*cs < GD2_CHUNKSIZE_MIN) || (*cs > GD2_CHUNKSIZE_MAX)) {
		GD2_DBG(php_gd_error(""Bad chunk size: %d"", *cs));
		goto fail1;
	}

	
	if (gdGetWord(fmt, in) != 1) {
		goto fail1;
	}
	GD2_DBG(php_gd_error(""Format: %d"", *fmt));

	if ((*fmt != GD2_FMT_RAW) && (*fmt != GD2_FMT_COMPRESSED) && (*fmt != GD2_FMT_TRUECOLOR_RAW) && (*fmt != GD2_FMT_TRUECOLOR_COMPRESSED)) {
		GD2_DBG(php_gd_error(""Bad data format: %d"", *fmt));
		goto fail1;
	}

	
	if (gdGetWord(ncx, in) != 1) {
		goto fail1;
	}
	GD2_DBG(php_gd_error(""%d Chunks Wide"", *ncx));

	
	if (gdGetWord(ncy, in) != 1) {
		goto fail1;
	}
	GD2_DBG(php_gd_error(""%d Chunks vertically"", *ncy));

	if (gd2_compressed(*fmt)) {
		nc = (*ncx) * (*ncy);
		GD2_DBG(php_gd_error(""Reading %d chunk index entries"", nc));
		if (overflow2(sidx, nc)) {
			goto fail1;
		}
		sidx = sizeof(t_chunk_info) * nc;
		if (sidx <= 0) {
			goto fail1;
		}
		cidx = gdCalloc(sidx, 1);
		if (cidx == NULL) {
			goto fail1;
		}

		for (i = 0; i < nc; i++) {
			if (gdGetInt(&cidx[i].offset, in) != 1) {
				gdFree(cidx);
				goto fail1;
			}
			if (gdGetInt(&cidx[i].size, in) != 1) {
				gdFree(cidx);
				goto fail1;
			}
			if (cidx[i].offset < 0 || cidx[i].size < 0) {
				gdFree(cidx);
				goto fail1;
			}
		}
		*chunkIdx = cidx;
	}

	GD2_DBG(php_gd_error(""gd2 header complete""));

	return 1;

fail1:
	return 0;
}
","1. char id[5];
2. int nc;
3. id[i] = ch;
4. if (gdGetWord(vers, in) != 1) {
5. goto fail1;
6. goto fail1;
7. GD2_DBG(php_gd_error(""Bad chunk size: %d"", *cs));
8. goto fail1;
9. GD2_DBG(php_gd_error(""%d Chunks vertically"", *ncy));
10. GD2_DBG(php_gd_error(""Reading %d chunk index entries"", nc));
if (overflow2(sidx, nc)) {
11. goto fail1;
12. gdFree(cidx);
13. return 0;","5
8
17
30
37
53
58
75
83
87-88
107
110
122","CWE-190,CWE-125,CWE-59,CWE-119"
credssp_new,"rdpCredssp* credssp_new(freerdp* instance, rdpTransport* transport, rdpSettings* settings)
{
	rdpCredssp* credssp;

	credssp = (rdpCredssp*) malloc(sizeof(rdpCredssp));
	ZeroMemory(credssp, sizeof(rdpCredssp));

	if (credssp != NULL)
	{
		HKEY hKey;
		LONG status;
		DWORD dwType;
		DWORD dwSize;

		credssp->instance = instance;
		credssp->settings = settings;
		credssp->server = settings->ServerMode;
		credssp->transport = transport;
		credssp->send_seq_num = 0;
		credssp->recv_seq_num = 0;
 		ZeroMemory(&credssp->negoToken, sizeof(SecBuffer));
 		ZeroMemory(&credssp->pubKeyAuth, sizeof(SecBuffer));
 		ZeroMemory(&credssp->authInfo, sizeof(SecBuffer));
		SecInvalidateHandle(&credssp->context);
 
 		if (credssp->server)
 		{
			status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T(""Software\\FreeRDP\\Server""),
					0, KEY_READ | KEY_WOW64_64KEY, &hKey);

			if (status == ERROR_SUCCESS)
			{
				status = RegQueryValueEx(hKey, _T(""SspiModule""), NULL, &dwType, NULL, &dwSize);

				if (status == ERROR_SUCCESS)
				{
					credssp->SspiModule = (LPTSTR) malloc(dwSize + sizeof(TCHAR));

					status = RegQueryValueEx(hKey, _T(""SspiModule""), NULL, &dwType,
							(BYTE*) credssp->SspiModule, &dwSize);

					if (status == ERROR_SUCCESS)
					{
						_tprintf(_T(""Using SSPI Module: %s\n""), credssp->SspiModule);
						RegCloseKey(hKey);
					}
				}
			}
		}
	}

	return credssp;
}
","1. credssp = (rdpCredssp*) malloc(sizeof(rdpCredssp));
2. if (credssp != NULL)
3. credssp->send_seq_num = 0;
4. status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T(""Software\\FreeRDP\\Server""),
5. credssp->SspiModule = (LPTSTR) malloc(dwSize + sizeof(TCHAR));","5
8
19
28
37","CWE-476,CWE-908,CWE-200,CWE-787,CWE-119"
may_create_in_sticky-33817489490564,"static int may_create_in_sticky(umode_t dir_mode, kuid_t dir_uid,
				struct inode * const inode)
{
	if ((!sysctl_protected_fifos && S_ISFIFO(inode->i_mode)) ||
	    (!sysctl_protected_regular && S_ISREG(inode->i_mode)) ||
	    likely(!(dir_mode & S_ISVTX)) ||
	    uid_eq(inode->i_uid, dir_uid) ||
	    uid_eq(current_fsuid(), inode->i_uid))
		return 0;

	if (likely(dir_mode & 0002) ||
	    (dir_mode & 0020 &&
	     ((sysctl_protected_fifos >= 2 && S_ISFIFO(inode->i_mode)) ||
	      (sysctl_protected_regular >= 2 && S_ISREG(inode->i_mode))))) {
		const char *operation = S_ISFIFO(inode->i_mode) ?
					""sticky_create_fifo"" :
					""sticky_create_regular"";
		audit_log_path_denied(AUDIT_ANOM_CREAT, operation);
		return -EACCES;
	}
	return 0;
}
","1. static int may_create_in_sticky(umode_t dir_mode, kuid_t dir_uid,
struct inode * const inode)
2. likely(!(dir_mode & S_ISVTX)) ||
3. uid_eq(current_fsuid(), inode->i_uid))
4. (sysctl_protected_regular >= 2 && S_ISREG(inode->i_mode))))) {
const char *operation = S_ISFIFO(inode->i_mode) ?
5. ""sticky_create_regular"";","1-2
6
8
14-15
17","CWE-1284,CWE-264,CWE-416,CWE-119,CWE-59"
userauth_pubkey-199624108194204,"static int
userauth_pubkey(struct ssh *ssh)
{
	Authctxt *authctxt = ssh->authctxt;
	struct passwd *pw = authctxt->pw;
	struct sshbuf *b = NULL;
	struct sshkey *key = NULL;
	char *pkalg = NULL, *userstyle = NULL, *key_s = NULL, *ca_s = NULL;
	u_char *pkblob = NULL, *sig = NULL, have_sig;
	size_t blen, slen;
	int r, pktype;
	int authenticated = 0;
	struct sshauthopt *authopts = NULL;

	if ((r = sshpkt_get_u8(ssh, &have_sig)) != 0 ||
	    (r = sshpkt_get_cstring(ssh, &pkalg, NULL)) != 0 ||
	    (r = sshpkt_get_string(ssh, &pkblob, &blen)) != 0)
		fatal(""%s: parse request failed: %s"", __func__, ssh_err(r));
	pktype = sshkey_type_from_name(pkalg);
	if (pktype == KEY_UNSPEC) {
		
		verbose(""%s: unsupported public key algorithm: %s"",
		    __func__, pkalg);
		goto done;
	}
	if ((r = sshkey_from_blob(pkblob, blen, &key)) != 0) {
		error(""%s: could not parse key: %s"", __func__, ssh_err(r));
		goto done;
	}
	if (key == NULL) {
		error(""%s: cannot decode key: %s"", __func__, pkalg);
		goto done;
	}
	if (key->type != pktype) {
		error(""%s: type mismatch for decoded key ""
		    ""(received %d, expected %d)"", __func__, key->type, pktype);
		goto done;
	}
	if (sshkey_type_plain(key->type) == KEY_RSA &&
	    (ssh->compat & SSH_BUG_RSASIGMD5) != 0) {
		logit(""Refusing RSA key because client uses unsafe ""
		    ""signature scheme"");
		goto done;
	}
	if (auth2_key_already_used(authctxt, key)) {
		logit(""refusing previously-used %s key"", sshkey_type(key));
		goto done;
	}
	if (match_pattern_list(pkalg, options.pubkey_key_types, 0) != 1) {
		logit(""%s: key type %s not in PubkeyAcceptedKeyTypes"",
		    __func__, sshkey_ssh_name(key));
		goto done;
	}

	key_s = format_key(key);
	if (sshkey_is_cert(key))
		ca_s = format_key(key->cert->signature_key);

	if (have_sig) {
		debug3(""%s: have %s signature for %s%s%s"",
		    __func__, pkalg, key_s,
		    ca_s == NULL ? """" : "" CA "",
		    ca_s == NULL ? """" : ca_s);
		if ((r = sshpkt_get_string(ssh, &sig, &slen)) != 0 ||
		    (r = sshpkt_get_end(ssh)) != 0)
			fatal(""%s: %s"", __func__, ssh_err(r));
		if ((b = sshbuf_new()) == NULL)
			fatal(""%s: sshbuf_new failed"", __func__);
		if (ssh->compat & SSH_OLD_SESSIONID) {
			if ((r = sshbuf_put(b, session_id2,
			    session_id2_len)) != 0)
				fatal(""%s: sshbuf_put session id: %s"",
				    __func__, ssh_err(r));
		} else {
			if ((r = sshbuf_put_string(b, session_id2,
			    session_id2_len)) != 0)
				fatal(""%s: sshbuf_put_string session id: %s"",
				    __func__, ssh_err(r));
		}
		if (!authctxt->valid || authctxt->user == NULL) {
			debug2(""%s: disabled because of invalid user"",
			    __func__);
			goto done;
		}
		
		xasprintf(&userstyle, ""%s%s%s"", authctxt->user,
		    authctxt->style ? "":"" : """",
		    authctxt->style ? authctxt->style : """");
		if ((r = sshbuf_put_u8(b, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||
		    (r = sshbuf_put_cstring(b, userstyle)) != 0 ||
		    (r = sshbuf_put_cstring(b, authctxt->service)) != 0 ||
		    (r = sshbuf_put_cstring(b, ""publickey"")) != 0 ||
		    (r = sshbuf_put_u8(b, have_sig)) != 0 ||
		    (r = sshbuf_put_cstring(b, pkalg) != 0) ||
		    (r = sshbuf_put_string(b, pkblob, blen)) != 0)
			fatal(""%s: build packet failed: %s"",
			    __func__, ssh_err(r));
#ifdef DEBUG_PK
		sshbuf_dump(b, stderr);
#endif
		
		authenticated = 0;
		if (PRIVSEP(user_key_allowed(ssh, pw, key, 1, &authopts)) &&
		    PRIVSEP(sshkey_verify(key, sig, slen,
		    sshbuf_ptr(b), sshbuf_len(b),
		    (ssh->compat & SSH_BUG_SIGTYPE) == 0 ? pkalg : NULL,
		    ssh->compat)) == 0) {
			authenticated = 1;
		}
		sshbuf_free(b);
		auth2_record_key(authctxt, authenticated, key);
	} else {
		debug(""%s: test pkalg %s pkblob %s%s%s"",
		    __func__, pkalg, key_s,
		    ca_s == NULL ? """" : "" CA "",
		    ca_s == NULL ? """" : ca_s);

		if ((r = sshpkt_get_end(ssh)) != 0)
			fatal(""%s: %s"", __func__, ssh_err(r));

		if (!authctxt->valid || authctxt->user == NULL) {
			debug2(""%s: disabled because of invalid user"",
			    __func__);
			goto done;
		}
		
		
		if (PRIVSEP(user_key_allowed(ssh, pw, key, 0, NULL))) {
			if ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_PK_OK))
			    != 0 ||
			    (r = sshpkt_put_cstring(ssh, pkalg)) != 0 ||
			    (r = sshpkt_put_string(ssh, pkblob, blen)) != 0 ||
			    (r = sshpkt_send(ssh)) != 0 ||
			    (r = ssh_packet_write_wait(ssh)) != 0)
				fatal(""%s: %s"", __func__, ssh_err(r));
			authctxt->postponed = 1;
		}
	}
done:
	if (authenticated == 1 && auth_activate_options(ssh, authopts) != 0) {
		debug(""%s: key options inconsistent with existing"", __func__);
		authenticated = 0;
	}
	debug2(""%s: authenticated %d pkalg %s"", __func__, authenticated, pkalg);

	sshauthopt_free(authopts);
	sshkey_free(key);
	free(userstyle);
	free(pkalg);
	free(pkblob);
	free(key_s);
	free(ca_s);
	free(sig);
	return authenticated;
}
","1. struct sshkey *key = NULL;
2. if (pktype == KEY_UNSPEC) {
3. if (key == NULL) {
4. logit(""Refusing RSA key because client uses unsafe ""
5. logit(""refusing previously-used %s key"", sshkey_type(key));
goto done;
6. if (match_pattern_list(pkalg, options.pubkey_key_types, 0) != 1) {
7. key_s = format_key(key);
8. debug3(""%s: have %s signature for %s%s%s"",
9. goto done;
10. authctxt->style ? "":"" : """",
11. if ((r = sshbuf_put_u8(b, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||
12. (r = sshbuf_put_cstring(b, pkalg) != 0) ||
13. sshbuf_free(b);
14. __func__, pkalg, key_s,
15. (r = sshpkt_send(ssh)) != 0 ||
16. if (authenticated == 1 && auth_activate_options(ssh, authopts) != 0) {","7
20
30
41
46-47
49
55
60
83
87
89
94
110
114
139
146","CWE-310,CWE-362,CWE-190,CWE-200,CWE-399"
ssl2_generate_key_material,"
#define SSL

int ssl2_generate_key_material(SSL *s)
{
    unsigned int i;
    EVP_MD_CTX ctx;
    unsigned char *km;
    unsigned char c = '0';
    const EVP_MD *md5;
    int md_size;

    md5 = EVP_md5();

# ifdef CHARSET_EBCDIC
    c = os_toascii['0'];        
# endif
    EVP_MD_CTX_init(&ctx);
    km = s->s2->key_material;

    if (s->session->master_key_length < 0 ||
        s->session->master_key_length > (int)sizeof(s->session->master_key)) {
        SSLerr(SSL_F_SSL2_GENERATE_KEY_MATERIAL, ERR_R_INTERNAL_ERROR);
        return 0;
    }
    md_size = EVP_MD_size(md5);
    if (md_size < 0)
        return 0;
    for (i = 0; i < s->s2->key_material_length; i += md_size) {
        if (((km - s->s2->key_material) + md_size) >
            (int)sizeof(s->s2->key_material)) {
            
            SSLerr(SSL_F_SSL2_GENERATE_KEY_MATERIAL, ERR_R_INTERNAL_ERROR);
            return 0;
        }

        EVP_DigestInit_ex(&ctx, md5, NULL);
 
         OPENSSL_assert(s->session->master_key_length >= 0
                        && s->session->master_key_length
                       <= (int)sizeof(s->session->master_key));
         EVP_DigestUpdate(&ctx, s->session->master_key,
                          s->session->master_key_length);
         EVP_DigestUpdate(&ctx, &c, 1);
        c++;
        EVP_DigestUpdate(&ctx, s->s2->challenge, s->s2->challenge_length);
        EVP_DigestUpdate(&ctx, s->s2->conn_id, s->s2->conn_id_length);
        EVP_DigestFinal_ex(&ctx, km, NULL);
        km += md_size;
    }

    EVP_MD_CTX_cleanup(&ctx);
    return 1;
}
","1. int ssl2_generate_key_material(SSL *s)
2. EVP_MD_CTX ctx;
3. md5 = EVP_md5();
4. EVP_MD_CTX_init(&ctx);
5. SSLerr(SSL_F_SSL2_GENERATE_KEY_MATERIAL, ERR_R_INTERNAL_ERROR);
6. return 1;","4
7
13
19
24
56","CWE-200,CWE-20,CWE-59"
ReadTEXTImage,"
#define ExceptionInfo
#define Image
#define ImageInfo

static Image *ReadTEXTImage(const ImageInfo *image_info,Image *image,
  char *text,ExceptionInfo *exception)
{
  char
    filename[MaxTextExtent],
    geometry[MaxTextExtent],
    *p;

  DrawInfo
    *draw_info;

  Image
    *texture;

  MagickBooleanType
    status;

  PointInfo
    delta;

  RectangleInfo
    page;

  ssize_t
    offset;

  TypeMetric
    metrics;

  
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickSignature);
  
  delta.x=DefaultResolution;
  delta.y=DefaultResolution;
  if ((image->x_resolution == 0.0) || (image->y_resolution == 0.0))
    {
      GeometryInfo
        geometry_info;

      MagickStatusType
        flags;

      flags=ParseGeometry(PSDensityGeometry,&geometry_info);
      image->x_resolution=geometry_info.rho;
      image->y_resolution=geometry_info.sigma;
      if ((flags & SigmaValue) == 0)
        image->y_resolution=image->x_resolution;
    }
  page.width=612;
  page.height=792;
  page.x=43;
  page.y=43;
  if (image_info->page != (char *) NULL)
    (void) ParseAbsoluteGeometry(image_info->page,&page);
  
  image->columns=(size_t) floor((((double) page.width*image->x_resolution)/
     delta.x)+0.5);
   image->rows=(size_t) floor((((double) page.height*image->y_resolution)/
     delta.y)+0.5);
  status=SetImageExtent(image,image->columns,image->rows);
  if (status == MagickFalse)
    {
      InheritException(exception,&image->exception);
      return(DestroyImageList(image));
    }
   image->page.x=0;
   image->page.y=0;
   texture=(Image *) NULL;
  if (image_info->texture != (char *) NULL)
    {
      ImageInfo
        *read_info;

      read_info=CloneImageInfo(image_info);
      SetImageInfoBlob(read_info,(void *) NULL,0);
      (void) CopyMagickString(read_info->filename,image_info->texture,
        MaxTextExtent);
      texture=ReadImage(read_info,exception);
      read_info=DestroyImageInfo(read_info);
    }
  
  (void) SetImageBackgroundColor(image);
  draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL);
  (void) CloneString(&draw_info->text,image_info->filename);
  (void) FormatLocaleString(geometry,MaxTextExtent,""0x0%+ld%+ld"",(long) page.x,
    (long) page.y);
  (void) CloneString(&draw_info->geometry,geometry);
  status=GetTypeMetrics(image,draw_info,&metrics);
  if (status == MagickFalse)
    ThrowReaderException(TypeError,""UnableToGetTypeMetrics"");
  page.y=(ssize_t) ceil((double) page.y+metrics.ascent-0.5);
  (void) FormatLocaleString(geometry,MaxTextExtent,""0x0%+ld%+ld"",(long) page.x,
    (long) page.y);
  (void) CloneString(&draw_info->geometry,geometry);
  (void) CopyMagickString(filename,image_info->filename,MaxTextExtent);
  if (*draw_info->text != '\0')
    *draw_info->text='\0';
  p=text;
  for (offset=2*page.y; p != (char *) NULL; )
  {
    
    (void) ConcatenateString(&draw_info->text,text);
    (void) ConcatenateString(&draw_info->text,""\n"");
    offset+=(ssize_t) (metrics.ascent-metrics.descent);
    if (image->previous == (Image *) NULL)
      {
        status=SetImageProgress(image,LoadImageTag,offset,image->rows);
        if (status == MagickFalse)
          break;
      }
    p=ReadBlobString(image,text);
    if ((offset < (ssize_t) image->rows) && (p != (char *) NULL))
      continue;
    if (texture != (Image *) NULL)
      {
        MagickProgressMonitor
          progress_monitor;

        progress_monitor=SetImageProgressMonitor(image,
          (MagickProgressMonitor) NULL,image->client_data);
        (void) TextureImage(image,texture);
        (void) SetImageProgressMonitor(image,progress_monitor,
          image->client_data);
      }
    (void) AnnotateImage(image,draw_info);
    if (p == (char *) NULL)
      break;
    
    *draw_info->text='\0';
    offset=2*page.y;
    AcquireNextImage(image_info,image);
    if (GetNextImageInList(image) == (Image *) NULL)
      {
        image=DestroyImageList(image);
        return((Image *) NULL);
      }
    image->next->columns=image->columns;
    image->next->rows=image->rows;
    image=SyncNextImageInList(image);
    (void) CopyMagickString(image->filename,filename,MaxTextExtent);
    (void) SetImageBackgroundColor(image);
    status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
      GetBlobSize(image));
    if (status == MagickFalse)
      break;
  }
  if (texture != (Image *) NULL)
    {
      MagickProgressMonitor
        progress_monitor;

      progress_monitor=SetImageProgressMonitor(image,
        (MagickProgressMonitor) NULL,image->client_data);
      (void) TextureImage(image,texture);
      (void) SetImageProgressMonitor(image,progress_monitor,image->client_data);
    }
  (void) AnnotateImage(image,draw_info);
  if (texture != (Image *) NULL)
    texture=DestroyImage(texture);
  draw_info=DestroyDrawInfo(draw_info);
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}
","1. char *text,ExceptionInfo *exception)
2. status;
3. assert(image_info != (const ImageInfo *) NULL);
assert(image_info->signature == MagickSignature);
if (image_info->debug != MagickFalse)
4. page.x=43;
5. return(DestroyImageList(image));
6. image->page.y=0;
texture=(Image *) NULL;
7. SetImageInfoBlob(read_info,(void *) NULL,0);
8. MaxTextExtent);
texture=ReadImage(read_info,exception);
9. *draw_info->text='\0';
10. for (offset=2*page.y; p != (char *) NULL; )
11. if (image->previous == (Image *) NULL)
12. break;
13. p=ReadBlobString(image,text);
14. continue;
15. (void) TextureImage(image,texture);
16. if (p == (char *) NULL)
17. AcquireNextImage(image_info,image);
18. image->next->columns=image->columns;
19. image=SyncNextImageInList(image);
(void) CopyMagickString(image->filename,filename,MaxTextExtent);
(void) SetImageBackgroundColor(image);
status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
GetBlobSize(image));
20. progress_monitor;
21. (void) SetImageProgressMonitor(image,progress_monitor,image->client_data);
22. (void) CloseBlob(image);","7
21
38-40
66
81
84-85
92
94-95
116
118
126
130
132
134
142
147
154
160
162-166
173
178
184",CWE-119
bta_hh_co_open,"
#define UINT8

void bta_hh_co_open(UINT8 dev_handle, UINT8 sub_class, tBTA_HH_ATTR_MASK attr_mask,
                    UINT8 app_id)
{
    UINT32 i;
 btif_hh_device_t *p_dev = NULL;

 if (dev_handle == BTA_HH_INVALID_HANDLE) {
        APPL_TRACE_WARNING(""%s: Oops, dev_handle (%d) is invalid..."",
                           __FUNCTION__, dev_handle);
 return;
 }

 for (i = 0; i < BTIF_HH_MAX_HID; i++) {
        p_dev = &btif_hh_cb.devices[i];
 if (p_dev->dev_status != BTHH_CONN_STATE_UNKNOWN &&
            p_dev->dev_handle == dev_handle) {
            APPL_TRACE_WARNING(""%s: Found an existing device with the same handle ""
 ""dev_status = %d"",__FUNCTION__,
                                                                p_dev->dev_status);
            APPL_TRACE_WARNING(""%s:     bd_addr = [%02X:%02X:%02X:%02X:%02X:]"", __FUNCTION__,
                 p_dev->bd_addr.address[0], p_dev->bd_addr.address[1], p_dev->bd_addr.address[2],
                 p_dev->bd_addr.address[3], p_dev->bd_addr.address[4]);
                 APPL_TRACE_WARNING(""%s:     attr_mask = 0x%04x, sub_class = 0x%02x, app_id = %d"",

                                   __FUNCTION__, p_dev->attr_mask, p_dev->sub_class, p_dev->app_id);
 
             if(p_dev->fd<0) {
                p_dev->fd = TEMP_FAILURE_RETRY(open(dev_path, O_RDWR | O_CLOEXEC));
                 if (p_dev->fd < 0){
                     APPL_TRACE_ERROR(""%s: Error: failed to open uhid, err:%s"",
                                                                     __FUNCTION__,strerror(errno));
 return;
 }else
                    APPL_TRACE_DEBUG(""%s: uhid fd = %d"", __FUNCTION__, p_dev->fd);
 }

            p_dev->hh_keep_polling = 1;
            p_dev->hh_poll_thread_id = create_thread(btif_hh_poll_event_thread, p_dev);
 break;
 }
        p_dev = NULL;
 }

 if (p_dev == NULL) {
 for (i = 0; i < BTIF_HH_MAX_HID; i++) {
 if (btif_hh_cb.devices[i].dev_status == BTHH_CONN_STATE_UNKNOWN) {
                p_dev = &btif_hh_cb.devices[i];
                p_dev->dev_handle = dev_handle;
                p_dev->attr_mask  = attr_mask;
                p_dev->sub_class  = sub_class;
                p_dev->app_id     = app_id;
                p_dev->local_vup  = FALSE;

 
                 btif_hh_cb.device_num++;
                p_dev->fd = TEMP_FAILURE_RETRY(open(dev_path, O_RDWR | O_CLOEXEC));
                 if (p_dev->fd < 0){
                     APPL_TRACE_ERROR(""%s: Error: failed to open uhid, err:%s"",
                                                                     __FUNCTION__,strerror(errno));
 return;
 }else{
                    APPL_TRACE_DEBUG(""%s: uhid fd = %d"", __FUNCTION__, p_dev->fd);
                    p_dev->hh_keep_polling = 1;
                    p_dev->hh_poll_thread_id = create_thread(btif_hh_poll_event_thread, p_dev);
 }


 break;
 }
 }
 }

 if (p_dev == NULL) {
        APPL_TRACE_ERROR(""%s: Error: too many HID devices are connected"", __FUNCTION__);
 return;
 }

    p_dev->dev_status = BTHH_CONN_STATE_CONNECTED;
    APPL_TRACE_DEBUG(""%s: Return device status %d"", __FUNCTION__, p_dev->dev_status);
}
","1. APPL_TRACE_WARNING(""%s: Oops, dev_handle (%d) is invalid..."",
2. __FUNCTION__, p_dev->attr_mask, p_dev->sub_class, p_dev->app_id);
3. if(p_dev->fd<0) {
4. __FUNCTION__,strerror(errno));
5. p_dev->hh_keep_polling = 1;
6. for (i = 0; i < BTIF_HH_MAX_HID; i++) {
if (btif_hh_cb.devices[i].dev_status == BTHH_CONN_STATE_UNKNOWN) {
7. p_dev->fd = TEMP_FAILURE_RETRY(open(dev_path, O_RDWR | O_CLOEXEC));
8. APPL_TRACE_ERROR(""%s: Error: failed to open uhid, err:%s"",","11
28
30
34
40
48-49
59
61","CWE-476,CWE-362,CWE-119"
tcp_v6_syn_recv_sock_2-161770931890857,"static struct sock *tcp_v6_syn_recv_sock_2(const struct sock *sk, struct sk_buff *skb,
					 struct request_sock *req,
					 struct dst_entry *dst,
					 struct request_sock *req_unhash,
					 bool *own_req)
{
	struct inet_request_sock *ireq;
	struct ipv6_pinfo *newnp;
	const struct ipv6_pinfo *np = inet6_sk(sk);
	struct ipv6_txoptions *opt;
	struct tcp6_sock *newtcp6sk;
	struct inet_sock *newinet;
	struct tcp_sock *newtp;
	struct sock *newsk;
#ifdef CONFIG_TCP_MD5SIG
	struct tcp_md5sig_key *key;
#endif
	struct flowi6 fl6;

	if (skb->protocol == htons(ETH_P_IP)) {
		

		newsk = tcp_v4_syn_recv_sock(sk, skb, req, dst,
					     req_unhash, own_req);

		if (!newsk)
			return NULL;

		newtcp6sk = (struct tcp6_sock *)newsk;
		inet_sk(newsk)->pinet6 = &newtcp6sk->inet6;

		newinet = inet_sk(newsk);
		newnp = inet6_sk(newsk);
		newtp = tcp_sk(newsk);

		memcpy(newnp, np, sizeof(struct ipv6_pinfo));

		newnp->saddr = newsk->sk_v6_rcv_saddr;

		inet_csk(newsk)->icsk_af_ops = &ipv6_mapped;
		newsk->sk_backlog_rcv = tcp_v4_do_rcv;
#ifdef CONFIG_TCP_MD5SIG
		newtp->af_specific = &tcp_sock_ipv6_mapped_specific;
#endif

		newnp->ipv6_mc_list = NULL;
		newnp->ipv6_ac_list = NULL;
		newnp->ipv6_fl_list = NULL;
		newnp->pktoptions  = NULL;
		newnp->opt	   = NULL;
		newnp->mcast_oif   = tcp_v6_iif(skb);
		newnp->mcast_hops  = ipv6_hdr(skb)->hop_limit;
		newnp->rcv_flowinfo = ip6_flowinfo(ipv6_hdr(skb));
		if (np->repflow)
			newnp->flow_label = ip6_flowlabel(ipv6_hdr(skb));

		

		
		tcp_sync_mss(newsk, inet_csk(newsk)->icsk_pmtu_cookie);

		return newsk;
	}

	ireq = inet_rsk(req);

	if (sk_acceptq_is_full(sk))
		goto out_overflow;

	if (!dst) {
		dst = inet6_csk_route_req(sk, &fl6, req, IPPROTO_TCP);
		if (!dst)
			goto out;
	}

	newsk = tcp_create_openreq_child(sk, req, skb);
	if (!newsk)
		goto out_nonewsk;

	

	newsk->sk_gso_type = SKB_GSO_TCPV6;
	ip6_dst_store(newsk, dst, NULL, NULL);
	inet6_sk_rx_dst_set(newsk, skb);

	newtcp6sk = (struct tcp6_sock *)newsk;
	inet_sk(newsk)->pinet6 = &newtcp6sk->inet6;

	newtp = tcp_sk(newsk);
	newinet = inet_sk(newsk);
	newnp = inet6_sk(newsk);

	memcpy(newnp, np, sizeof(struct ipv6_pinfo));

	newsk->sk_v6_daddr = ireq->ir_v6_rmt_addr;
	newnp->saddr = ireq->ir_v6_loc_addr;
	newsk->sk_v6_rcv_saddr = ireq->ir_v6_loc_addr;
	newsk->sk_bound_dev_if = ireq->ir_iif;

	
	newinet->inet_opt = NULL;
	newnp->ipv6_mc_list = NULL;
	newnp->ipv6_ac_list = NULL;
	newnp->ipv6_fl_list = NULL;

	
	newnp->rxopt.all = np->rxopt.all;

	newnp->pktoptions = NULL;
	newnp->opt	  = NULL;
	newnp->mcast_oif  = tcp_v6_iif(skb);
	newnp->mcast_hops = ipv6_hdr(skb)->hop_limit;
	newnp->rcv_flowinfo = ip6_flowinfo(ipv6_hdr(skb));
	if (np->repflow)
		newnp->flow_label = ip6_flowlabel(ipv6_hdr(skb));

	
	opt = ireq->ipv6_opt;
	if (!opt)
		opt = rcu_dereference(np->opt);
	if (opt) {
		opt = ipv6_dup_options(newsk, opt);
		RCU_INIT_POINTER(newnp->opt, opt);
	}
	inet_csk(newsk)->icsk_ext_hdr_len = 0;
	if (opt)
		inet_csk(newsk)->icsk_ext_hdr_len = opt->opt_nflen +
						    opt->opt_flen;

	tcp_ca_openreq_child(newsk, dst);

	tcp_sync_mss(newsk, dst_mtu(dst));
	newtp->advmss = tcp_mss_clamp(tcp_sk(sk), dst_metric_advmss(dst));

	tcp_initialize_rcv_mss(newsk);

	newinet->inet_daddr = newinet->inet_saddr = LOOPBACK4_IPV6;
	newinet->inet_rcv_saddr = LOOPBACK4_IPV6;

#ifdef CONFIG_TCP_MD5SIG
	
	key = tcp_v6_md5_do_lookup(sk, &newsk->sk_v6_daddr);
	if (key) {
		
		tcp_md5_do_add(newsk, (union tcp_md5_addr *)&newsk->sk_v6_daddr,
			       AF_INET6, key->key, key->keylen,
			       sk_gfp_mask(sk, GFP_ATOMIC));
	}
#endif

	if (__inet_inherit_port(sk, newsk) < 0) {
		inet_csk_prepare_forced_close(newsk);
		tcp_done(newsk);
		goto out;
	}
	*own_req = inet_ehash_nolisten(newsk, req_to_sk(req_unhash));
	if (*own_req) {
		tcp_move_syn(newtp, req);

		
		if (ireq->pktopts) {
			newnp->pktoptions = skb_clone(ireq->pktopts,
						      sk_gfp_mask(sk, GFP_ATOMIC));
			consume_skb(ireq->pktopts);
			ireq->pktopts = NULL;
			if (newnp->pktoptions) {
				tcp_v6_restore_cb(newnp->pktoptions);
				skb_set_owner_r(newnp->pktoptions, newsk);
			}
		}
	}

	return newsk;

out_overflow:
	__NET_INC_STATS(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);
out_nonewsk:
	dst_release(dst);
out:
	tcp_listendrop(sk);
	return NULL;
}
","1. struct request_sock *req_unhash,
bool *own_req)
2. struct inet_request_sock *ireq;
3. if (!newsk)
4. newnp->opt	   = NULL;
5. if (!newsk)
6. inet6_sk_rx_dst_set(newsk, skb);
7. newnp->pktoptions = NULL;
8. if (np->repflow)
9. RCU_INIT_POINTER(newnp->opt, opt);
10. opt->opt_flen;
11. newinet->inet_rcv_saddr = LOOPBACK4_IPV6;
12. if (__inet_inherit_port(sk, newsk) < 0) {
13. dst_release(dst);
14. tcp_listendrop(sk);
return NULL;","4-5
7
28
52
86
97
125
130
144
149
159
176
203
205-206","CWE-362,CWE-264,CWE-416"
bgp_capability_parse-165367285886243,"static int
bgp_capability_parse (struct peer *peer, size_t length, u_char **error)
{
  int ret;
  struct stream *s = BGP_INPUT (peer);
  size_t end = stream_get_getp (s) + length;
  
  assert (STREAM_READABLE (s) >= length);
  
  while (stream_get_getp (s) < end)
    {
      size_t start;
      u_char *sp = stream_pnt (s);
      struct capability_header caphdr;
      
      
      if (stream_get_getp(s) + 2 > end)
	{
	  zlog_info (""%s Capability length error (< header)"", peer->host);
	  bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);
	  return -1;
	}
      
      caphdr.code = stream_getc (s);
      caphdr.length = stream_getc (s);
      start = stream_get_getp (s);
      
      
      if (start + caphdr.length > end)
	{
	  zlog_info (""%s Capability length error (< length)"", peer->host);
	  bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);
	  return -1;
	}
      
      if (BGP_DEBUG (normal, NORMAL))
	zlog_debug (""%s OPEN has %s capability (%u), length %u"",
		   peer->host,
		   LOOKUP (capcode_str, caphdr.code),
		   caphdr.code, caphdr.length);
      
      
      switch (caphdr.code)
        {
          case CAPABILITY_CODE_MP:
          case CAPABILITY_CODE_REFRESH:
          case CAPABILITY_CODE_REFRESH_OLD:
          case CAPABILITY_CODE_ORF:
          case CAPABILITY_CODE_ORF_OLD:
          case CAPABILITY_CODE_RESTART:
          case CAPABILITY_CODE_DYNAMIC:
              
              if (caphdr.length < cap_minsizes[caphdr.code])
                {
                  zlog_info (""%s %s Capability length error: got %u,""
                             "" expected at least %u"",
                             peer->host, 
                             LOOKUP (capcode_str, caphdr.code),
                             caphdr.length, cap_minsizes[caphdr.code]);
                  bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);
                  return -1;
                }
          
          default:
            break;
        }
      
      switch (caphdr.code)
        {
          case CAPABILITY_CODE_MP:
            {
              
              if (! CHECK_FLAG (peer->flags, PEER_FLAG_OVERRIDE_CAPABILITY))
                {
                  
                  ret = bgp_capability_mp (peer, &caphdr);

                  
                  if (ret < 0)
                    {
                      
                      memcpy (*error, sp, caphdr.length + 2);
                      *error += caphdr.length + 2;
                    }
                }
            }
            break;
          case CAPABILITY_CODE_REFRESH:
          case CAPABILITY_CODE_REFRESH_OLD:
            {
              
              if (caphdr.code == CAPABILITY_CODE_REFRESH_OLD)
                SET_FLAG (peer->cap, PEER_CAP_REFRESH_OLD_RCV);
              else
                SET_FLAG (peer->cap, PEER_CAP_REFRESH_NEW_RCV);
            }
            break;
          case CAPABILITY_CODE_ORF:
          case CAPABILITY_CODE_ORF_OLD:
            if (bgp_capability_orf (peer, &caphdr))
              return -1;
            break;
          case CAPABILITY_CODE_RESTART:
            if (bgp_capability_restart (peer, &caphdr))
              return -1;
            break;
          case CAPABILITY_CODE_DYNAMIC:
            SET_FLAG (peer->cap, PEER_CAP_DYNAMIC_RCV);
            break;
          default:
            if (caphdr.code > 128)
              {
                
                zlog_warn (""%s Vendor specific capability %d"",
                           peer->host, caphdr.code);
              }
            else
              {
                zlog_warn (""%s unrecognized capability code: %d - ignored"",
                           peer->host, caphdr.code);
                memcpy (*error, sp, caphdr.length + 2);
                *error += caphdr.length + 2;
              }
          }
      if (stream_get_getp(s) != (start + caphdr.length))
        {
          if (stream_get_getp(s) > (start + caphdr.length))
            zlog_warn (""%s Cap-parser for %s read past cap-length, %u!"",
                       peer->host, LOOKUP (capcode_str, caphdr.code),
                       caphdr.length);
          stream_set_getp (s, start + caphdr.length);
        }
    }
  return 0;
}
","1. static int
2. struct stream *s = BGP_INPUT (peer);
3. while (stream_get_getp (s) < end)
4. u_char *sp = stream_pnt (s);
struct capability_header caphdr;
5. if (stream_get_getp(s) + 2 > end)
6. zlog_info (""%s Capability length error (< header)"", peer->host);
bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);
return -1;
7. caphdr.code = stream_getc (s);
8. start = stream_get_getp (s);
9. if (start + caphdr.length > end)
10. if (BGP_DEBUG (normal, NORMAL))
11. LOOKUP (capcode_str, caphdr.code),
12. case CAPABILITY_CODE_REFRESH_OLD:
case CAPABILITY_CODE_ORF:
13. case CAPABILITY_CODE_DYNAMIC:
14. zlog_info (""%s %s Capability length error: got %u,""
15. LOOKUP (capcode_str, caphdr.code),
caphdr.length, cap_minsizes[caphdr.code]);
16. case CAPABILITY_CODE_MP:
17. if (! CHECK_FLAG (peer->flags, PEER_FLAG_OVERRIDE_CAPABILITY))
18. case CAPABILITY_CODE_REFRESH_OLD:
19. break;
20. return -1;
21. default:
22. *error += caphdr.length + 2;
23. if (stream_get_getp(s) > (start + caphdr.length))
24. peer->host, LOOKUP (capcode_str, caphdr.code),
25. return 0;","1
5
10
13-14
17
19-21
24
26
29
36
39
47-48
51
55
58-59
70
73
89
97
101
110
123
128
130
135","CWE-17,CWE-125,CWE-787"
l2tp_packet_alloc-198742619795156,"
#define H

struct l2tp_packet_t *l2tp_packet_alloc(int ver, int msg_type,
					const struct sockaddr_in *addr, int H,
					const char *secret, size_t secret_len)
{
	struct l2tp_packet_t *pack = mempool_alloc(pack_pool);
	if (!pack)
		return NULL;

	memset(pack, 0, sizeof(*pack));
	INIT_LIST_HEAD(&pack->attrs);
	pack->hdr.flags = L2TP_FLAG_T | L2TP_FLAG_L | L2TP_FLAG_S | (ver & L2TP_VER_MASK);
	memcpy(&pack->addr, addr, sizeof(*addr));
	pack->hide_avps = H;
	pack->secret = secret;
	pack->secret_len = secret_len;

	if (msg_type) {
		if (l2tp_packet_add_int16(pack, Message_Type, msg_type, 1)) {
			mempool_free(pack);
			return NULL;
		}
	}

	return pack;
}
","1. struct l2tp_packet_t *l2tp_packet_alloc(int ver, int msg_type,
2. return NULL;
3. memcpy(&pack->addr, addr, sizeof(*addr));
4. pack->secret = secret;
5. if (l2tp_packet_add_int16(pack, Message_Type, msg_type, 1)) {
6. return pack;","4
10
15
17
21
27","CWE-362,CWE-20,CWE-119"
dhcpGetOption-236760884706960,"
#define DhcpMessage

DhcpOption *dhcpGetOption(const DhcpMessage *message,
   size_t length, uint8_t optionCode)
{
   size_t i;
   DhcpOption *option;

   
   if(length >= sizeof(DhcpMessage))
   {
      
      length -= sizeof(DhcpMessage);

      
      for(i = 0; i < length; i++)
      {
         
         option = (DhcpOption *) (message->options + i);

         
         if(option->code == DHCP_OPT_PAD)
         {
            
            
         }
         else if(option->code == DHCP_OPT_END)
         {
            
            
            break;
         }
         else
         {
            
            if((i + 1) >= length)
               break;

            
            if((i + sizeof(DhcpOption) + option->length) > length)
               break;

            
            if(option->code == optionCode)
               return option;

            
            i += option->length + 1;
         }
      }
   }

   
   return NULL;
}
","1. size_t length, uint8_t optionCode)
2. DhcpOption *option;
3. if(option->code == DHCP_OPT_PAD)
4. break;
5. if((i + sizeof(DhcpOption) + option->length) > length)
6. return NULL;","5
8
23
32
41
55","CWE-200,CWE-20,CWE-22,CWE-284"
int_x509_param_set_hosts,"
#define X509_VERIFY_PARAM_ID

int_x509_param_set_hosts(X509_VERIFY_PARAM_ID *id, int mode,
    const char *name, size_t namelen)
 {
 	char *copy;
 
	if (name != NULL && namelen == 0)
		namelen = strlen(name);
 	
	if (name && memchr(name, '\0', namelen))
		return 0;

	if (mode == SET_HOST && id->hosts) {
		string_stack_free(id->hosts);
		id->hosts = NULL;
	}
	if (name == NULL || namelen == 0)
		return 1;
	copy = strndup(name, namelen);
	if (copy == NULL)
		return 0;

	if (id->hosts == NULL &&
	    (id->hosts = sk_OPENSSL_STRING_new_null()) == NULL) {
		free(copy);
		return 0;
	}

	if (!sk_OPENSSL_STRING_push(id->hosts, copy)) {
		free(copy);
		if (sk_OPENSSL_STRING_num(id->hosts) == 0) {
			sk_OPENSSL_STRING_free(id->hosts);
			id->hosts = NULL;
		}
		return 0;
	}

	return 1;
}
","1. int_x509_param_set_hosts(X509_VERIFY_PARAM_ID *id, int mode,
const char *name, size_t namelen)
2. char *copy;
3. if (name == NULL || namelen == 0)
return 1;
4. return 0;
5. if (id->hosts == NULL &&
(id->hosts = sk_OPENSSL_STRING_new_null()) == NULL) {
free(copy);
6. if (!sk_OPENSSL_STRING_push(id->hosts, copy)) {
free(copy);
7. sk_OPENSSL_STRING_free(id->hosts);
id->hosts = NULL;
8. return 0;
9. return 1;","4-5
7
22-23
26
28-30
34-35
37-38
40
43","CWE-320,CWE-125,CWE-787,CWE-189"
resolve_op_from_commit-43819895542797,"
#define FlatpakTransaction
#define FlatpakTransactionOperation
#define GFile
#define GVariant

static void
resolve_op_from_commit (FlatpakTransaction *self,
                        FlatpakTransactionOperation *op,
                        const char *checksum,
                        GFile *sideload_path,
                        GVariant *commit_data)
{
  g_autoptr(GBytes) metadata_bytes = NULL;
  g_autoptr(GVariant) commit_metadata = NULL;
  const char *xa_metadata = NULL;
  guint64 download_size = 0;
  guint64 installed_size = 0;

  commit_metadata = g_variant_get_child_value (commit_data, 0);
  g_variant_lookup (commit_metadata, ""xa.metadata"", ""&s"", &xa_metadata);
  if (xa_metadata == NULL)
    g_message (""Warning: No xa.metadata in local commit %s ref %s"", checksum, flatpak_decomposed_get_ref (op->ref));
  else
    metadata_bytes = g_bytes_new (xa_metadata, strlen (xa_metadata));

  if (g_variant_lookup (commit_metadata, ""xa.download-size"", ""t"", &download_size))
    op->download_size = GUINT64_FROM_BE (download_size);
  if (g_variant_lookup (commit_metadata, ""xa.installed-size"", ""t"", &installed_size))
    op->installed_size = GUINT64_FROM_BE (installed_size);

  g_variant_lookup (commit_metadata, OSTREE_COMMIT_META_KEY_ENDOFLIFE, ""s"", &op->eol);
  g_variant_lookup (commit_metadata, OSTREE_COMMIT_META_KEY_ENDOFLIFE_REBASE, ""s"", &op->eol_rebase);

  resolve_op_end (self, op, checksum, sideload_path, metadata_bytes);
}
","1. const char *xa_metadata = NULL;
2. metadata_bytes = g_bytes_new (xa_metadata, strlen (xa_metadata));
3. op->download_size = GUINT64_FROM_BE (download_size);
if (g_variant_lookup (commit_metadata, ""xa.installed-size"", ""t"", &installed_size))
op->installed_size = GUINT64_FROM_BE (installed_size);
4. g_variant_lookup (commit_metadata, OSTREE_COMMIT_META_KEY_ENDOFLIFE_REBASE, ""s"", &op->eol_rebase);","16
25
28-30
33","CWE-200,CWE-269,CWE-276"
destroy_surface-265437914224728,"static void destroy_surface(struct swaylock_surface *surface) {
	wl_list_remove(&surface->link);
	if (surface->layer_surface != NULL) {
		zwlr_layer_surface_v1_destroy(surface->layer_surface);
	}
	if (surface->ext_session_lock_surface_v1 != NULL) {
		ext_session_lock_surface_v1_destroy(surface->ext_session_lock_surface_v1);
	}
	if (surface->surface != NULL) {
		wl_surface_destroy(surface->surface);
	}
	destroy_buffer(&surface->buffers[0]);
	destroy_buffer(&surface->buffers[1]);
	destroy_buffer(&surface->indicator_buffers[0]);
	destroy_buffer(&surface->indicator_buffers[1]);
	wl_output_destroy(surface->output);
	free(surface);
}
","1. static void destroy_surface(struct swaylock_surface *surface) {
wl_list_remove(&surface->link);
if (surface->layer_surface != NULL) {
zwlr_layer_surface_v1_destroy(surface->layer_surface);
2. wl_surface_destroy(surface->surface);
3. destroy_buffer(&surface->buffers[0]);
destroy_buffer(&surface->buffers[1]);
4. destroy_buffer(&surface->indicator_buffers[1]);
wl_output_destroy(surface->output);","1-4
10
12-13
15-16","CWE-362,CWE-264,CWE-401,CWE-416,CWE-190"
add_bytes_c-124893861004965,"static void add_bytes_c(uint8_t *dst, uint8_t *src, int w){
    long i;
    for(i=0; i<=w-(int)sizeof(long); i+=sizeof(long)){
        long a = *(long*)(src+i);
        long b = *(long*)(dst+i);
        *(long*)(dst+i) = ((a&pb_7f) + (b&pb_7f)) ^ ((a^b)&pb_80);
    }
    for(; i<w; i++)
        dst[i+0] += src[i+0];
}
","1. static void add_bytes_c(uint8_t *dst, uint8_t *src, int w){
2. for(i=0; i<=w-(int)sizeof(long); i+=sizeof(long)){
long a = *(long*)(src+i);
long b = *(long*)(dst+i);
*(long*)(dst+i) = ((a&pb_7f) + (b&pb_7f)) ^ ((a^b)&pb_80);
3. for(; i<w; i++)","1
3-6
8","CWE-787,CWE-189"
_dl_dst_count-41461181100456,"size_t
_dl_dst_count (const char *name, int is_path)
{
  const char *const start = name;
  size_t cnt = 0;

  do
    {
      size_t len = 1;

      
      if ((((strncmp (&name[1], ""ORIGIN}"", 6) == 0
	     && (!__libc_enable_secure
		 || ((name[7] == '\0' || (is_path && name[7] == ':'))
		     && (name == start || (is_path && name[-1] == ':'))))
	     && (len = 7) != 0)
	    || (strncmp (&name[1], ""PLATFORM}"", 8) == 0 && (len = 9) != 0))
	   && (name[len] == '\0' || name[len] == '/'
	       || (is_path && name[len] == ':')))
	  || (name[1] == '{'
	      && ((strncmp (&name[2], ""ORIGIN}"", 7) == 0
		   && (!__libc_enable_secure
		       || ((name[9] == '\0' || (is_path && name[9] == ':'))
			   && (name == start || (is_path && name[-1] == ':'))))
		   && (len = 9) != 0)
		  || (strncmp (&name[2], ""PLATFORM}"", 9) == 0
		      && (len = 11) != 0))))
	++cnt;

      name = strchr (name + len, '$');
    }
  while (name != NULL);

  return cnt;
}
","1. do
2. || (strncmp (&name[1], ""PLATFORM}"", 8) == 0 && (len = 9) != 0))","7
20","CWE-310,CWE-264"
flac_read_loop,"
#define SF_PRIVATE

 flac_read_loop (SF_PRIVATE *psf, unsigned len)
 {	FLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;
	FLAC__StreamDecoderState state ;
 
 	pflac->pos = 0 ;
 	pflac->len = len ;
 	pflac->remain = len ;
 
	state = FLAC__stream_decoder_get_state (pflac->fsd) ;
	if (state > FLAC__STREAM_DECODER_END_OF_STREAM)
	{	psf_log_printf (psf, ""FLAC__stream_decoder_get_state returned %s\n"", FLAC__StreamDecoderStateString [state]) ;
		
		pflac->frame = NULL ;
		} ;

 	
 	if (pflac->frame != NULL && pflac->bufferpos < pflac->frame->header.blocksize)
 		flac_buffer_copy (psf) ;

	
 	while (pflac->pos < pflac->len)
 	{	if (FLAC__stream_decoder_process_single (pflac->fsd) == 0)
 			break ;
		state = FLAC__stream_decoder_get_state (pflac->fsd) ;
		if (state >= FLAC__STREAM_DECODER_END_OF_STREAM)
		{	psf_log_printf (psf, ""FLAC__stream_decoder_get_state returned %s\n"", FLAC__StreamDecoderStateString [state]) ;
			
			pflac->frame = NULL ;
 			break ;
			} ;
 		} ;
 
 	pflac->ptr = NULL ;

	return pflac->pos ;
} 
","1. flac_read_loop (SF_PRIVATE *psf, unsigned len)
2. pflac->pos = 0 ;
pflac->len = len ;
3. if (state > FLAC__STREAM_DECODER_END_OF_STREAM)
{	psf_log_printf (psf, ""FLAC__stream_decoder_get_state returned %s\n"", FLAC__StreamDecoderStateString [state]) ;
4. pflac->frame = NULL ;
5. if (pflac->frame != NULL && pflac->bufferpos < pflac->frame->header.blocksize)
6. {	if (FLAC__stream_decoder_process_single (pflac->fsd) == 0)
break ;
state = FLAC__stream_decoder_get_state (pflac->fsd) ;
7. pflac->frame = NULL ;","4
8-9
13-14
16
20
25-27
31","CWE-122,CWE-476,CWE-120,CWE-189"
tap_if_up,"static int tap_if_up(const char *devname, const bt_bdaddr_t *addr)
{
 struct ifreq ifr;
 int sk, err;

    sk = socket(AF_INET, SOCK_DGRAM, 0);
 if (sk < 0)
 return -1;


     memset(&ifr, 0, sizeof(ifr));
     strncpy(ifr.ifr_name, devname, IFNAMSIZ - 1);
    err = TEMP_FAILURE_RETRY(ioctl(sk, SIOCGIFHWADDR, &ifr));
     if (err < 0)
     {
         BTIF_TRACE_ERROR(""Could not get network hardware for interface:%s, errno:%s"", devname, strerror(errno));
        close(sk);
 return -1;
 }

    strncpy(ifr.ifr_name, devname, IFNAMSIZ - 1);
    memcpy(ifr.ifr_hwaddr.sa_data, addr->address, 6);

 
 if (ifr.ifr_hwaddr.sa_data[0] & 0x01) {
        BTIF_TRACE_WARNING(""Not a unicast MAC address, force multicast bit flipping"");

         ifr.ifr_hwaddr.sa_data[0] &= ~0x01;
     }
 
    err = TEMP_FAILURE_RETRY(ioctl(sk, SIOCSIFHWADDR, (caddr_t)&ifr));
 
     if (err < 0) {
         BTIF_TRACE_ERROR(""Could not set bt address for interface:%s, errno:%s"", devname, strerror(errno));
        close(sk);
 return -1;
 }

    memset(&ifr, 0, sizeof(ifr));
    strncpy(ifr.ifr_name, devname, IF_NAMESIZE - 1);


     ifr.ifr_flags |= IFF_UP;
     ifr.ifr_flags |= IFF_MULTICAST;
 
    err = TEMP_FAILURE_RETRY(ioctl(sk, SIOCSIFFLAGS, (caddr_t) &ifr));
 
 
     if (err < 0) {
        BTIF_TRACE_ERROR(""Could not bring up network interface:%s, errno:%d"", devname, errno);
        close(sk);
 return -1;
 }
    close(sk);
    BTIF_TRACE_DEBUG(""network interface: %s is up"", devname);
 return 0;
}
","1. struct ifreq ifr;
2. memset(&ifr, 0, sizeof(ifr));
3. BTIF_TRACE_ERROR(""Could not get network hardware for interface:%s, errno:%s"", devname, strerror(errno));
close(sk);
4. return -1;
5. err = TEMP_FAILURE_RETRY(ioctl(sk, SIOCSIFFLAGS, (caddr_t) &ifr));
6. if (err < 0) {
BTIF_TRACE_ERROR(""Could not bring up network interface:%s, errno:%d"", devname, errno);
7. return -1;
8. return 0;","3
11
16-17
40
50
53-54
56
60","CWE-476,CWE-20,CWE-787,CWE-119"
sig_int_handler-216931576890481,"static void sig_int_handler(int sig) {
  struct sigaction *old = NULL;
  switch (sig) {
#if !FIO_DISABLE_HOT_RESTART
  case SIGUSR1:
    fio_signal_children_flag = 1;
    old = &fio_old_sig_usr1;
    break;
#endif
    
  case SIGINT:
    if (!old)
      old = &fio_old_sig_int;
    
  case SIGTERM:
    if (!old)
      old = &fio_old_sig_term;
    fio_stop();
    break;
  case SIGPIPE:
    if (!old)
      old = &fio_old_sig_pipe;
  
  default:
    break;
  }
  
  if (old && old->sa_handler != SIG_IGN && old->sa_handler != SIG_DFL)
    old->sa_handler(sig);
}
",1. break;,8,"CWE-617,CWE-772,CWE-18"
pixel_copy," pixel_copy(png_bytep toBuffer, png_uint_32 toIndex,
   png_const_bytep fromBuffer, png_uint_32 fromIndex, unsigned int pixelSize,
   int littleendian)
 {
    
   toIndex *= pixelSize;
   fromIndex *= pixelSize;

    if (pixelSize < 8) 
    {
       
      unsigned int destMask = ((1U<<pixelSize)-1) <<
         (littleendian ? toIndex&7 : 8-pixelSize-(toIndex&7));
       
       unsigned int destByte = toBuffer[toIndex >> 3] & ~destMask;
       unsigned int sourceByte = fromBuffer[fromIndex >> 3];
 
       
       fromIndex &= 7;
      if (littleendian)
      {
         if (fromIndex > 0) sourceByte >>= fromIndex;
         if ((toIndex & 7) > 0) sourceByte <<= toIndex & 7;
      }

      else
      {
         if (fromIndex > 0) sourceByte <<= fromIndex;
         if ((toIndex & 7) > 0) sourceByte >>= toIndex & 7;
      }
 
       toBuffer[toIndex >> 3] = (png_byte)(destByte | (sourceByte & destMask));
    }
 else 
      memmove(toBuffer+(toIndex>>3), fromBuffer+(fromIndex>>3), pixelSize>>3);
}
","1. toIndex *= pixelSize;
2. unsigned int destMask = ((1U<<pixelSize)-1) <<
3. unsigned int destByte = toBuffer[toIndex >> 3] & ~destMask;
unsigned int sourceByte = fromBuffer[fromIndex >> 3];
4. fromIndex &= 7;
if (littleendian)
5. if ((toIndex & 7) > 0) sourceByte <<= toIndex & 7;
6. {
if (fromIndex > 0) sourceByte <<= fromIndex;
if ((toIndex & 7) > 0) sourceByte >>= toIndex & 7;","8
14
17-18
21-22
25
29-31","CWE-190,CWE-125,CWE-189"
snd_hrtimer_stop,"static int snd_hrtimer_stop(struct snd_timer *t)
 {
 	struct snd_hrtimer *stime = t->private_data;
 	atomic_set(&stime->running, 0);
	hrtimer_try_to_cancel(&stime->hrt);
 	return 0;
 }
","1. static int snd_hrtimer_stop(struct snd_timer *t)
2. struct snd_hrtimer *stime = t->private_data;
atomic_set(&stime->running, 0);
hrtimer_try_to_cancel(&stime->hrt);
return 0;","1
3-6","CWE-20,CWE-264,CWE-416"
inet6_csk_xmit-98147102372447,"int inet6_csk_xmit(struct sock *sk, struct sk_buff *skb, struct flowi *fl_unused)
{
	struct ipv6_pinfo *np = inet6_sk(sk);
	struct flowi6 fl6;
	struct dst_entry *dst;
	int res;

	dst = inet6_csk_route_socket(sk, &fl6);
	if (IS_ERR(dst)) {
		sk->sk_err_soft = -PTR_ERR(dst);
		sk->sk_route_caps = 0;
		kfree_skb(skb);
		return PTR_ERR(dst);
	}

	rcu_read_lock();
	skb_dst_set_noref(skb, dst);

	
	fl6.daddr = sk->sk_v6_daddr;

	res = ip6_xmit(sk, skb, &fl6, rcu_dereference(np->opt),
		       np->tclass);
	rcu_read_unlock();
	return res;
}
","1. struct dst_entry *dst;
int res;
2. sk->sk_route_caps = 0;
3. rcu_read_lock();
skb_dst_set_noref(skb, dst);
4. res = ip6_xmit(sk, skb, &fl6, rcu_dereference(np->opt),
np->tclass);
rcu_read_unlock();","5-6
11
16-17
22-24","CWE-310,CWE-264,CWE-416"
construct_command_line," construct_command_line(struct manager_ctx *manager, struct server *server)
 {
     static char cmd[BUF_SIZE];
     int i;
    int port;
 
    port = atoi(server->port);

    build_config(working_dir, manager, server);
 
     memset(cmd, 0, BUF_SIZE);
     snprintf(cmd, BUF_SIZE,
             ""%s --manager-address %s -f %s/.shadowsocks_%d.pid -c %s/.shadowsocks_%d.conf"",
             executable, manager->manager_address, working_dir, port, working_dir, port);
 
     if (manager->acl != NULL) {
         int len = strlen(cmd);
        snprintf(cmd + len, BUF_SIZE - len, "" --acl %s"", manager->acl);
    }
    if (manager->timeout != NULL) {
        int len = strlen(cmd);
        snprintf(cmd + len, BUF_SIZE - len, "" -t %s"", manager->timeout);
    }
#ifdef HAVE_SETRLIMIT
    if (manager->nofile) {
        int len = strlen(cmd);
        snprintf(cmd + len, BUF_SIZE - len, "" -n %d"", manager->nofile);
    }
#endif
    if (manager->user != NULL) {
        int len = strlen(cmd);
        snprintf(cmd + len, BUF_SIZE - len, "" -a %s"", manager->user);
    }
    if (manager->verbose) {
        int len = strlen(cmd);
        snprintf(cmd + len, BUF_SIZE - len, "" -v"");
    }
    if (server->mode == NULL && manager->mode == UDP_ONLY) {
        int len = strlen(cmd);
        snprintf(cmd + len, BUF_SIZE - len, "" -U"");
    }
    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {
        int len = strlen(cmd);
        snprintf(cmd + len, BUF_SIZE - len, "" -u"");
    }
    if (server->fast_open[0] == 0 && manager->fast_open) {
        int len = strlen(cmd);
        snprintf(cmd + len, BUF_SIZE - len, "" --fast-open"");
    }
    if (manager->ipv6first) {
        int len = strlen(cmd);
        snprintf(cmd + len, BUF_SIZE - len, "" -6"");
    }
    if (manager->mtu) {
        int len = strlen(cmd);
        snprintf(cmd + len, BUF_SIZE - len, "" --mtu %d"", manager->mtu);
    }
    if (server->plugin == NULL && manager->plugin) {
        int len = strlen(cmd);
        snprintf(cmd + len, BUF_SIZE - len, "" --plugin \""%s\"""", manager->plugin);
    }
    if (server->plugin_opts == NULL && manager->plugin_opts) {
        int len = strlen(cmd);
        snprintf(cmd + len, BUF_SIZE - len, "" --plugin-opts \""%s\"""", manager->plugin_opts);
    }
    for (i = 0; i < manager->nameserver_num; i++) {
        int len = strlen(cmd);
        snprintf(cmd + len, BUF_SIZE - len, "" -d %s"", manager->nameservers[i]);
    }
    for (i = 0; i < manager->host_num; i++) {
        int len = strlen(cmd);
        snprintf(cmd + len, BUF_SIZE - len, "" -s %s"", manager->hosts[i]);
    }
    {
        int len = strlen(cmd);
        snprintf(cmd + len, BUF_SIZE - len, "" --reuse-port"");
    }

    if (verbose) {
        LOGI(""cmd: %s"", cmd);
    }

    return cmd;
}
","1. executable, manager->manager_address, working_dir, port, working_dir, port);
2. if (manager->acl != NULL) {
int len = strlen(cmd);
snprintf(cmd + len, BUF_SIZE - len, "" --acl %s"", manager->acl);
3. int len = strlen(cmd);
snprintf(cmd + len, BUF_SIZE - len, "" -a %s"", manager->user);
4. int len = strlen(cmd);
snprintf(cmd + len, BUF_SIZE - len, "" -U"");
5. int len = strlen(cmd);
snprintf(cmd + len, BUF_SIZE - len, "" -u"");
6. int len = strlen(cmd);
7. snprintf(cmd + len, BUF_SIZE - len, "" --plugin-opts \""%s\"""", manager->plugin_opts);
8. int len = strlen(cmd);
9. int len = strlen(cmd);
10. LOGI(""cmd: %s"", cmd);","14
16-18
31-32
39-40
43-44
51
64
67
71
80","CWE-78,CWE-120,CWE-476,CWE-824,CWE-125"
vmw_gb_surface_define_ioctl-197244515682859,"int vmw_gb_surface_define_ioctl(struct drm_device *dev, void *data,
				struct drm_file *file_priv)
{
	struct vmw_private *dev_priv = vmw_priv(dev);
	struct vmw_user_surface *user_srf;
	struct vmw_surface *srf;
	struct vmw_resource *res;
	struct vmw_resource *tmp;
	union drm_vmw_gb_surface_create_arg *arg =
	    (union drm_vmw_gb_surface_create_arg *)data;
	struct drm_vmw_gb_surface_create_req *req = &arg->req;
	struct drm_vmw_gb_surface_create_rep *rep = &arg->rep;
	struct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile;
	int ret;
	uint32_t size;
	uint32_t backup_handle = 0;

	if (req->multisample_count != 0)
		return -EINVAL;

	if (req->mip_levels > DRM_VMW_MAX_MIP_LEVELS)
		return -EINVAL;

	if (unlikely(vmw_user_surface_size == 0))
		vmw_user_surface_size = ttm_round_pot(sizeof(*user_srf)) +
			128;

	size = vmw_user_surface_size + 128;

	
	ret = vmw_surface_gb_priv_define(dev,
			size,
			req->svga3d_flags,
			req->format,
			req->drm_surface_flags & drm_vmw_surface_flag_scanout,
			req->mip_levels,
			req->multisample_count,
			req->array_size,
			req->base_size,
			&srf);
	if (unlikely(ret != 0))
		return ret;

	user_srf = container_of(srf, struct vmw_user_surface, srf);
	if (drm_is_primary_client(file_priv))
		user_srf->master = drm_master_get(file_priv->master);

	ret = ttm_read_lock(&dev_priv->reservation_sem, true);
	if (unlikely(ret != 0))
		return ret;

	res = &user_srf->srf.res;


	if (req->buffer_handle != SVGA3D_INVALID_ID) {
		ret = vmw_user_dmabuf_lookup(tfile, req->buffer_handle,
					     &res->backup,
					     &user_srf->backup_base);
		if (ret == 0) {
			if (res->backup->base.num_pages * PAGE_SIZE <
			    res->backup_size) {
				DRM_ERROR(""Surface backup buffer is too small.\n"");
				vmw_dmabuf_unreference(&res->backup);
				ret = -EINVAL;
				goto out_unlock;
			} else {
				backup_handle = req->buffer_handle;
			}
		}
	} else if (req->drm_surface_flags & drm_vmw_surface_flag_create_buffer)
		ret = vmw_user_dmabuf_alloc(dev_priv, tfile,
					    res->backup_size,
					    req->drm_surface_flags &
					    drm_vmw_surface_flag_shareable,
					    &backup_handle,
					    &res->backup,
					    &user_srf->backup_base);

	if (unlikely(ret != 0)) {
		vmw_resource_unreference(&res);
		goto out_unlock;
	}

	tmp = vmw_resource_reference(res);
	ret = ttm_prime_object_init(tfile, res->backup_size, &user_srf->prime,
				    req->drm_surface_flags &
				    drm_vmw_surface_flag_shareable,
				    VMW_RES_SURFACE,
				    &vmw_user_surface_base_release, NULL);

	if (unlikely(ret != 0)) {
		vmw_resource_unreference(&tmp);
		vmw_resource_unreference(&res);
		goto out_unlock;
	}

	rep->handle      = user_srf->prime.base.hash.key;
	rep->backup_size = res->backup_size;
	if (res->backup) {
		rep->buffer_map_handle =
			drm_vma_node_offset_addr(&res->backup->base.vma_node);
		rep->buffer_size = res->backup->base.num_pages * PAGE_SIZE;
		rep->buffer_handle = backup_handle;
	} else {
		rep->buffer_map_handle = 0;
		rep->buffer_size = 0;
		rep->buffer_handle = SVGA3D_INVALID_ID;
	}

	vmw_resource_unreference(&res);

out_unlock:
	ttm_read_unlock(&dev_priv->reservation_sem);
	return ret;
}
","1. struct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile;
2. if (req->multisample_count != 0)
3. size = vmw_user_surface_size + 128;
4. req->base_size,
5. return ret;
6. return ret;
7. res->backup_size) {
DRM_ERROR(""Surface backup buffer is too small.\n"");
8. } else {
9. rep->backup_size = res->backup_size;
if (res->backup) {
10. drm_vma_node_offset_addr(&res->backup->base.vma_node);
11. rep->buffer_handle = backup_handle;
12. vmw_resource_unreference(&res);","13
18
28
39
42
50
61-62
66
98-99
101
103
110","CWE-125,CWE-787,CWE-189,CWE-119"
store_xauthority_1,"static int store_xauthority_1(void) {
	fs_build_mnt_dir();
 
 	char *src;
 	char *dest = RUN_XAUTHORITY_FILE;
	
 	FILE *fp = fopen(dest, ""w"");
 	if (fp) {
 		fprintf(fp, ""\n"");
 		SET_PERMS_STREAM(fp, getuid(), getgid(), 0600);
 		fclose(fp);
 	}
	
 	if (asprintf(&src, ""%s/.Xauthority"", cfg.homedir) == -1)
 		errExit(""asprintf"");
 	
 	struct stat s;
 	if (stat(src, &s) == 0) {
 		if (is_link(src)) {
			fprintf(stderr, ""Warning: invalid .Xauthority file\n"");
			return 0;
 		}
 
		copy_file_as_user(src, dest, getuid(), getgid(), 0600); 
		fs_logger2(""clone"", dest);
 		return 1; 
 	}
 	
	return 0;
}
","1. FILE *fp = fopen(dest, ""w"");
if (fp) {
2. if (asprintf(&src, ""%s/.Xauthority"", cfg.homedir) == -1)
errExit(""asprintf"");
3. fprintf(stderr, ""Warning: invalid .Xauthority file\n"");
return 0;
4. copy_file_as_user(src, dest, getuid(), getgid(), 0600);","7-8
14-15
20-21
24","CWE-190,CWE-269,CWE-59"
mincore_pte_range-214393791260370,"static int mincore_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end,
			struct mm_walk *walk)
{
	spinlock_t *ptl;
	struct vm_area_struct *vma = walk->vma;
	pte_t *ptep;
	unsigned char *vec = walk->private;
	int nr = (end - addr) >> PAGE_SHIFT;

	ptl = pmd_trans_huge_lock(pmd, vma);
	if (ptl) {
		memset(vec, 1, nr);
		spin_unlock(ptl);
		goto out;
	}

	
	if (pmd_trans_unstable(pmd)) {
		memset(vec, 1, nr);
		goto out;
	}

	ptep = pte_offset_map_lock(walk->mm, pmd, addr, &ptl);
	for (; addr != end; ptep++, addr += PAGE_SIZE) {
		pte_t pte = *ptep;

		if (pte_none(pte))
			*vec = 0;
		else if (pte_present(pte))
			*vec = 1;
		else { 
			swp_entry_t entry = pte_to_swp_entry(pte);

			
			*vec = !!non_swap_entry(entry);
		}
		vec++;
	}
	pte_unmap_unlock(ptep - 1, ptl);
out:
	walk->private += nr;
	cond_resched();
	return 0;
}
","1. static int mincore_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end,
struct mm_walk *walk)
2. struct vm_area_struct *vma = walk->vma;
3. unsigned char *vec = walk->private;
int nr = (end - addr) >> PAGE_SHIFT;
4. ptl = pmd_trans_huge_lock(pmd, vma);
5. goto out;
6. if (pmd_trans_unstable(pmd)) {
7. ptep = pte_offset_map_lock(walk->mm, pmd, addr, &ptl);
for (; addr != end; ptep++, addr += PAGE_SIZE) {
pte_t pte = *ptep;
8. if (pte_none(pte))
*vec = 0;
9. *vec = 1;
10. *vec = !!non_swap_entry(entry);","1-2
5
7-8
10
14
18
23-25
27-28
30
38","CWE-347,CWE-200,CWE-264,CWE-189"
do_replace-197127925200119,"
#define __user

static int do_replace(struct net *net, const void __user *user,
		      unsigned int len)
{
	int ret, countersize;
	struct ebt_table_info *newinfo;
	struct ebt_replace tmp;

	if (copy_from_user(&tmp, user, sizeof(tmp)) != 0)
		return -EFAULT;

	if (len != sizeof(tmp) + tmp.entries_size) {
		BUGPRINT(""Wrong len argument\n"");
		return -EINVAL;
	}

	if (tmp.entries_size == 0) {
		BUGPRINT(""Entries_size never zero\n"");
		return -EINVAL;
	}
	
	if (tmp.nentries >= ((INT_MAX - sizeof(struct ebt_table_info)) /
			NR_CPUS - SMP_CACHE_BYTES) / sizeof(struct ebt_counter))
		return -ENOMEM;
	if (tmp.num_counters >= INT_MAX / sizeof(struct ebt_counter))
		return -ENOMEM;

	tmp.name[sizeof(tmp.name) - 1] = 0;

	countersize = COUNTER_OFFSET(tmp.nentries) * nr_cpu_ids;
	newinfo = vmalloc(sizeof(*newinfo) + countersize);
	if (!newinfo)
		return -ENOMEM;

	if (countersize)
		memset(newinfo->counters, 0, countersize);

	newinfo->entries = vmalloc(tmp.entries_size);
	if (!newinfo->entries) {
		ret = -ENOMEM;
		goto free_newinfo;
	}
	if (copy_from_user(
	   newinfo->entries, tmp.entries, tmp.entries_size) != 0) {
		BUGPRINT(""Couldn't copy entries from userspace\n"");
		ret = -EFAULT;
		goto free_entries;
	}

	ret = do_replace_finish(net, &tmp, newinfo);
	if (ret == 0)
		return ret;
free_entries:
	vfree(newinfo->entries);
free_newinfo:
	vfree(newinfo);
	return ret;
}
","1. if (tmp.nentries >= ((INT_MAX - sizeof(struct ebt_table_info)) /
NR_CPUS - SMP_CACHE_BYTES) / sizeof(struct ebt_counter))
2. memset(newinfo->counters, 0, countersize);
3. newinfo->entries = vmalloc(tmp.entries_size);
4. goto free_newinfo;
5. if (copy_from_user(
newinfo->entries, tmp.entries, tmp.entries_size) != 0) {
BUGPRINT(""Couldn't copy entries from userspace\n"");
ret = -EFAULT;
6. if (ret == 0)","24-25
38
40
43
45-48
53","CWE-362,CWE-320,CWE-116"
udp_recvmsg-83823472151493,"int udp_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
		size_t len, int noblock, int flags, int *addr_len)
{
	struct inet_sock *inet = inet_sk(sk);
	struct sockaddr_in *sin = (struct sockaddr_in *)msg->msg_name;
	struct sk_buff *skb;
	unsigned int ulen, copied;
	int peeked, off = 0;
	int err;
	int is_udplite = IS_UDPLITE(sk);
	bool slow;

	if (flags & MSG_ERRQUEUE)
		return ip_recv_error(sk, msg, len);

try_again:
	skb = __skb_recv_datagram(sk, flags | (noblock ? MSG_DONTWAIT : 0),
				  &peeked, &off, &err);
	if (!skb)
		goto out;

	ulen = skb->len - sizeof(struct udphdr);
	copied = len;
	if (copied > ulen)
		copied = ulen;
	else if (copied < ulen)
		msg->msg_flags |= MSG_TRUNC;

	

	if (copied < ulen || UDP_SKB_CB(skb)->partial_cov) {
		if (udp_lib_checksum_complete(skb))
			goto csum_copy_err;
	}

	if (skb_csum_unnecessary(skb))
		err = skb_copy_datagram_iovec(skb, sizeof(struct udphdr),
					      msg->msg_iov, copied);
	else {
		err = skb_copy_and_csum_datagram_iovec(skb,
						       sizeof(struct udphdr),
						       msg->msg_iov);

		if (err == -EINVAL)
			goto csum_copy_err;
	}

	if (unlikely(err)) {
		trace_kfree_skb(skb, udp_recvmsg);
		if (!peeked) {
			atomic_inc(&sk->sk_drops);
			UDP_INC_STATS_USER(sock_net(sk),
					   UDP_MIB_INERRORS, is_udplite);
		}
		goto out_free;
	}

	if (!peeked)
		UDP_INC_STATS_USER(sock_net(sk),
				UDP_MIB_INDATAGRAMS, is_udplite);

	sock_recv_ts_and_drops(msg, sk, skb);

	
	if (sin) {
		sin->sin_family = AF_INET;
		sin->sin_port = udp_hdr(skb)->source;
		sin->sin_addr.s_addr = ip_hdr(skb)->saddr;
		memset(sin->sin_zero, 0, sizeof(sin->sin_zero));
		*addr_len = sizeof(*sin);
	}
	if (inet->cmsg_flags)
		ip_cmsg_recv(msg, skb);

	err = copied;
	if (flags & MSG_TRUNC)
		err = ulen;

out_free:
	skb_free_datagram_locked(sk, skb);
out:
	return err;

csum_copy_err:
	slow = lock_sock_fast(sk);
	if (!skb_kill_datagram(sk, skb, flags)) {
		UDP_INC_STATS_USER(sock_net(sk), UDP_MIB_CSUMERRORS, is_udplite);
		UDP_INC_STATS_USER(sock_net(sk), UDP_MIB_INERRORS, is_udplite);
	}
	unlock_sock_fast(sk, slow);

	if (noblock)
		return -EAGAIN;

	
	msg->msg_flags &= ~MSG_TRUNC;
	goto try_again;
}
","1. err = skb_copy_datagram_iovec(skb, sizeof(struct udphdr),
2. UDP_MIB_INDATAGRAMS, is_udplite);
3. sin->sin_port = udp_hdr(skb)->source;
4. return err;","41
64
71
86","CWE-120,CWE-200,CWE-119,CWE-125,CWE-399"
vnc_async_encoding_start,"
#define VncState

static void vnc_async_encoding_start(VncState *orig, VncState *local)
{
    local->vnc_encoding = orig->vnc_encoding;
    local->features = orig->features;
    local->ds = orig->ds;
     local->vd = orig->vd;
     local->lossy_rect = orig->lossy_rect;
     local->write_pixels = orig->write_pixels;
    local->client_pf = orig->client_pf;
    local->client_be = orig->client_be;
     local->tight = orig->tight;
     local->zlib = orig->zlib;
     local->hextile = orig->hextile;
    local->output =  queue->buffer;
    local->csock = -1; 

    buffer_reset(&local->output);
}
","1. local->lossy_rect = orig->lossy_rect;
2. local->csock = -1;
3. buffer_reset(&local->output);","10
18
20","CWE-125,CWE-787,CWE-119"
r_core_anal_type_match-177173795164015,"
#define RAnalFunction
#define RCore

R_API void r_core_anal_type_match(RCore *core, RAnalFunction *fcn) {
	RAnalBlock *bb;
	RListIter *it;
	RAnalOp aop = {0};
	bool resolved = false;

	r_return_if_fail (core && core->anal && fcn);

	if (!core->anal->esil) {
		eprintf (""Please run aeim\n"");
		return;
	}

	RAnal *anal = core->anal;
	Sdb *TDB = anal->sdb_types;
	bool chk_constraint = r_config_get_i (core->config, ""anal.types.constraint"");
	int ret, bsize = R_MAX (64, core->blocksize);
	const int mininstrsz = r_anal_archinfo (anal, R_ANAL_ARCHINFO_MIN_OP_SIZE);
	const int minopcode = R_MAX (1, mininstrsz);
	int cur_idx , prev_idx = 0;
	RConfigHold *hc = r_config_hold_new (core->config);
	if (!hc) {
		return;
	}
	RDebugTrace *dt = NULL;
	RAnalEsilTrace *et = NULL;
	if (!anal_emul_init (core, hc, &dt, &et) || !fcn) {
		anal_emul_restore (core, hc, dt, et);
		return;
	}
	ut8 *buf = malloc (bsize);
	if (!buf) {
		anal_emul_restore (core, hc, dt, et);
		return;
	}

	
	Sdb *etracedb = core->anal->esil->trace->db;
	HtPPOptions opt = etracedb->ht->opt;
	ht_pp_free (etracedb->ht);
	etracedb->ht = ht_pp_new_size (fcn->ninstr * 0xf, opt.dupvalue, opt.freefn, opt.calcsizeV);
	etracedb->ht->opt = opt;
	RDebugTrace *dtrace = core->dbg->trace;
	opt = dtrace->ht->opt;
	ht_pp_free (dtrace->ht);
	dtrace->ht = ht_pp_new_size (fcn->ninstr, opt.dupvalue, opt.freefn, opt.calcsizeV);
	dtrace->ht->opt = opt;

	char *fcn_name = NULL;
	char *ret_type = NULL;
	bool str_flag = false;
	bool prop = false;
	bool prev_var = false;
	char prev_type[256] = {0};
	const char *prev_dest = NULL;
	char *ret_reg = NULL;
	const char *_pc = r_reg_get_name (core->dbg->reg, R_REG_NAME_PC);
	if (!_pc) {
		free (buf);
		return;
	}
	char *pc = strdup (_pc);
	RRegItem *r = r_reg_get (core->dbg->reg, pc, -1);
	if (!r) {
		free (buf);
		return;
	}
	r_cons_break_push (NULL, NULL);
	r_list_sort (fcn->bbs, bb_cmpaddr); 
	r_list_foreach (fcn->bbs, it, bb) {
		ut64 addr = bb->addr;
		int i = 0;
		r_reg_set_value (core->dbg->reg, r, addr);
		while (1) {
			if (r_cons_is_breaked ()) {
				goto out_function;
			}
			if (i >= (bsize - 32)) {
				i = 0;
			}
			ut64 pcval = r_reg_getv (anal->reg, pc);
			if ((addr >= bb->addr + bb->size) || (addr < bb->addr) || pcval != addr) {
				break;
			}
			if (!i) {
				r_io_read_at (core->io, addr, buf, bsize);
			}
			ret = r_anal_op (anal, &aop, addr, buf + i, bsize - i, R_ANAL_OP_MASK_BASIC | R_ANAL_OP_MASK_VAL);
			if (ret <= 0) {
				i += minopcode;
				addr += minopcode;
				r_anal_op_fini (&aop);
				continue;
			}
			int loop_count = sdb_num_get (anal->esil->trace->db, sdb_fmt (""0x%""PFMT64x"".count"", addr), 0);
			if (loop_count > LOOP_MAX || aop.type == R_ANAL_OP_TYPE_RET) {
				r_anal_op_fini (&aop);
				break;
			}
			sdb_num_set (anal->esil->trace->db, sdb_fmt (""0x%""PFMT64x"".count"", addr), loop_count + 1, 0);
			if (r_anal_op_nonlinear (aop.type)) {   
				r_reg_set_value (core->dbg->reg, r, addr + ret);
			} else {
				r_core_esil_step (core, UT64_MAX, NULL, NULL, false);
			}
			bool userfnc = false;
			Sdb *trace = anal->esil->trace->db;
			cur_idx = sdb_num_get (trace, ""idx"", 0);
			RAnalVar *var = r_anal_get_used_function_var (anal, aop.addr);
			RAnalOp *next_op = r_core_anal_op (core, addr + ret, R_ANAL_OP_MASK_BASIC); 
			ut32 type = aop.type & R_ANAL_OP_TYPE_MASK;
			if (aop.type == R_ANAL_OP_TYPE_CALL || aop.type & R_ANAL_OP_TYPE_UCALL) {
				char *full_name = NULL;
				ut64 callee_addr;
				if (aop.type == R_ANAL_OP_TYPE_CALL) {
					RAnalFunction *fcn_call = r_anal_get_fcn_in (anal, aop.jump, -1);
					if (fcn_call) {
						full_name = fcn_call->name;
						callee_addr = fcn_call->addr;
					}
				} else if (aop.ptr != UT64_MAX) {
					RFlagItem *flag = r_flag_get_by_spaces (core->flags, aop.ptr, R_FLAGS_FS_IMPORTS, NULL);
					if (flag && flag->realname) {
						full_name = flag->realname;
						callee_addr = aop.ptr;
					}
				}
				if (full_name) {
					if (r_type_func_exist (TDB, full_name)) {
						fcn_name = strdup (full_name);
					} else {
						fcn_name = r_type_func_guess (TDB, full_name);
					}
					if (!fcn_name) {
						fcn_name = strdup (full_name);
						userfnc = true;
					}
					const char* Cc = r_anal_cc_func (anal, fcn_name);
					if (Cc && r_anal_cc_exist (anal, Cc)) {
						char *cc = strdup (Cc);
						type_match (core, fcn_name, addr, bb->addr, cc, prev_idx, userfnc, callee_addr);
						prev_idx = cur_idx;
						R_FREE (ret_type);
						const char *rt = r_type_func_ret (TDB, fcn_name);
						if (rt) {
							ret_type = strdup (rt);
						}
						R_FREE (ret_reg);
						const char *rr = r_anal_cc_ret (anal, cc);
						if (rr) {
							ret_reg = strdup (rr);
						}
						resolved = false;
						free (cc);
					}
					if (!strcmp (fcn_name, ""__stack_chk_fail"")) {
						const char *query = sdb_fmt (""%d.addr"", cur_idx - 1);
						ut64 mov_addr = sdb_num_get (trace, query, 0);
						RAnalOp *mop = r_core_anal_op (core, mov_addr, R_ANAL_OP_MASK_VAL | R_ANAL_OP_MASK_BASIC);
						if (mop) {
							RAnalVar *mopvar = r_anal_get_used_function_var (anal, mop->addr);
							ut32 type = mop->type & R_ANAL_OP_TYPE_MASK;
							if (type == R_ANAL_OP_TYPE_MOV) {
								__var_rename (anal, mopvar, ""canary"", addr);
							}
						}
						r_anal_op_free (mop);
					}
					free (fcn_name);
				}
			} else if (!resolved && ret_type && ret_reg) {
				
				char src[REGNAME_SIZE] = {0};
				const char *query = sdb_fmt (""%d.reg.write"", cur_idx);
				const char *cur_dest = sdb_const_get (trace, query, 0);
				get_src_regname (core, aop.addr, src, sizeof (src));
				if (ret_reg && *src && strstr (ret_reg, src)) {
					if (var && aop.direction == R_ANAL_OP_DIR_WRITE) {
						__var_retype (anal, var, NULL, ret_type, false, false);
						resolved = true;
					} else if (type == R_ANAL_OP_TYPE_MOV) {
						R_FREE (ret_reg);
						if (cur_dest) {
							ret_reg = strdup (cur_dest);
						}
					}
				} else if (cur_dest) {
					char *foo = strdup (cur_dest);
					char *tmp = strchr (foo, ',');
					if (tmp) {
						*tmp++ = '\0';
					}
					if (ret_reg && (strstr (ret_reg, foo) || (tmp && strstr (ret_reg, tmp)))) {
						resolved = true;
					} else if (type == R_ANAL_OP_TYPE_MOV &&
							(next_op && next_op->type == R_ANAL_OP_TYPE_MOV)){
						
						
						
						char nsrc[REGNAME_SIZE] = {0};
						get_src_regname (core, next_op->addr, nsrc, sizeof (nsrc));
						if (ret_reg && *nsrc && strstr (ret_reg, nsrc) && var &&
								aop.direction == R_ANAL_OP_DIR_READ) {
							__var_retype (anal, var, NULL, ret_type, true, false);
						}
					}
					free (foo);
				}
			}
			
			if (var) {
				bool sign = false;
				if ((type == R_ANAL_OP_TYPE_CMP) && next_op) {
					if (next_op->sign) {
						sign = true;
					} else {
						
						__var_retype (anal, var, NULL, ""unsigned"", false, true);
					}
				}
				
				if (sign || aop.sign) {
					__var_retype (anal, var, NULL, ""signed"", false, true);
				}
				
				
				if (prev_dest && (type == R_ANAL_OP_TYPE_MOV || type == R_ANAL_OP_TYPE_STORE)) {
					char reg[REGNAME_SIZE] = {0};
					get_src_regname (core, addr, reg, sizeof (reg));
					bool match = strstr (prev_dest, reg) != NULL;
					if (str_flag && match) {
						__var_retype (anal, var, NULL, ""const char *"", false, false);
					}
					if (prop && match && prev_var) {
						__var_retype (anal, var, NULL, prev_type, false, false);
					}
				}
				if (chk_constraint && var && (type == R_ANAL_OP_TYPE_CMP && aop.disp != UT64_MAX)
						&& next_op && next_op->type == R_ANAL_OP_TYPE_CJMP) {
					bool jmp = false;
					RAnalOp *jmp_op = {0};
					ut64 jmp_addr = next_op->jump;
					RAnalBlock *jmpbb = r_anal_fcn_bbget_in (anal, fcn, jmp_addr);

					
					for (i = 0; i < MAX_INSTR ; i++) {
						jmp_op = r_core_anal_op (core, jmp_addr, R_ANAL_OP_MASK_BASIC);
						if (!jmp_op) {
							break;
						}
						if ((jmp_op->type == R_ANAL_OP_TYPE_RET && r_anal_block_contains (jmpbb, jmp_addr))
								|| jmp_op->type == R_ANAL_OP_TYPE_CJMP) {
							jmp = true;
							r_anal_op_free (jmp_op);
							break;
						}
						jmp_addr += jmp_op->size;
						r_anal_op_free (jmp_op);
					}
					RAnalVarConstraint constr = {
						.cond = jmp? cond_invert (anal, next_op->cond): next_op->cond,
						.val = aop.val
					};
					r_anal_var_add_constraint (var, &constr);
				}
			}
			prev_var = (var && aop.direction == R_ANAL_OP_DIR_READ);
			str_flag = false;
			prop = false;
			prev_dest = NULL;
			switch (type) {
			case R_ANAL_OP_TYPE_MOV:
			case R_ANAL_OP_TYPE_LEA:
			case R_ANAL_OP_TYPE_LOAD:
				if (aop.ptr && aop.refptr && aop.ptr != UT64_MAX) {
					if (type == R_ANAL_OP_TYPE_LOAD) {
						ut8 buf[256] = {0};
						r_io_read_at (core->io, aop.ptr, buf, sizeof (buf) - 1);
						ut64 ptr = r_read_ble (buf, core->print->big_endian, aop.refptr * 8);
						if (ptr && ptr != UT64_MAX) {
							RFlagItem *f = r_flag_get_by_spaces (core->flags, ptr, R_FLAGS_FS_STRINGS, NULL);
							if (f) {
								str_flag = true;
							}
						}
					} else if (r_flag_exist_at (core->flags, ""str"", 3, aop.ptr)) {
						str_flag = true;
					}
				}
				
				if (var && str_flag) {
					__var_retype (anal, var, NULL, ""const char *"", false, false);
				}
				const char *query = sdb_fmt (""%d.reg.write"", cur_idx);
				prev_dest = sdb_const_get (trace, query, 0);
				if (var) {
					strncpy (prev_type, var->type, sizeof (prev_type) - 1);
					prop = true;
				}
			}
			i += ret;
			addr += ret;
			r_anal_op_free (next_op);
			r_anal_op_fini (&aop);

		}
	}
	
	RList *list = r_anal_var_list (anal, fcn, R_ANAL_VAR_KIND_REG);
	RAnalVar *rvar;
	RListIter *iter;
	r_list_foreach (list, iter, rvar) {
		RAnalVar *lvar = r_anal_var_get_dst_var (rvar);
		RRegItem *i = r_reg_index_get (anal->reg, rvar->delta);
		if (!i) {
			continue;
		}
		if (lvar) {
			
			__var_retype (anal, rvar, NULL, lvar->type, false, false);
			
			__var_retype (anal, lvar, NULL, rvar->type, false, false);
		}
	}
	r_list_free (list);
out_function:
	R_FREE (ret_reg);
	R_FREE (ret_type);
	free (buf);
	r_cons_break_pop();
	anal_emul_restore (core, hc, dt, et);
	free (pc);
}
","1. R_API void r_core_anal_type_match(RCore *core, RAnalFunction *fcn) {
2. const int mininstrsz = r_anal_archinfo (anal, R_ANAL_ARCHINFO_MIN_OP_SIZE);
3. HtPPOptions opt = etracedb->ht->opt;
4. bool str_flag = false;
5. free (buf);
6. if (ret <= 0) {
7. r_anal_op_fini (&aop);
8. ut64 callee_addr;
9. RAnalFunction *fcn_call = r_anal_get_fcn_in (anal, aop.jump, -1);
10. if (flag && flag->realname) {
full_name = flag->realname;
11. fcn_name = r_type_func_guess (TDB, full_name);
12. type_match (core, fcn_name, addr, bb->addr, cc, prev_idx, userfnc, callee_addr);
13. R_FREE (ret_reg);
14. if (rr) {
15. free (cc);
16. if (type == R_ANAL_OP_TYPE_MOV) {
17. char src[REGNAME_SIZE] = {0};
18. if (prev_dest && (type == R_ANAL_OP_TYPE_MOV || type == R_ANAL_OP_TYPE_STORE)) {
char reg[REGNAME_SIZE] = {0};
19. if (str_flag && match) {
20. if (!jmp_op) {
21. if (ptr && ptr != UT64_MAX) {
22. if (var) {
23. RAnalVar *rvar;
24. R_FREE (ret_type);","5
22
43
55
63
93
96
118
120
127-128
136
145
152
154
158
167
177
231-232
235
252
284
300
314
332","CWE-200,CWE-772,CWE-20,CWE-416"
ssl3_client_hello,"
#define SSL

int ssl3_client_hello(SSL *s)
{
    unsigned char *buf;
    unsigned char *p, *d;
    int i;
    unsigned long l;
    int al = 0;
#ifndef OPENSSL_NO_COMP
    int j;
    SSL_COMP *comp;
#endif

    buf = (unsigned char *)s->init_buf->data;
    if (s->state == SSL3_ST_CW_CLNT_HELLO_A) {
        SSL_SESSION *sess = s->session;
        if ((sess == NULL) ||
            (sess->ssl_version != s->version) ||
            !sess->session_id_length || (sess->not_resumable)) {
            if (!ssl_get_new_session(s, 0))
                goto err;
        }
        if (s->method->version == DTLS_ANY_VERSION) {
            
            int options = s->options;
            
            if (options & SSL_OP_NO_DTLSv1_2) {
                if (tls1_suiteb(s)) {
                    SSLerr(SSL_F_SSL3_CLIENT_HELLO,
                           SSL_R_ONLY_DTLS_1_2_ALLOWED_IN_SUITEB_MODE);
                    goto err;
                }
                
                if (options & SSL_OP_NO_DTLSv1) {
                    SSLerr(SSL_F_SSL3_CLIENT_HELLO, SSL_R_WRONG_SSL_VERSION);
                    goto err;
                }
                
                s->method = DTLSv1_client_method();
                s->version = DTLS1_VERSION;
            } else {
                
                if (options & SSL_OP_NO_DTLSv1)
                    s->method = DTLSv1_2_client_method();
                s->version = DTLS1_2_VERSION;
            }
            s->client_version = s->version;
        }
        

        p = s->s3->client_random;

        
        if (SSL_IS_DTLS(s)) {
            size_t idx;
            i = 1;
            for (idx = 0; idx < sizeof(s->s3->client_random); idx++) {
                if (p[idx]) {
                    i = 0;
                    break;
                }
            }
         } else
             i = 1;
 
        if (i && ssl_fill_hello_random(s, 0, p,
                                       sizeof(s->s3->client_random)) <= 0)
            goto err;
 
         
         d = p = ssl_handshake_start(s);
        
        *(p++) = s->client_version >> 8;
        *(p++) = s->client_version & 0xff;

        
        memcpy(p, s->s3->client_random, SSL3_RANDOM_SIZE);
        p += SSL3_RANDOM_SIZE;

        
        if (s->new_session)
            i = 0;
        else
            i = s->session->session_id_length;
        *(p++) = i;
        if (i != 0) {
            if (i > (int)sizeof(s->session->session_id)) {
                SSLerr(SSL_F_SSL3_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);
                goto err;
            }
            memcpy(p, s->session->session_id, i);
            p += i;
        }

        
        if (SSL_IS_DTLS(s)) {
            if (s->d1->cookie_len > sizeof(s->d1->cookie)) {
                SSLerr(SSL_F_SSL3_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);
                goto err;
            }
            *(p++) = s->d1->cookie_len;
            memcpy(p, s->d1->cookie, s->d1->cookie_len);
            p += s->d1->cookie_len;
        }

        
        i = ssl_cipher_list_to_bytes(s, SSL_get_ciphers(s), &(p[2]), 0);
        if (i == 0) {
            SSLerr(SSL_F_SSL3_CLIENT_HELLO, SSL_R_NO_CIPHERS_AVAILABLE);
            goto err;
        }
#ifdef OPENSSL_MAX_TLS1_2_CIPHER_LENGTH
        
        if (TLS1_get_version(s) >= TLS1_2_VERSION
            && i > OPENSSL_MAX_TLS1_2_CIPHER_LENGTH)
            i = OPENSSL_MAX_TLS1_2_CIPHER_LENGTH & ~1;
#endif
        s2n(i, p);
        p += i;

        
#ifdef OPENSSL_NO_COMP
        *(p++) = 1;
#else

        if (!ssl_allow_compression(s) || !s->ctx->comp_methods)
            j = 0;
        else
            j = sk_SSL_COMP_num(s->ctx->comp_methods);
        *(p++) = 1 + j;
        for (i = 0; i < j; i++) {
            comp = sk_SSL_COMP_value(s->ctx->comp_methods, i);
            *(p++) = comp->id;
        }
#endif
        *(p++) = 0;             

#ifndef OPENSSL_NO_TLSEXT
        
        if (ssl_prepare_clienthello_tlsext(s) <= 0) {
            SSLerr(SSL_F_SSL3_CLIENT_HELLO, SSL_R_CLIENTHELLO_TLSEXT);
            goto err;
        }
        if ((p =
             ssl_add_clienthello_tlsext(s, p, buf + SSL3_RT_MAX_PLAIN_LENGTH,
                                        &al)) == NULL) {
            ssl3_send_alert(s, SSL3_AL_FATAL, al);
            SSLerr(SSL_F_SSL3_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);
            goto err;
        }
#endif

        l = p - d;
        ssl_set_handshake_header(s, SSL3_MT_CLIENT_HELLO, l);
        s->state = SSL3_ST_CW_CLNT_HELLO_B;
    }

    
    return ssl_do_write(s);
 err:
    return (-1);
}
","1. if (!ssl_get_new_session(s, 0))
2. if (tls1_suiteb(s)) {
3. if (SSL_IS_DTLS(s)) {
4. i = 1;
5. sizeof(s->s3->client_random)) <= 0)
6. memcpy(p, s->s3->client_random, SSL3_RANDOM_SIZE);
7. p += s->d1->cookie_len;
8. SSLerr(SSL_F_SSL3_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);","22
30
65
75
78
117
143
192","CWE-362,CWE-310,CWE-20,CWE-77"
ovl_fill_super-246233907054197,"static int ovl_fill_super(struct super_block *sb, void *data, int silent)
{
	struct path lowerpath;
	struct path upperpath;
	struct path workpath;
	struct inode *root_inode;
	struct dentry *root_dentry;
	struct ovl_entry *oe;
	struct ovl_fs *ufs;
	struct kstatfs statfs;
	int err;

	err = -ENOMEM;
	ufs = kzalloc(sizeof(struct ovl_fs), GFP_KERNEL);
	if (!ufs)
		goto out;

	err = ovl_parse_opt((char *) data, &ufs->config);
	if (err)
		goto out_free_config;

	
	err = -EINVAL;
	if (!ufs->config.upperdir || !ufs->config.lowerdir ||
	    !ufs->config.workdir) {
		pr_err(""overlayfs: missing upperdir or lowerdir or workdir\n"");
		goto out_free_config;
	}

	err = -ENOMEM;
	oe = ovl_alloc_entry();
	if (oe == NULL)
		goto out_free_config;

	err = ovl_mount_dir(ufs->config.upperdir, &upperpath);
	if (err)
		goto out_free_oe;

	err = ovl_mount_dir(ufs->config.lowerdir, &lowerpath);
	if (err)
		goto out_put_upperpath;

	err = ovl_mount_dir(ufs->config.workdir, &workpath);
	if (err)
		goto out_put_lowerpath;

	err = -EINVAL;
	if (!S_ISDIR(upperpath.dentry->d_inode->i_mode) ||
	    !S_ISDIR(lowerpath.dentry->d_inode->i_mode) ||
	    !S_ISDIR(workpath.dentry->d_inode->i_mode)) {
		pr_err(""overlayfs: upperdir or lowerdir or workdir not a directory\n"");
		goto out_put_workpath;
	}

	if (upperpath.mnt != workpath.mnt) {
		pr_err(""overlayfs: workdir and upperdir must reside under the same mount\n"");
		goto out_put_workpath;
	}
	if (!ovl_workdir_ok(workpath.dentry, upperpath.dentry)) {
		pr_err(""overlayfs: workdir and upperdir must be separate subtrees\n"");
		goto out_put_workpath;
	}

	if (!ovl_is_allowed_fs_type(upperpath.dentry)) {
		pr_err(""overlayfs: filesystem of upperdir is not supported\n"");
		goto out_put_workpath;
	}

	if (!ovl_is_allowed_fs_type(lowerpath.dentry)) {
		pr_err(""overlayfs: filesystem of lowerdir is not supported\n"");
		goto out_put_workpath;
	}

	err = vfs_statfs(&lowerpath, &statfs);
	if (err) {
		pr_err(""overlayfs: statfs failed on lowerpath\n"");
		goto out_put_workpath;
	}
	ufs->lower_namelen = statfs.f_namelen;

	sb->s_stack_depth = max(upperpath.mnt->mnt_sb->s_stack_depth,
				lowerpath.mnt->mnt_sb->s_stack_depth) + 1;

	err = -EINVAL;
	if (sb->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
		pr_err(""overlayfs: maximum fs stacking depth exceeded\n"");
		goto out_put_workpath;
	}

	ufs->upper_mnt = clone_private_mount(&upperpath);
	err = PTR_ERR(ufs->upper_mnt);
	if (IS_ERR(ufs->upper_mnt)) {
		pr_err(""overlayfs: failed to clone upperpath\n"");
		goto out_put_workpath;
	}

	ufs->lower_mnt = clone_private_mount(&lowerpath);
	err = PTR_ERR(ufs->lower_mnt);
	if (IS_ERR(ufs->lower_mnt)) {
		pr_err(""overlayfs: failed to clone lowerpath\n"");
		goto out_put_upper_mnt;
	}

	ufs->workdir = ovl_workdir_create(ufs->upper_mnt, workpath.dentry);
	err = PTR_ERR(ufs->workdir);
	if (IS_ERR(ufs->workdir)) {
		pr_err(""overlayfs: failed to create directory %s/%s\n"",
		       ufs->config.workdir, OVL_WORKDIR_NAME);
		goto out_put_lower_mnt;
	}

	
	ufs->lower_mnt->mnt_flags |= MNT_READONLY;

	
	if (ufs->upper_mnt->mnt_sb->s_flags & MS_RDONLY)
		sb->s_flags |= MS_RDONLY;

	sb->s_d_op = &ovl_dentry_operations;

	err = -ENOMEM;
	root_inode = ovl_new_inode(sb, S_IFDIR, oe);
	if (!root_inode)
		goto out_put_workdir;

	root_dentry = d_make_root(root_inode);
	if (!root_dentry)
		goto out_put_workdir;

	mntput(upperpath.mnt);
	mntput(lowerpath.mnt);
	path_put(&workpath);

	oe->__upperdentry = upperpath.dentry;
	oe->lowerdentry = lowerpath.dentry;

	root_dentry->d_fsdata = oe;

	sb->s_magic = OVERLAYFS_SUPER_MAGIC;
	sb->s_op = &ovl_super_operations;
	sb->s_root = root_dentry;
	sb->s_fs_info = ufs;

	return 0;

out_put_workdir:
	dput(ufs->workdir);
out_put_lower_mnt:
	mntput(ufs->lower_mnt);
out_put_upper_mnt:
	mntput(ufs->upper_mnt);
out_put_workpath:
	path_put(&workpath);
out_put_lowerpath:
	path_put(&lowerpath);
out_put_upperpath:
	path_put(&upperpath);
out_free_oe:
	kfree(oe);
out_free_config:
	kfree(ufs->config.lowerdir);
	kfree(ufs->config.upperdir);
	kfree(ufs->config.workdir);
	kfree(ufs);
out:
	return err;
}
","1. ufs = kzalloc(sizeof(struct ovl_fs), GFP_KERNEL);
2. goto out;
3. if (!ufs->config.upperdir || !ufs->config.lowerdir ||
4. goto out_free_config;
5. err = ovl_mount_dir(ufs->config.upperdir, &upperpath);
if (err)
6. err = -EINVAL;
7. !S_ISDIR(workpath.dentry->d_inode->i_mode)) {
8. goto out_put_workpath;
9. if (!ovl_workdir_ok(workpath.dentry, upperpath.dentry)) {
10. pr_err(""overlayfs: filesystem of upperdir is not supported\n"");
11. pr_err(""overlayfs: maximum fs stacking depth exceeded\n"");
12. pr_err(""overlayfs: failed to clone upperpath\n"");
13. ufs->config.workdir, OVL_WORKDIR_NAME);
goto out_put_lower_mnt;
14. if (ufs->upper_mnt->mnt_sb->s_flags & MS_RDONLY)
15. goto out_put_workdir;
16. root_dentry->d_fsdata = oe;
17. out_put_lower_mnt:
18. out_free_oe:
19. out_free_config:
20. return err;","14
16
24
27
35-36
47
50
57
59
65
86
93
108-109
119
127
140
151
161
163
169","CWE-1284,CWE-772,CWE-264,CWE-19,CWE-17"
rds_ib_laddr_check-77106373048548,"
#define __be32

static int rds_ib_laddr_check(__be32 addr)
{
	int ret;
	struct rdma_cm_id *cm_id;
	struct sockaddr_in sin;

	
	cm_id = rdma_create_id(NULL, NULL, RDMA_PS_TCP, IB_QPT_RC);
	if (IS_ERR(cm_id))
		return PTR_ERR(cm_id);

	memset(&sin, 0, sizeof(sin));
	sin.sin_family = AF_INET;
	sin.sin_addr.s_addr = addr;

	
	ret = rdma_bind_addr(cm_id, (struct sockaddr *)&sin);
	
	if (ret || !cm_id->device ||
	    cm_id->device->node_type != RDMA_NODE_IB_CA)
		ret = -EADDRNOTAVAIL;

	rdsdebug(""addr %pI4 ret %d node type %d\n"",
		&addr, ret,
		cm_id->device ? cm_id->device->node_type : -1);

	rdma_destroy_id(cm_id);

	return ret;
}
","1. int ret;
struct rdma_cm_id *cm_id;
struct sockaddr_in sin;
2. return PTR_ERR(cm_id);
3. memset(&sin, 0, sizeof(sin));
4. if (ret || !cm_id->device ||
cm_id->device->node_type != RDMA_NODE_IB_CA)
5. rdsdebug(""addr %pI4 ret %d node type %d\n"",
&addr, ret,
6. rdma_destroy_id(cm_id);","6-8
15
17
25-26
29-30
33","CWE-264,CWE-125"
__nla_parse-78390484117772,"int __nla_parse(struct nlattr **tb, int maxtype,
		const struct nlattr *head, int len,
		const struct nla_policy *policy, unsigned int validate,
		struct netlink_ext_ack *extack)
{
	return __nla_validate_parse(head, len, maxtype, policy, validate,
				    extack, tb, 0);
}
","1. int __nla_parse(struct nlattr **tb, int maxtype,
const struct nlattr *head, int len,
2. extack, tb, 0);","1-2
7","CWE-362,CWE-264,CWE-326,CWE-200,CWE-119"
mwifiex_ret_wmm_get_status-146501781772375,"int mwifiex_ret_wmm_get_status(struct mwifiex_private *priv,
			       const struct host_cmd_ds_command *resp)
{
	u8 *curr = (u8 *) &resp->params.get_wmm_status;
	uint16_t resp_len = le16_to_cpu(resp->size), tlv_len;
	int mask = IEEE80211_WMM_IE_AP_QOSINFO_PARAM_SET_CNT_MASK;
	bool valid = true;

	struct mwifiex_ie_types_data *tlv_hdr;
	struct mwifiex_ie_types_wmm_queue_status *tlv_wmm_qstatus;
	struct ieee_types_wmm_parameter *wmm_param_ie = NULL;
	struct mwifiex_wmm_ac_status *ac_status;

	mwifiex_dbg(priv->adapter, INFO,
		    ""info: WMM: WMM_GET_STATUS cmdresp received: %d\n"",
		    resp_len);

	while ((resp_len >= sizeof(tlv_hdr->header)) && valid) {
		tlv_hdr = (struct mwifiex_ie_types_data *) curr;
		tlv_len = le16_to_cpu(tlv_hdr->header.len);

		if (resp_len < tlv_len + sizeof(tlv_hdr->header))
			break;

		switch (le16_to_cpu(tlv_hdr->header.type)) {
		case TLV_TYPE_WMMQSTATUS:
			tlv_wmm_qstatus =
				(struct mwifiex_ie_types_wmm_queue_status *)
				tlv_hdr;
			mwifiex_dbg(priv->adapter, CMD,
				    ""info: CMD_RESP: WMM_GET_STATUS:\t""
				    ""QSTATUS TLV: %d, %d, %d\n"",
				    tlv_wmm_qstatus->queue_index,
				    tlv_wmm_qstatus->flow_required,
				    tlv_wmm_qstatus->disabled);

			ac_status = &priv->wmm.ac_status[tlv_wmm_qstatus->
							 queue_index];
			ac_status->disabled = tlv_wmm_qstatus->disabled;
			ac_status->flow_required =
						tlv_wmm_qstatus->flow_required;
			ac_status->flow_created = tlv_wmm_qstatus->flow_created;
			break;

		case WLAN_EID_VENDOR_SPECIFIC:
			

			wmm_param_ie =
				(struct ieee_types_wmm_parameter *) (curr +
								    2);
			wmm_param_ie->vend_hdr.len = (u8) tlv_len;
			wmm_param_ie->vend_hdr.element_id =
						WLAN_EID_VENDOR_SPECIFIC;

			mwifiex_dbg(priv->adapter, CMD,
				    ""info: CMD_RESP: WMM_GET_STATUS:\t""
				    ""WMM Parameter Set Count: %d\n"",
				    wmm_param_ie->qos_info_bitmap & mask);

			if (wmm_param_ie->vend_hdr.len + 2 >
				sizeof(struct ieee_types_wmm_parameter))
				break;

			memcpy((u8 *) &priv->curr_bss_params.bss_descriptor.
			       wmm_ie, wmm_param_ie,
			       wmm_param_ie->vend_hdr.len + 2);

			break;

		default:
			valid = false;
			break;
		}

		curr += (tlv_len + sizeof(tlv_hdr->header));
		resp_len -= (tlv_len + sizeof(tlv_hdr->header));
	}

	mwifiex_wmm_setup_queue_priorities(priv, wmm_param_ie);
	mwifiex_wmm_setup_ac_downgrade(priv);

	return 0;
}
","1. default:
valid = false;
2. curr += (tlv_len + sizeof(tlv_hdr->header));","73-74
78","CWE-190,CWE-200,CWE-415,CWE-189"
uio_mmap_physical,"static int uio_mmap_physical(struct vm_area_struct *vma)
 {
 	struct uio_device *idev = vma->vm_private_data;
 	int mi = uio_find_mem_index(vma);
	struct uio_mem *mem;
 	if (mi < 0)
 		return -EINVAL;
	mem = idev->info->mem + mi;
 
	if (vma->vm_end - vma->vm_start > mem->size)
		return -EINVAL;
 
	vma->vm_ops = &uio_physical_vm_ops;
 	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
 
	
 	return remap_pfn_range(vma,
 			       vma->vm_start,
			       mem->addr >> PAGE_SHIFT,
 			       vma->vm_end - vma->vm_start,
 			       vma->vm_page_prot);
 }
","1. static int uio_mmap_physical(struct vm_area_struct *vma)
2. int mi = uio_find_mem_index(vma);
struct uio_mem *mem;
if (mi < 0)
return -EINVAL;
mem = idev->info->mem + mi;
3. if (vma->vm_end - vma->vm_start > mem->size)
return -EINVAL;
4. vma->vm_ops = &uio_physical_vm_ops;
vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
5. vma->vm_start,
mem->addr >> PAGE_SHIFT,
vma->vm_end - vma->vm_start,
vma->vm_page_prot);","1
4-8
10-11
13-14
26-29","CWE-362,CWE-835,CWE-125,CWE-189"
fp4_read_bin-172167877249369,"void fp4_read_bin(fp4_t a, const uint8_t *bin, size_t len) {
	if (len != 4 * RLC_FP_BYTES) {
		RLC_THROW(ERR_NO_BUFFER);
		return;
	}
	fp2_read_bin(a[0], bin, 2 * RLC_FP_BYTES);
	fp2_read_bin(a[1], bin + 2 * RLC_FP_BYTES, 2 * RLC_FP_BYTES);
}
","1. void fp4_read_bin(fp4_t a, const uint8_t *bin, size_t len) {
if (len != 4 * RLC_FP_BYTES) {
RLC_THROW(ERR_NO_BUFFER);
return;
2. fp2_read_bin(a[0], bin, 2 * RLC_FP_BYTES);
fp2_read_bin(a[1], bin + 2 * RLC_FP_BYTES, 2 * RLC_FP_BYTES);","1-4
6-7",CWE-190
xfs_attr3_leaf_list_int,"xfs_attr3_leaf_list_int(
	struct xfs_buf			*bp,
	struct xfs_attr_list_context	*context)
{
	struct attrlist_cursor_kern	*cursor;
	struct xfs_attr_leafblock	*leaf;
	struct xfs_attr3_icleaf_hdr	ichdr;
	struct xfs_attr_leaf_entry	*entries;
	struct xfs_attr_leaf_entry	*entry;
	int				retval;
	int				i;

	trace_xfs_attr_list_leaf(context);

	leaf = bp->b_addr;
	xfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);
	entries = xfs_attr3_leaf_entryp(leaf);

	cursor = context->cursor;
	cursor->initted = 1;

	
	if (context->resynch) {
		entry = &entries[0];
		for (i = 0; i < ichdr.count; entry++, i++) {
			if (be32_to_cpu(entry->hashval) == cursor->hashval) {
				if (cursor->offset == context->dupcnt) {
					context->dupcnt = 0;
					break;
				}
				context->dupcnt++;
			} else if (be32_to_cpu(entry->hashval) >
					cursor->hashval) {
				context->dupcnt = 0;
				break;
			}
		}
		if (i == ichdr.count) {
			trace_xfs_attr_list_notfound(context);
			return 0;
		}
	} else {
		entry = &entries[0];
		i = 0;
	}
	context->resynch = 0;

	
	retval = 0;
	for (; i < ichdr.count; entry++, i++) {
		if (be32_to_cpu(entry->hashval) != cursor->hashval) {
			cursor->hashval = be32_to_cpu(entry->hashval);
			cursor->offset = 0;
		}

		if (entry->flags & XFS_ATTR_INCOMPLETE)
			continue;		

		if (entry->flags & XFS_ATTR_LOCAL) {
			xfs_attr_leaf_name_local_t *name_loc =
				xfs_attr3_leaf_name_local(leaf, i);

			retval = context->put_listent(context,
						entry->flags,
						name_loc->nameval,
						(int)name_loc->namelen,
						be16_to_cpu(name_loc->valuelen),
						&name_loc->nameval[name_loc->namelen]);
			if (retval)
				return retval;
		} else {
			xfs_attr_leaf_name_remote_t *name_rmt =
				xfs_attr3_leaf_name_remote(leaf, i);

			int valuelen = be32_to_cpu(name_rmt->valuelen);

			if (context->put_value) {
				xfs_da_args_t args;

				memset((char *)&args, 0, sizeof(args));
 				args.dp = context->dp;
 				args.whichfork = XFS_ATTR_FORK;
 				args.valuelen = valuelen;
				args.rmtvaluelen = valuelen;
 				args.value = kmem_alloc(valuelen, KM_SLEEP | KM_NOFS);
 				args.rmtblkno = be32_to_cpu(name_rmt->valueblk);
 				args.rmtblkcnt = xfs_attr3_rmt_blocks(
							args.dp->i_mount, valuelen);
				retval = xfs_attr_rmtval_get(&args);
				if (retval)
					return retval;
				retval = context->put_listent(context,
						entry->flags,
						name_rmt->name,
						(int)name_rmt->namelen,
						valuelen,
						args.value);
				kmem_free(args.value);
			} else {
				retval = context->put_listent(context,
						entry->flags,
						name_rmt->name,
						(int)name_rmt->namelen,
						valuelen,
						NULL);
			}
			if (retval)
				return retval;
		}
		if (context->seen_enough)
			break;
		cursor->offset++;
	}
	trace_xfs_attr_list_leaf_end(context);
	return retval;
}
","1. leaf = bp->b_addr;
2. entries = xfs_attr3_leaf_entryp(leaf);
3. } else if (be32_to_cpu(entry->hashval) >
4. context->resynch = 0;
5. if (be32_to_cpu(entry->hashval) != cursor->hashval) {
6. int valuelen = be32_to_cpu(name_rmt->valuelen);
7. memset((char *)&args, 0, sizeof(args));
8. if (retval)
9. name_rmt->name,
10. break;","15
17
34
48
55
79
84
94
98
115","CWE-476,CWE-200,CWE-125"
paravirt_patch_jmp-122376278163017,"unsigned paravirt_patch_jmp(void *insnbuf, const void *target,
			    unsigned long addr, unsigned len)
{
	struct branch *b = insnbuf;
	unsigned long delta = (unsigned long)target - (addr+5);

	if (len < 5) {
#ifdef CONFIG_RETPOLINE
		WARN_ONCE(""Failing to patch indirect JMP in %ps\n"", (void *)addr);
#endif
		return len;	
	}

	b->opcode = 0xe9;	
	b->delta = delta;

	return 5;
}
","1. unsigned paravirt_patch_jmp(void *insnbuf, const void *target,
unsigned long addr, unsigned len)
2. struct branch *b = insnbuf;
unsigned long delta = (unsigned long)target - (addr+5);
3. if (len < 5) {
4. b->opcode = 0xe9;
b->delta = delta;
5. return 5;","1-2
4-5
7
14-15
17","CWE-190,CWE-200"
fuse_do_ioctl,"long fuse_do_ioctl(struct file *file, unsigned int cmd, unsigned long arg,
		   unsigned int flags)
{
	struct fuse_file *ff = file->private_data;
	struct fuse_conn *fc = ff->fc;
	struct fuse_ioctl_in inarg = {
		.fh = ff->fh,
		.cmd = cmd,
		.arg = arg,
		.flags = flags
	};
	struct fuse_ioctl_out outarg;
	struct fuse_req *req = NULL;
	struct page **pages = NULL;
	struct page *iov_page = NULL;
	struct iovec *in_iov = NULL, *out_iov = NULL;
	unsigned int in_iovs = 0, out_iovs = 0, num_pages = 0, max_pages;
	size_t in_size, out_size, transferred;
	int err;

	
	BUILD_BUG_ON(sizeof(struct iovec) * FUSE_IOCTL_MAX_IOV > PAGE_SIZE);

	err = -ENOMEM;
	pages = kzalloc(sizeof(pages[0]) * FUSE_MAX_PAGES_PER_REQ, GFP_KERNEL);
	iov_page = alloc_page(GFP_KERNEL);
	if (!pages || !iov_page)
		goto out;

	
	if (!(flags & FUSE_IOCTL_UNRESTRICTED)) {
		struct iovec *iov = page_address(iov_page);

		iov->iov_base = (void __user *)arg;
		iov->iov_len = _IOC_SIZE(cmd);

		if (_IOC_DIR(cmd) & _IOC_WRITE) {
			in_iov = iov;
			in_iovs = 1;
		}

		if (_IOC_DIR(cmd) & _IOC_READ) {
			out_iov = iov;
			out_iovs = 1;
		}
	}

 retry:
	inarg.in_size = in_size = iov_length(in_iov, in_iovs);
	inarg.out_size = out_size = iov_length(out_iov, out_iovs);

	
	out_size = max_t(size_t, out_size, PAGE_SIZE);
	max_pages = DIV_ROUND_UP(max(in_size, out_size), PAGE_SIZE);

	
	err = -ENOMEM;
	if (max_pages > FUSE_MAX_PAGES_PER_REQ)
		goto out;
	while (num_pages < max_pages) {
		pages[num_pages] = alloc_page(GFP_KERNEL | __GFP_HIGHMEM);
		if (!pages[num_pages])
			goto out;
		num_pages++;
	}

	req = fuse_get_req(fc);
	if (IS_ERR(req)) {
		err = PTR_ERR(req);
		req = NULL;
		goto out;
	}
	memcpy(req->pages, pages, sizeof(req->pages[0]) * num_pages);
	req->num_pages = num_pages;

	
	req->in.h.opcode = FUSE_IOCTL;
	req->in.h.nodeid = ff->nodeid;
	req->in.numargs = 1;
	req->in.args[0].size = sizeof(inarg);
	req->in.args[0].value = &inarg;
	if (in_size) {
		req->in.numargs++;
		req->in.args[1].size = in_size;
		req->in.argpages = 1;

		err = fuse_ioctl_copy_user(pages, in_iov, in_iovs, in_size,
					   false);
		if (err)
			goto out;
	}

	req->out.numargs = 2;
	req->out.args[0].size = sizeof(outarg);
	req->out.args[0].value = &outarg;
	req->out.args[1].size = out_size;
	req->out.argpages = 1;
	req->out.argvar = 1;

	fuse_request_send(fc, req);
	err = req->out.h.error;
	transferred = req->out.args[1].size;
	fuse_put_request(fc, req);
	req = NULL;
	if (err)
		goto out;

	
	if (outarg.flags & FUSE_IOCTL_RETRY) {
		char *vaddr;

		
		err = -EIO;
		if (!(flags & FUSE_IOCTL_UNRESTRICTED))
			goto out;

		in_iovs = outarg.in_iovs;
		out_iovs = outarg.out_iovs;

		
		err = -ENOMEM;
		if (in_iovs > FUSE_IOCTL_MAX_IOV ||
		    out_iovs > FUSE_IOCTL_MAX_IOV ||
		    in_iovs + out_iovs > FUSE_IOCTL_MAX_IOV)
			goto out;

		vaddr = kmap_atomic(pages[0], KM_USER0);
		err = fuse_copy_ioctl_iovec(page_address(iov_page), vaddr,
					    transferred, in_iovs + out_iovs,
					    (flags & FUSE_IOCTL_COMPAT) != 0);
		kunmap_atomic(vaddr, KM_USER0);
		if (err)
			goto out;

 		in_iov = page_address(iov_page);
 		out_iov = in_iov + in_iovs;
 
		err = fuse_verify_ioctl_iov(in_iov, in_iovs);
		if (err)
			goto out;

		err = fuse_verify_ioctl_iov(out_iov, out_iovs);
		if (err)
			goto out;

 		goto retry;
 	}
 
	err = -EIO;
	if (transferred > inarg.out_size)
		goto out;

	err = fuse_ioctl_copy_user(pages, out_iov, out_iovs, transferred, true);
 out:
	if (req)
		fuse_put_request(fc, req);
	if (iov_page)
		__free_page(iov_page);
	while (num_pages)
		__free_page(pages[--num_pages]);
	kfree(pages);

	return err ? err : outarg.result;
}
","1. long fuse_do_ioctl(struct file *file, unsigned int cmd, unsigned long arg,
2. .fh = ff->fh,
3. struct fuse_ioctl_out outarg;
4. struct page **pages = NULL;
5. size_t in_size, out_size, transferred;
6. err = -ENOMEM;
7. goto out;
8. in_iov = iov;
9. pages[num_pages] = alloc_page(GFP_KERNEL | __GFP_HIGHMEM);
10. goto out;
11. req = NULL;
goto out;
12. if (in_size) {
13. req->out.args[0].value = &outarg;
14. goto out;
15. err = -EIO;
16. in_iovs = outarg.in_iovs;
17. if (err)
goto out;","1
7
12
14
18
24
28
41
67
69
76-77
88
101
112
119
123
141-142","CWE-362,CWE-19,CWE-119"
nested_vmx_check_permission," static int nested_vmx_check_permission(struct kvm_vcpu *vcpu)
 {
	if (vmx_get_cpl(vcpu)) {
		kvm_queue_exception(vcpu, UD_VECTOR);
		return 0;
	}

 	if (!to_vmx(vcpu)->nested.vmxon) {
 		kvm_queue_exception(vcpu, UD_VECTOR);
 		return 0;
	}
	return 1;
}
","1. static int nested_vmx_check_permission(struct kvm_vcpu *vcpu)
2. kvm_queue_exception(vcpu, UD_VECTOR);
return 0;
3. if (!to_vmx(vcpu)->nested.vmxon) {
kvm_queue_exception(vcpu, UD_VECTOR);
return 0;
4. return 1;","1
4-5
8-10
12","CWE-704,CWE-787,CWE-189,CWE-119"
bpf_obj_do_get-131129021564876,"static void *bpf_obj_do_get(const struct filename *pathname,
			    enum bpf_type *type)
{
	struct inode *inode;
	struct path path;
	void *raw;
	int ret;

	ret = kern_path(pathname->name, LOOKUP_FOLLOW, &path);
	if (ret)
		return ERR_PTR(ret);

	inode = d_backing_inode(path.dentry);
	ret = inode_permission(inode, MAY_WRITE);
	if (ret)
		goto out;

	ret = bpf_inode_type(inode, type);
	if (ret)
		goto out;

	raw = bpf_any_get(inode->i_private, *type);
	if (!IS_ERR(raw))
		touch_atime(&path);

	path_put(&path);
	return raw;
out:
	path_put(&path);
	return ERR_PTR(ret);
}
","1. struct path path;
2. ret = kern_path(pathname->name, LOOKUP_FOLLOW, &path);
3. return ERR_PTR(ret);
4. raw = bpf_any_get(inode->i_private, *type);
5. path_put(&path);
return ERR_PTR(ret);","5
9
11
22
29-30","CWE-17,CWE-200,CWE-125,CWE-20"
get_privs_2_svc-131298436463723,"getprivs_ret * get_privs_2_svc(krb5_ui_4 *arg, struct svc_req *rqstp)
{
    static getprivs_ret            ret;
    gss_buffer_desc                client_name = GSS_C_EMPTY_BUFFER;
    gss_buffer_desc                service_name = GSS_C_EMPTY_BUFFER;
    OM_uint32                      minor_stat;
    kadm5_server_handle_t          handle;
    const char                     *errmsg = NULL;

    xdr_free(xdr_getprivs_ret, &ret);

    if ((ret.code = new_server_handle(*arg, rqstp, &handle)))
        goto exit_func;

    if ((ret.code = check_handle((void *)handle)))
        goto exit_func;

    ret.api_version = handle->api_version;

    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {
        ret.code = KADM5_FAILURE;
        goto exit_func;
    }

    ret.code = kadm5_get_privs((void *)handle, &ret.privs);
    if( ret.code != 0 )
        errmsg = krb5_get_error_message(handle->context, ret.code);

    log_done(""kadm5_get_privs"", client_name.value, errmsg,
             &client_name, &service_name, rqstp);

    if (errmsg != NULL)
        krb5_free_error_message(handle->context, errmsg);

exit_func:
    gss_release_buffer(&minor_stat, &client_name);
    gss_release_buffer(&minor_stat, &service_name);
    free_server_handle(handle);
    return &ret;
}
","1. static getprivs_ret            ret;
2. OM_uint32                      minor_stat;
kadm5_server_handle_t          handle;
3. if ((ret.code = new_server_handle(*arg, rqstp, &handle)))
4. &client_name, &service_name, rqstp);
5. exit_func:
6. gss_release_buffer(&minor_stat, &service_name);
free_server_handle(handle);","3
6-7
12
30
35
37-38","CWE-772,CWE-119"
adjust_scalar_min_max_vals_5-14720173858966,"static int adjust_scalar_min_max_vals_5(struct bpf_verifier_env *env,
				      struct bpf_insn *insn,
				      struct bpf_reg_state *dst_reg,
				      struct bpf_reg_state src_reg)
{
	struct bpf_reg_state *regs = cur_regs(env);
	u8 opcode = BPF_OP(insn->code);
	bool src_known, dst_known;
	s64 smin_val, smax_val;
	u64 umin_val, umax_val;
	u64 insn_bitness = (BPF_CLASS(insn->code) == BPF_ALU64) ? 64 : 32;
	u32 dst = insn->dst_reg;
	int ret;

	if (insn_bitness == 32) {
		
		coerce_reg_to_size(dst_reg, 4);
		coerce_reg_to_size(&src_reg, 4);
	}

	smin_val = src_reg.smin_value;
	smax_val = src_reg.smax_value;
	umin_val = src_reg.umin_value;
	umax_val = src_reg.umax_value;
	src_known = tnum_is_const(src_reg.var_off);
	dst_known = tnum_is_const(dst_reg->var_off);

	if ((src_known && (smin_val != smax_val || umin_val != umax_val)) ||
	    smin_val > smax_val || umin_val > umax_val) {
		
		__mark_reg_unknown(dst_reg);
		return 0;
	}

	if (!src_known &&
	    opcode != BPF_ADD && opcode != BPF_SUB && opcode != BPF_AND) {
		__mark_reg_unknown(dst_reg);
		return 0;
	}

	switch (opcode) {
	case BPF_ADD:
		ret = sanitize_val_alu(env, insn);
		if (ret < 0) {
			verbose(env, ""R%d tried to add from different pointers or scalars\n"", dst);
			return ret;
		}
		if (signed_add_overflows(dst_reg->smin_value, smin_val) ||
		    signed_add_overflows(dst_reg->smax_value, smax_val)) {
			dst_reg->smin_value = S64_MIN;
			dst_reg->smax_value = S64_MAX;
		} else {
			dst_reg->smin_value += smin_val;
			dst_reg->smax_value += smax_val;
		}
		if (dst_reg->umin_value + umin_val < umin_val ||
		    dst_reg->umax_value + umax_val < umax_val) {
			dst_reg->umin_value = 0;
			dst_reg->umax_value = U64_MAX;
		} else {
			dst_reg->umin_value += umin_val;
			dst_reg->umax_value += umax_val;
		}
		dst_reg->var_off = tnum_add(dst_reg->var_off, src_reg.var_off);
		break;
	case BPF_SUB:
		ret = sanitize_val_alu(env, insn);
		if (ret < 0) {
			verbose(env, ""R%d tried to sub from different pointers or scalars\n"", dst);
			return ret;
		}
		if (signed_sub_overflows(dst_reg->smin_value, smax_val) ||
		    signed_sub_overflows(dst_reg->smax_value, smin_val)) {
			
			dst_reg->smin_value = S64_MIN;
			dst_reg->smax_value = S64_MAX;
		} else {
			dst_reg->smin_value -= smax_val;
			dst_reg->smax_value -= smin_val;
		}
		if (dst_reg->umin_value < umax_val) {
			
			dst_reg->umin_value = 0;
			dst_reg->umax_value = U64_MAX;
		} else {
			
			dst_reg->umin_value -= umax_val;
			dst_reg->umax_value -= umin_val;
		}
		dst_reg->var_off = tnum_sub(dst_reg->var_off, src_reg.var_off);
		break;
	case BPF_MUL:
		dst_reg->var_off = tnum_mul(dst_reg->var_off, src_reg.var_off);
		if (smin_val < 0 || dst_reg->smin_value < 0) {
			
			__mark_reg_unbounded(dst_reg);
			__update_reg_bounds(dst_reg);
			break;
		}
		
		if (umax_val > U32_MAX || dst_reg->umax_value > U32_MAX) {
			
			__mark_reg_unbounded(dst_reg);
			
			__update_reg_bounds(dst_reg);
			break;
		}
		dst_reg->umin_value *= umin_val;
		dst_reg->umax_value *= umax_val;
		if (dst_reg->umax_value > S64_MAX) {
			
			dst_reg->smin_value = S64_MIN;
			dst_reg->smax_value = S64_MAX;
		} else {
			dst_reg->smin_value = dst_reg->umin_value;
			dst_reg->smax_value = dst_reg->umax_value;
		}
		break;
	case BPF_AND:
		if (src_known && dst_known) {
			__mark_reg_known(dst_reg, dst_reg->var_off.value &
						  src_reg.var_off.value);
			break;
		}
		
		dst_reg->var_off = tnum_and(dst_reg->var_off, src_reg.var_off);
		dst_reg->umin_value = dst_reg->var_off.value;
		dst_reg->umax_value = min(dst_reg->umax_value, umax_val);
		if (dst_reg->smin_value < 0 || smin_val < 0) {
			
			dst_reg->smin_value = S64_MIN;
			dst_reg->smax_value = S64_MAX;
		} else {
			
			dst_reg->smin_value = dst_reg->umin_value;
			dst_reg->smax_value = dst_reg->umax_value;
		}
		
		__update_reg_bounds(dst_reg);
		break;
	case BPF_OR:
		if (src_known && dst_known) {
			__mark_reg_known(dst_reg, dst_reg->var_off.value |
						  src_reg.var_off.value);
			break;
		}
		
		dst_reg->var_off = tnum_or(dst_reg->var_off, src_reg.var_off);
		dst_reg->umin_value = max(dst_reg->umin_value, umin_val);
		dst_reg->umax_value = dst_reg->var_off.value |
				      dst_reg->var_off.mask;
		if (dst_reg->smin_value < 0 || smin_val < 0) {
			
			dst_reg->smin_value = S64_MIN;
			dst_reg->smax_value = S64_MAX;
		} else {
			
			dst_reg->smin_value = dst_reg->umin_value;
			dst_reg->smax_value = dst_reg->umax_value;
		}
		
		__update_reg_bounds(dst_reg);
		break;
	case BPF_LSH:
		if (umax_val >= insn_bitness) {
			
			mark_reg_unknown(env, regs, insn->dst_reg);
			break;
		}
		
		dst_reg->smin_value = S64_MIN;
		dst_reg->smax_value = S64_MAX;
		
		if (dst_reg->umax_value > 1ULL << (63 - umax_val)) {
			dst_reg->umin_value = 0;
			dst_reg->umax_value = U64_MAX;
		} else {
			dst_reg->umin_value <<= umin_val;
			dst_reg->umax_value <<= umax_val;
		}
		dst_reg->var_off = tnum_lshift(dst_reg->var_off, umin_val);
		
		__update_reg_bounds(dst_reg);
		break;
	case BPF_RSH:
		if (umax_val >= insn_bitness) {
			
			mark_reg_unknown(env, regs, insn->dst_reg);
			break;
		}
		
		dst_reg->smin_value = S64_MIN;
		dst_reg->smax_value = S64_MAX;
		dst_reg->var_off = tnum_rshift(dst_reg->var_off, umin_val);
		dst_reg->umin_value >>= umax_val;
		dst_reg->umax_value >>= umin_val;
		
		__update_reg_bounds(dst_reg);
		break;
	case BPF_ARSH:
		if (umax_val >= insn_bitness) {
			
			mark_reg_unknown(env, regs, insn->dst_reg);
			break;
		}

		
		dst_reg->smin_value >>= umin_val;
		dst_reg->smax_value >>= umin_val;
		dst_reg->var_off = tnum_arshift(dst_reg->var_off, umin_val);

		
		dst_reg->umin_value = 0;
		dst_reg->umax_value = U64_MAX;
		__update_reg_bounds(dst_reg);
		break;
	default:
		mark_reg_unknown(env, regs, insn->dst_reg);
		break;
	}

	if (BPF_CLASS(insn->code) != BPF_ALU64) {
		
		coerce_reg_to_size(dst_reg, 4);
	}

	__reg_deduce_bounds(dst_reg);
	__reg_bound_offset(dst_reg);
	return 0;
}
","1. struct bpf_reg_state *dst_reg,
struct bpf_reg_state src_reg)
2. bool src_known, dst_known;
3. if (insn_bitness == 32) {
4. if ((src_known && (smin_val != smax_val || umin_val != umax_val)) ||
5. dst_reg->smin_value = S64_MIN;
dst_reg->smax_value = S64_MAX;
6. dst_reg->var_off = tnum_add(dst_reg->var_off, src_reg.var_off);
break;
7. ret = sanitize_val_alu(env, insn);
8. return ret;
9. dst_reg->smax_value = S64_MAX;
10. if (dst_reg->umin_value < umax_val) {
11. if (umax_val > U32_MAX || dst_reg->umax_value > U32_MAX) {
12. __update_reg_bounds(dst_reg);
13. dst_reg->umin_value *= umin_val;
dst_reg->umax_value *= umax_val;
if (dst_reg->umax_value > S64_MAX) {
14. dst_reg->smax_value = S64_MAX;
15. dst_reg->umin_value = dst_reg->var_off.value;
16. dst_reg->smin_value = dst_reg->umin_value;
17. __update_reg_bounds(dst_reg);
break;
18. src_reg.var_off.value);
19. dst_reg->umin_value = max(dst_reg->umin_value, umin_val);
20. } else {
21. break;
22. dst_reg->smin_value = S64_MIN;
23. dst_reg->umin_value <<= umin_val;
24. case BPF_RSH:
if (umax_val >= insn_bitness) {
25. break;
26. dst_reg->var_off = tnum_arshift(dst_reg->var_off, umin_val);
27. dst_reg->umin_value = 0;
28. if (BPF_CLASS(insn->code) != BPF_ALU64) {
29. coerce_reg_to_size(dst_reg, 4);
30. return 0;","3-4
8
15
31
55-56
69-70
72
75
81
86
108
112
115-117
120
136
148
152-153
157
164
173
189
194
201
208-209
214
252
257
266
268
273","CWE-476,CWE-190,CWE-189"
scm_fp_dup-113663688715075,"struct scm_fp_list *scm_fp_dup(struct scm_fp_list *fpl)
{
	struct scm_fp_list *new_fpl;
	int i;

	if (!fpl)
		return NULL;

	new_fpl = kmemdup(fpl, offsetof(struct scm_fp_list, fp[fpl->count]),
			  GFP_KERNEL);
	if (new_fpl) {
		for (i = 0; i < fpl->count; i++)
			get_file(fpl->fp[i]);
		new_fpl->max = new_fpl->count;
		new_fpl->user = get_uid(fpl->user);
	}
	return new_fpl;
}
","1. struct scm_fp_list *new_fpl;
2. if (!fpl)
return NULL;
3. if (new_fpl) {
4. get_file(fpl->fp[i]);","3
6-7
11
13","CWE-476,CWE-20,CWE-399,CWE-119"
devzvol_readdir-257030450696344,"static int
devzvol_readdir(struct vnode *dvp, struct uio *uiop, struct cred *cred,
    int *eofp, caller_context_t *ct_unused, int flags_unused)
{
	struct sdev_node *sdvp = VTOSDEV(dvp);
	char *ptr;

	sdcmn_err13((""zv readdir of '%s' %s'"", sdvp->sdev_path,
	    sdvp->sdev_name));

	if (strcmp(sdvp->sdev_path, ZVOL_DIR) == 0) {
		struct vnode *vp;

		rw_exit(&sdvp->sdev_contents);
		(void) devname_lookup_func(sdvp, ""dsk"", &vp, cred,
		    devzvol_create_dir, SDEV_VATTR);
		VN_RELE(vp);
		(void) devname_lookup_func(sdvp, ""rdsk"", &vp, cred,
		    devzvol_create_dir, SDEV_VATTR);
		VN_RELE(vp);
		rw_enter(&sdvp->sdev_contents, RW_READER);
		return (devname_readdir_func(dvp, uiop, cred, eofp, 0));
	}
	if (uiop->uio_offset == 0)
		devzvol_prunedir(sdvp);
	ptr = sdvp->sdev_path + strlen(ZVOL_DIR);
	if ((strcmp(ptr, ""/dsk"") == 0) || (strcmp(ptr, ""/rdsk"") == 0)) {
		rw_exit(&sdvp->sdev_contents);
		devzvol_create_pool_dirs(dvp);
		rw_enter(&sdvp->sdev_contents, RW_READER);
		return (devname_readdir_func(dvp, uiop, cred, eofp, 0));
	}

	ptr = strchr(ptr + 1, '/');
	if (ptr == NULL)
		return (ENOENT);
	ptr++;
	rw_exit(&sdvp->sdev_contents);
	sdev_iter_datasets(dvp, ZFS_IOC_DATASET_LIST_NEXT, ptr);
	rw_enter(&sdvp->sdev_contents, RW_READER);
	return (devname_readdir_func(dvp, uiop, cred, eofp, 0));
}
","1. struct sdev_node *sdvp = VTOSDEV(dvp);
2. rw_exit(&sdvp->sdev_contents);","5
14","CWE-20,CWE-400"
qemu_ram_free-37448886506789,"
#define RAMBlock

void qemu_ram_free(struct uc_struct *uc, RAMBlock *block)
{
    if (!block) {
        return;
    }

    
    
    

    QLIST_REMOVE_RCU(block, next);
    uc->ram_list.mru_block = NULL;
    
    
    
    reclaim_ramblock(uc, block);
}
","1. void qemu_ram_free(struct uc_struct *uc, RAMBlock *block)
2. if (!block) {
return;
3. QLIST_REMOVE_RCU(block, next);
uc->ram_list.mru_block = NULL;
4. reclaim_ramblock(uc, block);","4
6-7
14-15
19","CWE-362,CWE-20,CWE-119"
collapse_huge_page-56069907818141,"static void collapse_huge_page(struct mm_struct *mm,
			       unsigned long address,
			       struct page **hpage,
			       struct vm_area_struct *vma,
			       int node)
{
	pgd_t *pgd;
	pud_t *pud;
	pmd_t *pmd, _pmd;
	pte_t *pte;
	pgtable_t pgtable;
	struct page *new_page;
	spinlock_t *ptl;
	int isolated;
	unsigned long hstart, hend;

	VM_BUG_ON(address & ~HPAGE_PMD_MASK);
#ifndef CONFIG_NUMA
	VM_BUG_ON(!*hpage);
	new_page = *hpage;
	if (unlikely(mem_cgroup_newpage_charge(new_page, mm, GFP_KERNEL))) {
		up_read(&mm->mmap_sem);
		return;
	}
#else
	VM_BUG_ON(*hpage);
	
	new_page = alloc_hugepage_vma(khugepaged_defrag(), vma, address,
				      node, __GFP_OTHER_NODE);
	if (unlikely(!new_page)) {
		up_read(&mm->mmap_sem);
		count_vm_event(THP_COLLAPSE_ALLOC_FAILED);
		*hpage = ERR_PTR(-ENOMEM);
		return;
	}
	count_vm_event(THP_COLLAPSE_ALLOC);
	if (unlikely(mem_cgroup_newpage_charge(new_page, mm, GFP_KERNEL))) {
		up_read(&mm->mmap_sem);
		put_page(new_page);
		return;
	}
#endif

	
	up_read(&mm->mmap_sem);

	
	down_write(&mm->mmap_sem);
	if (unlikely(khugepaged_test_exit(mm)))
		goto out;

	vma = find_vma(mm, address);
	hstart = (vma->vm_start + ~HPAGE_PMD_MASK) & HPAGE_PMD_MASK;
	hend = vma->vm_end & HPAGE_PMD_MASK;
	if (address < hstart || address + HPAGE_PMD_SIZE > hend)
		goto out;

	if ((!(vma->vm_flags & VM_HUGEPAGE) && !khugepaged_always()) ||
	    (vma->vm_flags & VM_NOHUGEPAGE))
		goto out;

	if (!vma->anon_vma || vma->vm_ops)
		goto out;
	if (is_vma_temporary_stack(vma))
		goto out;
	
	VM_BUG_ON(is_linear_pfn_mapping(vma) || vma->vm_flags & VM_NO_THP);

	pgd = pgd_offset(mm, address);
	if (!pgd_present(*pgd))
		goto out;

	pud = pud_offset(pgd, address);
	if (!pud_present(*pud))
		goto out;

	pmd = pmd_offset(pud, address);
	
	if (!pmd_present(*pmd) || pmd_trans_huge(*pmd))
		goto out;

	anon_vma_lock(vma->anon_vma);

	pte = pte_offset_map(pmd, address);
	ptl = pte_lockptr(mm, pmd);

	spin_lock(&mm->page_table_lock); 
	
	_pmd = pmdp_clear_flush_notify(vma, address, pmd);
	spin_unlock(&mm->page_table_lock);

	spin_lock(ptl);
	isolated = __collapse_huge_page_isolate(vma, address, pte);
	spin_unlock(ptl);

	if (unlikely(!isolated)) {
		pte_unmap(pte);
		spin_lock(&mm->page_table_lock);
		BUG_ON(!pmd_none(*pmd));
		set_pmd_at(mm, address, pmd, _pmd);
		spin_unlock(&mm->page_table_lock);
		anon_vma_unlock(vma->anon_vma);
		goto out;
	}

	
	anon_vma_unlock(vma->anon_vma);

	__collapse_huge_page_copy(pte, new_page, vma, address, ptl);
	pte_unmap(pte);
	__SetPageUptodate(new_page);
	pgtable = pmd_pgtable(_pmd);
	VM_BUG_ON(page_count(pgtable) != 1);
	VM_BUG_ON(page_mapcount(pgtable) != 0);

	_pmd = mk_pmd(new_page, vma->vm_page_prot);
	_pmd = maybe_pmd_mkwrite(pmd_mkdirty(_pmd), vma);
	_pmd = pmd_mkhuge(_pmd);

	
	smp_wmb();

	spin_lock(&mm->page_table_lock);
	BUG_ON(!pmd_none(*pmd));
	page_add_new_anon_rmap(new_page, vma, address);
	set_pmd_at(mm, address, pmd, _pmd);
	update_mmu_cache(vma, address, entry);
	prepare_pmd_huge_pte(pgtable, mm);
	mm->nr_ptes--;
	spin_unlock(&mm->page_table_lock);

#ifndef CONFIG_NUMA
	*hpage = NULL;
#endif
	khugepaged_pages_collapsed++;
out_up_write:
	up_write(&mm->mmap_sem);
	return;

out:
	mem_cgroup_uncharge_page(new_page);
#ifdef CONFIG_NUMA
	put_page(new_page);
#endif
	goto out_up_write;
}
","1. unsigned long address,
struct page **hpage,
2. pgd_t *pgd;
3. int isolated;
4. (vma->vm_flags & VM_NOHUGEPAGE))
goto out;
5. goto out;
if (is_vma_temporary_stack(vma))
6. goto out;
7. anon_vma_lock(vma->anon_vma);
8. pte = pte_offset_map(pmd, address);
9. anon_vma_unlock(vma->anon_vma);
10. __collapse_huge_page_copy(pte, new_page, vma, address, ptl);
11. _pmd = mk_pmd(new_page, vma->vm_page_prot);
12. BUG_ON(!pmd_none(*pmd));
13. out_up_write:
up_write(&mm->mmap_sem);
14. goto out_up_write;","2-3
7
14
72-73
76-77
87
98
100
123
133
140
152
164-165
173","CWE-20,CWE-125,CWE-399,CWE-119"
archive_read_format_cpio_read_header,"archive_read_format_cpio_read_header(struct archive_read *a,
    struct archive_entry *entry)
{
	struct cpio *cpio;
	const void *h;
	struct archive_string_conv *sconv;
	size_t namelength;
	size_t name_pad;
	int r;

	cpio = (struct cpio *)(a->format->data);
	sconv = cpio->opt_sconv;
	if (sconv == NULL) {
		if (!cpio->init_default_conversion) {
			cpio->sconv_default =
			    archive_string_default_conversion_for_read(
			      &(a->archive));
			cpio->init_default_conversion = 1;
		}
		sconv = cpio->sconv_default;
	}
	
	r = (cpio->read_header(a, cpio, entry, &namelength, &name_pad));

	if (r < ARCHIVE_WARN)
		return (r);

	
	h = __archive_read_ahead(a, namelength + name_pad, NULL);
	if (h == NULL)
	    return (ARCHIVE_FATAL);
	if (archive_entry_copy_pathname_l(entry,
	    (const char *)h, namelength, sconv) != 0) {
		if (errno == ENOMEM) {
			archive_set_error(&a->archive, ENOMEM,
			    ""Can't allocate memory for Pathname"");
			return (ARCHIVE_FATAL);
		}
		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Pathname can't be converted from %s to current locale."",
		    archive_string_conversion_charset_name(sconv));
		r = ARCHIVE_WARN;
	}
	cpio->entry_offset = 0;

	__archive_read_consume(a, namelength + name_pad);
 
 	
 	if (archive_entry_filetype(entry) == AE_IFLNK) {
		if (cpio->entry_bytes_remaining > 1024 * 1024) {
			archive_set_error(&a->archive, ENOMEM,
			    ""Rejecting malformed cpio archive: symlink contents exceed 1 megabyte"");
			return (ARCHIVE_FATAL);
		}
 		h = __archive_read_ahead(a,
 			(size_t)cpio->entry_bytes_remaining, NULL);
 		if (h == NULL)
			return (ARCHIVE_FATAL);
		if (archive_entry_copy_symlink_l(entry, (const char *)h,
		    (size_t)cpio->entry_bytes_remaining, sconv) != 0) {
			if (errno == ENOMEM) {
				archive_set_error(&a->archive, ENOMEM,
				    ""Can't allocate memory for Linkname"");
				return (ARCHIVE_FATAL);
			}
			archive_set_error(&a->archive,
			    ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Linkname can't be converted from %s to ""
			    ""current locale."",
			    archive_string_conversion_charset_name(sconv));
			r = ARCHIVE_WARN;
		}
		__archive_read_consume(a, cpio->entry_bytes_remaining);
		cpio->entry_bytes_remaining = 0;
	}

	

	
	if (namelength == 11 && strcmp((const char *)h, ""TRAILER!!!"") == 0) {
		
		archive_clear_error(&a->archive);
		return (ARCHIVE_EOF);
	}

	
	if (record_hardlink(a, cpio, entry) != ARCHIVE_OK) {
		return (ARCHIVE_FATAL);
	}

	return (r);
}
","1. struct archive_entry *entry)
2. if (sconv == NULL) {
3. cpio->sconv_default =
4. archive_string_conversion_charset_name(sconv));","2
13
15
70","CWE-190,CWE-400,CWE-284,CWE-835"
handle_spawn_1-269300774606340,"
#define GDBusMethodInvocation
#define GUnixFDList
#define GVariant
#define PortalFlatpak

static gboolean
handle_spawn_1 (PortalFlatpak         *object,
              GDBusMethodInvocation *invocation,
              GUnixFDList           *fd_list,
              const gchar           *arg_cwd_path,
              const gchar *const    *arg_argv,
              GVariant              *arg_fds,
              GVariant              *arg_envs,
              guint                  arg_flags,
              GVariant              *arg_options)
{
  g_autoptr(GError) error = NULL;
  ChildSetupData child_setup_data = { NULL };
  GPid pid;
  PidData *pid_data;
  InstanceIdReadData *instance_id_read_data = NULL;
  gsize i, j, n_fds, n_envs;
  const gint *fds = NULL;
  gint fds_len = 0;
  g_autofree FdMapEntry *fd_map = NULL;
  gchar **env;
  gint32 max_fd;
  GKeyFile *app_info;
  g_autoptr(GPtrArray) flatpak_argv = g_ptr_array_new_with_free_func (g_free);
  g_autofree char *app_id = NULL;
  g_autofree char *branch = NULL;
  g_autofree char *arch = NULL;
  g_autofree char *app_commit = NULL;
  g_autofree char *runtime_ref = NULL;
  g_auto(GStrv) runtime_parts = NULL;
  g_autofree char *runtime_commit = NULL;
  g_autofree char *instance_path = NULL;
  g_auto(GStrv) extra_args = NULL;
  g_auto(GStrv) shares = NULL;
  g_auto(GStrv) sockets = NULL;
  g_auto(GStrv) devices = NULL;
  g_auto(GStrv) sandbox_expose = NULL;
  g_auto(GStrv) sandbox_expose_ro = NULL;
  g_autoptr(GVariant) sandbox_expose_fd = NULL;
  g_autoptr(GVariant) sandbox_expose_fd_ro = NULL;
  g_autoptr(GOutputStream) instance_id_out_stream = NULL;
  guint sandbox_flags = 0;
  gboolean sandboxed;
  gboolean expose_pids;
  gboolean share_pids;
  gboolean notify_start;
  gboolean devel;
  g_autoptr(GString) env_string = g_string_new ("""");

  child_setup_data.instance_id_fd = -1;
  child_setup_data.env_fd = -1;

  if (fd_list != NULL)
    fds = g_unix_fd_list_peek_fds (fd_list, &fds_len);

  app_info = g_object_get_data (G_OBJECT (invocation), ""app-info"");
  g_assert (app_info != NULL);

  app_id = g_key_file_get_string (app_info,
                                  FLATPAK_METADATA_GROUP_APPLICATION,
                                  FLATPAK_METADATA_KEY_NAME, NULL);
  g_assert (app_id != NULL);

  g_debug (""spawn() called from app: '%s'"", app_id);
  if (*app_id == 0)
    {
      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,
                                             G_DBUS_ERROR_INVALID_ARGS,
                                             ""org.freedesktop.portal.Flatpak.Spawn only works in a flatpak"");
      return G_DBUS_METHOD_INVOCATION_HANDLED;
    }

  if (*arg_cwd_path == 0)
    arg_cwd_path = NULL;

  if (arg_argv == NULL || *arg_argv == NULL)
    {
      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,
                                             G_DBUS_ERROR_INVALID_ARGS,
                                             ""No command given"");
      return G_DBUS_METHOD_INVOCATION_HANDLED;
    }

  if ((arg_flags & ~FLATPAK_SPAWN_FLAGS_ALL) != 0)
    {
      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS,
                                             ""Unsupported flags enabled: 0x%x"", arg_flags & ~FLATPAK_SPAWN_FLAGS_ALL);
      return G_DBUS_METHOD_INVOCATION_HANDLED;
    }

  runtime_ref = g_key_file_get_string (app_info,
                                       FLATPAK_METADATA_GROUP_APPLICATION,
                                       FLATPAK_METADATA_KEY_RUNTIME, NULL);
  if (runtime_ref == NULL)
    {
      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS,
                                             ""No runtime found"");
      return G_DBUS_METHOD_INVOCATION_HANDLED;
    }

  runtime_parts = g_strsplit (runtime_ref, ""/"", -1);

  branch = g_key_file_get_string (app_info,
                                  FLATPAK_METADATA_GROUP_INSTANCE,
                                  FLATPAK_METADATA_KEY_BRANCH, NULL);
  instance_path = g_key_file_get_string (app_info,
                                         FLATPAK_METADATA_GROUP_INSTANCE,
                                         FLATPAK_METADATA_KEY_INSTANCE_PATH, NULL);
  arch = g_key_file_get_string (app_info,
                                FLATPAK_METADATA_GROUP_INSTANCE,
                                FLATPAK_METADATA_KEY_ARCH, NULL);
  extra_args = g_key_file_get_string_list (app_info,
                                           FLATPAK_METADATA_GROUP_INSTANCE,
                                           FLATPAK_METADATA_KEY_EXTRA_ARGS, NULL, NULL);
  app_commit = g_key_file_get_string (app_info,
                                      FLATPAK_METADATA_GROUP_INSTANCE,
                                      FLATPAK_METADATA_KEY_APP_COMMIT, NULL);
  runtime_commit = g_key_file_get_string (app_info,
                                          FLATPAK_METADATA_GROUP_INSTANCE,
                                          FLATPAK_METADATA_KEY_RUNTIME_COMMIT, NULL);
  shares = g_key_file_get_string_list (app_info, FLATPAK_METADATA_GROUP_CONTEXT,
                                       FLATPAK_METADATA_KEY_SHARED, NULL, NULL);
  sockets = g_key_file_get_string_list (app_info, FLATPAK_METADATA_GROUP_CONTEXT,
                                       FLATPAK_METADATA_KEY_SOCKETS, NULL, NULL);
  devices = g_key_file_get_string_list (app_info, FLATPAK_METADATA_GROUP_CONTEXT,
                                        FLATPAK_METADATA_KEY_DEVICES, NULL, NULL);

  devel = g_key_file_get_boolean (app_info, FLATPAK_METADATA_GROUP_INSTANCE,
                                  FLATPAK_METADATA_KEY_DEVEL, NULL);

  g_variant_lookup (arg_options, ""sandbox-expose"", ""^as"", &sandbox_expose);
  g_variant_lookup (arg_options, ""sandbox-expose-ro"", ""^as"", &sandbox_expose_ro);
  g_variant_lookup (arg_options, ""sandbox-flags"", ""u"", &sandbox_flags);
  sandbox_expose_fd = g_variant_lookup_value (arg_options, ""sandbox-expose-fd"", G_VARIANT_TYPE (""ah""));
  sandbox_expose_fd_ro = g_variant_lookup_value (arg_options, ""sandbox-expose-fd-ro"", G_VARIANT_TYPE (""ah""));

  if ((sandbox_flags & ~FLATPAK_SPAWN_SANDBOX_FLAGS_ALL) != 0)
    {
      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS,
                                             ""Unsupported sandbox flags enabled: 0x%x"", arg_flags & ~FLATPAK_SPAWN_SANDBOX_FLAGS_ALL);
      return G_DBUS_METHOD_INVOCATION_HANDLED;
    }

  if (instance_path == NULL &&
      ((sandbox_expose != NULL && sandbox_expose[0] != NULL) ||
       (sandbox_expose_ro != NULL && sandbox_expose_ro[0] != NULL)))
    {
      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,
                                             G_DBUS_ERROR_INVALID_ARGS,
                                             ""Invalid sandbox expose, caller has no instance path"");
      return G_DBUS_METHOD_INVOCATION_HANDLED;
    }

  for (i = 0; sandbox_expose != NULL && sandbox_expose[i] != NULL; i++)
    {
      const char *expose = sandbox_expose[i];

      g_debug (""exposing %s"", expose);
      if (!is_valid_expose (expose, &error))
        {
          g_dbus_method_invocation_return_gerror (invocation, error);
          return G_DBUS_METHOD_INVOCATION_HANDLED;
        }
    }

  for (i = 0; sandbox_expose_ro != NULL && sandbox_expose_ro[i] != NULL; i++)
    {
      const char *expose = sandbox_expose_ro[i];
      g_debug (""exposing %s"", expose);
      if (!is_valid_expose (expose, &error))
        {
          g_dbus_method_invocation_return_gerror (invocation, error);
          return G_DBUS_METHOD_INVOCATION_HANDLED;
        }
    }

  g_debug (""Running spawn command %s"", arg_argv[0]);

  n_fds = 0;
  if (fds != NULL)
    n_fds = g_variant_n_children (arg_fds);
  fd_map = g_new0 (FdMapEntry, n_fds);

  child_setup_data.fd_map = fd_map;
  child_setup_data.fd_map_len = n_fds;

  max_fd = -1;
  for (i = 0; i < n_fds; i++)
    {
      gint32 handle, dest_fd;
      int handle_fd;

      g_variant_get_child (arg_fds, i, ""{uh}"", &dest_fd, &handle);

      if (handle >= fds_len || handle < 0)
        {
          g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,
                                                 G_DBUS_ERROR_INVALID_ARGS,
                                                 ""No file descriptor for handle %d"",
                                                 handle);
          return G_DBUS_METHOD_INVOCATION_HANDLED;
        }

      handle_fd = fds[handle];

      fd_map[i].to = dest_fd;
      fd_map[i].from = handle_fd;
      fd_map[i].final = fd_map[i].to;

      
      if ((dest_fd == 0 || dest_fd == 1 || dest_fd == 2) &&
          !child_setup_data.set_tty &&
          isatty (handle_fd))
        {
          child_setup_data.set_tty = TRUE;
          child_setup_data.tty = handle_fd;
        }

      max_fd = MAX (max_fd, fd_map[i].to);
      max_fd = MAX (max_fd, fd_map[i].from);
    }

  
  for (i = 0; i < n_fds; i++)
    {
      int to_fd = fd_map[i].to;
      gboolean conflict = FALSE;

      
      for (j = i + 1; j < n_fds; j++)
        {
          int from_fd = fd_map[j].from;
          if (from_fd == to_fd)
            {
              conflict = TRUE;
              break;
            }
        }

      if (conflict)
        fd_map[i].to = ++max_fd;
    }

  if (arg_flags & FLATPAK_SPAWN_FLAGS_CLEAR_ENV)
    {
      char *empty[] = { NULL };
      env = g_strdupv (empty);
    }
  else
    env = g_get_environ ();

  
  n_envs = g_variant_n_children (arg_envs);
  for (i = 0; i < n_envs; i++)
    {
      const char *var = NULL;
      const char *val = NULL;
      g_variant_get_child (arg_envs, i, ""{&s&s}"", &var, &val);

      if (var[0] == '\0')
        {
          g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,
                                                 G_DBUS_ERROR_INVALID_ARGS,
                                                 ""Environment variable cannot have empty name"");
          return G_DBUS_METHOD_INVOCATION_HANDLED;
        }

      if (strchr (var, '=') != NULL)
        {
          g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,
                                                 G_DBUS_ERROR_INVALID_ARGS,
                                                 ""Environment variable name cannot contain '='"");
          return G_DBUS_METHOD_INVOCATION_HANDLED;
        }

      g_string_append (env_string, var);
      g_string_append_c (env_string, '=');
      g_string_append (env_string, val);
      g_string_append_c (env_string, '\0');
    }

  g_ptr_array_add (flatpak_argv, g_strdup (""flatpak""));
  g_ptr_array_add (flatpak_argv, g_strdup (""run""));

  sandboxed = (arg_flags & FLATPAK_SPAWN_FLAGS_SANDBOX) != 0;

  if (sandboxed)
    {
      g_ptr_array_add (flatpak_argv, g_strdup (""--sandbox""));

      if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_SHARE_DISPLAY)
        {
          if (sockets != NULL && g_strv_contains ((const char * const *) sockets, ""wayland""))
            g_ptr_array_add (flatpak_argv, g_strdup (""--socket=wayland""));
          if (sockets != NULL && g_strv_contains ((const char * const *) sockets, ""fallback-x11""))
            g_ptr_array_add (flatpak_argv, g_strdup (""--socket=fallback-x11""));
          if (sockets != NULL && g_strv_contains ((const char * const *) sockets, ""x11""))
            g_ptr_array_add (flatpak_argv, g_strdup (""--socket=x11""));
          if (shares != NULL && g_strv_contains ((const char * const *) shares, ""ipc"") &&
              sockets != NULL && (g_strv_contains ((const char * const *) sockets, ""fallback-x11"") ||
                                  g_strv_contains ((const char * const *) sockets, ""x11"")))
            g_ptr_array_add (flatpak_argv, g_strdup (""--share=ipc""));
        }
      if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_SHARE_SOUND)
        {
          if (sockets != NULL && g_strv_contains ((const char * const *) sockets, ""pulseaudio""))
            g_ptr_array_add (flatpak_argv, g_strdup (""--socket=pulseaudio""));
        }
      if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_SHARE_GPU)
        {
          if (devices != NULL &&
              (g_strv_contains ((const char * const *) devices, ""dri"") ||
               g_strv_contains ((const char * const *) devices, ""all"")))
            g_ptr_array_add (flatpak_argv, g_strdup (""--device=dri""));
        }
      if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_ALLOW_DBUS)
        g_ptr_array_add (flatpak_argv, g_strdup (""--session-bus""));
      if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_ALLOW_A11Y)
        g_ptr_array_add (flatpak_argv, g_strdup (""--a11y-bus""));
    }
  else
    {
      for (i = 0; extra_args != NULL && extra_args[i] != NULL; i++)
        {
          if (g_str_has_prefix (extra_args[i], ""--env=""))
            {
              const char *var_val = extra_args[i] + strlen (""--env="");

              if (var_val[0] == '\0' || var_val[0] == '=')
                {
                  g_warning (""Environment variable in extra-args has empty name"");
                  continue;
                }

              if (strchr (var_val, '=') == NULL)
                {
                  g_warning (""Environment variable in extra-args has no value"");
                  continue;
                }

              g_string_append (env_string, var_val);
              g_string_append_c (env_string, '\0');
            }
          else
            {
              g_ptr_array_add (flatpak_argv, g_strdup (extra_args[i]));
            }
        }
    }

  if (env_string->len > 0)
    {
      g_auto(GLnxTmpfile) env_tmpf  = { 0, };

      if (!flatpak_buffer_to_sealed_memfd_or_tmpfile (&env_tmpf, ""environ"",
                                                      env_string->str,
                                                      env_string->len, &error))
        {
          g_dbus_method_invocation_return_gerror (invocation, error);
          return G_DBUS_METHOD_INVOCATION_HANDLED;
        }

      child_setup_data.env_fd = glnx_steal_fd (&env_tmpf.fd);
      g_ptr_array_add (flatpak_argv,
                       g_strdup_printf (""--env-fd=%d"",
                                        child_setup_data.env_fd));
    }

  expose_pids = (arg_flags & FLATPAK_SPAWN_FLAGS_EXPOSE_PIDS) != 0;
  share_pids = (arg_flags & FLATPAK_SPAWN_FLAGS_SHARE_PIDS) != 0;

  if (expose_pids || share_pids)
    {
      g_autofree char *instance_id = NULL;
      int sender_pid1 = 0;

      if (!(supports & FLATPAK_SPAWN_SUPPORT_FLAGS_EXPOSE_PIDS))
        {
          g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,
                                                 G_DBUS_ERROR_NOT_SUPPORTED,
                                                 ""Expose pids not supported with setuid bwrap"");
          return G_DBUS_METHOD_INVOCATION_HANDLED;
        }

      instance_id = g_key_file_get_string (app_info,
                                           FLATPAK_METADATA_GROUP_INSTANCE,
                                           FLATPAK_METADATA_KEY_INSTANCE_ID, NULL);

      if (instance_id)
        {
          g_autoptr(FlatpakInstance) instance = flatpak_instance_new_for_id (instance_id);
          sender_pid1 = flatpak_instance_get_child_pid (instance);
        }

      if (sender_pid1 == 0)
        {
          g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,
                                                 G_DBUS_ERROR_INVALID_ARGS,
                                                 ""Could not find requesting pid"");
          return G_DBUS_METHOD_INVOCATION_HANDLED;
        }

      g_ptr_array_add (flatpak_argv, g_strdup_printf (""--parent-pid=%d"", sender_pid1));

      if (share_pids)
        g_ptr_array_add (flatpak_argv, g_strdup (""--parent-share-pids""));
      else
        g_ptr_array_add (flatpak_argv, g_strdup (""--parent-expose-pids""));
    }

  notify_start = (arg_flags & FLATPAK_SPAWN_FLAGS_NOTIFY_START) != 0;
  if (notify_start)
    {
      int pipe_fds[2];
      if (pipe (pipe_fds) == -1)
        {
          int errsv = errno;
          g_dbus_method_invocation_return_error (invocation, G_IO_ERROR,
                                                 g_io_error_from_errno (errsv),
                                                 ""Failed to create instance ID pipe: %s"",
                                                 g_strerror (errsv));
          return G_DBUS_METHOD_INVOCATION_HANDLED;
        }

      GInputStream *in_stream = G_INPUT_STREAM (g_unix_input_stream_new (pipe_fds[0], TRUE));
      
      instance_id_out_stream = G_OUTPUT_STREAM (g_unix_output_stream_new (pipe_fds[1], TRUE));

      instance_id_read_data = g_new0 (InstanceIdReadData, 1);

      g_input_stream_read_async (in_stream, instance_id_read_data->buffer,
                                 INSTANCE_ID_BUFFER_SIZE - 1, G_PRIORITY_DEFAULT, NULL,
                                 instance_id_read_finish, instance_id_read_data);

      g_ptr_array_add (flatpak_argv, g_strdup_printf (""--instance-id-fd=%d"", pipe_fds[1]));
      child_setup_data.instance_id_fd = pipe_fds[1];
    }

  if (devel)
    g_ptr_array_add (flatpak_argv, g_strdup (""--devel""));

  
  if (shares != NULL && g_strv_contains ((const char * const *) shares, ""network"") &&
      !(arg_flags & FLATPAK_SPAWN_FLAGS_NO_NETWORK))
    g_ptr_array_add (flatpak_argv, g_strdup (""--share=network""));
  else
    g_ptr_array_add (flatpak_argv, g_strdup (""--unshare=network""));


  if (instance_path)
    {
      for (i = 0; sandbox_expose != NULL && sandbox_expose[i] != NULL; i++)
        g_ptr_array_add (flatpak_argv,
                         filesystem_sandbox_arg (instance_path, sandbox_expose[i], FALSE));
      for (i = 0; sandbox_expose_ro != NULL && sandbox_expose_ro[i] != NULL; i++)
        g_ptr_array_add (flatpak_argv,
                         filesystem_sandbox_arg (instance_path, sandbox_expose_ro[i], TRUE));
    }

  for (i = 0; sandbox_expose_ro != NULL && sandbox_expose_ro[i] != NULL; i++)
    {
      const char *expose = sandbox_expose_ro[i];
      g_debug (""exposing %s"", expose);
    }

  if (sandbox_expose_fd != NULL)
    {
      gsize len = g_variant_n_children (sandbox_expose_fd);
      for (i = 0; i < len; i++)
        {
          gint32 handle;
          g_variant_get_child (sandbox_expose_fd, i, ""h"", &handle);
          if (handle >= 0 && handle < fds_len)
            {
              int handle_fd = fds[handle];
              g_autofree char *path = NULL;
              gboolean writable = FALSE;

              path = get_path_for_fd (handle_fd, &writable, &error);

              if (path)
                {
                  g_ptr_array_add (flatpak_argv, filesystem_arg (path, !writable));
                }
              else
                {
                  g_debug (""unable to get path for sandbox-exposed fd %d, ignoring: %s"",
                           handle_fd, error->message);
                  g_clear_error (&error);
                }
            }
          else
            {
              g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,
                                                     G_DBUS_ERROR_INVALID_ARGS,
                                                     ""No file descriptor for handle %d"",
                                                     handle);
              return G_DBUS_METHOD_INVOCATION_HANDLED;
            }
        }
    }

  if (sandbox_expose_fd_ro != NULL)
    {
      gsize len = g_variant_n_children (sandbox_expose_fd_ro);
      for (i = 0; i < len; i++)
        {
          gint32 handle;
          g_variant_get_child (sandbox_expose_fd_ro, i, ""h"", &handle);
          if (handle >= 0 && handle < fds_len)
            {
              int handle_fd = fds[handle];
              g_autofree char *path = NULL;
              gboolean writable = FALSE;

              path = get_path_for_fd (handle_fd, &writable, &error);

              if (path)
                {
                  g_ptr_array_add (flatpak_argv, filesystem_arg (path, TRUE));
                }
              else
                {
                  g_debug (""unable to get path for sandbox-exposed fd %d, ignoring: %s"",
                           handle_fd, error->message);
                  g_clear_error (&error);
                }
            }
          else
            {
              g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,
                                                     G_DBUS_ERROR_INVALID_ARGS,
                                                     ""No file descriptor for handle %d"",
                                                     handle);
              return G_DBUS_METHOD_INVOCATION_HANDLED;
            }
        }
    }

  g_ptr_array_add (flatpak_argv, g_strdup_printf (""--runtime=%s"", runtime_parts[1]));
  g_ptr_array_add (flatpak_argv, g_strdup_printf (""--runtime-version=%s"", runtime_parts[3]));

  if ((arg_flags & FLATPAK_SPAWN_FLAGS_LATEST_VERSION) == 0)
    {
      if (app_commit)
        g_ptr_array_add (flatpak_argv, g_strdup_printf (""--commit=%s"", app_commit));
      if (runtime_commit)
        g_ptr_array_add (flatpak_argv, g_strdup_printf (""--runtime-commit=%s"", runtime_commit));
    }

  if (arg_cwd_path != NULL)
    g_ptr_array_add (flatpak_argv, g_strdup_printf (""--cwd=%s"", arg_cwd_path));

  if (arg_argv[0][0] != 0)
    g_ptr_array_add (flatpak_argv, g_strdup_printf (""--command=%s"", arg_argv[0]));

  g_ptr_array_add (flatpak_argv, g_strdup_printf (""%s/%s/%s"", app_id, arch ? arch : """", branch ? branch : """"));
  for (i = 1; arg_argv[i] != NULL; i++)
    g_ptr_array_add (flatpak_argv, g_strdup (arg_argv[i]));
  g_ptr_array_add (flatpak_argv, NULL);

  if (opt_verbose)
    {
      g_autoptr(GString) cmd = g_string_new ("""");

      for (i = 0; flatpak_argv->pdata[i] != NULL; i++)
        {
          if (i > 0)
            g_string_append (cmd, "" "");
          g_string_append (cmd, flatpak_argv->pdata[i]);
        }

      g_debug (""Starting: %s\n"", cmd->str);
    }

  
  if (!g_spawn_async_with_pipes (NULL,
                                 (char **) flatpak_argv->pdata,
                                 env,
                                 G_SPAWN_SEARCH_PATH | G_SPAWN_DO_NOT_REAP_CHILD | G_SPAWN_LEAVE_DESCRIPTORS_OPEN,
                                 child_setup_func, &child_setup_data,
                                 &pid,
                                 NULL,
                                 NULL,
                                 NULL,
                                 &error))
    {
      gint code = G_DBUS_ERROR_FAILED;
      if (g_error_matches (error, G_SPAWN_ERROR, G_SPAWN_ERROR_ACCES))
        code = G_DBUS_ERROR_ACCESS_DENIED;
      else if (g_error_matches (error, G_SPAWN_ERROR, G_SPAWN_ERROR_NOENT))
        code = G_DBUS_ERROR_FILE_NOT_FOUND;
      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, code,
                                             ""Failed to start command: %s"",
                                             error->message);
      return G_DBUS_METHOD_INVOCATION_HANDLED;
    }

  if (instance_id_read_data)
    instance_id_read_data->pid = pid;

  pid_data = g_new0 (PidData, 1);
  pid_data->pid = pid;
  pid_data->client = g_strdup (g_dbus_method_invocation_get_sender (invocation));
  pid_data->watch_bus = (arg_flags & FLATPAK_SPAWN_FLAGS_WATCH_BUS) != 0;
  pid_data->expose_or_share_pids = (expose_pids || share_pids);
  pid_data->child_watch = g_child_watch_add_full (G_PRIORITY_DEFAULT,
                                                  pid,
                                                  child_watch_died,
                                                  pid_data,
                                                  NULL);

  g_debug (""Client Pid is %d"", pid_data->pid);

  g_hash_table_replace (client_pid_data_hash, GUINT_TO_POINTER (pid_data->pid),
                        pid_data);

  portal_flatpak_complete_spawn (object, invocation, NULL, pid);
  return G_DBUS_METHOD_INVOCATION_HANDLED;
}
","1. const gchar *const    *arg_argv,
2. g_auto(GStrv) runtime_parts = NULL;
3. g_autofree char *instance_path = NULL;
4. g_autoptr(GString) env_string = g_string_new ("""");
5. FLATPAK_METADATA_GROUP_APPLICATION,
6. if (*app_id == 0)
7. FLATPAK_METADATA_KEY_RUNTIME, NULL);
8. FLATPAK_METADATA_GROUP_INSTANCE,
9. if (instance_path == NULL &&
((sandbox_expose != NULL && sandbox_expose[0] != NULL) ||
10. ""Invalid sandbox expose, caller has no instance path"");
11. g_dbus_method_invocation_return_gerror (invocation, error);
12. fd_map[i].final = fd_map[i].to;
13. n_envs = g_variant_n_children (arg_envs);
14. ""Environment variable name cannot contain '='"");
15. g_string_append_c (env_string, '=');
g_string_append (env_string, val);
16. if (shares != NULL && g_strv_contains ((const char * const *) shares, ""ipc"") &&
17. if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_SHARE_SOUND)
18. if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_SHARE_GPU)
19. g_autofree char *instance_id = NULL;
20. instance_id_out_stream = G_OUTPUT_STREAM (g_unix_output_stream_new (pipe_fds[1], TRUE));
21. child_setup_data.instance_id_fd = pipe_fds[1];
22. if (devel)
g_ptr_array_add (flatpak_argv, g_strdup (""--devel""));
23. if (shares != NULL && g_strv_contains ((const char * const *) shares, ""network"") &&
24. if (instance_path)
25. g_debug (""exposing %s"", expose);
26. if (path)
27. {
28. return G_DBUS_METHOD_INVOCATION_HANDLED;
29. g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,
30. g_ptr_array_add (flatpak_argv, g_strdup (arg_argv[i]));
31. G_SPAWN_SEARCH_PATH | G_SPAWN_DO_NOT_REAP_CHILD | G_SPAWN_LEAVE_DESCRIPTORS_OPEN,
32. code = G_DBUS_ERROR_ACCESS_DENIED;
33. g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, code,
34. if (instance_id_read_data)","12
36
38
54
66
71
99
116
150-151
156
167
214
273
292
297-298
319
324
329
394
447
456
459-460
464
471
484
502
514
519
552
580
601
611
614
620","CWE-362,CWE-20,CWE-17"
pretty_print_packet-42273775877792,"void
pretty_print_packet(netdissect_options *ndo, const struct pcap_pkthdr *h,
		    const u_char *sp, u_int packets_captured)
{
	u_int hdrlen = 0;
	int invalid_header = 0;

	if (ndo->ndo_print_sampling && packets_captured % ndo->ndo_print_sampling != 0)
		return;

#ifdef ENABLE_INSTRUMENT_FUNCTIONS
	if (pretty_print_packet_level == -1)
		pretty_print_packet_level = profile_func_level;
#endif

	if (ndo->ndo_packet_number)
		ND_PRINT(""%5u  "", packets_captured);

	if (ndo->ndo_lengths)
		ND_PRINT(""caplen %u len %u "", h->caplen, h->len);

	
	if (h->caplen == 0) {
		invalid_header = 1;
		ND_PRINT(""[Invalid header: caplen==0"");
	}
	if (h->len == 0) {
		if (!invalid_header) {
			invalid_header = 1;
			ND_PRINT(""[Invalid header:"");
		} else
			ND_PRINT("","");
		ND_PRINT("" len==0"");
	} else if (h->len < h->caplen) {
		if (!invalid_header) {
			invalid_header = 1;
			ND_PRINT(""[Invalid header:"");
		} else
			ND_PRINT("","");
		ND_PRINT("" len(%u) < caplen(%u)"", h->len, h->caplen);
	}
	if (h->caplen > MAXIMUM_SNAPLEN) {
		if (!invalid_header) {
			invalid_header = 1;
			ND_PRINT(""[Invalid header:"");
		} else
			ND_PRINT("","");
		ND_PRINT("" caplen(%u) > %u"", h->caplen, MAXIMUM_SNAPLEN);
	}
	if (h->len > MAXIMUM_SNAPLEN) {
		if (!invalid_header) {
			invalid_header = 1;
			ND_PRINT(""[Invalid header:"");
		} else
			ND_PRINT("","");
		ND_PRINT("" len(%u) > %u"", h->len, MAXIMUM_SNAPLEN);
	}
	if (invalid_header) {
		ND_PRINT(""]\n"");
		return;
	}

	

	
	struct timeval tvbuf;
	tvbuf.tv_sec = h->ts.tv_sec;
	tvbuf.tv_usec = h->ts.tv_usec;
	ts_print(ndo, &tvbuf);

	
	ndo->ndo_snapend = sp + h->caplen;
	ndo->ndo_packetp = sp;

	ndo->ndo_protocol = """";
	ndo->ndo_ll_hdr_len = 0;
	switch (setjmp(ndo->ndo_early_end)) {
	case 0:
		
		(ndo->ndo_if_printer)(ndo, h, sp);
		break;
	case ND_TRUNCATED:
		
		nd_print_trunc(ndo);
		
		ndo->ndo_ll_hdr_len = 0;
#ifdef ENABLE_INSTRUMENT_FUNCTIONS
		
		profile_func_level = pretty_print_packet_level;
#endif
		break;
	}
	hdrlen = ndo->ndo_ll_hdr_len;

	
	nd_pop_all_packet_info(ndo);

	
	ndo->ndo_snapend = sp + h->caplen;
	ndo->ndo_packetp = sp;
	if (ndo->ndo_Xflag) {
		
		if (ndo->ndo_Xflag > 1) {
			
			hex_and_ascii_print(ndo, ""\n\t"", sp, h->caplen);
		} else {
			
			if (h->caplen > hdrlen)
				hex_and_ascii_print(ndo, ""\n\t"", sp + hdrlen,
						    h->caplen - hdrlen);
		}
	} else if (ndo->ndo_xflag) {
		
		if (ndo->ndo_xflag > 1) {
			
			hex_print(ndo, ""\n\t"", sp, h->caplen);
		} else {
			
			if (h->caplen > hdrlen)
				hex_print(ndo, ""\n\t"", sp + hdrlen,
					  h->caplen - hdrlen);
		}
	} else if (ndo->ndo_Aflag) {
		
		if (ndo->ndo_Aflag > 1) {
			
			ascii_print(ndo, sp, h->caplen);
		} else {
			
			if (h->caplen > hdrlen)
				ascii_print(ndo, sp + hdrlen, h->caplen - hdrlen);
		}
	}

	ND_PRINT(""\n"");
	nd_free_all(ndo);
}
","1. ts_print(ndo, &tvbuf);",84,"CWE-269,CWE-189,CWE-200,CWE-119,CWE-125"
update_open_stateid-96093297386335,"static int update_open_stateid(struct nfs4_state *state, nfs4_stateid *open_stateid, nfs4_stateid *delegation, fmode_t fmode)
{
	struct nfs_inode *nfsi = NFS_I(state->inode);
	struct nfs_delegation *deleg_cur;
	int ret = 0;

	fmode &= (FMODE_READ|FMODE_WRITE);

	rcu_read_lock();
	deleg_cur = rcu_dereference(nfsi->delegation);
	if (deleg_cur == NULL)
		goto no_delegation;

	spin_lock(&deleg_cur->lock);
	if (nfsi->delegation != deleg_cur ||
	    (deleg_cur->type & fmode) != fmode)
		goto no_delegation_unlock;

	if (delegation == NULL)
		delegation = &deleg_cur->stateid;
	else if (memcmp(deleg_cur->stateid.data, delegation->data, NFS4_STATEID_SIZE) != 0)
		goto no_delegation_unlock;

	nfs_mark_delegation_referenced(deleg_cur);
	__update_open_stateid(state, open_stateid, &deleg_cur->stateid, fmode);
	ret = 1;
no_delegation_unlock:
	spin_unlock(&deleg_cur->lock);
no_delegation:
	rcu_read_unlock();

	if (!ret && open_stateid != NULL) {
		__update_open_stateid(state, open_stateid, NULL, fmode);
		ret = 1;
	}

	return ret;
}
","1. static int update_open_stateid(struct nfs4_state *state, nfs4_stateid *open_stateid, nfs4_stateid *delegation, fmode_t fmode)
2. int ret = 0;
3. spin_lock(&deleg_cur->lock);
4. if (delegation == NULL)
5. else if (memcmp(deleg_cur->stateid.data, delegation->data, NFS4_STATEID_SIZE) != 0)
6. nfs_mark_delegation_referenced(deleg_cur);
7. ret = 1;
8. no_delegation:
rcu_read_unlock();
9. ret = 1;","1
5
14
19
21
24
26
29-30
34","CWE-20,CWE-264,CWE-787,CWE-59,CWE-399"
IsHighDPIEnabled," bool IsHighDPIEnabled() {
  
  
  static DWORD value = ReadRegistryValue(
      HKEY_CURRENT_USER, kRegistryProfilePath,
      kHighDPISupportW, FALSE);
  return force_highdpi_for_testing || (value == 1);
 }
",1. return force_highdpi_for_testing || (value == 1);,7,"CWE-415,CWE-125,CWE-399,CWE-189"
do_perf_sw_event-189045741577961,"static void do_perf_sw_event(enum perf_type_id type, u32 event_id,
				    u64 nr,
				    struct perf_sample_data *data,
				    struct pt_regs *regs)
{
	struct swevent_htable *swhash = &__get_cpu_var(swevent_htable);
	struct perf_event *event;
	struct hlist_node *node;
	struct hlist_head *head;

	rcu_read_lock();
	head = find_swevent_head_rcu(swhash, type, event_id);
	if (!head)
		goto end;

	hlist_for_each_entry_rcu(event, node, head, hlist_entry) {
		if (perf_swevent_match(event, type, event_id, data, regs))
			perf_swevent_event(event, nr, data, regs);
	}
end:
	rcu_read_unlock();
}
","1. static void do_perf_sw_event(enum perf_type_id type, u32 event_id,
2. struct pt_regs *regs)
3. struct perf_event *event;
4. head = find_swevent_head_rcu(swhash, type, event_id);
5. goto end;
6. hlist_for_each_entry_rcu(event, node, head, hlist_entry) {
if (perf_swevent_match(event, type, event_id, data, regs))","1
4
7
12
14
16-17","CWE-190,CWE-200,CWE-399,CWE-119"
inet_create-179691403069162,"static int inet_create(struct net *net, struct socket *sock, int protocol,
		       int kern)
{
	struct sock *sk;
	struct inet_protosw *answer;
	struct inet_sock *inet;
	struct proto *answer_prot;
	unsigned char answer_flags;
	int try_loading_module = 0;
	int err;

	if (protocol < 0 || protocol >= IPPROTO_MAX)
		return -EINVAL;

	sock->state = SS_UNCONNECTED;

	
lookup_protocol:
	err = -ESOCKTNOSUPPORT;
	rcu_read_lock();
	list_for_each_entry_rcu(answer, &inetsw[sock->type], list) {

		err = 0;
		
		if (protocol == answer->protocol) {
			if (protocol != IPPROTO_IP)
				break;
		} else {
			
			if (IPPROTO_IP == protocol) {
				protocol = answer->protocol;
				break;
			}
			if (IPPROTO_IP == answer->protocol)
				break;
		}
		err = -EPROTONOSUPPORT;
	}

	if (unlikely(err)) {
		if (try_loading_module < 2) {
			rcu_read_unlock();
			
			if (++try_loading_module == 1)
				request_module(""net-pf-%d-proto-%d-type-%d"",
					       PF_INET, protocol, sock->type);
			
			else
				request_module(""net-pf-%d-proto-%d"",
					       PF_INET, protocol);
			goto lookup_protocol;
		} else
			goto out_rcu_unlock;
	}

	err = -EPERM;
	if (sock->type == SOCK_RAW && !kern &&
	    !ns_capable(net->user_ns, CAP_NET_RAW))
		goto out_rcu_unlock;

	sock->ops = answer->ops;
	answer_prot = answer->prot;
	answer_flags = answer->flags;
	rcu_read_unlock();

	WARN_ON(!answer_prot->slab);

	err = -ENOBUFS;
	sk = sk_alloc(net, PF_INET, GFP_KERNEL, answer_prot, kern);
	if (!sk)
		goto out;

	err = 0;
	if (INET_PROTOSW_REUSE & answer_flags)
		sk->sk_reuse = SK_CAN_REUSE;

	inet = inet_sk(sk);
	inet->is_icsk = (INET_PROTOSW_ICSK & answer_flags) != 0;

	inet->nodefrag = 0;

	if (SOCK_RAW == sock->type) {
		inet->inet_num = protocol;
		if (IPPROTO_RAW == protocol)
			inet->hdrincl = 1;
	}

	if (net->ipv4.sysctl_ip_no_pmtu_disc)
		inet->pmtudisc = IP_PMTUDISC_DONT;
	else
		inet->pmtudisc = IP_PMTUDISC_WANT;

	inet->inet_id = 0;

	sock_init_data(sock, sk);

	sk->sk_destruct	   = inet_sock_destruct;
	sk->sk_protocol	   = protocol;
	sk->sk_backlog_rcv = sk->sk_prot->backlog_rcv;

	inet->uc_ttl	= -1;
	inet->mc_loop	= 1;
	inet->mc_ttl	= 1;
	inet->mc_all	= 1;
	inet->mc_index	= 0;
	inet->mc_list	= NULL;
	inet->rcv_tos	= 0;

	sk_refcnt_debug_inc(sk);

	if (inet->inet_num) {
		
		inet->inet_sport = htons(inet->inet_num);
		
		sk->sk_prot->hash(sk);
	}

	if (sk->sk_prot->init) {
		err = sk->sk_prot->init(sk);
		if (err)
			sk_common_release(sk);
	}
out:
	return err;
out_rcu_unlock:
	rcu_read_unlock();
	goto out;
}
","1. struct sock *sk;
2. int err;
3. rcu_read_lock();
list_for_each_entry_rcu(answer, &inetsw[sock->type], list) {
4. protocol = answer->protocol;
5. if (unlikely(err)) {
if (try_loading_module < 2) {
6. if (++try_loading_module == 1)
request_module(""net-pf-%d-proto-%d-type-%d"",
7. request_module(""net-pf-%d-proto-%d"",
8. if (net->ipv4.sysctl_ip_no_pmtu_disc)
9. return err;
10. rcu_read_unlock();","4
10
20-21
31
40-41
47-48
55
94
134
136","CWE-20,CWE-416,CWE-200,CWE-125,CWE-59"
ecall_start-62337663924665,"int ecall_start(struct ecall *ecall, enum icall_call_type call_type,
		bool audio_cbr)
{
	int err;

	info(""ecall(%p): start call_type=%d cbr=%d\n"",
	     ecall, call_type, audio_cbr);

	if (!ecall)
		return EINVAL;

#ifdef ECALL_CBR_ALWAYS_ON
	audio_cbr = true;
#endif

	if (ecall->econn) {
		if (ECONN_PENDING_INCOMING == econn_current_state(ecall->econn)) {
			return ecall_answer(ecall, call_type, audio_cbr);
		}
		else {
			warning(""ecall: start: already in progress (econn=%s)\n"",
				econn_state_name(econn_current_state(ecall->econn)));
			return EALREADY;
		}
	}

#if 0
	if (ecall->turnc == 0) {
		warning(""ecall: start: no TURN servers -- cannot start\n"");
		return EINTR;
	}
#endif

	ecall->call_type = call_type;
	
	err = ecall_create_econn(ecall);
	if (err) {
		warning(""ecall: start: create_econn failed: %m\n"", err);
		return err;
	}

	econn_set_state(ecall_get_econn(ecall), ECONN_PENDING_OUTGOING);

	err = alloc_flow(ecall, ASYNC_OFFER, ecall->call_type, audio_cbr);
	if (err) {
		warning(""ecall: start: alloc_flow failed: %m\n"", err);
		goto out;
	}

	IFLOW_CALL(ecall->flow, set_audio_cbr, audio_cbr);
	
	if (ecall->props_local &&
	    (call_type == ICALL_CALL_TYPE_VIDEO
	     && ecall->vstate == ICALL_VIDEO_STATE_STARTED)) {
		const char *vstate_string = ""true"";

		int err2 = econn_props_update(ecall->props_local,
					      ""videosend"", vstate_string);
		if (err2) {
			warning(""ecall(%p): econn_props_update(videosend)"",
				"" failed (%m)\n"", ecall, err2);
			
		}
	}

	ecall->sdp.async = ASYNC_NONE;
	err = generate_offer(ecall);
	if (err) {
		warning(""ecall(%p): start: generate_offer""
			"" failed (%m)\n"", ecall, err);
		goto out;
	}

	ecall->ts_started = tmr_jiffies();
	ecall->call_setup_time = -1;

 out:
	
	return err;
}
","1. ecall, call_type, audio_cbr);
2. econn_state_name(econn_current_state(ecall->econn)));
3. ecall->call_type = call_type;
4. err = ecall_create_econn(ecall);
5. ecall->sdp.async = ASYNC_NONE;","7
22
34
36
66","CWE-119,CWE-125,CWE-400"
wilc_parse_join_bss_param-168885799343134,"void *wilc_parse_join_bss_param(struct cfg80211_bss *bss,
				struct cfg80211_crypto_settings *crypto)
{
	struct wilc_join_bss_param *param;
	struct ieee80211_p2p_noa_attr noa_attr;
	u8 rates_len = 0;
	const u8 *tim_elm, *ssid_elm, *rates_ie, *supp_rates_ie;
	const u8 *ht_ie, *wpa_ie, *wmm_ie, *rsn_ie;
	int ret;
	const struct cfg80211_bss_ies *ies = rcu_dereference(bss->ies);

	param = kzalloc(sizeof(*param), GFP_KERNEL);
	if (!param)
		return NULL;

	param->beacon_period = cpu_to_le16(bss->beacon_interval);
	param->cap_info = cpu_to_le16(bss->capability);
	param->bss_type = WILC_FW_BSS_TYPE_INFRA;
	param->ch = ieee80211_frequency_to_channel(bss->channel->center_freq);
	ether_addr_copy(param->bssid, bss->bssid);

	ssid_elm = cfg80211_find_ie(WLAN_EID_SSID, ies->data, ies->len);
	if (ssid_elm) {
		if (ssid_elm[1] <= IEEE80211_MAX_SSID_LEN)
			memcpy(param->ssid, ssid_elm + 2, ssid_elm[1]);
	}

	tim_elm = cfg80211_find_ie(WLAN_EID_TIM, ies->data, ies->len);
	if (tim_elm && tim_elm[1] >= 2)
		param->dtim_period = tim_elm[3];

	memset(param->p_suites, 0xFF, 3);
	memset(param->akm_suites, 0xFF, 3);

	rates_ie = cfg80211_find_ie(WLAN_EID_SUPP_RATES, ies->data, ies->len);
	if (rates_ie) {
		rates_len = rates_ie[1];
		if (rates_len > WILC_MAX_RATES_SUPPORTED)
			rates_len = WILC_MAX_RATES_SUPPORTED;
		param->supp_rates[0] = rates_len;
		memcpy(&param->supp_rates[1], rates_ie + 2, rates_len);
	}

	if (rates_len < WILC_MAX_RATES_SUPPORTED) {
		supp_rates_ie = cfg80211_find_ie(WLAN_EID_EXT_SUPP_RATES,
						 ies->data, ies->len);
		if (supp_rates_ie) {
			u8 ext_rates = supp_rates_ie[1];

			if (ext_rates > (WILC_MAX_RATES_SUPPORTED - rates_len))
				param->supp_rates[0] = WILC_MAX_RATES_SUPPORTED;
			else
				param->supp_rates[0] += ext_rates;

			memcpy(&param->supp_rates[rates_len + 1],
			       supp_rates_ie + 2,
			       (param->supp_rates[0] - rates_len));
		}
	}

	ht_ie = cfg80211_find_ie(WLAN_EID_HT_CAPABILITY, ies->data, ies->len);
	if (ht_ie)
		param->ht_capable = true;

	ret = cfg80211_get_p2p_attr(ies->data, ies->len,
				    IEEE80211_P2P_ATTR_ABSENCE_NOTICE,
				    (u8 *)&noa_attr, sizeof(noa_attr));
	if (ret > 0) {
		param->tsf_lo = cpu_to_le32(ies->tsf);
		param->noa_enabled = 1;
		param->idx = noa_attr.index;
		if (noa_attr.oppps_ctwindow & IEEE80211_P2P_OPPPS_ENABLE_BIT) {
			param->opp_enabled = 1;
			param->opp_en.ct_window = noa_attr.oppps_ctwindow;
			param->opp_en.cnt = noa_attr.desc[0].count;
			param->opp_en.duration = noa_attr.desc[0].duration;
			param->opp_en.interval = noa_attr.desc[0].interval;
			param->opp_en.start_time = noa_attr.desc[0].start_time;
		} else {
			param->opp_enabled = 0;
			param->opp_dis.cnt = noa_attr.desc[0].count;
			param->opp_dis.duration = noa_attr.desc[0].duration;
			param->opp_dis.interval = noa_attr.desc[0].interval;
			param->opp_dis.start_time = noa_attr.desc[0].start_time;
		}
	}
	wmm_ie = cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,
					 WLAN_OUI_TYPE_MICROSOFT_WMM,
					 ies->data, ies->len);
	if (wmm_ie) {
		struct ieee80211_wmm_param_ie *ie;

		ie = (struct ieee80211_wmm_param_ie *)wmm_ie;
		if ((ie->oui_subtype == 0 || ie->oui_subtype == 1) &&
		    ie->version == 1) {
			param->wmm_cap = true;
			if (ie->qos_info & BIT(7))
				param->uapsd_cap = true;
		}
	}

	wpa_ie = cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,
					 WLAN_OUI_TYPE_MICROSOFT_WPA,
					 ies->data, ies->len);
	if (wpa_ie) {
		param->mode_802_11i = 1;
		param->rsn_found = true;
	}

	rsn_ie = cfg80211_find_ie(WLAN_EID_RSN, ies->data, ies->len);
	if (rsn_ie) {
		int rsn_ie_len = sizeof(struct element) + rsn_ie[1];
		int offset = 8;

		
		if (offset < rsn_ie_len) {
			
			offset += (rsn_ie[offset] * 4) + 2;

			if (offset < rsn_ie_len) {
				
				offset += (rsn_ie[offset] * 4) + 2;

				if (offset + 1 < rsn_ie_len) {
					param->mode_802_11i = 2;
					param->rsn_found = true;
					memcpy(param->rsn_cap, &rsn_ie[offset], 2);
				}
			}
		}
	}

	if (param->rsn_found) {
		int i;

		param->rsn_grp_policy = crypto->cipher_group & 0xFF;
		for (i = 0; i < crypto->n_ciphers_pairwise && i < 3; i++)
			param->p_suites[i] = crypto->ciphers_pairwise[i] & 0xFF;

		for (i = 0; i < crypto->n_akm_suites && i < 3; i++)
			param->akm_suites[i] = crypto->akm_suites[i] & 0xFF;
	}

	return (void *)param;
}
","1. void *wilc_parse_join_bss_param(struct cfg80211_bss *bss,
2. struct wilc_join_bss_param *param;
3. u8 rates_len = 0;
4. int ret;
const struct cfg80211_bss_ies *ies = rcu_dereference(bss->ies);
5. param->dtim_period = tim_elm[3];
6. memset(param->akm_suites, 0xFF, 3);
7. if (rates_len > WILC_MAX_RATES_SUPPORTED)
rates_len = WILC_MAX_RATES_SUPPORTED;
8. memcpy(&param->supp_rates[1], rates_ie + 2, rates_len);
9. supp_rates_ie = cfg80211_find_ie(WLAN_EID_EXT_SUPP_RATES,
ies->data, ies->len);
if (supp_rates_ie) {
10. if (ext_rates > (WILC_MAX_RATES_SUPPORTED - rates_len))
11. memcpy(&param->supp_rates[rates_len + 1],
12. (param->supp_rates[0] - rates_len));
13. ht_ie = cfg80211_find_ie(WLAN_EID_HT_CAPABILITY, ies->data, ies->len);
14. ret = cfg80211_get_p2p_attr(ies->data, ies->len,
IEEE80211_P2P_ATTR_ABSENCE_NOTICE,
15. param->opp_en.interval = noa_attr.desc[0].interval;
16. param->opp_dis.start_time = noa_attr.desc[0].start_time;
17. if (wmm_ie) {
18. ie = (struct ieee80211_wmm_param_ie *)wmm_ie;
19. param->wmm_cap = true;
20. param->uapsd_cap = true;
21. param->rsn_found = true;
22. for (i = 0; i < crypto->n_akm_suites && i < 3; i++)","1
4
6
9-10
30
33
38-39
41
45-47
50
55
57
61
65-66
77
84
90
93
96
98
126
140","CWE-362,CWE-134,CWE-787,CWE-401"
tja1100Init-196492453248179,"
#define NetInterface

error_t tja1100Init(NetInterface *interface)
{
   uint16_t value;

   
   TRACE_INFO(""Initializing TJA1100...\r\n"");

   
   if(interface->phyAddr >= 32)
   {
      
      interface->phyAddr = TJA1100_PHY_ADDR;
   }

   
   if(interface->smiDriver != NULL)
   {
      interface->smiDriver->init();
   }

   
   if(interface->extIntDriver != NULL)
   {
      interface->extIntDriver->init();
   }

   
   tja1100WritePhyReg(interface, TJA1100_BASIC_CTRL,
      TJA1100_BASIC_CTRL_RESET);

   
   while(tja1100ReadPhyReg(interface, TJA1100_BASIC_CTRL) &
      TJA1100_BASIC_CTRL_RESET)
   {
   }

   
   tja1100DumpPhyReg(interface);

   
   value = tja1100ReadPhyReg(interface, TJA1100_EXTENDED_CTRL);
   value |= TJA1100_EXTENDED_CTRL_CONFIG_EN;
   tja1100WritePhyReg(interface, TJA1100_EXTENDED_CTRL, value);

   
   value = tja1100ReadPhyReg(interface, TJA1100_CONFIG1);
   value &= ~TJA1100_CONFIG1_MII_MODE;
   value |= TJA1100_CONFIG1_MII_MODE_RMII_25MHZ_XTAL;
   tja1100WritePhyReg(interface, TJA1100_CONFIG1, value);

   
   value = tja1100ReadPhyReg(interface, TJA1100_CONFIG1);
   value |= TJA1100_CONFIG1_AUTO_OP;
   tja1100WritePhyReg(interface, TJA1100_CONFIG1, value);

   
   interface->phyEvent = TRUE;
   
   osSetEvent(&netEvent);

   
   return NO_ERROR;
}
","1. TRACE_INFO(""Initializing TJA1100...\r\n"");
2. if(interface->extIntDriver != NULL)
3. interface->extIntDriver->init();
4. TJA1100_BASIC_CTRL_RESET)
5. value = tja1100ReadPhyReg(interface, TJA1100_EXTENDED_CTRL);
6. tja1100WritePhyReg(interface, TJA1100_EXTENDED_CTRL, value);","9
25
27
36
44
46",CWE-20
dtls1_read_bytes_1,"
#define SSL

int dtls1_read_bytes_1(SSL *s, int type, unsigned char *buf, int len, int peek)
	{
	int al,i,j,ret;
	unsigned int n;
	SSL3_RECORD *rr;
	void (*cb)(const SSL *ssl,int type2,int val)=NULL;

	if (s->s3->rbuf.buf == NULL) 
		if (!ssl3_setup_buffers(s))
			return(-1);

	if ((type && (type != SSL3_RT_APPLICATION_DATA) && 
		(type != SSL3_RT_HANDSHAKE)) ||
	    (peek && (type != SSL3_RT_APPLICATION_DATA)))
		{
		SSLerr(SSL_F_DTLS1_READ_BYTES, ERR_R_INTERNAL_ERROR);
		return -1;
		}

	
	if ( (ret = have_handshake_fragment(s, type, buf, len, peek)))
		return ret;

	

#ifndef OPENSSL_NO_SCTP
	
	if ((!s->in_handshake && SSL_in_init(s)) ||
	    (BIO_dgram_is_sctp(SSL_get_rbio(s)) &&
	     (s->state == DTLS1_SCTP_ST_SR_READ_SOCK || s->state == DTLS1_SCTP_ST_CR_READ_SOCK) &&
	     s->s3->in_read_app_data != 2))
#else
	if (!s->in_handshake && SSL_in_init(s))
#endif
		{
		
		i=s->handshake_func(s);
		if (i < 0) return(i);
		if (i == 0)
			{
			SSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_SSL_HANDSHAKE_FAILURE);
			return(-1);
			}
		}

start:
	s->rwstate=SSL_NOTHING;

	
	rr = &(s->s3->rrec);

	
	if (s->state == SSL_ST_OK && rr->length == 0)
		{
		pitem *item;
		item = pqueue_pop(s->d1->buffered_app_data.q);
		if (item)
			{
#ifndef OPENSSL_NO_SCTP
			
			if (BIO_dgram_is_sctp(SSL_get_rbio(s)))
				{
				DTLS1_RECORD_DATA *rdata = (DTLS1_RECORD_DATA *) item->data;
				BIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SCTP_SET_RCVINFO, sizeof(rdata->recordinfo), &rdata->recordinfo);
				}
#endif

			dtls1_copy_record(s, item);

			OPENSSL_free(item->data);
			pitem_free(item);
			}
		}

	
	if (dtls1_handle_timeout(s) > 0)
		goto start;

	
	if ((rr->length == 0) || (s->rstate == SSL_ST_READ_BODY))
		{
		ret=dtls1_get_record(s);
		if (ret <= 0) 
			{
			ret = dtls1_read_failed(s, ret);
			
			if (ret <= 0)  
				return(ret);
			else
				goto start;
			}
		}

	if (s->d1->listen && rr->type != SSL3_RT_HANDSHAKE)
		{
		rr->length = 0;
		goto start;
		}

	

	if (s->s3->change_cipher_spec 
		&& (rr->type != SSL3_RT_HANDSHAKE))
		{
		
		if(dtls1_buffer_record(s, &(s->d1->buffered_app_data), rr->seq_num)<0)
			{
			SSLerr(SSL_F_DTLS1_READ_BYTES, ERR_R_INTERNAL_ERROR);
			return -1;
			}
 		rr->length = 0;
 		goto start;
 		}

	
	if (s->shutdown & SSL_RECEIVED_SHUTDOWN)
		{
		rr->length=0;
		s->rwstate=SSL_NOTHING;
		return(0);
		}


	if (type == rr->type) 
		{
		
		if (SSL_in_init(s) && (type == SSL3_RT_APPLICATION_DATA) &&
			(s->enc_read_ctx == NULL))
			{
			al=SSL_AD_UNEXPECTED_MESSAGE;
			SSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_APP_DATA_IN_HANDSHAKE);
			goto f_err;
			}

		if (len <= 0) return(len);

		if ((unsigned int)len > rr->length)
			n = rr->length;
		else
			n = (unsigned int)len;

		memcpy(buf,&(rr->data[rr->off]),n);
		if (!peek)
			{
			rr->length-=n;
			rr->off+=n;
			if (rr->length == 0)
				{
				s->rstate=SSL_ST_READ_HEADER;
				rr->off=0;
				}
			}

#ifndef OPENSSL_NO_SCTP
			
			if (BIO_dgram_is_sctp(SSL_get_rbio(s)) &&
			    rr->type == SSL3_RT_APPLICATION_DATA &&
			    (s->state == DTLS1_SCTP_ST_SR_READ_SOCK || s->state == DTLS1_SCTP_ST_CR_READ_SOCK))
				{
				s->rwstate=SSL_READING;
				BIO_clear_retry_flags(SSL_get_rbio(s));
				BIO_set_retry_read(SSL_get_rbio(s));
				}

			
			if (BIO_dgram_is_sctp(SSL_get_rbio(s)) &&
			    s->d1->shutdown_received && !BIO_dgram_sctp_msg_waiting(SSL_get_rbio(s)))
				{
				s->shutdown |= SSL_RECEIVED_SHUTDOWN;
				return(0);
				}
#endif			
		return(n);
		}


	

	
		{
		unsigned int k, dest_maxlen = 0;
		unsigned char *dest = NULL;
		unsigned int *dest_len = NULL;

		if (rr->type == SSL3_RT_HANDSHAKE)
			{
			dest_maxlen = sizeof s->d1->handshake_fragment;
			dest = s->d1->handshake_fragment;
			dest_len = &s->d1->handshake_fragment_len;
			}
		else if (rr->type == SSL3_RT_ALERT)
			{
			dest_maxlen = sizeof(s->d1->alert_fragment);
			dest = s->d1->alert_fragment;
			dest_len = &s->d1->alert_fragment_len;
			}
#ifndef OPENSSL_NO_HEARTBEATS
		else if (rr->type == TLS1_RT_HEARTBEAT)
			{
			dtls1_process_heartbeat(s);

			
			rr->length = 0;
			s->rwstate=SSL_READING;
			BIO_clear_retry_flags(SSL_get_rbio(s));
			BIO_set_retry_read(SSL_get_rbio(s));
			return(-1);
			}
#endif
		
		else if (rr->type != SSL3_RT_CHANGE_CIPHER_SPEC)
			{
			
			if (rr->type == SSL3_RT_APPLICATION_DATA)
				{
				BIO *bio;
				s->s3->in_read_app_data=2;
				bio=SSL_get_rbio(s);
				s->rwstate=SSL_READING;
				BIO_clear_retry_flags(bio);
				BIO_set_retry_read(bio);
				return(-1);
				}

			
			al=SSL_AD_UNEXPECTED_MESSAGE;
			SSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_UNEXPECTED_RECORD);
			goto f_err;
			}

		if (dest_maxlen > 0)
			{
            
			if ( rr->length < dest_maxlen)
				{
#ifdef DTLS1_AD_MISSING_HANDSHAKE_MESSAGE
				
				FIX ME
#endif
				s->rstate=SSL_ST_READ_HEADER;
				rr->length = 0;
				goto start;
				}

			
			for ( k = 0; k < dest_maxlen; k++)
				{
				dest[k] = rr->data[rr->off++];
				rr->length--;
				}
			*dest_len = dest_maxlen;
			}
		}

	

	
	if ((!s->server) &&
		(s->d1->handshake_fragment_len >= DTLS1_HM_HEADER_LENGTH) &&
		(s->d1->handshake_fragment[0] == SSL3_MT_HELLO_REQUEST) &&
		(s->session != NULL) && (s->session->cipher != NULL))
		{
		s->d1->handshake_fragment_len = 0;

		if ((s->d1->handshake_fragment[1] != 0) ||
			(s->d1->handshake_fragment[2] != 0) ||
			(s->d1->handshake_fragment[3] != 0))
			{
			al=SSL_AD_DECODE_ERROR;
			SSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_BAD_HELLO_REQUEST);
			goto err;
			}

		

		if (s->msg_callback)
			s->msg_callback(0, s->version, SSL3_RT_HANDSHAKE, 
				s->d1->handshake_fragment, 4, s, s->msg_callback_arg);

		if (SSL_is_init_finished(s) &&
			!(s->s3->flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS) &&
			!s->s3->renegotiate)
			{
			s->d1->handshake_read_seq++;
			s->new_session = 1;
			ssl3_renegotiate(s);
			if (ssl3_renegotiate_check(s))
				{
				i=s->handshake_func(s);
				if (i < 0) return(i);
				if (i == 0)
					{
					SSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_SSL_HANDSHAKE_FAILURE);
					return(-1);
					}

				if (!(s->mode & SSL_MODE_AUTO_RETRY))
					{
					if (s->s3->rbuf.left == 0) 
						{
						BIO *bio;
						
						s->rwstate=SSL_READING;
						bio=SSL_get_rbio(s);
						BIO_clear_retry_flags(bio);
						BIO_set_retry_read(bio);
						return(-1);
						}
					}
				}
			}
		
		goto start;
		}

	if (s->d1->alert_fragment_len >= DTLS1_AL_HEADER_LENGTH)
		{
		int alert_level = s->d1->alert_fragment[0];
		int alert_descr = s->d1->alert_fragment[1];

		s->d1->alert_fragment_len = 0;

		if (s->msg_callback)
			s->msg_callback(0, s->version, SSL3_RT_ALERT, 
				s->d1->alert_fragment, 2, s, s->msg_callback_arg);

		if (s->info_callback != NULL)
			cb=s->info_callback;
		else if (s->ctx->info_callback != NULL)
			cb=s->ctx->info_callback;

		if (cb != NULL)
			{
			j = (alert_level << 8) | alert_descr;
			cb(s, SSL_CB_READ_ALERT, j);
			}

		if (alert_level == 1) 
			{
			s->s3->warn_alert = alert_descr;
			if (alert_descr == SSL_AD_CLOSE_NOTIFY)
				{
#ifndef OPENSSL_NO_SCTP
				
				if (BIO_dgram_is_sctp(SSL_get_rbio(s)) &&
					BIO_dgram_sctp_msg_waiting(SSL_get_rbio(s)))
					{
					s->d1->shutdown_received = 1;
					s->rwstate=SSL_READING;
					BIO_clear_retry_flags(SSL_get_rbio(s));
					BIO_set_retry_read(SSL_get_rbio(s));
					return -1;
					}
#endif
				s->shutdown |= SSL_RECEIVED_SHUTDOWN;
				return(0);
				}
#if 0
            
			
			if (alert_descr == DTLS1_AD_MISSING_HANDSHAKE_MESSAGE)
				{
				unsigned short seq;
				unsigned int frag_off;
				unsigned char *p = &(s->d1->alert_fragment[2]);

				n2s(p, seq);
				n2l3(p, frag_off);

				dtls1_retransmit_message(s,
										 dtls1_get_queue_priority(frag->msg_header.seq, 0),
										 frag_off, &found);
				if ( ! found  && SSL_in_init(s))
					{
					
					
					ssl3_send_alert(s,SSL3_AL_WARNING,
						DTLS1_AD_MISSING_HANDSHAKE_MESSAGE);
					}
				}
#endif
			}
		else if (alert_level == 2) 
			{
			char tmp[16];

			s->rwstate=SSL_NOTHING;
			s->s3->fatal_alert = alert_descr;
			SSLerr(SSL_F_DTLS1_READ_BYTES, SSL_AD_REASON_OFFSET + alert_descr);
			BIO_snprintf(tmp,sizeof tmp,""%d"",alert_descr);
			ERR_add_error_data(2,""SSL alert number "",tmp);
			s->shutdown|=SSL_RECEIVED_SHUTDOWN;
			SSL_CTX_remove_session(s->ctx,s->session);
			return(0);
			}
		else
			{
			al=SSL_AD_ILLEGAL_PARAMETER;
			SSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_UNKNOWN_ALERT_TYPE);
			goto f_err;
			}

		goto start;
		}

	if (s->shutdown & SSL_SENT_SHUTDOWN) 
		{
		s->rwstate=SSL_NOTHING;
		rr->length=0;
		return(0);
		}

	if (rr->type == SSL3_RT_CHANGE_CIPHER_SPEC)
		{
		struct ccs_header_st ccs_hdr;
		unsigned int ccs_hdr_len = DTLS1_CCS_HEADER_LENGTH;

		dtls1_get_ccs_header(rr->data, &ccs_hdr);

		if (s->version == DTLS1_BAD_VER)
			ccs_hdr_len = 3;

		
		
		if (	(rr->length != ccs_hdr_len) || 
			(rr->off != 0) || (rr->data[0] != SSL3_MT_CCS))
			{
			i=SSL_AD_ILLEGAL_PARAMETER;
			SSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_BAD_CHANGE_CIPHER_SPEC);
			goto err;
			}

		rr->length=0;

		if (s->msg_callback)
			s->msg_callback(0, s->version, SSL3_RT_CHANGE_CIPHER_SPEC, 
				rr->data, 1, s, s->msg_callback_arg);

		
		if (!s->d1->change_cipher_spec_ok)
			{
			goto start;
			}

		s->d1->change_cipher_spec_ok = 0;

		s->s3->change_cipher_spec=1;
		if (!ssl3_do_change_cipher_spec(s))
			goto err;

		
		dtls1_reset_seq_numbers(s, SSL3_CC_READ);

		if (s->version == DTLS1_BAD_VER)
			s->d1->handshake_read_seq++;

#ifndef OPENSSL_NO_SCTP
		
		BIO_ctrl(SSL_get_wbio(s), BIO_CTRL_DGRAM_SCTP_AUTH_CCS_RCVD, 1, NULL);
#endif

		goto start;
		}

	
	if ((s->d1->handshake_fragment_len >= DTLS1_HM_HEADER_LENGTH) && 
		!s->in_handshake)
		{
		struct hm_header_st msg_hdr;
		
		
		dtls1_get_message_header(rr->data, &msg_hdr);
		if( rr->epoch != s->d1->r_epoch)
			{
			rr->length = 0;
			goto start;
			}

		
		if (msg_hdr.type == SSL3_MT_FINISHED)
			{
			if (dtls1_check_timeout_num(s) < 0)
				return -1;

			dtls1_retransmit_buffered_messages(s);
			rr->length = 0;
			goto start;
			}

		if (((s->state&SSL_ST_MASK) == SSL_ST_OK) &&
			!(s->s3->flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS))
			{
#if 0 
			s->state=SSL_ST_BEFORE|(s->server)
				?SSL_ST_ACCEPT
				:SSL_ST_CONNECT;
#else
			s->state = s->server ? SSL_ST_ACCEPT : SSL_ST_CONNECT;
#endif
			s->renegotiate=1;
			s->new_session=1;
			}
		i=s->handshake_func(s);
		if (i < 0) return(i);
		if (i == 0)
			{
			SSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_SSL_HANDSHAKE_FAILURE);
			return(-1);
			}

		if (!(s->mode & SSL_MODE_AUTO_RETRY))
			{
			if (s->s3->rbuf.left == 0) 
				{
				BIO *bio;
				
				s->rwstate=SSL_READING;
				bio=SSL_get_rbio(s);
				BIO_clear_retry_flags(bio);
				BIO_set_retry_read(bio);
				return(-1);
				}
			}
		goto start;
		}

	switch (rr->type)
		{
	default:
#ifndef OPENSSL_NO_TLS
		
		if (s->version == TLS1_VERSION)
			{
			rr->length = 0;
			goto start;
			}
#endif
		al=SSL_AD_UNEXPECTED_MESSAGE;
		SSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_UNEXPECTED_RECORD);
		goto f_err;
	case SSL3_RT_CHANGE_CIPHER_SPEC:
	case SSL3_RT_ALERT:
	case SSL3_RT_HANDSHAKE:
		
		al=SSL_AD_UNEXPECTED_MESSAGE;
		SSLerr(SSL_F_DTLS1_READ_BYTES,ERR_R_INTERNAL_ERROR);
		goto f_err;
	case SSL3_RT_APPLICATION_DATA:
		
		if (s->s3->in_read_app_data &&
			(s->s3->total_renegotiations != 0) &&
			((
				(s->state & SSL_ST_CONNECT) &&
				(s->state >= SSL3_ST_CW_CLNT_HELLO_A) &&
				(s->state <= SSL3_ST_CR_SRVR_HELLO_A)
				) || (
					(s->state & SSL_ST_ACCEPT) &&
					(s->state <= SSL3_ST_SW_HELLO_REQ_A) &&
					(s->state >= SSL3_ST_SR_CLNT_HELLO_A)
					)
				))
			{
			s->s3->in_read_app_data=2;
			return(-1);
			}
		else
			{
			al=SSL_AD_UNEXPECTED_MESSAGE;
			SSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_UNEXPECTED_RECORD);
			goto f_err;
			}
		}
	

f_err:
	ssl3_send_alert(s,SSL3_AL_FATAL,al);
err:
	return(-1);
	}
","1. int al,i,j,ret;
2. if (!ssl3_setup_buffers(s))
3. (peek && (type != SSL3_RT_APPLICATION_DATA)))
4. SSLerr(SSL_F_DTLS1_READ_BYTES, ERR_R_INTERNAL_ERROR);
5. (BIO_dgram_is_sctp(SSL_get_rbio(s)) &&
6. start:
7. ret = dtls1_read_failed(s, ret);
8. goto start;
9. && (rr->type != SSL3_RT_HANDSHAKE))
10. s->rwstate=SSL_NOTHING;
11. if (type == rr->type)
12. if ((unsigned int)len > rr->length)
13. if (!peek)
14. BIO_clear_retry_flags(SSL_get_rbio(s));
15. if (rr->type == SSL3_RT_APPLICATION_DATA)
16. *dest_len = dest_maxlen;
17. goto err;
18. if (i == 0)
19. SSLerr(SSL_F_DTLS1_READ_BYTES,SSL_R_SSL_HANDSHAKE_FAILURE);
20. if (!(s->mode & SSL_MODE_AUTO_RETRY))
21. int alert_descr = s->d1->alert_fragment[1];
22. cb=s->info_callback;
else if (s->ctx->info_callback != NULL)
23. cb(s, SSL_CB_READ_ALERT, j);
24. s->rwstate=SSL_READING;
25. s->s3->change_cipher_spec=1;
if (!ssl3_do_change_cipher_spec(s))
26. if (s->version == DTLS1_BAD_VER)
27. dtls1_get_message_header(rr->data, &msg_hdr);
28. rr->length = 0;
29. if (s->s3->rbuf.left == 0)
30. (s->state & SSL_ST_ACCEPT) &&
31. err:","6
12
17
19
34
51
98
103
117
138
143
157
163
183
244
286
308
328
330
334
360
369-370
376
393
495-496
502
524
540
569
624
644","CWE-310,CWE-399,CWE-119"
print_ipcp_config_options,"print_ipcp_config_options(netdissect_options *ndo,
                          const u_char *p, int length)
{
	int len, opt;
        u_int compproto, ipcomp_subopttotallen, ipcomp_subopt, ipcomp_suboptlen;

	if (length < 2)
		return 0;
	ND_TCHECK2(*p, 2);
	len = p[1];
	opt = p[0];
	if (length < len)
		return 0;
	if (len < 2) {
		ND_PRINT((ndo, ""\n\t  %s Option (0x%02x), length %u (length bogus, should be >= 2)"",
		       tok2str(ipcpopt_values,""unknown"",opt),
		       opt,
		       len));
		return 0;
	}

	ND_PRINT((ndo, ""\n\t  %s Option (0x%02x), length %u"",
	       tok2str(ipcpopt_values,""unknown"",opt),
	       opt,
	       len));

	switch (opt) {
	case IPCPOPT_2ADDR:		
		if (len != 10) {
			ND_PRINT((ndo, "" (length bogus, should be = 10)""));
			return len;
		}
		ND_TCHECK2(*(p + 6), 4);
		ND_PRINT((ndo, "": src %s, dst %s"",
		       ipaddr_string(ndo, p + 2),
		       ipaddr_string(ndo, p + 6)));
		break;
	case IPCPOPT_IPCOMP:
		if (len < 4) {
 			ND_PRINT((ndo, "" (length bogus, should be >= 4)""));
 			return 0;
 		}
		ND_TCHECK_16BITS(p+2);
 		compproto = EXTRACT_16BITS(p+2);
 
 		ND_PRINT((ndo, "": %s (0x%02x):"",
		          tok2str(ipcpopt_compproto_values, ""Unknown"", compproto),
		          compproto));

		switch (compproto) {
                case PPP_VJC:
			
                        break;
                case IPCPOPT_IPCOMP_HDRCOMP:
                        if (len < IPCPOPT_IPCOMP_MINLEN) {
                        	ND_PRINT((ndo, "" (length bogus, should be >= %u)"",
                        		IPCPOPT_IPCOMP_MINLEN));
                        	return 0;
                        }

                        ND_TCHECK2(*(p + 2), IPCPOPT_IPCOMP_MINLEN);
                        ND_PRINT((ndo, ""\n\t    TCP Space %u, non-TCP Space %u"" \
                               "", maxPeriod %u, maxTime %u, maxHdr %u"",
                               EXTRACT_16BITS(p+4),
                               EXTRACT_16BITS(p+6),
                               EXTRACT_16BITS(p+8),
                               EXTRACT_16BITS(p+10),
                               EXTRACT_16BITS(p+12)));

                        
                        if (len > IPCPOPT_IPCOMP_MINLEN) {
                                ipcomp_subopttotallen = len - IPCPOPT_IPCOMP_MINLEN;
                                p += IPCPOPT_IPCOMP_MINLEN;

                                ND_PRINT((ndo, ""\n\t      Suboptions, length %u"", ipcomp_subopttotallen));

                                while (ipcomp_subopttotallen >= 2) {
                                        ND_TCHECK2(*p, 2);
                                        ipcomp_subopt = *p;
                                        ipcomp_suboptlen = *(p+1);

                                        
                                        if (ipcomp_subopt == 0 ||
                                            ipcomp_suboptlen == 0 )
                                                break;

                                        
                                        ND_PRINT((ndo, ""\n\t\t%s Suboption #%u, length %u"",
                                               tok2str(ipcpopt_compproto_subopt_values,
                                                       ""Unknown"",
                                                       ipcomp_subopt),
                                               ipcomp_subopt,
                                               ipcomp_suboptlen));

                                        ipcomp_subopttotallen -= ipcomp_suboptlen;
                                        p += ipcomp_suboptlen;
                                }
                        }
                        break;
                default:
                        break;
		}
		break;

	case IPCPOPT_ADDR:     
	case IPCPOPT_MOBILE4:
	case IPCPOPT_PRIDNS:
	case IPCPOPT_PRINBNS:
	case IPCPOPT_SECDNS:
	case IPCPOPT_SECNBNS:
		if (len != 6) {
			ND_PRINT((ndo, "" (length bogus, should be = 6)""));
			return 0;
		}
		ND_TCHECK2(*(p + 2), 4);
		ND_PRINT((ndo, "": %s"", ipaddr_string(ndo, p + 2)));
		break;
	default:
		
		if (ndo->ndo_vflag < 2)
			print_unknown_data(ndo, &p[2], ""\n\t    "", len - 2);
		break;
	}
	if (ndo->ndo_vflag > 1)
		print_unknown_data(ndo, &p[2], ""\n\t    "", len - 2); 
	return len;

trunc:
	ND_PRINT((ndo, ""[|ipcp]""));
	return 0;
}
","1. len = p[1];
opt = p[0];
2. if (len < 2) {
3. opt,
4. ND_PRINT((ndo, ""\n\t  %s Option (0x%02x), length %u"",
5. switch (opt) {
6. if (len != 10) {
7. ND_TCHECK2(*(p + 6), 4);
8. ipaddr_string(ndo, p + 6)));
9. case IPCPOPT_IPCOMP:
if (len < 4) {
10. ND_TCHECK_16BITS(p+2);
11. switch (compproto) {
case PPP_VJC:
12. ND_PRINT((ndo, "" (length bogus, should be >= %u)"",
13. while (ipcomp_subopttotallen >= 2) {
14. ipcomp_suboptlen = *(p+1);
15. ND_PRINT((ndo, ""\n\t\t%s Suboption #%u, length %u"",
tok2str(ipcpopt_compproto_subopt_values,
""Unknown"",
ipcomp_subopt),
16. ipcomp_suboptlen));
17. ipcomp_subopttotallen -= ipcomp_suboptlen;
p += ipcomp_suboptlen;
18. default:
19. case IPCPOPT_PRINBNS:
20. return 0;
21. ND_TCHECK2(*(p + 2), 4);
ND_PRINT((ndo, "": %s"", ipaddr_string(ndo, p + 2)));
22. print_unknown_data(ndo, &p[2], ""\n\t    "", len - 2);
23. trunc:
ND_PRINT((ndo, ""[|ipcp]""));","10-11
14
17
22
27
29
33
36
38-39
43
50-51
56
77
80
88-91
93
95-96
100
108
113
115-116
124
131-132",CWE-125
scm_check_creds-109295752560170,"static __inline__ int scm_check_creds(struct ucred *creds)
{
	const struct cred *cred = current_cred();
	kuid_t uid = make_kuid(cred->user_ns, creds->uid);
	kgid_t gid = make_kgid(cred->user_ns, creds->gid);

	if (!uid_valid(uid) || !gid_valid(gid))
		return -EINVAL;

	if ((creds->pid == task_tgid_vnr(current) ||
	     ns_capable(current->nsproxy->pid_ns->user_ns, CAP_SYS_ADMIN)) &&
	    ((uid_eq(uid, cred->uid)   || uid_eq(uid, cred->euid) ||
	      uid_eq(uid, cred->suid)) || nsown_capable(CAP_SETUID)) &&
	    ((gid_eq(gid, cred->gid)   || gid_eq(gid, cred->egid) ||
	      gid_eq(gid, cred->sgid)) || nsown_capable(CAP_SETGID))) {
	       return 0;
	}
	return -EPERM;
}
","1. ((uid_eq(uid, cred->uid)   || uid_eq(uid, cred->euid) ||
2. ((gid_eq(gid, cred->gid)   || gid_eq(gid, cred->egid) ||","12
14","CWE-254,CWE-264"
hashtable_get,"void *hashtable_get(hashtable_t *hashtable, const char *key)
{
    pair_t *pair;
    size_t hash;
     bucket_t *bucket;
 
     hash = hash_str(key);
    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];
 
     pair = hashtable_find_pair(hashtable, bucket, key, hash);
     if(!pair)
        return NULL;

    return pair->value;
}
","1. void *hashtable_get(hashtable_t *hashtable, const char *key)
2. bucket_t *bucket;
3. return NULL;
4. return pair->value;","1
5
12
14","CWE-310,CWE-119"
cliprdr_process-115916128516756,"
#define STREAM

static void
cliprdr_process(STREAM s)
{
	uint16 type, status;
	uint32 length, format;
	uint8 *data;
	struct stream packet = *s;

	in_uint16_le(s, type);
	in_uint16_le(s, status);
	in_uint32_le(s, length);
	data = s->p;

	logger(Clipboard, Debug, ""cliprdr_process(), type=%d, status=%d, length=%d"", type, status,
	       length);

	if (!s_check_rem(s, length))
	{
		rdp_protocol_error(""cliprdr_process(), consume of packet from stream would overrun"", &packet);
	}

	if (status == CLIPRDR_ERROR)
	{
		switch (type)
		{
			case CLIPRDR_FORMAT_ACK:
				
				cliprdr_send_native_format_announce(last_formats,
								    last_formats_length);
				break;
			case CLIPRDR_DATA_RESPONSE:
				ui_clip_request_failed();
				break;
			default:
				logger(Clipboard, Warning,
				       ""cliprdr_process(), unhandled error (type=%d)"", type);
		}

		return;
	}

	switch (type)
	{
		case CLIPRDR_CONNECT:
			ui_clip_sync();
			break;
		case CLIPRDR_FORMAT_ANNOUNCE:
			ui_clip_format_announce(data, length);
			cliprdr_send_packet(CLIPRDR_FORMAT_ACK, CLIPRDR_RESPONSE, NULL, 0);
			return;
		case CLIPRDR_FORMAT_ACK:
			break;
		case CLIPRDR_DATA_REQUEST:
			in_uint32_le(s, format);
			ui_clip_request_data(format);
			break;
		case CLIPRDR_DATA_RESPONSE:
			ui_clip_handle_data(data, length);
			break;
		case 7:	
			break;
		default:
			logger(Clipboard, Warning, ""cliprdr_process(), unhandled packet type %d"",
			       type);
	}
}
","1. rdp_protocol_error(""cliprdr_process(), consume of packet from stream would overrun"", &packet);
2. if (status == CLIPRDR_ERROR)
3. switch (type)
4. case CLIPRDR_FORMAT_ACK:
5. logger(Clipboard, Warning,
6. return;
7. cliprdr_send_packet(CLIPRDR_FORMAT_ACK, CLIPRDR_RESPONSE, NULL, 0);
8. break;
9. in_uint32_le(s, format);
10. break;
11. type);","22
25
27
29
39
43
53
56
58
60
68","CWE-125,CWE-119"
zsetstrokecolor," zsetstrokecolor(i_ctx_t * i_ctx_p)
 {
     int code;
    es_ptr iesp = esp;  
 
     code = zswapcolors(i_ctx_p);
     if (code < 0)

    
    
    check_estack(1);
    
    push_op_estack(setstrokecolor_cont);

    code = zsetcolor(i_ctx_p);

    if (code >= 0)
     if (code >= 0)
         return o_push_estack;
 
    
    esp = iesp;
    (void)zswapcolors(i_ctx_p);
     return code;
 }
","1. if (code >= 0)
return o_push_estack;
2. return code;","18-19
24","CWE-362,CWE-189,CWE-704,CWE-119,CWE-125"
njs_array_convert_to_slow_array-144727892327589,"njs_int_t
njs_array_convert_to_slow_array(njs_vm_t *vm, njs_array_t *array)
{
    uint32_t           i, length;
    njs_value_t        index, value;
    njs_object_prop_t  *prop;

    if (njs_slow_path(!array->object.fast_array)) {
        return NJS_OK;
    }

    njs_set_array(&value, array);
    array->object.fast_array = 0;

    length = array->length;

    for (i = 0; i < length; i++) {
        if (njs_is_valid(&array->start[i])) {
            njs_uint32_to_string(&index, i);
            prop = njs_object_property_add(vm, &value, &index, 0);
            if (njs_slow_path(prop == NULL)) {
                return NJS_ERROR;
            }

            prop->value = array->start[i];
        }
    }

    

    njs_mp_free(vm->mem_pool, array->start);
    array->start = NULL;

    return NJS_OK;
}
","1. njs_int_t
njs_array_convert_to_slow_array(njs_vm_t *vm, njs_array_t *array)
2. njs_value_t        index, value;
njs_object_prop_t  *prop;
3. array->object.fast_array = 0;
4. njs_uint32_to_string(&index, i);
5. prop->value = array->start[i];
6. return NJS_OK;","1-2
5-6
13
19
25
34","CWE-617,CWE-416,CWE-190,CWE-843,CWE-400"
test_bson_validate,"test_bson_validate (void)
{
   char filename[64];
   size_t offset;
   bson_t *b;
   int i;
   bson_error_t error;

   for (i = 1; i <= 38; i++) {
      bson_snprintf (filename, sizeof filename, ""test%u.bson"", i);
      b = get_bson (filename);
      BSON_ASSERT (bson_validate (b, BSON_VALIDATE_NONE, &offset));
      bson_destroy (b);
   }

   b = get_bson (""codewscope.bson"");
   BSON_ASSERT (bson_validate (b, BSON_VALIDATE_NONE, &offset));
   bson_destroy (b);

   b = get_bson (""empty_key.bson"");
   BSON_ASSERT (bson_validate (b,
                               BSON_VALIDATE_NONE | BSON_VALIDATE_UTF8 |
                                  BSON_VALIDATE_DOLLAR_KEYS |
                                  BSON_VALIDATE_DOT_KEYS,
                               &offset));
   bson_destroy (b);

#define VALIDATE_TEST(_filename, _flags, _offset, _flag, _msg)     \
   b = get_bson (_filename);                                       \
   BSON_ASSERT (!bson_validate (b, _flags, &offset));              \
   ASSERT_CMPSIZE_T (offset, ==, (size_t) _offset);                \
   BSON_ASSERT (!bson_validate_with_error (b, _flags, &error));    \
   ASSERT_ERROR_CONTAINS (error, BSON_ERROR_INVALID, _flag, _msg); \
   bson_destroy (b)

   VALIDATE_TEST (""overflow2.bson"",
                  BSON_VALIDATE_NONE,
                  9,
                  BSON_VALIDATE_NONE,
                  ""corrupt BSON"");
   VALIDATE_TEST (""trailingnull.bson"",
                  BSON_VALIDATE_NONE,
                  14,
                  BSON_VALIDATE_NONE,
                  ""corrupt BSON"");
   VALIDATE_TEST (""dollarquery.bson"",
                  BSON_VALIDATE_DOLLAR_KEYS | BSON_VALIDATE_DOT_KEYS,
                  4,
                  BSON_VALIDATE_DOLLAR_KEYS,
                  ""keys cannot begin with \""$\"": \""$query\"""");
   VALIDATE_TEST (""dotquery.bson"",
                  BSON_VALIDATE_DOLLAR_KEYS | BSON_VALIDATE_DOT_KEYS,
                  4,
                  BSON_VALIDATE_DOT_KEYS,
                  ""keys cannot contain \"".\"": \""abc.def\"""");
   VALIDATE_TEST (""overflow3.bson"",
                  BSON_VALIDATE_NONE,
                  9,
                  BSON_VALIDATE_NONE,
                  ""corrupt BSON"");
   
   VALIDATE_TEST (""overflow3.bson"",
                  BSON_VALIDATE_UTF8,
                  9,
                  BSON_VALIDATE_NONE,
                  ""corrupt BSON"");
   VALIDATE_TEST (""overflow4.bson"",
                  BSON_VALIDATE_NONE,
                  9,
                  BSON_VALIDATE_NONE,
                  ""corrupt BSON"");
   VALIDATE_TEST (""empty_key.bson"",
                  BSON_VALIDATE_EMPTY_KEYS,
                  4,
                  BSON_VALIDATE_EMPTY_KEYS,
                  ""empty key"");
   VALIDATE_TEST (
      ""test40.bson"", BSON_VALIDATE_NONE, 6, BSON_VALIDATE_NONE, ""corrupt BSON"");
   VALIDATE_TEST (
      ""test41.bson"", BSON_VALIDATE_NONE, 6, BSON_VALIDATE_NONE, ""corrupt BSON"");
   VALIDATE_TEST (
      ""test42.bson"", BSON_VALIDATE_NONE, 6, BSON_VALIDATE_NONE, ""corrupt BSON"");
   VALIDATE_TEST (
      ""test43.bson"", BSON_VALIDATE_NONE, 6, BSON_VALIDATE_NONE, ""corrupt BSON"");
   VALIDATE_TEST (
      ""test44.bson"", BSON_VALIDATE_NONE, 6, BSON_VALIDATE_NONE, ""corrupt BSON"");
   VALIDATE_TEST (
      ""test45.bson"", BSON_VALIDATE_NONE, 6, BSON_VALIDATE_NONE, ""corrupt BSON"");
   VALIDATE_TEST (
      ""test46.bson"", BSON_VALIDATE_NONE, 6, BSON_VALIDATE_NONE, ""corrupt BSON"");
   VALIDATE_TEST (
      ""test47.bson"", BSON_VALIDATE_NONE, 6, BSON_VALIDATE_NONE, ""corrupt BSON"");
   VALIDATE_TEST (
      ""test48.bson"", BSON_VALIDATE_NONE, 6, BSON_VALIDATE_NONE, ""corrupt BSON"");
   VALIDATE_TEST (
      ""test49.bson"", BSON_VALIDATE_NONE, 6, BSON_VALIDATE_NONE, ""corrupt BSON"");
   VALIDATE_TEST (""test50.bson"",
                  BSON_VALIDATE_NONE,
                  10,
                  BSON_VALIDATE_NONE,
                  ""corrupt code-with-scope"");
   VALIDATE_TEST (""test51.bson"",
                  BSON_VALIDATE_NONE,
                  10,
                  BSON_VALIDATE_NONE,
                  ""corrupt code-with-scope"");
   VALIDATE_TEST (
      ""test52.bson"", BSON_VALIDATE_NONE, 9, BSON_VALIDATE_NONE, ""corrupt BSON"");
   VALIDATE_TEST (
      ""test53.bson"", BSON_VALIDATE_NONE, 6, BSON_VALIDATE_NONE, ""corrupt BSON"");
   VALIDATE_TEST (""test54.bson"",
                  BSON_VALIDATE_NONE,
                   12,
                   BSON_VALIDATE_NONE,
                   ""corrupt BSON"");
   VALIDATE_TEST (""test59.bson"",
                  BSON_VALIDATE_NONE,
                  9,
                  BSON_VALIDATE_NONE,
                  ""corrupt BSON"");
 
    
    b = BCON_NEW (""my_dbref"",
                 ""{"",
                 ""$ref"",
                 BCON_UTF8 (""collection""),
                 ""$id"",
                 BCON_INT32 (1),
                 ""}"");
   BSON_ASSERT (bson_validate_with_error (b, BSON_VALIDATE_NONE, &error));
   BSON_ASSERT (
      bson_validate_with_error (b, BSON_VALIDATE_DOLLAR_KEYS, &error));
   bson_destroy (b);

   
   b = BCON_NEW (""my_dbref"", ""{"", ""$id"", BCON_INT32 (1), ""}"");
   BSON_ASSERT (bson_validate_with_error (b, BSON_VALIDATE_NONE, &error));
   BSON_ASSERT (
      !bson_validate_with_error (b, BSON_VALIDATE_DOLLAR_KEYS, &error));
   ASSERT_ERROR_CONTAINS (error,
                          BSON_ERROR_INVALID,
                          BSON_VALIDATE_DOLLAR_KEYS,
                          ""keys cannot begin with \""$\"": \""$id\"""");
   bson_destroy (b);

   
   b = BCON_NEW (""my_dbref"",
                 ""{"",
                 ""$ref"",
                 BCON_UTF8 (""collection""),
                 ""$ref"",
                 BCON_UTF8 (""collection""),
                 ""}"");
   BSON_ASSERT (bson_validate_with_error (b, BSON_VALIDATE_NONE, &error));
   BSON_ASSERT (
      !bson_validate_with_error (b, BSON_VALIDATE_DOLLAR_KEYS, &error));
   ASSERT_ERROR_CONTAINS (error,
                          BSON_ERROR_INVALID,
                          BSON_VALIDATE_DOLLAR_KEYS,
                          ""keys cannot begin with \""$\"": \""$ref\"""");
   bson_destroy (b);

   
   b = BCON_NEW (""my_dbref"",
                 ""{"",
                 ""$ref"",
                 BCON_UTF8 (""collection""),
                 ""extra"",
                 BCON_INT32 (2),
                 ""$id"",
                 BCON_INT32 (1),
                 ""}"");
   BSON_ASSERT (bson_validate_with_error (b, BSON_VALIDATE_NONE, &error));
   BSON_ASSERT (
      !bson_validate_with_error (b, BSON_VALIDATE_DOLLAR_KEYS, &error));
   ASSERT_ERROR_CONTAINS (error,
                          BSON_ERROR_INVALID,
                          BSON_VALIDATE_DOLLAR_KEYS,
                          ""invalid key within DBRef subdocument: \""extra\"""");
   bson_destroy (b);

#undef VALIDATE_TEST
}
","1. int i;
2. b = get_bson (filename);
BSON_ASSERT (bson_validate (b, BSON_VALIDATE_NONE, &offset));
3. b = get_bson (""codewscope.bson"");
BSON_ASSERT (bson_validate (b, BSON_VALIDATE_NONE, &offset));
4. BSON_VALIDATE_DOT_KEYS,
5. VALIDATE_TEST (""trailingnull.bson"",
6. VALIDATE_TEST (""overflow3.bson"",
7. VALIDATE_TEST (""overflow3.bson"",
8. VALIDATE_TEST (""overflow4.bson"",
9. VALIDATE_TEST (
10. VALIDATE_TEST (
11. VALIDATE_TEST (
12. VALIDATE_TEST (
13. VALIDATE_TEST (
14. VALIDATE_TEST (""test50.bson"",
15. VALIDATE_TEST (
16. VALIDATE_TEST (""test59.bson"",
17. BCON_UTF8 (""collection""),
""$id"",
BCON_INT32 (1),
18. bson_destroy (b);
19. ASSERT_ERROR_CONTAINS (error,
20. ""{"",
21. BCON_UTF8 (""collection""),
22. BCON_UTF8 (""collection""),
23. BSON_ASSERT (bson_validate_with_error (b, BSON_VALIDATE_NONE, &error));
BSON_ASSERT (
!bson_validate_with_error (b, BSON_VALIDATE_DOLLAR_KEYS, &error));
24. BSON_ERROR_INVALID,
25. ""{"",
26. BCON_UTF8 (""collection""),
""extra"",
BCON_INT32 (2),
27. ""}"");
28. BSON_ERROR_INVALID,
29. ""invalid key within DBRef subdocument: \""extra\"""");","6
11-12
16-17
24
41
56
62
67
77
81
85
91
93
97
109
116
126-128
133
140
148
150
152
154-156
158
165
167-169
172
177
179","CWE-200,CWE-125,CWE-94,CWE-552"
options_parse-269979932853079,"
#define CONF_TYPE

int options_parse(CONF_TYPE type) {
    SERVICE_OPTIONS *section;

    options_defaults();
    section=&new_service_options;
    
    if(options_file(configuration_file, type, &section) ||
            init_section(1, &section)) {
        s_log(LOG_ERR, ""Configuration failed"");
        options_free(0); 
        return 1;
    }
    s_log(LOG_NOTICE, ""Configuration successful"");
    return 0;
}
","1. options_defaults();
section=&new_service_options;",7-8,"CWE-476,CWE-787,CWE-119"
gen_values-82660388429159,"static int
gen_values(codegen_scope *s, node *t, int val, int limit)
{
  int n = 0;
  int first = 1;
  int slimit = GEN_VAL_STACK_MAX;

  if (limit == 0) limit = GEN_LIT_ARY_MAX;
  if (cursp() >= slimit) slimit = INT16_MAX;

  if (!val) {
    while (t) {
      codegen(s, t->car, NOVAL);
      n++;
      t = t->cdr;
    }
    return n;
  }

  while (t) {
    int is_splat = nint(t->car->car) == NODE_SPLAT;

    if (is_splat || cursp() >= slimit) { 
      pop_n(n);
      if (first) {
        if (n == 0) {
          genop_1(s, OP_LOADNIL, cursp());
        }
        else {
          genop_2(s, OP_ARRAY, cursp(), n);
        }
        push();
        first = 0;
        limit = GEN_LIT_ARY_MAX;
      }
      else if (n > 0) {
        pop();
        genop_2(s, OP_ARYPUSH, cursp(), n);
        push();
      }
      n = 0;
    }
    codegen(s, t->car, val);
    if (is_splat) {
      pop(); pop();
      genop_1(s, OP_ARYCAT, cursp());
      push();
    }
    else {
      n++;
    }
    t = t->cdr;
  }
  if (!first) {
    pop();
    if (n > 0) {
      pop_n(n);
      genop_2(s, OP_ARYPUSH, cursp(), n);
    }
    return -1;                  
  }
  else if (n > limit) {
    pop_n(n);
    genop_2(s, OP_ARRAY, cursp(), n);
    return -1;
  }
  return n;
}
","1. int n = 0;
2. if (limit == 0) limit = GEN_LIT_ARY_MAX;
3. while (t) {
4. return n;
5. if (first) {
6. first = 0;
7. pop();
8. codegen(s, t->car, val);
if (is_splat) {
9. genop_1(s, OP_ARYCAT, cursp());
10. t = t->cdr;
11. pop();
if (n > 0) {
12. pop_n(n);
genop_2(s, OP_ARRAY, cursp(), n);
return -1;","4
8
12
17
25
33
37
43-44
46
52
55-56
63-65","CWE-476,CWE-125,CWE-119"
ntlm_read_message_fields-258977843872492,"
#define NTLM_MESSAGE_FIELDS

static int ntlm_read_message_fields(wStream* s, NTLM_MESSAGE_FIELDS* fields)
{
	if (Stream_GetRemainingLength(s) < 8)
		return -1;

	Stream_Read_UINT16(s, fields->Len); 
	Stream_Read_UINT16(s, fields->MaxLen); 
	Stream_Read_UINT32(s, fields->BufferOffset); 
	return 1;
}
","1. static int ntlm_read_message_fields(wStream* s, NTLM_MESSAGE_FIELDS* fields)
2. if (Stream_GetRemainingLength(s) < 8)
return -1;
3. Stream_Read_UINT16(s, fields->Len);
Stream_Read_UINT16(s, fields->MaxLen);
Stream_Read_UINT32(s, fields->BufferOffset);
return 1;","4
6-7
9-12","CWE-125,CWE-119"
syscall_cryp_state_copy-71540481170859,"TEE_Result syscall_cryp_state_copy(unsigned long dst, unsigned long src)
{
	TEE_Result res;
	struct tee_cryp_state *cs_dst;
	struct tee_cryp_state *cs_src;
	struct tee_ta_session *sess;

	res = tee_ta_get_current_session(&sess);
	if (res != TEE_SUCCESS)
		return res;

	res = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(dst), &cs_dst);
	if (res != TEE_SUCCESS)
		return res;

	res = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(src), &cs_src);
	if (res != TEE_SUCCESS)
		return res;
	if (cs_dst->algo != cs_src->algo || cs_dst->mode != cs_src->mode)
		return TEE_ERROR_BAD_PARAMETERS;

	switch (TEE_ALG_GET_CLASS(cs_src->algo)) {
	case TEE_OPERATION_CIPHER:
		crypto_cipher_copy_state(cs_dst->ctx, cs_src->ctx,
					 cs_src->algo);
		break;
	case TEE_OPERATION_AE:
		crypto_authenc_copy_state(cs_dst->ctx, cs_src->ctx,
					  cs_src->algo);
		break;
	case TEE_OPERATION_DIGEST:
		crypto_hash_copy_state(cs_dst->ctx, cs_src->ctx, cs_src->algo);
		break;
	case TEE_OPERATION_MAC:
		crypto_mac_copy_state(cs_dst->ctx, cs_src->ctx, cs_src->algo);
		break;
	default:
		return TEE_ERROR_BAD_STATE;
	}

	cs_dst->state = cs_src->state;

	return TEE_SUCCESS;
}
","1. if (res != TEE_SUCCESS)
2. switch (TEE_ALG_GET_CLASS(cs_src->algo)) {","17
22","CWE-310,CWE-358,CWE-362,CWE-190,CWE-125"
pit_ioport_read-88971637389130,"static int pit_ioport_read(struct kvm_io_device *this,
			   gpa_t addr, int len, void *data)
{
	struct kvm_pit *pit = dev_to_pit(this);
	struct kvm_kpit_state *pit_state = &pit->pit_state;
	struct kvm *kvm = pit->kvm;
	int ret, count;
	struct kvm_kpit_channel_state *s;
	if (!pit_in_range(addr))
		return -EOPNOTSUPP;

	addr &= KVM_PIT_CHANNEL_MASK;
	if (addr == 3)
		return 0;

	s = &pit_state->channels[addr];

	mutex_lock(&pit_state->lock);

	if (s->status_latched) {
		s->status_latched = 0;
		ret = s->status;
	} else if (s->count_latched) {
		switch (s->count_latched) {
		default:
		case RW_STATE_LSB:
			ret = s->latched_count & 0xff;
			s->count_latched = 0;
			break;
		case RW_STATE_MSB:
			ret = s->latched_count >> 8;
			s->count_latched = 0;
			break;
		case RW_STATE_WORD0:
			ret = s->latched_count & 0xff;
			s->count_latched = RW_STATE_MSB;
			break;
		}
	} else {
		switch (s->read_state) {
		default:
		case RW_STATE_LSB:
			count = pit_get_count(kvm, addr);
			ret = count & 0xff;
			break;
		case RW_STATE_MSB:
			count = pit_get_count(kvm, addr);
			ret = (count >> 8) & 0xff;
			break;
		case RW_STATE_WORD0:
			count = pit_get_count(kvm, addr);
			ret = count & 0xff;
			s->read_state = RW_STATE_WORD1;
			break;
		case RW_STATE_WORD1:
			count = pit_get_count(kvm, addr);
			ret = (count >> 8) & 0xff;
			s->read_state = RW_STATE_WORD0;
			break;
		}
	}

	if (len > sizeof(ret))
		len = sizeof(ret);
	memcpy(data, (char *)&ret, len);

	mutex_unlock(&pit_state->lock);
	return 0;
}
","1. struct kvm_pit *pit = dev_to_pit(this);
2. addr &= KVM_PIT_CHANNEL_MASK;
3. break;
4. ret = count & 0xff;
5. break;
6. s->read_state = RW_STATE_WORD0;
7. if (len > sizeof(ret))","4
12
33
52
54
58
63","CWE-362,CWE-119,CWE-18,CWE-125,CWE-415"
ceph_x_verify_authorizer_reply-208677490259080,"static int ceph_x_verify_authorizer_reply(struct ceph_auth_client *ac,
					  struct ceph_authorizer *a, size_t len)
{
	struct ceph_x_authorizer *au = (void *)a;
	struct ceph_x_ticket_handler *th;
	int ret = 0;
	struct ceph_x_authorize_reply reply;
	void *preply = &reply;
	void *p = au->reply_buf;
	void *end = p + sizeof(au->reply_buf);

	th = get_ticket_handler(ac, au->service);
	if (IS_ERR(th))
		return PTR_ERR(th);
	ret = ceph_x_decrypt(&th->session_key, &p, end, &preply, sizeof(reply));
	if (ret < 0)
		return ret;
	if (ret != sizeof(reply))
		return -EPERM;

	if (au->nonce + 1 != le64_to_cpu(reply.nonce_plus_one))
		ret = -EPERM;
	else
		ret = 0;
	dout(""verify_authorizer_reply nonce %llx got %llx ret %d\n"",
	     au->nonce, le64_to_cpu(reply.nonce_plus_one), ret);
	return ret;
}
","1. struct ceph_authorizer *a, size_t len)
2. void *preply = &reply;
void *p = au->reply_buf;
3. th = get_ticket_handler(ac, au->service);
4. if (ret < 0)
5. if (ret != sizeof(reply))","2
8-9
12
16
18","CWE-119,CWE-264,CWE-79,CWE-416"
open_ssl_connection-70141634679793,"static SSL *
open_ssl_connection (rfbClient *client, int sockfd, rfbBool anonTLS, rfbCredential *cred)
{
  SSL_CTX *ssl_ctx = NULL;
  SSL *ssl = NULL;
  int n, finished = 0;
  X509_VERIFY_PARAM *param;
  uint8_t verify_crls;

  if (!(ssl_ctx = SSL_CTX_new(SSLv23_client_method())))
  {
    rfbClientLog(""Could not create new SSL context.\n"");
    return NULL;
  }

  param = X509_VERIFY_PARAM_new();

  
  if (!anonTLS)
  {
    verify_crls = cred->x509Credential.x509CrlVerifyMode;
    if (cred->x509Credential.x509CACertFile)
    {
      if (!SSL_CTX_load_verify_locations(ssl_ctx, cred->x509Credential.x509CACertFile, NULL))
      {
        rfbClientLog(""Failed to load CA certificate from %s.\n"",
                     cred->x509Credential.x509CACertFile);
        goto error_free_ctx;
      }
    } else {
      rfbClientLog(""Using default paths for certificate verification.\n"");
      SSL_CTX_set_default_verify_paths (ssl_ctx);
    }

    if (cred->x509Credential.x509CACrlFile)
    {
      if (!load_crls_from_file(cred->x509Credential.x509CACrlFile, ssl_ctx))
      {
        rfbClientLog(""CRLs could not be loaded.\n"");
        goto error_free_ctx;
      }
      if (verify_crls == rfbX509CrlVerifyNone) verify_crls = rfbX509CrlVerifyAll;
    }

    if (cred->x509Credential.x509ClientCertFile && cred->x509Credential.x509ClientKeyFile)
    {
      if (SSL_CTX_use_certificate_chain_file(ssl_ctx, cred->x509Credential.x509ClientCertFile) != 1)
      {
        rfbClientLog(""Client certificate could not be loaded.\n"");
        goto error_free_ctx;
      }

      if (SSL_CTX_use_PrivateKey_file(ssl_ctx, cred->x509Credential.x509ClientKeyFile,
                                      SSL_FILETYPE_PEM) != 1)
      {
        rfbClientLog(""Client private key could not be loaded.\n"");
        goto error_free_ctx;
      }

      if (SSL_CTX_check_private_key(ssl_ctx) == 0) {
        rfbClientLog(""Client certificate and private key do not match.\n"");
        goto error_free_ctx;
      }
    }

    SSL_CTX_set_verify(ssl_ctx, SSL_VERIFY_PEER, NULL);

    if (verify_crls == rfbX509CrlVerifyClient) 
      X509_VERIFY_PARAM_set_flags(param, X509_V_FLAG_CRL_CHECK);
    else if (verify_crls == rfbX509CrlVerifyAll)
      X509_VERIFY_PARAM_set_flags(param, X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL);

    if(!X509_VERIFY_PARAM_set1_host(param, client->serverHost, strlen(client->serverHost)))
    {
      rfbClientLog(""Could not set server name for verification.\n"");
      goto error_free_ctx;
    }
    SSL_CTX_set1_param(ssl_ctx, param);
  }

  if (!(ssl = SSL_new (ssl_ctx)))
  {
    rfbClientLog(""Could not create a new SSL session.\n"");
    goto error_free_ctx;
  }

  
  SSL_set_cipher_list(ssl, ""ALL"");

  SSL_set_fd (ssl, sockfd);
  SSL_CTX_set_app_data (ssl_ctx, client);

  do
  {
    n = SSL_connect(ssl);
		
    if (n != 1) 
    {
      if (wait_for_data(ssl, n, 1) != 1) 
      {
        finished = 1;
        SSL_shutdown(ssl);

        goto error_free_ssl;
      }
    }
  } while( n != 1 && finished != 1 );

  X509_VERIFY_PARAM_free(param);
  return ssl;

error_free_ssl:
  SSL_free(ssl);

error_free_ctx:
  X509_VERIFY_PARAM_free(param);
  SSL_CTX_free(ssl_ctx);

  return NULL;
}
","1. if (!(ssl_ctx = SSL_CTX_new(SSLv23_client_method())))
2. return NULL;
3. if (!anonTLS)
4. if (cred->x509Credential.x509ClientCertFile && cred->x509Credential.x509ClientKeyFile)
5. rfbClientLog(""Client certificate and private key do not match.\n"");
6. X509_VERIFY_PARAM_set_flags(param, X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL);
7. SSL_CTX_set1_param(ssl_ctx, param);
8. SSL_set_cipher_list(ssl, ""ALL"");
9. finished = 1;
SSL_shutdown(ssl);
10. X509_VERIFY_PARAM_free(param);
return ssl;
11. error_free_ssl:
12. X509_VERIFY_PARAM_free(param);
SSL_CTX_free(ssl_ctx);","10
13
19
45
61
71
78
88
101-102
109-110
112
116-117","CWE-264,CWE-190,CWE-200,CWE-17,CWE-399"
nci_extract_rf_params_nfca_passive_poll,"
#define __u8

static __u8 *nci_extract_rf_params_nfca_passive_poll(struct nci_dev *ndev,
			struct rf_tech_specific_params_nfca_poll *nfca_poll,
						     __u8 *data)
{
 	nfca_poll->sens_res = __le16_to_cpu(*((__u16 *)data));
 	data += 2;
 
	nfca_poll->nfcid1_len = min_t(__u8, *data++, NFC_NFCID1_MAXSIZE);
 
 	pr_debug(""sens_res 0x%x, nfcid1_len %d\n"",
 		 nfca_poll->sens_res, nfca_poll->nfcid1_len);

	memcpy(nfca_poll->nfcid1, data, nfca_poll->nfcid1_len);
	data += nfca_poll->nfcid1_len;

	nfca_poll->sel_res_len = *data++;

	if (nfca_poll->sel_res_len != 0)
		nfca_poll->sel_res = *data++;

	pr_debug(""sel_res_len %d, sel_res 0x%x\n"",
		 nfca_poll->sel_res_len,
		 nfca_poll->sel_res);

	return data;
}
","1. struct rf_tech_specific_params_nfca_poll *nfca_poll,
__u8 *data)
2. data += 2;
3. nfca_poll->sens_res, nfca_poll->nfcid1_len);
4. memcpy(nfca_poll->nfcid1, data, nfca_poll->nfcid1_len);
data += nfca_poll->nfcid1_len;
5. nfca_poll->sel_res_len = *data++;
6. if (nfca_poll->sel_res_len != 0)
7. pr_debug(""sel_res_len %d, sel_res 0x%x\n"",
8. nfca_poll->sel_res);
9. return data;","5-6
9
14
16-17
19
21
24
26
28","CWE-189,CWE-119"
StopInputMethodProcess,"  bool StopInputMethodProcess() {
  
  virtual bool StopInputMethodProcess() {
     if (!IBusConnectionsAreAlive()) {
       LOG(ERROR) << ""StopInputMethodProcess: IBus connection is not alive"";
       return false;
    }

    ibus_bus_exit_async(ibus_,
                        FALSE  ,
                        -1  ,
                        NULL  ,
                        NULL  ,
                        NULL  );

    if (ibus_config_) {
      g_object_unref(ibus_config_);
      ibus_config_ = NULL;
    }
     return true;
   }
",1. NULL  );,14,"CWE-476,CWE-358,CWE-416"
xen_free_irq_1-63127338352331,"static void xen_free_irq_1(unsigned irq)
{
	struct irq_info *info = info_for_irq(irq);
	unsigned long flags;

	if (WARN_ON(!info))
		return;

	write_lock_irqsave(&evtchn_rwlock, flags);

	if (!list_empty(&info->eoi_list))
		lateeoi_list_del(info);

	list_del(&info->list);

	set_info_for_irq(irq, NULL);

	WARN_ON(info->refcnt > 0);

	write_unlock_irqrestore(&evtchn_rwlock, flags);

	kfree(info);

	
	if (irq < nr_legacy_irqs())
		return;

	irq_free_desc(irq);
}
","1. return;
2. write_lock_irqsave(&evtchn_rwlock, flags);
3. if (!list_empty(&info->eoi_list))
lateeoi_list_del(info);
4. set_info_for_irq(irq, NULL);
5. write_unlock_irqrestore(&evtchn_rwlock, flags);","7
9
11-12
16
20","CWE-362,CWE-416,CWE-119"
nfssvc_decode_readlinkargs,"
#define __be32

nfssvc_decode_readlinkargs(struct svc_rqst *rqstp, __be32 *p, struct nfsd_readlinkargs *args)
{
 	p = decode_fh(p, &args->fh);
 	if (!p)
 		return 0;
	if (!xdr_argsize_check(rqstp, p))
		return 0;
 	args->buffer = page_address(*(rqstp->rq_next_page++));
 
	return 1;
 }
","1. if (!p)
2. if (!xdr_argsize_check(rqstp, p))","7
9","CWE-125,CWE-416"
_single_string_alloc_and_expand-12854419930553,"
#define LPCSTR

SQLWCHAR* _single_string_alloc_and_expand( LPCSTR in )
{
    SQLWCHAR *chr;
    int len = 0;

    if ( !in )
    {
        return NULL;
    }

    while ( in[ len ] != 0 )
    {
        len ++;
    }

    chr = malloc( sizeof( SQLWCHAR ) * ( len + 1 ));

    len = 0;
    while ( in[ len ] != 0 )
    {
        chr[ len ] = in[ len ];
        len ++;
    }
    chr[ len ++ ] = 0;

    return chr;
}
","1. SQLWCHAR* _single_string_alloc_and_expand( LPCSTR in )
2. while ( in[ len ] != 0 )
3. len = 0;","4
14
21",CWE-119
grub_ext2_iterate_dir,"grub_ext2_iterate_dir (grub_fshelp_node_t dir,
		       int (*hook) (const char *filename,
				    enum grub_fshelp_filetype filetype,
				    grub_fshelp_node_t node,
				    void *closure),
		       void *closure)
{
  unsigned int fpos = 0;
  struct grub_fshelp_node *diro = (struct grub_fshelp_node *) dir;

  if (! diro->inode_read)
    {
      grub_ext2_read_inode (diro->data, diro->ino, &diro->inode);
      if (grub_errno)
	return 0;
    }

  
  if (hook)
  while (fpos < grub_le_to_cpu32 (diro->inode.size))
    {
      struct ext2_dirent dirent;

      grub_ext2_read_file (diro, NULL, NULL, 0, fpos, sizeof (dirent),
			   (char *) &dirent);
      if (grub_errno)
	return 0;

      if (dirent.direntlen == 0)
        return 0;
 
       if (dirent.namelen != 0)
 	{
 	  char * filename = grub_malloc (dirent.namelen + 1);
 	  struct grub_fshelp_node *fdiro;
 	  enum grub_fshelp_filetype type = GRUB_FSHELP_UNKNOWN;
 
if (!filename) {
break;
}
 	  grub_ext2_read_file (diro, 0, 0, 0,
 			       fpos + sizeof (struct ext2_dirent),
 			       dirent.namelen, filename);
	  if (grub_errno) {
            free (filename);
 	    return 0;
	  }
 
 	  fdiro = grub_malloc (sizeof (struct grub_fshelp_node));
	  if (! fdiro) {
            free (filename);
 	    return 0;
          }
 
 	  fdiro->data = diro->data;
 	  fdiro->ino = grub_le_to_cpu32 (dirent.inode);

	  filename[dirent.namelen] = '\0';

	  if (dirent.filetype != FILETYPE_UNKNOWN)
	    {
	      fdiro->inode_read = 0;

	      if (dirent.filetype == FILETYPE_DIRECTORY)
		type = GRUB_FSHELP_DIR;
	      else if (dirent.filetype == FILETYPE_SYMLINK)
		type = GRUB_FSHELP_SYMLINK;
	      else if (dirent.filetype == FILETYPE_REG)
		type = GRUB_FSHELP_REG;
	    }
	  else
	    {
	      
 	      grub_ext2_read_inode (diro->data,
                                     grub_le_to_cpu32 (dirent.inode),
 				    &fdiro->inode);
	      if (grub_errno) {
                  free (filename);
 		  grub_free (fdiro);
 		  return 0;
 		}

	      fdiro->inode_read = 1;

	      if ((grub_le_to_cpu16 (fdiro->inode.mode)
		   & FILETYPE_INO_MASK) == FILETYPE_INO_DIRECTORY)
		type = GRUB_FSHELP_DIR;
	      else if ((grub_le_to_cpu16 (fdiro->inode.mode)
			& FILETYPE_INO_MASK) == FILETYPE_INO_SYMLINK)
		type = GRUB_FSHELP_SYMLINK;
	      else if ((grub_le_to_cpu16 (fdiro->inode.mode)
			& FILETYPE_INO_MASK) == FILETYPE_INO_REG)
 		type = GRUB_FSHELP_REG;
 	    }
 
	  if (hook (filename, type, fdiro, closure)) {
            free (filename);
 	    return 1;
          }
          free (filename);
 	}
 
       fpos += grub_le_to_cpu16 (dirent.direntlen);
    }

  return 0;
}
","1. grub_ext2_iterate_dir (grub_fshelp_node_t dir,
int (*hook) (const char *filename,
2. void *closure)
3. struct grub_fshelp_node *diro = (struct grub_fshelp_node *) dir;
4. if (! diro->inode_read)
5. grub_ext2_read_inode (diro->data, diro->ino, &diro->inode);
6. return 0;
7. if (hook)
while (fpos < grub_le_to_cpu32 (diro->inode.size))
8. grub_ext2_read_file (diro, NULL, NULL, 0, fpos, sizeof (dirent),
(char *) &dirent);
if (grub_errno)
return 0;
9. if (dirent.direntlen == 0)
return 0;
10. if (dirent.namelen != 0)
11. char * filename = grub_malloc (dirent.namelen + 1);
struct grub_fshelp_node *fdiro;
12. break;
13. fpos + sizeof (struct ext2_dirent),
14. fdiro = grub_malloc (sizeof (struct grub_fshelp_node));
15. free (filename);
return 0;
16. fdiro->ino = grub_le_to_cpu32 (dirent.inode);
17. type = GRUB_FSHELP_DIR;
18. else if (dirent.filetype == FILETYPE_REG)
type = GRUB_FSHELP_REG;
19. grub_le_to_cpu32 (dirent.inode),
&fdiro->inode);
20. free (filename);
grub_free (fdiro);
return 0;
21. fdiro->inode_read = 1;
22. if ((grub_le_to_cpu16 (fdiro->inode.mode)
& FILETYPE_INO_MASK) == FILETYPE_INO_DIRECTORY)
23. else if ((grub_le_to_cpu16 (fdiro->inode.mode)
& FILETYPE_INO_MASK) == FILETYPE_INO_SYMLINK)
24. else if ((grub_le_to_cpu16 (fdiro->inode.mode)
& FILETYPE_INO_MASK) == FILETYPE_INO_REG)
25. if (hook (filename, type, fdiro, closure)) {
free (filename);
return 1;
26. free (filename);
27. fpos += grub_le_to_cpu16 (dirent.direntlen);
28. return 0;","1-2
6
9
11
13
15
19-20
24-27
29-30
32
34-35
39
42
49
51-52
56
65
68-69
76-77
79-81
84
86-87
89-90
92-93
97-99
101
104
107","CWE-770,CWE-264,CWE-787,CWE-119"
pdf_summarize-270270729660848,"
#define FILE

void pdf_summarize(
    FILE        *fp,
    const pdf_t *pdf,
    const char  *name,
    pdf_flag_t   flags)
{
    int   i, j, page, n_versions, n_entries;
    FILE *dst, *out;
    char *dst_name, *c;

    dst = NULL;
    dst_name = NULL;

    if (name)
    {
        dst_name = safe_calloc(strlen(name) * 2 + 16);
        sprintf(dst_name, ""%s/%s"", name, name);

        if ((c = strrchr(dst_name, '.')) && (strncmp(c, "".pdf"", 4) == 0))
          *c = '\0';

        strcat(dst_name, "".summary"");
        if (!(dst = fopen(dst_name, ""w"")))
        {
            ERR(""Could not open file '%s' for writing\n"", dst_name);
            return;
        }
    }
    
    
    out = (dst) ? dst : stdout;

    
    n_versions = pdf->n_xrefs;
    if (n_versions && pdf->xrefs[0].is_linear)
      --n_versions;

    
    for (i=1; i<pdf->n_xrefs; ++i)
      if (pdf->xrefs[i].end == 0)
        --n_versions;

    
    if (!pdf->n_xrefs || (!n_versions && pdf->xrefs[0].is_linear))
      n_versions = 1;

    
    n_entries = 0;
    for (i=0; !(const int)pdf->has_xref_streams && i<pdf->n_xrefs; i++)
    {
        if (flags & PDF_FLAG_QUIET)
          continue;

        for (j=0; j<pdf->xrefs[i].n_entries; j++)
        {
            ++n_entries;
            fprintf(out,
                    ""%s: --%c-- Version %d -- Object %d (%s)"",
                    pdf->name,
                    pdf_get_object_status(pdf, i, j),
                    pdf->xrefs[i].version,
                    pdf->xrefs[i].entries[j].obj_id,
                    get_type(fp, pdf->xrefs[i].entries[j].obj_id,
                             &pdf->xrefs[i]));

            

            if (0 )
              fprintf(out, "" Page(%d)\n"", page);
            else
              fprintf(out, ""\n"");
        }
    }

    
    if (!(flags & PDF_FLAG_QUIET))
    {
        
        if (pdf->has_xref_streams || !n_entries)
           fprintf(out,
               ""%s: This PDF contains potential cross reference streams.\n""
               ""%s: An object summary is not available.\n"",
               pdf->name,
               pdf->name);

        fprintf(out,
                ""---------- %s ----------\n""
                ""Versions: %d\n"", 
                pdf->name,
                n_versions);

        
        if (!pdf->has_xref_streams)
          for (i=0; i<pdf->n_xrefs; i++)
          {
              if (pdf->xrefs[i].is_linear)
                continue;

              n_entries = pdf->xrefs[i].n_entries;

              
              if (pdf->xrefs[0].is_linear)
                n_entries += pdf->xrefs[0].n_entries; 

              if (pdf->xrefs[i].version && n_entries)
                fprintf(out,
                        ""Version %d -- %d objects\n"",
                        pdf->xrefs[i].version, 
                        n_entries);
           }
    }
    else 
      fprintf(out, ""%s: %d\n"", pdf->name, n_versions);

    if (dst)
    {
        fclose(dst);
        free(dst_name);
    }
}
","1. const char  *name,
2. char *dst_name, *c;
3. ERR(""Could not open file '%s' for writing\n"", dst_name);
4. for (j=0; j<pdf->xrefs[i].n_entries; j++)
5. n_entries += pdf->xrefs[0].n_entries;","7
12
28
57
113","CWE-22,CWE-276,CWE-787,CWE-552"
close_connection,"void close_connection(h2o_http2_conn_t *conn)
int close_connection(h2o_http2_conn_t *conn)
 {
     conn->state = H2O_HTTP2_CONN_STATE_IS_CLOSING;
 
     if (conn->_write.buf_in_flight != NULL || h2o_timeout_is_linked(&conn->_write.timeout_entry)) {
         
     } else {
         close_connection_now(conn);
        return -1;
     }
    return 0;
 }
","1. if (conn->_write.buf_in_flight != NULL || h2o_timeout_is_linked(&conn->_write.timeout_entry)) {
2. } else {","6
8","CWE-287,CWE-120,CWE-787,CWE-399"
evtchn_fifo_percpu_deinit-96121985099877,"static int evtchn_fifo_percpu_deinit(unsigned int cpu)
{
	__evtchn_fifo_handle_events(cpu, NULL);
	return 0;
}
","1. static int evtchn_fifo_percpu_deinit(unsigned int cpu)
2. __evtchn_fifo_handle_events(cpu, NULL);
return 0;","1
3-4","CWE-399,CWE-119"
ssl23_get_client_method,"static const SSL_METHOD *ssl23_get_client_method(int ver)
	{
#ifndef OPENSSL_NO_SSL2
        if (ver == SSL2_VERSION)
                return(SSLv2_client_method());
 #endif
#ifndef OPENSSL_NO_SSL3
        if (ver == SSL3_VERSION)
                return(SSLv3_client_method());
#endif
       if (ver == TLS1_VERSION)
                return(TLSv1_client_method());
        else if (ver == TLS1_1_VERSION)
                return(TLSv1_1_client_method());
	else
		return(NULL);
	}
","1. static const SSL_METHOD *ssl23_get_client_method(int ver)
2. return(SSLv2_client_method());
3. if (ver == SSL3_VERSION)
return(SSLv3_client_method());
4. return(TLSv1_1_client_method());","1
5
8-9
14","CWE-310,CWE-20,CWE-327,CWE-354,CWE-122"
ih264d_parse_islice,"
#define UWORD16

WORD32 ih264d_parse_islice(dec_struct_t *ps_dec,
                            UWORD16 u2_first_mb_in_slice)
{
 dec_pic_params_t * ps_pps = ps_dec->ps_cur_pps;
 dec_slice_params_t * ps_slice = ps_dec->ps_cur_slice;
    UWORD32 *pu4_bitstrm_buf = ps_dec->ps_bitstrm->pu4_buffer;
    UWORD32 *pu4_bitstrm_ofst = &ps_dec->ps_bitstrm->u4_ofst;
    UWORD32 u4_temp;
    WORD32 i_temp;
    WORD32 ret;

 
 
 
 
 

     if(ps_slice->u1_nal_ref_idc != 0)
     {
         if(!ps_dec->ps_dpb_cmds->u1_dpb_commands_read)
        {
            i_temp = ih264d_read_mmco_commands(ps_dec);
            if (i_temp < 0)
            {
                return ERROR_DBP_MANAGER_T;
            }
            ps_dec->u4_bitoffset = i_temp;
        }
         else
             ps_dec->ps_bitstrm->u4_ofst += ps_dec->u4_bitoffset;
     }
 

 
    i_temp = ps_pps->u1_pic_init_qp
 + ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 if((i_temp < 0) || (i_temp > 51))
 return ERROR_INV_RANGE_QP_T;
    ps_slice->u1_slice_qp = i_temp;
    COPYTHECONTEXT(""SH: slice_qp_delta"",
                    ps_slice->u1_slice_qp - ps_pps->u1_pic_init_qp);

 if(ps_pps->u1_deblocking_filter_parameters_present_flag == 1)
 {
        u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
        COPYTHECONTEXT(""SH: disable_deblocking_filter_idc"", u4_temp);

 if(u4_temp > SLICE_BOUNDARY_DBLK_DISABLED)
 {
 return ERROR_INV_SLICE_HDR_T;
 }
        ps_slice->u1_disable_dblk_filter_idc = u4_temp;
 if(u4_temp != 1)
 {
            i_temp = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf)
 << 1;
 if((MIN_DBLK_FIL_OFF > i_temp) || (i_temp > MAX_DBLK_FIL_OFF))
 {
 return ERROR_INV_SLICE_HDR_T;
 }
            ps_slice->i1_slice_alpha_c0_offset = i_temp;
            COPYTHECONTEXT(""SH: slice_alpha_c0_offset_div2"",
                            ps_slice->i1_slice_alpha_c0_offset >> 1);

            i_temp = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf)
 << 1;
 if((MIN_DBLK_FIL_OFF > i_temp) || (i_temp > MAX_DBLK_FIL_OFF))
 {
 return ERROR_INV_SLICE_HDR_T;
 }
            ps_slice->i1_slice_beta_offset = i_temp;
            COPYTHECONTEXT(""SH: slice_beta_offset_div2"",
                            ps_slice->i1_slice_beta_offset >> 1);

 }
 else
 {
            ps_slice->i1_slice_alpha_c0_offset = 0;
            ps_slice->i1_slice_beta_offset = 0;
 }
 }
 else
 {
        ps_slice->u1_disable_dblk_filter_idc = 0;
        ps_slice->i1_slice_alpha_c0_offset = 0;
        ps_slice->i1_slice_beta_offset = 0;
 }

 
 
    ps_dec->u2_mv_2mb[0] = 0;
    ps_dec->u2_mv_2mb[1] = 0;


 
    ps_dec->u1_slice_header_done = 2;

 if(ps_pps->u1_entropy_coding_mode)
 {
        SWITCHOFFTRACE; SWITCHONTRACECABAC;
 if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag)
 {
            ps_dec->pf_get_mb_info = ih264d_get_mb_info_cabac_mbaff;
 }
 else
            ps_dec->pf_get_mb_info = ih264d_get_mb_info_cabac_nonmbaff;

        ret = ih264d_parse_islice_data_cabac(ps_dec, ps_slice,
                                             u2_first_mb_in_slice);
 if(ret != OK)
 return ret;
        SWITCHONTRACE; SWITCHOFFTRACECABAC;
 }
 else
 {
 if(ps_dec->ps_cur_slice->u1_mbaff_frame_flag)
 {
            ps_dec->pf_get_mb_info = ih264d_get_mb_info_cavlc_mbaff;
 }
 else
            ps_dec->pf_get_mb_info = ih264d_get_mb_info_cavlc_nonmbaff;
        ret = ih264d_parse_islice_data_cavlc(ps_dec, ps_slice,
                                       u2_first_mb_in_slice);
 if(ret != OK)
 return ret;
 }

 return OK;
}
","1. UWORD16 u2_first_mb_in_slice)
2. ps_slice->i1_slice_alpha_c0_offset = i_temp;
3. ps_slice->i1_slice_alpha_c0_offset >> 1);
4. << 1;
5. ps_slice->i1_slice_beta_offset = 0;
6. ps_dec->u2_mv_2mb[0] = 0;
7. return ret;","5
64
66
69
82
94
114","CWE-416,CWE-264,CWE-787,CWE-119"
ieee80211_sta_ps_deliver_wakeup,"void ieee80211_sta_ps_deliver_wakeup(struct sta_info *sta)
{
	struct ieee80211_sub_if_data *sdata = sta->sdata;
	struct ieee80211_local *local = sdata->local;
	struct sk_buff_head pending;
	int filtered = 0, buffered = 0, ac;
	unsigned long flags;

	clear_sta_flag(sta, WLAN_STA_SP);

	BUILD_BUG_ON(BITS_TO_LONGS(IEEE80211_NUM_TIDS) > 1);
	sta->driver_buffered_tids = 0;

	if (!(local->hw.flags & IEEE80211_HW_AP_LINK_PS))
		drv_sta_notify(local, sdata, STA_NOTIFY_AWAKE, &sta->sta);
 
 	skb_queue_head_init(&pending);
 
	
	spin_lock(&sta->ps_lock);
 	
 	for (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {
 		int count = skb_queue_len(&pending), tmp;

		spin_lock_irqsave(&sta->tx_filtered[ac].lock, flags);
		skb_queue_splice_tail_init(&sta->tx_filtered[ac], &pending);
		spin_unlock_irqrestore(&sta->tx_filtered[ac].lock, flags);
		tmp = skb_queue_len(&pending);
		filtered += tmp - count;
		count = tmp;

		spin_lock_irqsave(&sta->ps_tx_buf[ac].lock, flags);
		skb_queue_splice_tail_init(&sta->ps_tx_buf[ac], &pending);
		spin_unlock_irqrestore(&sta->ps_tx_buf[ac].lock, flags);
		tmp = skb_queue_len(&pending);
		buffered += tmp - count;
 	}
 
 	ieee80211_add_pending_skbs_fn(local, &pending, clear_sta_ps_flags, sta);
	spin_unlock(&sta->ps_lock);
 
 	
 	if (!ieee80211_smps_is_restrictive(sta->known_smps_mode,
					   sdata->smps_mode) &&
	    sta->known_smps_mode != sdata->bss->req_smps &&
	    sta_info_tx_streams(sta) != 1) {
		ht_dbg(sdata,
		       ""%pM just woke up and MIMO capable - update SMPS\n"",
		       sta->sta.addr);
		ieee80211_send_smps_action(sdata, sdata->bss->req_smps,
					   sta->sta.addr,
					   sdata->vif.bss_conf.bssid);
	}

	local->total_ps_buffered -= buffered;

	sta_info_recalc_tim(sta);

	ps_dbg(sdata,
	       ""STA %pM aid %d sending %d filtered/%d PS frames since STA not sleeping anymore\n"",
	       sta->sta.addr, sta->sta.aid, filtered, buffered);
}
","1. struct ieee80211_sub_if_data *sdata = sta->sdata;
2. clear_sta_flag(sta, WLAN_STA_SP);
3. for (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {
int count = skb_queue_len(&pending), tmp;
4. skb_queue_splice_tail_init(&sta->tx_filtered[ac], &pending);
5. sta_info_tx_streams(sta) != 1) {
6. ieee80211_send_smps_action(sdata, sdata->bss->req_smps,
7. sdata->vif.bss_conf.bssid);
8. sta_info_recalc_tim(sta);
9. ps_dbg(sdata,","3
9
22-23
26
46
50
52
57
59","CWE-362,CWE-17,CWE-787,CWE-399"
rfcomm_sock_bind," static int rfcomm_sock_bind(struct socket *sock, struct sockaddr *addr, int addr_len)
 {
	struct sockaddr_rc sa;
 	struct sock *sk = sock->sk;
	int len, err = 0;
 
 	if (!addr || addr->sa_family != AF_BLUETOOTH)
 		return -EINVAL;
 
	memset(&sa, 0, sizeof(sa));
	len = min_t(unsigned int, sizeof(sa), addr_len);
	memcpy(&sa, addr, len);

	BT_DBG(""sk %p %pMR"", sk, &sa.rc_bdaddr);

 	lock_sock(sk);
 
 	if (sk->sk_state != BT_OPEN) {
		err = -EBADFD;
		goto done;
	}

	if (sk->sk_type != SOCK_STREAM) {
		err = -EINVAL;
		goto done;
	}
 
 	write_lock(&rfcomm_sk_list.lock);
 
	if (sa.rc_channel &&
	    __rfcomm_get_listen_sock_by_addr(sa.rc_channel, &sa.rc_bdaddr)) {
 		err = -EADDRINUSE;
 	} else {
 		
		bacpy(&rfcomm_pi(sk)->src, &sa.rc_bdaddr);
		rfcomm_pi(sk)->channel = sa.rc_channel;
 		sk->sk_state = BT_BOUND;
 	}
 
	write_unlock(&rfcomm_sk_list.lock);

done:
	release_sock(sk);
	return err;
}
","1. static int rfcomm_sock_bind(struct socket *sock, struct sockaddr *addr, int addr_len)
2. struct sockaddr_rc sa;
struct sock *sk = sock->sk;
int len, err = 0;
3. return -EINVAL;
4. memcpy(&sa, addr, len);
5. lock_sock(sk);
6. err = -EBADFD;
goto done;
7. if (sk->sk_type != SOCK_STREAM) {
8. goto done;
9. write_lock(&rfcomm_sk_list.lock);
10. if (sa.rc_channel &&
11. } else {
12. bacpy(&rfcomm_pi(sk)->src, &sa.rc_bdaddr);
13. sk->sk_state = BT_BOUND;
14. write_unlock(&rfcomm_sk_list.lock);
15. done:
16. return err;","1
3-5
8
12
16
19-20
23
25
28
30
33
35
37
40
42
44","CWE-476,CWE-284,CWE-189,CWE-119"
x509stack_peek_level-131282373124804,"unsigned int
x509stack_peek_level(struct cert_stack *stack)
{
	struct metadata_node *meta = SLIST_FIRST(&stack->metas);
	return (meta != NULL) ? meta->level : 0;
}
",1. struct metadata_node *meta = SLIST_FIRST(&stack->metas);,4,"CWE-190,CWE-264,CWE-399,CWE-416"
vcc_recvmsg_1-26958891640664,"int vcc_recvmsg_1(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,
		size_t size, int flags)
{
	struct sock *sk = sock->sk;
	struct atm_vcc *vcc;
	struct sk_buff *skb;
	int copied, error = -EINVAL;

	if (sock->state != SS_CONNECTED)
		return -ENOTCONN;

	
	if (flags & ~(MSG_DONTWAIT | MSG_PEEK))
		return -EOPNOTSUPP;

	vcc = ATM_SD(sock);
	if (test_bit(ATM_VF_RELEASED, &vcc->flags) ||
	    test_bit(ATM_VF_CLOSE, &vcc->flags) ||
	    !test_bit(ATM_VF_READY, &vcc->flags))
		return 0;

	skb = skb_recv_datagram(sk, flags, flags & MSG_DONTWAIT, &error);
	if (!skb)
		return error;

	copied = skb->len;
	if (copied > size) {
		copied = size;
		msg->msg_flags |= MSG_TRUNC;
	}

	error = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);
	if (error)
		return error;
	sock_recv_ts_and_drops(msg, sk, skb);

	if (!(flags & MSG_PEEK)) {
		pr_debug(""%d -= %d\n"", atomic_read(&sk->sk_rmem_alloc),
			 skb->truesize);
		atm_return(vcc, skb->truesize);
	}

	skb_free_datagram(sk, skb);
	return copied;
}
","1. int vcc_recvmsg_1(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,
2. return -EOPNOTSUPP;
3. test_bit(ATM_VF_CLOSE, &vcc->flags) ||
4. if (!(flags & MSG_PEEK)) {","1
14
18
37","CWE-200,CWE-20"
ipv4_pktinfo_prepare-40839431740172,"void ipv4_pktinfo_prepare(const struct sock *sk, struct sk_buff *skb)
{
	struct in_pktinfo *pktinfo = PKTINFO_SKB_CB(skb);
	bool prepare = (inet_sk(sk)->cmsg_flags & IP_CMSG_PKTINFO) ||
		       ipv6_sk_rxinfo(sk);

	if (prepare && skb_rtable(skb)) {
		
		if (pktinfo->ipi_ifindex == LOOPBACK_IFINDEX)
			pktinfo->ipi_ifindex = inet_iif(skb);

		pktinfo->ipi_spec_dst.s_addr = fib_compute_spec_dst(skb);
	} else {
		pktinfo->ipi_ifindex = 0;
		pktinfo->ipi_spec_dst.s_addr = 0;
	}
	
	if (unlikely(IPCB(skb)->opt.optlen))
		skb_dst_force(skb);
	else
		skb_dst_drop(skb);
}
","1. struct in_pktinfo *pktinfo = PKTINFO_SKB_CB(skb);
bool prepare = (inet_sk(sk)->cmsg_flags & IP_CMSG_PKTINFO) ||
2. if (prepare && skb_rtable(skb)) {
3. pktinfo->ipi_ifindex = inet_iif(skb);
4. pktinfo->ipi_spec_dst.s_addr = fib_compute_spec_dst(skb);
} else {
pktinfo->ipi_ifindex = 0;
5. skb_dst_drop(skb);","3-4
7
18
20-22
32","CWE-476,CWE-17,CWE-284"
xmlParseAttributeListDecl,"xmlParseAttributeListDecl(xmlParserCtxtPtr ctxt) {
    const xmlChar *elemName;
    const xmlChar *attrName;
    xmlEnumerationPtr tree;

    if (CMP9(CUR_PTR, '<', '!', 'A', 'T', 'T', 'L', 'I', 'S', 'T')) {
	xmlParserInputPtr input = ctxt->input;

	SKIP(9);
	if (!IS_BLANK_CH(CUR)) {
	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
		                 ""Space required after '<!ATTLIST'\n"");
	}
        SKIP_BLANKS;
        elemName = xmlParseName(ctxt);
	if (elemName == NULL) {
	    xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
			   ""ATTLIST: no name for Element\n"");
	    return;
 	}
 	SKIP_BLANKS;
 	GROW;
	while ((RAW != '>') && (ctxt->instate != XML_PARSER_EOF)) {
 	    const xmlChar *check = CUR_PTR;
 	    int type;
 	    int def;
	    xmlChar *defaultValue = NULL;

	    GROW;
            tree = NULL;
	    attrName = xmlParseName(ctxt);
	    if (attrName == NULL) {
		xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
			       ""ATTLIST: no name for Attribute\n"");
		break;
	    }
	    GROW;
	    if (!IS_BLANK_CH(CUR)) {
		xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
		        ""Space required after the attribute name\n"");
		break;
	    }
	    SKIP_BLANKS;

	    type = xmlParseAttributeType(ctxt, &tree);
	    if (type <= 0) {
	        break;
	    }

	    GROW;
	    if (!IS_BLANK_CH(CUR)) {
		xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
			       ""Space required after the attribute type\n"");
	        if (tree != NULL)
		    xmlFreeEnumeration(tree);
		break;
	    }
	    SKIP_BLANKS;

	    def = xmlParseDefaultDecl(ctxt, &defaultValue);
	    if (def <= 0) {
                if (defaultValue != NULL)
		    xmlFree(defaultValue);
	        if (tree != NULL)
		    xmlFreeEnumeration(tree);
	        break;
	    }
	    if ((type != XML_ATTRIBUTE_CDATA) && (defaultValue != NULL))
	        xmlAttrNormalizeSpace(defaultValue, defaultValue);

	    GROW;
            if (RAW != '>') {
		if (!IS_BLANK_CH(CUR)) {
		    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
			""Space required after the attribute default value\n"");
		    if (defaultValue != NULL)
			xmlFree(defaultValue);
		    if (tree != NULL)
			xmlFreeEnumeration(tree);
		    break;
		}
		SKIP_BLANKS;
	    }
	    if (check == CUR_PTR) {
		xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
		            ""in xmlParseAttributeListDecl\n"");
		if (defaultValue != NULL)
		    xmlFree(defaultValue);
	        if (tree != NULL)
		    xmlFreeEnumeration(tree);
		break;
	    }
	    if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&
		(ctxt->sax->attributeDecl != NULL))
		ctxt->sax->attributeDecl(ctxt->userData, elemName, attrName,
	                        type, def, defaultValue, tree);
	    else if (tree != NULL)
		xmlFreeEnumeration(tree);

	    if ((ctxt->sax2) && (defaultValue != NULL) &&
	        (def != XML_ATTRIBUTE_IMPLIED) && 
		(def != XML_ATTRIBUTE_REQUIRED)) {
		xmlAddDefAttrs(ctxt, elemName, attrName, defaultValue);
	    }
	    if (ctxt->sax2) {
		xmlAddSpecialAttr(ctxt, elemName, attrName, type);
	    }
	    if (defaultValue != NULL)
	        xmlFree(defaultValue);
	    GROW;
	}
	if (RAW == '>') {
	    if (input != ctxt->input) {
		xmlValidityError(ctxt, XML_ERR_ENTITY_BOUNDARY,
    ""Attribute list declaration doesn't start and stop in the same entity\n"",
                                 NULL, NULL);
	    }
	    NEXT;
	}
    }
}
","1. const xmlChar *elemName;
2. if (!IS_BLANK_CH(CUR)) {
xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
3. int type;
int def;
4. tree = NULL;
attrName = xmlParseName(ctxt);
5. GROW;
6. break;
7. break;
8. SKIP_BLANKS;
9. xmlAttrNormalizeSpace(defaultValue, defaultValue);
10. if (!IS_BLANK_CH(CUR)) {
xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
""Space required after the attribute default value\n"");
11. break;
12. if (check == CUR_PTR) {
xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,
13. xmlFreeEnumeration(tree);
14. ctxt->sax->attributeDecl(ctxt->userData, elemName, attrName,
type, def, defaultValue, tree);
15. xmlFree(defaultValue);
16. NEXT;","2
10-11
25-26
30-31
37
41
56
58
69
73-75
80
84-85
90
95-96
109
118","CWE-59,CWE-119"
data_on_connection-111852731924987,"int data_on_connection(int fd, callback_remove_handler remove)
{
	int nread;
	char *network_packet;
	char network_line[8192];
	char *p;
	unsigned long id;

	char string[1024];
	unsigned long msg_id = UINT32_MAX;
	enum network_protocol version = network_client_get_version(fd);

	ioctl(fd, FIONREAD, &nread);

	univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""new connection data = %d\n"",nread);

	if(nread == 0)
	{
		univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_PROCESS, ""%d failed, got 0 close connection to listener "", fd);
		close(fd);
		FD_CLR(fd, &readfds);
		remove(fd);
		network_client_dump ();
		return 0;
	}


	if ( nread >= 8192 ) {

		univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ERROR, ""%d failed, more than 8192 close connection to listener "", fd);
		close(fd);
		FD_CLR(fd, &readfds);
		remove(fd);

		return 0;
	}

	
	network_packet=malloc((nread+1) * sizeof(char));
	read(fd, network_packet, nread);
	network_packet[nread]='\0';

	memset(network_line, 0, 8192);
	p=network_packet;
	p_sem(sem_id);

	while ( get_network_line(p, network_line) ) {

		if ( strlen(network_line) > 0 ) {
			univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""line = [%s]"",network_line);
		}

		
		if ( !strncmp(network_line, ""MSGID: "", strlen(""MSGID: "")) ) {
			

			msg_id=strtoul(&(network_line[strlen(""MSGID: "")]), NULL, 10);

			p+=strlen(network_line);


		} else if ( !strncmp(network_line, ""Version: "", strlen(""Version: "")) ) {
			char *head = network_line, *end;

			univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""RECV: VERSION"");

			version = strtoul(head + 9, &end, 10);
			if (!head[9] || *end)
				goto failed;

			univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""VERSION=%d"", version);

			if (version < network_procotol_version) {
				univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_PROCESS, ""Forbidden VERSION=%d < %d, close connection to listener"", version, network_procotol_version);
				goto close;
			} else if (version >= PROTOCOL_LAST) {
				univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_PROCESS, ""Future VERSION=%d"", version);
				version = PROTOCOL_LAST - 1;
			}
			network_client_set_version(fd, version);
			
			
			msg_id = UINT32_MAX;

			p+=strlen(network_line);


		} else if ( !strncmp(network_line, ""Capabilities: "", strlen(""Capabilities: "")) ) {

			univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""RECV: Capabilities"");

			if ( version > PROTOCOL_UNKNOWN ) {

				memset(string, 0, sizeof(string));
				
				snprintf(string, sizeof(string), ""Version: %d\nCapabilities: \n\n"", version);

				univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""SEND: %s"", string);

				write(fd, string, strlen(string));

			} else {
				
				univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""Capabilities recv, but no version line"");
				
			}

			p+=strlen(network_line);


		} else if ( !strncmp(network_line, ""GET_DN "", strlen(""GET_DN "")) && msg_id != UINT32_MAX && version > PROTOCOL_UNKNOWN && version < PROTOCOL_3) {

			univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""RECV: GET_DN"");

			id=strtoul(&(network_line[strlen(""GET_DN "")]), NULL, 10);

			univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""id: %ld"",id);

			if ( id <= notify_last_id.id) {

				char *dn_string = NULL;

				univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""try to read %ld from cache"", id);

				
				if ( (dn_string = notifier_cache_get(id)) == NULL ) {

					univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""%ld not found in cache"", id);

					univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""%ld get one dn"", id);

					
					if( (dn_string=notify_transcation_get_one_dn ( id )) == NULL ) {

						univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""%ld failed "", id);
						

						univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ERROR, ""%d failed, close connection to listener "", fd);
						close(fd);
						FD_CLR(fd, &readfds);
						remove(fd);

						return 0;
					}
				}

				if ( dn_string != NULL ) {

					snprintf(string, sizeof(string), ""MSGID: %ld\n%s\n\n"",msg_id,dn_string);

					univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""--> %d: [%s]"",fd, string);

					write(fd, string, strlen(string));

					free(dn_string);

				}


			} else {
				

				network_client_set_next_id(fd, id);
				network_client_set_msg_id(fd, msg_id);

			}

			p+=strlen(network_line)+1;
			msg_id = UINT32_MAX;

		} else if (!strncmp(p, ""WAIT_ID "", 8) && msg_id != UINT32_MAX && version >= PROTOCOL_3) {
			char *head = network_line, *end;
			univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""RECV: WAIT_ID"");
			id = strtoul(head + 8, &end, 10);
			if (!head[8] || *end)
				goto failed;
			univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""id: %ld"", id);

			if (id <= notify_last_id.id) {
				snprintf(string, sizeof(string), ""MSGID: %ld\n%ld\n\n"", msg_id, notify_last_id.id);
				write(fd, string, strlen(string));
			} else {
				
				network_client_set_next_id(fd, id);
				network_client_set_msg_id(fd, msg_id);
			}

			p += strlen(network_line) + 1;
			msg_id = UINT32_MAX;

		} else if ( !strncmp(network_line, ""GET_ID"", strlen(""GET_ID"")) && msg_id != UINT32_MAX  && network_client_get_version(fd) > 0) {

			univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""RECV: GET_ID"");

			memset(string, 0, sizeof(string));

			snprintf(string, sizeof(string), ""MSGID: %ld\n%ld\n\n"",msg_id,notify_last_id.id);

			write(fd, string, strlen(string));

			p+=strlen(network_line)+1;
			msg_id = UINT32_MAX;


		} else if ( !strncmp(network_line, ""GET_SCHEMA_ID"", strlen(""GET_SCHEMA_ID"")) && msg_id != UINT32_MAX  && network_client_get_version(fd) > 0) {

			univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""RECV: GET_SCHEMA_ID"");

			memset(string, 0, sizeof(string));

			snprintf(string, sizeof(string), ""MSGID: %ld\n%ld\n\n"",msg_id,SCHEMA_ID);

			univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""--> %d: [%s]"",fd, string);

			write(fd, string, strlen(string));

			p+=strlen(network_line)+1;
			msg_id = UINT32_MAX;


		} else if ( !strncmp(network_line, ""ALIVE"", strlen(""ALIVE"")) && msg_id != UINT32_MAX  && network_client_get_version(fd) > 0) {

			univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""RECV: ALIVE"");

			snprintf(string, sizeof(string), ""MSGID: %ld\nOKAY\n\n"",msg_id);

			write(fd, string, strlen(string));

			p+=strlen(network_line)+1;
			msg_id = UINT32_MAX;

		} else {

			p+=strlen(network_line);

			if (strlen(network_line) == 0 ) {
				p+=1;
 			} else {
				univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ERROR, ""Drop package [%s]"", network_line);
			}

		}
	}
	v_sem(sem_id);

	univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""END Package"");
	

	network_client_dump ();

	return 0;

failed:
	univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_PROCESS, ""Failed parsing [%s]"", p);
close:
	close(fd);
	FD_CLR(fd, &readfds);
	remove(fd);
	return 0;
}
","1. char *network_packet;
char network_line[8192];
char *p;
2. enum network_protocol version = network_client_get_version(fd);
3. if ( nread >= 8192 ) {
4. FD_CLR(fd, &readfds);
remove(fd);
5. network_packet=malloc((nread+1) * sizeof(char));
6. p_sem(sem_id);
7. if ( strlen(network_line) > 0 ) {
8. msg_id=strtoul(&(network_line[strlen(""MSGID: "")]), NULL, 10);
9. if (version < network_procotol_version) {
10. goto close;
11. univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""RECV: Capabilities"");
12. univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""RECV: GET_DN"");
13. id=strtoul(&(network_line[strlen(""GET_DN "")]), NULL, 10);
14. univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""%ld get one dn"", id);
15. univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ERROR, ""%d failed, close connection to listener "", fd);
close(fd);
16. write(fd, string, strlen(string));
17. network_client_set_next_id(fd, id);
18. msg_id = UINT32_MAX;
19. write(fd, string, strlen(string));
} else {
20. univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""RECV: GET_ID"");
21. memset(string, 0, sizeof(string));
22. msg_id = UINT32_MAX;
23. write(fd, string, strlen(string));
24. msg_id = UINT32_MAX;
25. } else {
univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ERROR, ""Drop package [%s]"", network_line);","4-6
11
28
32-33
39
45
49
57
73
75
90
113
115
130
138-139
153
163
169
181-182
193
195
202
215
218
238-239","CWE-476,CWE-125,CWE-19,CWE-401"
ReadMATImage_3-33332284513199,"
#define ExceptionInfo
#define ImageInfo

static Image *ReadMATImage_3(const ImageInfo *image_info,ExceptionInfo *exception)
{
  Image *image, *image2=NULL,
   *rotated_image;
  register Quantum *q;

  unsigned int status;
  MATHeader MATLAB_HDR;
  size_t size;
  size_t CellType;
  QuantumInfo *quantum_info;
  ImageInfo *clone_info;
  int i;
  ssize_t ldblk;
  unsigned char *BImgBuff = NULL;
  double MinVal, MaxVal;
  unsigned z, z2;
  unsigned Frames;
  int logging;
  int sample_size;
  MagickOffsetType filepos=0x80;
  BlobInfo *blob;
  size_t one;

  unsigned int (*ReadBlobXXXLong)(Image *image);
  unsigned short (*ReadBlobXXXShort)(Image *image);
  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);
  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);


  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  logging = LogMagickEvent(CoderEvent,GetMagickModule(),""enter"");

  
  image = AcquireImage(image_info,exception);

  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  
  quantum_info=(QuantumInfo *) NULL;
  clone_info=CloneImageInfo(image_info);
  if (ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  if (strncmp(MATLAB_HDR.identific,""MATLAB"",6) != 0)
    {
      image2=ReadMATImageV4(image_info,image,exception);
      if (image2  == NULL)
        goto MATLAB_KO;
      image=image2;
      goto END_OF_READING;
    }
  MATLAB_HDR.Version = ReadBlobLSBShort(image);
  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");

  if (logging)
    (void) LogMagickEvent(CoderEvent,GetMagickModule(),""  Endian %c%c"",
      MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);
  if (!strncmp(MATLAB_HDR.EndianIndicator, ""IM"", 2))
  {
    ReadBlobXXXLong = ReadBlobLSBLong;
    ReadBlobXXXShort = ReadBlobLSBShort;
    ReadBlobDoublesXXX = ReadBlobDoublesLSB;
    ReadBlobFloatsXXX = ReadBlobFloatsLSB;
    image->endian = LSBEndian;
  }
  else if (!strncmp(MATLAB_HDR.EndianIndicator, ""MI"", 2))
  {
    ReadBlobXXXLong = ReadBlobMSBLong;
    ReadBlobXXXShort = ReadBlobMSBShort;
    ReadBlobDoublesXXX = ReadBlobDoublesMSB;
    ReadBlobFloatsXXX = ReadBlobFloatsMSB;
    image->endian = MSBEndian;
  }
  else
    goto MATLAB_KO;    

  if (strncmp(MATLAB_HDR.identific, ""MATLAB"", 6))
MATLAB_KO: ThrowReaderException(CorruptImageError,""ImproperImageHeader"");

  filepos = TellBlob(image);
  while(!EOFBlob(image)) 
  {
    Frames = 1;
    (void) SeekBlob(image,filepos,SEEK_SET);
    

    MATLAB_HDR.DataType = ReadBlobXXXLong(image);
    if(EOFBlob(image)) break;
    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);
    if(EOFBlob(image)) break;
    filepos += MATLAB_HDR.ObjectSize + 4 + 4;

    image2 = image;
#if defined(MAGICKCORE_ZLIB_DELEGATE)
    if(MATLAB_HDR.DataType == miCOMPRESSED)
    {
      image2 = DecompressBlock(image,MATLAB_HDR.ObjectSize,clone_info,exception);
      if(image2==NULL) continue;
      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); 
    }
#endif

    if(MATLAB_HDR.DataType!=miMATRIX) continue;  

    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);
    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);

    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);
    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;
    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;

    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);
    if(image!=image2)
      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  
    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);
    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);
    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);
    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);


    switch(MATLAB_HDR.DimFlag)
    {
      case  8: z2=z=1; break;      
      case 12: z2=z = ReadBlobXXXLong(image2);  
           (void) ReadBlobXXXLong(image2);
         if(z!=3) ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
         break;
      case 16: z2=z = ReadBlobXXXLong(image2);  
         if(z!=3 && z!=1)
            ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
         Frames = ReadBlobXXXLong(image2);
         if (Frames == 0)
           ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
         break;
      default: ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
    }

    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);
    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);

    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
          ""MATLAB_HDR.StructureClass %d"",MATLAB_HDR.StructureClass);
    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&
        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    
        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    
        MATLAB_HDR.StructureClass != mxINT8_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    
        MATLAB_HDR.StructureClass != mxINT16_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    
        MATLAB_HDR.StructureClass != mxINT32_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    
        MATLAB_HDR.StructureClass != mxINT64_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    
      ThrowReaderException(CoderError,""UnsupportedCellTypeInTheMatrix"");

    switch (MATLAB_HDR.NameFlag)
    {
      case 0:
        size = ReadBlobXXXLong(image2);  
        size = 4 * (ssize_t) ((size + 3 + 1) / 4);
        (void) SeekBlob(image2, size, SEEK_CUR);
        break;
      case 1:
      case 2:
      case 3:
      case 4:
        (void) ReadBlob(image2, 4, (unsigned char *) &size); 
        break;
      default:
        goto MATLAB_KO;
    }

    CellType = ReadBlobXXXLong(image2);    
    if (logging)
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""MATLAB_HDR.CellType: %.20g"",(double) CellType);

    (void) ReadBlob(image2, 4, (unsigned char *) &size);     

    NEXT_FRAME:
    switch (CellType)
    {
      case miINT8:
      case miUINT8:
        sample_size = 8;
        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)
          image->depth = 1;
        else
          image->depth = 8;         
        ldblk = (ssize_t) MATLAB_HDR.SizeX;
        break;
      case miINT16:
      case miUINT16:
        sample_size = 16;
        image->depth = 16;        
        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);
        break;
      case miINT32:
      case miUINT32:
        sample_size = 32;
        image->depth = 32;        
        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
        break;
      case miINT64:
      case miUINT64:
        sample_size = 64;
        image->depth = 64;        
        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
        break;
      case miSINGLE:
        sample_size = 32;
        image->depth = 32;        
        (void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
  {              
  }
        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
        break;
      case miDOUBLE:
        sample_size = 64;
        image->depth = 64;        
        (void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
DisableMSCWarning(4127)
        if (sizeof(double) != 8)
RestoreMSCWarning
          ThrowReaderException(CoderError, ""IncompatibleSizeOfDouble"");
        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
  {                         
  }
        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
        break;
      default:
        ThrowReaderException(CoderError, ""UnsupportedCellTypeInTheMatrix"");
    }
    (void) sample_size;
    image->columns = MATLAB_HDR.SizeX;
    image->rows = MATLAB_HDR.SizeY;
    quantum_info=AcquireQuantumInfo(clone_info,image);
    if (quantum_info == (QuantumInfo *) NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    one=1;
    image->colors = one << image->depth;
    if (image->columns == 0 || image->rows == 0)
      goto MATLAB_KO;
    
    if ((MATLAB_HDR.DimFlag == 8) &&
        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
      {
        image->type=GrayscaleType;
        SetImageColorspace(image,GRAYColorspace,exception);
      }


    
    if (image_info->ping)
    {
      size_t temp = image->columns;
      image->columns = image->rows;
      image->rows = temp;
      goto done_reading; 
    }
    status=SetImageExtent(image,image->columns,image->rows,exception);
    if (status == MagickFalse)
      return(DestroyImageList(image));

  
    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    
    if (BImgBuff == NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));

    MinVal = 0;
    MaxVal = 0;
    if (CellType==miDOUBLE || CellType==miSINGLE)        
    {
      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);
    }

    
    if(z==1) z=0; 
    
    do
    {
      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
      {
        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);
        if (q == (Quantum *) NULL)
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  MAT set image pixels returns unexpected NULL on a row %u."", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto done_reading;    
  }
        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
             ""  MAT cannot read scanrow %u from a file."", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto ExitLoop;
  }
        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))
        {
          FixLogical((unsigned char *)BImgBuff,ldblk);
          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
    {
ImportQuantumPixelsFailed:
      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  MAT failed to ImportQuantumPixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
      break;
    }
        }
        else
        {
          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
      goto ImportQuantumPixelsFailed;


          if (z<=1 &&       
          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))
      FixSignedValues(image,q,MATLAB_HDR.SizeX);
        }

        if (!SyncAuthenticPixels(image,exception))
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
            ""  MAT failed to sync image pixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto ExitLoop;
  }
      }
    } while(z-- >= 2);
ExitLoop:


    
    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
    {        
      CellType = ReadBlobXXXLong(image2);    
      i = ReadBlobXXXLong(image2);           

      if (CellType==miDOUBLE || CellType==miSINGLE)
      {
        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);
      }

      if (CellType==miDOUBLE)
        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
  {
          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);
          InsertComplexDoubleRow(image, (double *)BImgBuff, i, MinVal, MaxVal,
            exception);
  }

      if (CellType==miSINGLE)
        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
  {
          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);
          InsertComplexFloatRow(image,(float *)BImgBuff,i,MinVal,MaxVal,
            exception);
  }
    }

      
    if ((MATLAB_HDR.DimFlag == 8) &&
        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
      image->type=GrayscaleType;
    if (image->depth == 1)
      image->type=BilevelType;

    if(image2==image)
        image2 = NULL;    

      
    rotated_image = RotateImage(image, 90.0, exception);
    if (rotated_image != (Image *) NULL)
    {
        
      rotated_image->page.x=0;
      rotated_image->page.y=0;

      blob = rotated_image->blob;
      rotated_image->blob = image->blob;
      rotated_image->colors = image->colors;
      image->blob = blob;
      AppendImageToList(&image,rotated_image);
      DeleteImageFromList(&image);
    }

done_reading:

    if(image2!=NULL)
      if(image2!=image)
      {
        DeleteImageFromList(&image2);
  if(clone_info)
  {
          if(clone_info->file)
    {
            fclose(clone_info->file);
            clone_info->file = NULL;
            (void) remove_utf8(clone_info->filename);
    }
        }
      }

      
    AcquireNextImage(image_info,image,exception);
    if (image->next == (Image *) NULL) break;
    image=SyncNextImageInList(image);
    image->columns=image->rows=0;
    image->colors=0;

      
    RelinquishMagickMemory(BImgBuff);
    BImgBuff = NULL;

    if(--Frames>0)
    {
      z = z2;
      if(image2==NULL) image2 = image;
      goto NEXT_FRAME;
    }
    if ((image2!=NULL) && (image2!=image))   
      {

        DeleteImageFromList(&image2);
        if(clone_info)
        {
          if(clone_info->file)
          {
            fclose(clone_info->file);
            clone_info->file = NULL;
            (void) remove_utf8(clone_info->filename);
          }
        }
        }
  }

  RelinquishMagickMemory(BImgBuff);
  if (quantum_info != (QuantumInfo *) NULL)
    quantum_info=DestroyQuantumInfo(quantum_info);
END_OF_READING:
  clone_info=DestroyImageInfo(clone_info);
  CloseBlob(image);


  {
    Image *p;
    ssize_t scene=0;

    
    p=image;
    image=NULL;
    while (p != (Image *) NULL)
      {
        Image *tmp=p;
        if ((p->rows == 0) || (p->columns == 0)) {
          p=p->previous;
          DeleteImageFromList(&tmp);
        } else {
          image=p;
          p=p->previous;
        }
      }

    
    for (p=image; p != (Image *) NULL; p=p->next)
      p->scene=scene++;
  }

  if(clone_info != NULL)  
  {
    if(clone_info->file)
    {
      fclose(clone_info->file);
      clone_info->file = NULL;
      (void) remove_utf8(clone_info->filename);
    }
    DestroyImageInfo(clone_info);
    clone_info = NULL;
  }
  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),""return"");
  if(image==NULL)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  return (image);
}
","1. ReadBlobFloatsXXX = ReadBlobFloatsLSB;
2. default:
3. case miINT16:
4. break;
5. sample_size = 64;
6. if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))","79
185
208
219
236
318","CWE-772,CWE-200,CWE-416"
handle_wrmsr,"static int handle_wrmsr(struct kvm_vcpu *vcpu)
{
	struct msr_data msr;
	u32 ecx = vcpu->arch.regs[VCPU_REGS_RCX];
	u64 data = (vcpu->arch.regs[VCPU_REGS_RAX] & -1u)
		| ((u64)(vcpu->arch.regs[VCPU_REGS_RDX] & -1u) << 32);

 	msr.data = data;
 	msr.index = ecx;
 	msr.host_initiated = false;
	if (kvm_set_msr(vcpu, &msr) != 0) {
 		trace_kvm_msr_write_ex(ecx, data);
 		kvm_inject_gp(vcpu, 0);
 		return 1;
	}

	trace_kvm_msr_write(ecx, data);
	skip_emulated_instruction(vcpu);
	return 1;
}
","1. static int handle_wrmsr(struct kvm_vcpu *vcpu)
2. struct msr_data msr;
3. u64 data = (vcpu->arch.regs[VCPU_REGS_RAX] & -1u)
| ((u64)(vcpu->arch.regs[VCPU_REGS_RDX] & -1u) << 32);
4. msr.data = data;
msr.index = ecx;
msr.host_initiated = false;
if (kvm_set_msr(vcpu, &msr) != 0) {
trace_kvm_msr_write_ex(ecx, data);
5. return 1;
6. trace_kvm_msr_write(ecx, data);","1
3
5-6
8-12
14
17","CWE-617,CWE-264,CWE-190,CWE-119,CWE-125"
_pickle_UnpicklerMemoProxy_copy_impl-270976899220828,"
#define UnpicklerMemoProxyObject

static PyObject *
_pickle_UnpicklerMemoProxy_copy_impl(UnpicklerMemoProxyObject *self)

{
    size_t i;
    PyObject *new_memo = PyDict_New();
    if (new_memo == NULL)
        return NULL;

    for (i = 0; i < self->unpickler->memo_size; i++) {
        int status;
        PyObject *key, *value;

        value = self->unpickler->memo[i];
        if (value == NULL)
            continue;

        key = PyLong_FromSsize_t(i);
        if (key == NULL)
            goto error;
        status = PyDict_SetItem(new_memo, key, value);
        Py_DECREF(key);
        if (status < 0)
            goto error;
    }
    return new_memo;

error:
    Py_DECREF(new_memo);
    return NULL;
}
","1. static PyObject *
2. PyObject *new_memo = PyDict_New();
if (new_memo == NULL)
3. goto error;
4. Py_DECREF(new_memo);","4
9-10
23
32","CWE-190,CWE-125,CWE-358"
do_mathemu-82757675208228,"int do_mathemu(struct pt_regs *regs, struct task_struct *fpt)
{
	

	

	int i;
	int retcode = 0;                               
	unsigned long insn;

	perf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, regs, 0);

#ifdef DEBUG_MATHEMU
	printk(""In do_mathemu()... pc is %08lx\n"", regs->pc);
	printk(""fpqdepth is %ld\n"", fpt->thread.fpqdepth);
	for (i = 0; i < fpt->thread.fpqdepth; i++)
		printk(""%d: %08lx at %08lx\n"", i, fpt->thread.fpqueue[i].insn,
		       (unsigned long)fpt->thread.fpqueue[i].insn_addr);
#endif

	if (fpt->thread.fpqdepth == 0) {                   
#ifdef DEBUG_MATHEMU
		printk(""precise trap at %08lx\n"", regs->pc);
#endif
		if (!get_user(insn, (u32 __user *) regs->pc)) {
			retcode = do_one_mathemu(insn, &fpt->thread.fsr, fpt->thread.float_regs);
			if (retcode) {
				
				regs->pc = regs->npc;
				regs->npc += 4;
			}
		}
		return retcode;
	}

	
	for (i = 0; i < fpt->thread.fpqdepth; i++) {
		retcode = do_one_mathemu(fpt->thread.fpqueue[i].insn, &(fpt->thread.fsr), fpt->thread.float_regs);
		if (!retcode)                               
			break;
	}
	
	if (retcode)
		fpt->thread.fsr &= ~(0x3000 | FSR_CEXC_MASK);
	else
		fpt->thread.fsr &= ~0x3000;
	fpt->thread.fpqdepth = 0;

	return retcode;
}
","1. if (!get_user(insn, (u32 __user *) regs->pc)) {
retcode = do_one_mathemu(insn, &fpt->thread.fsr, fpt->thread.float_regs);
2. regs->pc = regs->npc;
3. if (retcode)
4. return retcode;","39-40
43
57
63","CWE-416,CWE-399,CWE-400"
do_connect-250414279493123,"void do_connect(struct st_command *command)
{
  int con_port= opt_port;
  char *con_options;
  my_bool con_ssl= 0, con_compress= 0;
  my_bool con_pipe= 0, con_shm= 0, con_cleartext_enable= 0;
  my_bool con_secure_auth= 1;
  struct st_connection* con_slot;
#if defined(HAVE_OPENSSL) && !defined(EMBEDDED_LIBRARY)
  my_bool save_opt_use_ssl= opt_use_ssl;
#endif

  static DYNAMIC_STRING ds_connection_name;
  static DYNAMIC_STRING ds_host;
  static DYNAMIC_STRING ds_user;
  static DYNAMIC_STRING ds_password;
  static DYNAMIC_STRING ds_database;
  static DYNAMIC_STRING ds_port;
  static DYNAMIC_STRING ds_sock;
  static DYNAMIC_STRING ds_options;
  static DYNAMIC_STRING ds_default_auth;
#if defined (_WIN32) && !defined (EMBEDDED_LIBRARY)
  static DYNAMIC_STRING ds_shm;
#endif
  const struct command_arg connect_args[] = {
    { ""connection name"", ARG_STRING, TRUE, &ds_connection_name, ""Name of the connection"" },
    { ""host"", ARG_STRING, TRUE, &ds_host, ""Host to connect to"" },
    { ""user"", ARG_STRING, FALSE, &ds_user, ""User to connect as"" },
    { ""passsword"", ARG_STRING, FALSE, &ds_password, ""Password used when connecting"" },
    { ""database"", ARG_STRING, FALSE, &ds_database, ""Database to select after connect"" },
    { ""port"", ARG_STRING, FALSE, &ds_port, ""Port to connect to"" },
    { ""socket"", ARG_STRING, FALSE, &ds_sock, ""Socket to connect with"" },
    { ""options"", ARG_STRING, FALSE, &ds_options, ""Options to use while connecting"" },
    { ""default_auth"", ARG_STRING, FALSE, &ds_default_auth, ""Default authentication to use"" }
  };

  DBUG_ENTER(""do_connect"");
  DBUG_PRINT(""enter"",(""connect: %s"", command->first_argument));

  strip_parentheses(command);
  check_command_args(command, command->first_argument, connect_args,
                     sizeof(connect_args)/sizeof(struct command_arg),
                     ',');

  
  if (ds_port.length)
  {
    con_port= atoi(ds_port.str);
    if (con_port == 0)
      die(""Illegal argument for port: '%s'"", ds_port.str);
  }

#if defined (_WIN32) && !defined (EMBEDDED_LIBRARY)
  
  init_dynamic_string(&ds_shm, ds_sock.str, 0, 0);
#endif

  
  if (ds_sock.length)
  {
    
    if (*ds_sock.str != FN_LIBCHAR)
    {
      char buff[FN_REFLEN];
      fn_format(buff, ds_sock.str, TMPDIR, """", 0);
      dynstr_set(&ds_sock, buff);
    }
  }
  else
  {
    
    dynstr_set(&ds_sock, unix_sock);
  }
  DBUG_PRINT(""info"", (""socket: %s"", ds_sock.str));


  
  con_options= ds_options.str;
  while (*con_options)
  {
    char* end;
    
    while (*con_options && my_isspace(charset_info, *con_options))
     con_options++;
    
    end= con_options;
    while (*end && !my_isspace(charset_info, *end))
      end++;
    if (!strncmp(con_options, ""SSL"", 3))
      con_ssl= 1;
    else if (!strncmp(con_options, ""COMPRESS"", 8))
      con_compress= 1;
    else if (!strncmp(con_options, ""PIPE"", 4))
      con_pipe= 1;
    else if (!strncmp(con_options, ""SHM"", 3))
      con_shm= 1;
    else if (!strncmp(con_options, ""CLEARTEXT"", 9))
      con_cleartext_enable= 1;
    else if (!strncmp(con_options, ""SKIPSECUREAUTH"",14))
      con_secure_auth= 0;
    else
      die(""Illegal option to connect: %.*s"", 
          (int) (end - con_options), con_options);
    
    con_options= end;
  }

  if (find_connection_by_name(ds_connection_name.str))
    die(""Connection %s already exists"", ds_connection_name.str);
    
  if (next_con != connections_end)
    con_slot= next_con;
  else
  {
    if (!(con_slot= find_connection_by_name(""-closed_connection-"")))
      die(""Connection limit exhausted, you can have max %d connections"",
          opt_max_connections);
  }

#ifdef EMBEDDED_LIBRARY
  init_connection_thd(con_slot);
#endif 

  if (!mysql_init(&con_slot->mysql))
    die(""Failed on mysql_init()"");

  if (opt_connect_timeout)
    mysql_options(&con_slot->mysql, MYSQL_OPT_CONNECT_TIMEOUT,
                  (void *) &opt_connect_timeout);

  if (opt_compress || con_compress)
    mysql_options(&con_slot->mysql, MYSQL_OPT_COMPRESS, NullS);
  mysql_options(&con_slot->mysql, MYSQL_OPT_LOCAL_INFILE, 0);
  mysql_options(&con_slot->mysql, MYSQL_SET_CHARSET_NAME,
                charset_info->csname);
  if (opt_charsets_dir)
    mysql_options(&con_slot->mysql, MYSQL_SET_CHARSET_DIR,
                  opt_charsets_dir);

#if defined(HAVE_OPENSSL) && !defined(EMBEDDED_LIBRARY)
  if (opt_use_ssl)
    con_ssl= 1;

  opt_use_ssl= con_ssl;

  if (opt_use_ssl)
  {
    
    opt_ssl_verify_server_cert= !strcmp(ds_host.str, ""localhost"");
  }
#else
  
  con_ssl = con_ssl ? TRUE : FALSE;
#endif
  SSL_SET_OPTIONS(&con_slot->mysql);
#if defined(HAVE_OPENSSL) && !defined(EMBEDDED_LIBRARY)
  opt_use_ssl= save_opt_use_ssl;
#endif

  if (con_pipe)
  {
#if defined(_WIN32) && !defined(EMBEDDED_LIBRARY)
    opt_protocol= MYSQL_PROTOCOL_PIPE;
#endif
  }

#ifndef EMBEDDED_LIBRARY
  if (opt_protocol)
    mysql_options(&con_slot->mysql, MYSQL_OPT_PROTOCOL, (char*) &opt_protocol);
#endif

  if (con_shm)
  {
#if defined (_WIN32) && !defined (EMBEDDED_LIBRARY)
    uint protocol= MYSQL_PROTOCOL_MEMORY;
    if (!ds_shm.length)
      die(""Missing shared memory base name"");
    mysql_options(&con_slot->mysql, MYSQL_SHARED_MEMORY_BASE_NAME, ds_shm.str);
    mysql_options(&con_slot->mysql, MYSQL_OPT_PROTOCOL, &protocol);
#endif
  }
#if defined (_WIN32) && !defined (EMBEDDED_LIBRARY)
  else if (shared_memory_base_name)
  {
    mysql_options(&con_slot->mysql, MYSQL_SHARED_MEMORY_BASE_NAME,
                  shared_memory_base_name);
  }
#endif

  
  if (ds_database.length == 0)
    dynstr_set(&ds_database, opt_db);

  if (opt_plugin_dir && *opt_plugin_dir)
    mysql_options(&con_slot->mysql, MYSQL_PLUGIN_DIR, opt_plugin_dir);

  if (ds_default_auth.length)
    mysql_options(&con_slot->mysql, MYSQL_DEFAULT_AUTH, ds_default_auth.str);

#if !defined(HAVE_YASSL)
  
  if (opt_server_public_key && *opt_server_public_key)
    mysql_options(&con_slot->mysql, MYSQL_SERVER_PUBLIC_KEY,
                  opt_server_public_key);
#endif
  
  if (con_cleartext_enable)
    mysql_options(&con_slot->mysql, MYSQL_ENABLE_CLEARTEXT_PLUGIN,
                  (char*) &con_cleartext_enable);

  if (!con_secure_auth)
    mysql_options(&con_slot->mysql, MYSQL_SECURE_AUTH,
                  (char*) &con_secure_auth);

  
  if (ds_database.length && !strcmp(ds_database.str,""*NO-ONE*""))
    dynstr_set(&ds_database, """");

  if (connect_n_handle_errors(command, &con_slot->mysql,
                              ds_host.str,ds_user.str,
                              ds_password.str, ds_database.str,
                              con_port, ds_sock.str))
  {
    DBUG_PRINT(""info"", (""Inserting connection %s in connection pool"",
                        ds_connection_name.str));
    if (!(con_slot->name= my_strdup(PSI_NOT_INSTRUMENTED,
                                    ds_connection_name.str, MYF(MY_WME))))
      die(""Out of memory"");
    con_slot->name_len= strlen(con_slot->name);
    set_current_connection(con_slot);

    if (con_slot == next_con)
      next_con++; 
  }

  dynstr_free(&ds_connection_name);
  dynstr_free(&ds_host);
  dynstr_free(&ds_user);
  dynstr_free(&ds_password);
  dynstr_free(&ds_database);
  dynstr_free(&ds_port);
  dynstr_free(&ds_sock);
  dynstr_free(&ds_options);
  dynstr_free(&ds_default_auth);
#if defined (_WIN32) && !defined (EMBEDDED_LIBRARY)
  dynstr_free(&ds_shm);
#endif
  DBUG_VOID_RETURN;
}
","1. my_bool con_ssl= 0, con_compress= 0;
2. static DYNAMIC_STRING ds_host;
3. static DYNAMIC_STRING ds_sock;
static DYNAMIC_STRING ds_options;
4. { ""host"", ARG_STRING, TRUE, &ds_host, ""Host to connect to"" },
5. { ""passsword"", ARG_STRING, FALSE, &ds_password, ""Password used when connecting"" },
6. strip_parentheses(command);
check_command_args(command, command->first_argument, connect_args,
7. dynstr_set(&ds_sock, buff);
8. con_options= ds_options.str;
9. end= con_options;
while (*end && !my_isspace(charset_info, *end))
10. con_pipe= 1;
11. else if (!strncmp(con_options, ""CLEARTEXT"", 9))
12. if (find_connection_by_name(ds_connection_name.str))
die(""Connection %s already exists"", ds_connection_name.str);
13. con_slot= next_con;
14. {
15. opt_max_connections);
16. mysql_options(&con_slot->mysql, MYSQL_SET_CHARSET_DIR,
17. SSL_SET_OPTIONS(&con_slot->mysql);
18. mysql_options(&con_slot->mysql, MYSQL_OPT_PROTOCOL, (char*) &opt_protocol);
19. if (ds_database.length == 0)
20. mysql_options(&con_slot->mysql, MYSQL_SERVER_PUBLIC_KEY,
opt_server_public_key);
21. if (!con_secure_auth)
mysql_options(&con_slot->mysql, MYSQL_SECURE_AUTH,
22. if (ds_database.length && !strcmp(ds_database.str,""*NO-ONE*""))
23. ds_connection_name.str, MYF(MY_WME))))
die(""Out of memory"");
24. set_current_connection(con_slot);
25. if (con_slot == next_con)
26. dynstr_free(&ds_port);
27. dynstr_free(&ds_options);
dynstr_free(&ds_default_auth);","5
14
19-20
27
29
40-41
69
81
89-90
97
100
111-112
115
117
120
140
158
172
194
206-207
214-215
219
230-231
233
235
244
246-247","CWE-20,CWE-400,CWE-399,CWE-323"
copy_cred," static int copy_cred(struct svc_cred *target, struct svc_cred *source)
 {
	target->cr_principal = kstrdup(source->cr_principal, GFP_KERNEL);
	target->cr_raw_principal = kstrdup(source->cr_raw_principal,
								GFP_KERNEL);
	if ((source->cr_principal && ! target->cr_principal) ||
	    (source->cr_raw_principal && ! target->cr_raw_principal))
		return -ENOMEM;
 
 	target->cr_flavor = source->cr_flavor;
 	target->cr_uid = source->cr_uid;
 	target->cr_gid = source->cr_gid;
	target->cr_group_info = source->cr_group_info;
	get_group_info(target->cr_group_info);
	target->cr_gss_mech = source->cr_gss_mech;
	if (source->cr_gss_mech)
		gss_mech_get(source->cr_gss_mech);
	return 0;
}
","1. (source->cr_raw_principal && ! target->cr_raw_principal))
2. get_group_info(target->cr_group_info);
target->cr_gss_mech = source->cr_gss_mech;","7
14-15","CWE-264,CWE-119"
copy_to_user_state," static void copy_to_user_state(struct xfrm_state *x, struct xfrm_usersa_info *p)
 {
	memset(p, 0, sizeof(*p));
 	memcpy(&p->id, &x->id, sizeof(p->id));
 	memcpy(&p->sel, &x->sel, sizeof(p->sel));
 	memcpy(&p->lft, &x->lft, sizeof(p->lft));
	memcpy(&p->curlft, &x->curlft, sizeof(p->curlft));
	memcpy(&p->stats, &x->stats, sizeof(p->stats));
	memcpy(&p->saddr, &x->props.saddr, sizeof(p->saddr));
	p->mode = x->props.mode;
	p->replay_window = x->props.replay_window;
	p->reqid = x->props.reqid;
	p->family = x->props.family;
	p->flags = x->props.flags;
	p->seq = x->km.seq;
}
","1. memcpy(&p->id, &x->id, sizeof(p->id));
memcpy(&p->sel, &x->sel, sizeof(p->sel));
2. memcpy(&p->curlft, &x->curlft, sizeof(p->curlft));
3. p->mode = x->props.mode;
4. p->reqid = x->props.reqid;
p->family = x->props.family;
p->flags = x->props.flags;
p->seq = x->km.seq;","4-5
7
10
12-15","CWE-476,CWE-200,CWE-189"
rawsock_recvmsg-102761997289877,"static int rawsock_recvmsg(struct kiocb *iocb, struct socket *sock,
			   struct msghdr *msg, size_t len, int flags)
{
	int noblock = flags & MSG_DONTWAIT;
	struct sock *sk = sock->sk;
	struct sk_buff *skb;
	int copied;
	int rc;

	pr_debug(""sock=%p sk=%p len=%zu flags=%d\n"", sock, sk, len, flags);

	skb = skb_recv_datagram(sk, flags, noblock, &rc);
	if (!skb)
		return rc;

	copied = skb->len;
	if (len < copied) {
		msg->msg_flags |= MSG_TRUNC;
		copied = len;
	}

	rc = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);

	skb_free_datagram(sk, skb);

	return rc ? : copied;
}
","1. if (len < copied) {
msg->msg_flags |= MSG_TRUNC;",17-18,"CWE-476,CWE-20,CWE-404,CWE-119"
nfc_llcp_local_get-45951662654352,"static struct nfc_llcp_local *nfc_llcp_local_get(struct nfc_llcp_local *local)
{
	kref_get(&local->ref);

	return local;
}
","1. static struct nfc_llcp_local *nfc_llcp_local_get(struct nfc_llcp_local *local)
2. kref_get(&local->ref);
3. return local;","1
3
5","CWE-476,CWE-362,CWE-404,CWE-416"
m88rs2000_frontend_attach,"static int m88rs2000_frontend_attach(struct dvb_usb_adapter *d)
static int m88rs2000_frontend_attach(struct dvb_usb_adapter *adap)
 {
	struct dvb_usb_device *d = adap->dev;
	struct dw2102_state *state = d->priv;

	mutex_lock(&d->data_mutex);
 
	state->data[0] = 0x51;

	if (dvb_usb_generic_rw(d, state->data, 1, state->data, 1, 0) < 0)
 		err(""command 0x51 transfer failed."");
 
	mutex_unlock(&d->data_mutex);
 
	adap->fe_adap[0].fe = dvb_attach(m88rs2000_attach,
					&s421_m88rs2000_config,
					&d->i2c_adap);

	if (adap->fe_adap[0].fe == NULL)
 		return -EIO;
 
	if (dvb_attach(ts2020_attach, adap->fe_adap[0].fe,
 				&dw2104_ts2020_config,
				&d->i2c_adap)) {
 		info(""Attached RS2000/TS2020!"");
 		return 0;
 	}

	info(""Failed to attach RS2000/TS2020!"");
	return -EIO;
}
","1. static int m88rs2000_frontend_attach(struct dvb_usb_adapter *adap)
2. struct dvb_usb_device *d = adap->dev;
struct dw2102_state *state = d->priv;
3. mutex_lock(&d->data_mutex);
4. state->data[0] = 0x51;
5. if (dvb_usb_generic_rw(d, state->data, 1, state->data, 1, 0) < 0)
err(""command 0x51 transfer failed."");
6. mutex_unlock(&d->data_mutex);
7. adap->fe_adap[0].fe = dvb_attach(m88rs2000_attach,
&s421_m88rs2000_config,
&d->i2c_adap);
8. if (adap->fe_adap[0].fe == NULL)
return -EIO;
9. if (dvb_attach(ts2020_attach, adap->fe_adap[0].fe,
&dw2104_ts2020_config,
&d->i2c_adap)) {
info(""Attached RS2000/TS2020!"");
return 0;
10. info(""Failed to attach RS2000/TS2020!"");
return -EIO;","2
4-5
7
9
11-12
14
16-18
20-21
23-27
30-31","CWE-125,CWE-119"
rec_parse_comment-7433094838312,"static bool
rec_parse_comment (rec_parser_t parser, rec_comment_t *comment)
{
  bool ret;
  rec_buf_t buf;
  char *str;
  size_t str_size;
  int ci;
  char c;

  ret = false;
  buf = rec_buf_new (&str, &str_size);

  
  if (rec_expect (parser, ""#""))
    {
      while ((ci = rec_parser_getc (parser)) != EOF)
        {
          c = (char) ci;

          if (c == '\n')
            {
              if ((ci = rec_parser_getc (parser)) == EOF)
                break;
              c = (char) ci;

              if (c != '#')
                {
                  rec_parser_ungetc (parser, ci);
                  break;
                }
              else
                c = '\n';
            }

          if (rec_buf_putc (ci, buf) == EOF)
            {
              
              parser->error = REC_PARSER_ENOMEM;
              return false;
            }
        }

      ret = true;
    }

  rec_buf_close (buf);

  if (ret)
    *comment = rec_comment_new (str);
  else
    *comment = NULL;

  free (str);
  return ret;
}
","1. c = '\n';
2. *comment = NULL;
3. free (str);","35
54
56","CWE-189,CWE-476,CWE-200,CWE-59,CWE-399"
trustedBlsSignMessageAES-245396440263668,"
#define _hashX
#define _hashY

void trustedBlsSignMessageAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey,
                              uint64_t enc_len, char *_hashX,
                              char *_hashY, char *signature) {
    LOG_DEBUG(__FUNCTION__);
    INIT_ERROR_STATE

    CHECK_STATE(encryptedPrivateKey);
    CHECK_STATE(_hashX);
    CHECK_STATE(_hashY);
    CHECK_STATE(signature);

    SAFE_CHAR_BUF(key, BUF_LEN);SAFE_CHAR_BUF(sig, BUF_LEN);

    int status = AES_decrypt(encryptedPrivateKey, enc_len, key, BUF_LEN);

    CHECK_STATUS(""AES decrypt failed"")

    if (!enclave_sign(key, _hashX, _hashY, sig)) {
        strncpy(errString, ""Enclave failed to create bls signature"", BUF_LEN);
        LOG_ERROR(errString);
        *errStatus = -1;
        goto clean;
    }

    strncpy(signature, sig, BUF_LEN);

    if (strnlen(signature, BUF_LEN) < 10) {
        strncpy(errString, ""Signature too short"", BUF_LEN);
        LOG_ERROR(errString);
        *errStatus = -1;
        goto clean;
    }

    SET_SUCCESS

    LOG_DEBUG(""SGX call completed"");

    clean:
    ;
    LOG_DEBUG(""SGX call completed"");
}
","1. void trustedBlsSignMessageAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey,
uint64_t enc_len, char *_hashX,
2. LOG_DEBUG(__FUNCTION__);
3. CHECK_STATE(_hashY);
4. CHECK_STATUS(""AES decrypt failed"")
5. strncpy(errString, ""Enclave failed to create bls signature"", BUF_LEN);
6. *errStatus = -1;
7. strncpy(signature, sig, BUF_LEN);
8. goto clean;
9. SET_SUCCESS
10. LOG_DEBUG(""SGX call completed"");
11. LOG_DEBUG(""SGX call completed"");","5-6
8
13
20
23
25
29
35
38
40
44","CWE-200,CWE-264,CWE-787"
WriteIPLImage,"
#define Image
#define ImageInfo

static MagickBooleanType WriteIPLImage(const ImageInfo *image_info,Image *image)
{
  ExceptionInfo
    *exception;

  IPLInfo
    ipl_info;

  MagickBooleanType
    status;

  MagickOffsetType
    scene;

  register const PixelPacket
    *p;

  QuantumInfo
    *quantum_info;

  ssize_t
    y;

  unsigned char
    *pixels;

   
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  assert(image != (Image *) NULL);
  assert(image->signature == MagickSignature);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);
  if (status == MagickFalse)
    return(status);
   scene=0;
 
   quantum_info=AcquireQuantumInfo(image_info, image);
  if (quantum_info == (QuantumInfo *) NULL)
    ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
   if ((quantum_info->format == UndefinedQuantumFormat) &&
       (IsHighDynamicRangeImage(image,&image->exception) != MagickFalse))
     SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);
  switch(quantum_info->depth){
  case 8:
    ipl_info.byteType = 0;
    break;
  case 16:
    if(quantum_info->format == SignedQuantumFormat){
      ipl_info.byteType = 2;
    }
    else{
      ipl_info.byteType = 1;
    }
    break;
  case 32:
    if(quantum_info->format == FloatingPointQuantumFormat){
      ipl_info.byteType = 3;
    }
    else{
      ipl_info.byteType = 4;
    }
    break;
  case 64:
    ipl_info.byteType = 10;
    break;
  default:
    ipl_info.byteType = 2;
    break;

  }
  ipl_info.z = (unsigned int) GetImageListLength(image);
  
  ipl_info.time = 1;
  ipl_info.width = (unsigned int) image->columns;
  ipl_info.height = (unsigned int) image->rows;
  (void) TransformImageColorspace(image,sRGBColorspace);
  if(IssRGBCompatibleColorspace(image->colorspace) != MagickFalse) { ipl_info.colors = 3; }
  else{ ipl_info.colors = 1; }

  ipl_info.size = (unsigned int) (28 +
    ((image->depth)/8)*ipl_info.height*ipl_info.width*ipl_info.colors*ipl_info.z);

  

  
  

  if(image_info->endian == MSBEndian)
    (void) WriteBlob(image, 4, (const unsigned char *) ""mmmm"");
  else{
    image->endian = LSBEndian;
    (void) WriteBlob(image, 4, (const unsigned char *) ""iiii"");
  }
  (void) WriteBlobLong(image, 4);
  (void) WriteBlob(image, 4, (const unsigned char *) ""100f"");
  (void) WriteBlob(image, 4, (const unsigned char *) ""data"");
  (void) WriteBlobLong(image, ipl_info.size);
  (void) WriteBlobLong(image, ipl_info.width);
  (void) WriteBlobLong(image, ipl_info.height);
  (void) WriteBlobLong(image, ipl_info.colors);
  if(image_info->adjoin == MagickFalse)
  (void) WriteBlobLong(image, 1);
  else
  (void) WriteBlobLong(image, ipl_info.z);
  (void) WriteBlobLong(image, ipl_info.time);
  (void) WriteBlobLong(image, ipl_info.byteType);

  exception=(&image->exception);
  do
    {
      
      pixels=GetQuantumPixels(quantum_info);
  if(ipl_info.colors == 1){
  
  for(y = 0; y < (ssize_t) ipl_info.height; y++){
    p=GetAuthenticPixels(image,0,y,image->columns,1,exception);
    if (p == (PixelPacket *) NULL)
      break;
    (void) ExportQuantumPixels(image,(const CacheView *) NULL, quantum_info,
      GrayQuantum, pixels,&image->exception);
    (void) WriteBlob(image, image->columns*image->depth/8, pixels);
  }

}
  if(ipl_info.colors == 3){
  
  for(y = 0; y < (ssize_t) ipl_info.height; y++){
    p=GetAuthenticPixels(image,0,y,image->columns,1,exception);
    if (p == (PixelPacket *) NULL)
      break;
    (void) ExportQuantumPixels(image,(const CacheView *) NULL, quantum_info,
      RedQuantum, pixels,&image->exception);
    (void) WriteBlob(image, image->columns*image->depth/8, pixels);
  }

    
    for(y = 0; y < (ssize_t) ipl_info.height; y++){
      p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);
      if (p == (PixelPacket *) NULL)
        break;
      (void) ExportQuantumPixels(image,(const CacheView *) NULL, quantum_info,
        GreenQuantum, pixels,&image->exception);
      (void) WriteBlob(image, image->columns*image->depth/8, pixels);
    }
    
    for(y = 0; y < (ssize_t) ipl_info.height; y++){
      p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);
      if (p == (PixelPacket *) NULL)
        break;
      (void) ExportQuantumPixels(image,(const CacheView *) NULL, quantum_info,
        BlueQuantum, pixels,&image->exception);
      (void) WriteBlob(image, image->columns*image->depth/8, pixels);
      if (image->previous == (Image *) NULL)
        {
          status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
                image->rows);
          if (status == MagickFalse)
            break;
        }
    }
  }
  quantum_info=DestroyQuantumInfo(quantum_info);
  if (GetNextImageInList(image) == (Image *) NULL)
    break;
      image=SyncNextImageInList(image);
      status=SetImageProgress(image,SaveImagesTag,scene++,
        GetImageListLength(image));
      if (status == MagickFalse)
        break;
    }while (image_info->adjoin != MagickFalse);

  (void) WriteBlob(image, 4, (const unsigned char *) ""fini"");
  (void) WriteBlobLong(image, 0);

CloseBlob(image);
return(MagickTrue);
}
","1. *exception;
2. ipl_info;
3. *p;
4. y;
5. (IsHighDynamicRangeImage(image,&image->exception) != MagickFalse))
SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);
6. ipl_info.byteType = 0;
7. default:
8. break;
9. if(IssRGBCompatibleColorspace(image->colorspace) != MagickFalse) { ipl_info.colors = 3; }
10. ((image->depth)/8)*ipl_info.height*ipl_info.width*ipl_info.colors*ipl_info.z);
11. (void) WriteBlob(image, 4, (const unsigned char *) ""iiii"");
12. (void) WriteBlobLong(image, 4);
(void) WriteBlob(image, 4, (const unsigned char *) ""100f"");
13. if(image_info->adjoin == MagickFalse)
(void) WriteBlobLong(image, 1);
14. (void) WriteBlobLong(image, ipl_info.time);
15. (void) ExportQuantumPixels(image,(const CacheView *) NULL, quantum_info,
GrayQuantum, pixels,&image->exception);
16. p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);
17. break;
18. GreenQuantum, pixels,&image->exception);
(void) WriteBlob(image, image->columns*image->depth/8, pixels);
19. for(y = 0; y < (ssize_t) ipl_info.height; y++){
p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);
20. break;
21. BlueQuantum, pixels,&image->exception);
22. status=SetImageProgress(image,SaveImagesTag,scene++,
GetImageListLength(image));","8
11
20
26
49-50
53
74
76
85
89
104
106-107
113-114
117
133-134
152
154
156-157
160-161
163
165
180-181","CWE-772,CWE-119"
gif_process_raster-135119347838718,"static SIXELSTATUS
gif_process_raster(
    gif_context_t  *s,
    gif_t          *g
)
{
    SIXELSTATUS status = SIXEL_FALSE;
    unsigned char lzw_cs;
    signed int len, code;
    unsigned int first;
    signed int codesize, codemask, avail, oldcode, bits, valid_bits, clear;
    gif_lzw *p;

    
    lzw_cs = gif_get8(s);
    if (lzw_cs > gif_lzw_max_code_size) {
        sixel_helper_set_additional_message(
            ""Unsupported GIF (LZW code size)"");
        status = SIXEL_RUNTIME_ERROR;
        goto end;
    }

    clear = 1 << lzw_cs;
    first = 1;
    codesize = lzw_cs + 1;
    codemask = (1 << codesize) - 1;
    bits = 0;
    valid_bits = 0;
    for (code = 0; code < clear; code++) {
        g->codes[code].prefix = -1;
        g->codes[code].first = (unsigned char) code;
        g->codes[code].suffix = (unsigned char) code;
    }

    
    avail = clear + 2;
    oldcode = (-1);

    len = 0;
    for(;;) {
        if (valid_bits < codesize) {
            if (len == 0) {
                len = gif_get8(s); 
                if (len == 0) {
                    return SIXEL_OK;
                }
            }
            --len;
            bits |= (signed int) gif_get8(s) << valid_bits;
            valid_bits += 8;
        } else {
            code = bits & codemask;
            bits >>= codesize;
            valid_bits -= codesize;
            
            if (code == clear) {  
                codesize = lzw_cs + 1;
                codemask = (1 << codesize) - 1;
                avail = clear + 2;
                oldcode = -1;
                first = 0;
            } else if (code == clear + 1) { 
                s->img_buffer += len;
                while ((len = gif_get8(s)) > 0) {
                    s->img_buffer += len;
                }
                return SIXEL_OK;
            } else if (code <= avail) {
                if (first) {
                    sixel_helper_set_additional_message(
                        ""corrupt GIF (reason: no clear code)."");
                    status = SIXEL_RUNTIME_ERROR;
                    goto end;
                }
                if (oldcode >= 0) {
                    if (avail < (1 << gif_lzw_max_code_size)) {
                        p = &g->codes[avail++];
                        p->prefix = (signed short) oldcode;
                        p->first = g->codes[oldcode].first;
                        p->suffix = (code == avail) ? p->first : g->codes[code].first;
                    }
                } else if (code == avail) {
                    sixel_helper_set_additional_message(
                        ""corrupt GIF (reason: illegal code in raster)."");
                    status = SIXEL_RUNTIME_ERROR;
                    goto end;
                }

                gif_out_code(g, (unsigned short) code);

                if ((avail & codemask) == 0 && avail <= 0x0FFF) {
                    codesize++;
                    codemask = (1 << codesize) - 1;
                }

                oldcode = code;
            } else {
                sixel_helper_set_additional_message(
                    ""corrupt GIF (reason: illegal code in raster)."");
                status = SIXEL_RUNTIME_ERROR;
                goto end;
            }
        }
    }

    status = SIXEL_OK;

end:
    return status;
}
","1. signed int len, code;
2. g->codes[code].prefix = -1;
3. if (len == 0) {
len = gif_get8(s);
4. avail = clear + 2;
5. } else if (code == clear + 1) {
6. while ((len = gif_get8(s)) > 0) {
7. if (first) {
8. status = SIXEL_RUNTIME_ERROR;
9. goto end;","9
30
42-43
59
62
64
69
72
86","CWE-17,CWE-787,CWE-119"
t1_check_unusual_charstring_1-200424129552097,"static void t1_check_unusual_charstring_1(void)
{
    char *p = strstr(t1_line_array, charstringname) + strlen(charstringname);
    int i;
    
    if (sscanf(p, ""%i"", &i) != 1) {
        strcpy(t1_buf_array, t1_line_array);
        t1_getline();
        alloc_array(t1_buf, strlen(t1_line_array) + strlen(t1_buf_array) + 1, T1_BUF_SIZE);
        strcat(t1_buf_array, t1_line_array);
        alloc_array(t1_line, strlen(t1_buf_array) + 1, T1_BUF_SIZE);
        strcpy(t1_line_array, t1_buf_array);
        t1_line_ptr = eol(t1_line_array);
    }
}
","1. char *p = strstr(t1_line_array, charstringname) + strlen(charstringname);
2. if (sscanf(p, ""%i"", &i) != 1) {
strcpy(t1_buf_array, t1_line_array);
t1_getline();
alloc_array(t1_buf, strlen(t1_line_array) + strlen(t1_buf_array) + 1, T1_BUF_SIZE);
strcat(t1_buf_array, t1_line_array);
alloc_array(t1_line, strlen(t1_buf_array) + 1, T1_BUF_SIZE);
3. t1_line_ptr = eol(t1_line_array);","3
6-11
13","CWE-125,CWE-119"
__nfs4_close-192906662472405,"static void __nfs4_close(struct path *path, struct nfs4_state *state, fmode_t fmode, int wait)
{
	struct nfs4_state_owner *owner = state->owner;
	int call_close = 0;
	fmode_t newstate;

	atomic_inc(&owner->so_count);
	
	spin_lock(&owner->so_lock);
	switch (fmode & (FMODE_READ | FMODE_WRITE)) {
		case FMODE_READ:
			state->n_rdonly--;
			break;
		case FMODE_WRITE:
			state->n_wronly--;
			break;
		case FMODE_READ|FMODE_WRITE:
			state->n_rdwr--;
	}
	newstate = FMODE_READ|FMODE_WRITE;
	if (state->n_rdwr == 0) {
		if (state->n_rdonly == 0) {
			newstate &= ~FMODE_READ;
			call_close |= test_bit(NFS_O_RDONLY_STATE, &state->flags);
			call_close |= test_bit(NFS_O_RDWR_STATE, &state->flags);
		}
		if (state->n_wronly == 0) {
			newstate &= ~FMODE_WRITE;
			call_close |= test_bit(NFS_O_WRONLY_STATE, &state->flags);
			call_close |= test_bit(NFS_O_RDWR_STATE, &state->flags);
		}
		if (newstate == 0)
			clear_bit(NFS_DELEGATED_STATE, &state->flags);
	}
	nfs4_state_set_mode_locked(state, newstate);
	spin_unlock(&owner->so_lock);

	if (!call_close) {
		nfs4_put_open_state(state);
		nfs4_put_state_owner(owner);
	} else
		nfs4_do_close(path, state, wait);
}
","1. struct nfs4_state_owner *owner = state->owner;
int call_close = 0;
fmode_t newstate;
2. atomic_inc(&owner->so_count);
3. spin_lock(&owner->so_lock);
switch (fmode & (FMODE_READ | FMODE_WRITE)) {
case FMODE_READ:
state->n_rdonly--;
break;
case FMODE_WRITE:
state->n_wronly--;
break;
case FMODE_READ|FMODE_WRITE:
4. newstate = FMODE_READ|FMODE_WRITE;
if (state->n_rdwr == 0) {
if (state->n_rdonly == 0) {
newstate &= ~FMODE_READ;
5. call_close |= test_bit(NFS_O_RDWR_STATE, &state->flags);
6. if (state->n_wronly == 0) {
newstate &= ~FMODE_WRITE;
call_close |= test_bit(NFS_O_WRONLY_STATE, &state->flags);
call_close |= test_bit(NFS_O_RDWR_STATE, &state->flags);
7. if (newstate == 0)
clear_bit(NFS_DELEGATED_STATE, &state->flags);
8. nfs4_state_set_mode_locked(state, newstate);
spin_unlock(&owner->so_lock);
9. nfs4_put_open_state(state);
nfs4_put_state_owner(owner);
10. nfs4_do_close(path, state, wait);","3-5
7
9-17
20-23
25
27-30
32-33
35-36
39-40
42","CWE-269,CWE-20"
vt_reset_keyboard," int vt_reset_keyboard(int fd) {
        int kb, r;
 
         
         kb = vt_default_utf8() != 0 ? K_UNICODE : K_XLATE;
 
        r = vt_verify_kbmode(fd);
        if (r == -EBUSY) {
                log_debug_errno(r, ""Keyboard is not in XLATE or UNICODE mode, not resetting: %m"");
                return 0;
        } else if (r < 0)
                return r;

         if (ioctl(fd, KDSKBMODE, kb) < 0)
                 return -errno;
 
        return 0;
}
","1. int kb, r;
2. if (r == -EBUSY) {
log_debug_errno(r, ""Keyboard is not in XLATE or UNICODE mode, not resetting: %m"");
3. } else if (r < 0)
4. if (ioctl(fd, KDSKBMODE, kb) < 0)
return -errno;
5. return 0;","2
8-9
11
14-15
17","CWE-255,CWE-787,CWE-264,CWE-22"
mapi_attr_read-269537695494408,"MAPI_Attr**
mapi_attr_read (size_t len, unsigned char *buf)
{
    size_t idx = 0;
    uint32 i,j;
    assert(len > 4);
    uint32 num_properties = GETINT32(buf+idx);
    assert((num_properties+1) != 0);
    MAPI_Attr** attrs = CHECKED_XMALLOC (MAPI_Attr*, (num_properties + 1));

    idx += 4;

    if (!attrs) return NULL;
    for (i = 0; i < num_properties; i++)
    {
	MAPI_Attr* a = attrs[i] = CHECKED_XCALLOC(MAPI_Attr, 1);
	MAPI_Value* v = NULL;

	CHECKINT16(idx, len); a->type = GETINT16(buf+idx); idx += 2;
	CHECKINT16(idx, len); a->name = GETINT16(buf+idx); idx += 2;

	
	if (a->name & GUID_EXISTS_FLAG)
	{
	    
	    a->guid = CHECKED_XMALLOC(GUID, 1);
	    copy_guid_from_buf(a->guid, buf+idx, len);
	    idx += sizeof (GUID);

	    CHECKINT32(idx, len); a->num_names = GETINT32(buf+idx); idx += 4;
	    if (a->num_names > 0)
	    {
		
		size_t i;

		a->names = CHECKED_XCALLOC(VarLenData, a->num_names);

		for (i = 0; i < a->num_names; i++)
		{
		    size_t j;

		    CHECKINT32(idx, len); a->names[i].len = GETINT32(buf+idx); idx += 4;

		    
		    a->names[i].data 
			= CHECKED_XMALLOC(unsigned char, a->names[i].len);
		    assert((idx+(a->names[i].len*2)) <= len);
		    for (j = 0; j < (a->names[i].len >> 1); j++)
			a->names[i].data[j] = (buf+idx)[j*2];

		    
		    
		    idx += pad_to_4byte(a->names[i].len);
		}
	    }
	    else
	    {
		
		CHECKINT32(idx, len); a->name = GETINT32(buf+idx); idx+= 4;
	    }
	}

	
	if (a->type & MULTI_VALUE_FLAG ||
	    a->type == szMAPI_STRING ||
	    a->type == szMAPI_UNICODE_STRING ||
	    a->type == szMAPI_OBJECT ||
	    a->type == szMAPI_BINARY)
	{
	    CHECKINT32(idx, len); a->num_values = GETINT32(buf+idx);
	    idx += 4;
	}
        else
        {
	    a->num_values = 1;
        }

	
	if (a->type & MULTI_VALUE_FLAG)
	{
	    a->type -= MULTI_VALUE_FLAG;
	}


	v = alloc_mapi_values (a);

	for (j = 0; j < a->num_values; j++) 
	{
	    switch (a->type)
	    {
	    case szMAPI_SHORT:	
		v->len = 2;
		CHECKINT16(idx, len); v->data.bytes2 = GETINT16(buf+idx);
		idx += 4;	
		break;

	    case szMAPI_INT:	
		v->len = 4;
		CHECKINT32(idx, len); v->data.bytes4 = GETINT32(buf+idx);
		idx += 4;
		v++;
		break;

	    case szMAPI_FLOAT:	
	    case szMAPI_BOOLEAN: 
		v->len = 4;
		CHECKINT32(idx, len); v->data.bytes4 = GETINT32(buf+idx);
		idx += v->len;
		break;

	    case szMAPI_SYSTIME: 
		v->len = 8;
		CHECKINT32(idx, len); v->data.bytes8[0] = GETINT32(buf+idx);
		CHECKINT32(idx+4, len); v->data.bytes8[1] = GETINT32(buf+idx+4);
		idx += 8;
		v++;
		break;

	    case szMAPI_DOUBLE:	
	    case szMAPI_APPTIME:
	    case szMAPI_CURRENCY:
	    case szMAPI_INT8BYTE:
		v->len = 8;
		CHECKINT32(idx, len); v->data.bytes8[0] = GETINT32(buf+idx);
		CHECKINT32(idx+4, len); v->data.bytes8[1] = GETINT32(buf+idx+4);
		idx += v->len;
		break;

	    case szMAPI_CLSID:
		v->len = sizeof (GUID);
		copy_guid_from_buf(&v->data.guid, buf+idx, len);
		idx += v->len;
		break;

	    case szMAPI_STRING:
	    case szMAPI_UNICODE_STRING:
	    case szMAPI_OBJECT:
	    case szMAPI_BINARY:
		CHECKINT32(idx, len); v->len = GETINT32(buf+idx); idx += 4;

		assert(v->len + idx <= len);

		if (a->type == szMAPI_UNICODE_STRING)
		{
		    assert(v->len != 0);
		    v->data.buf = (unsigned char*)unicode_to_utf8(v->len, buf+idx);
		}
		else
		{
		    v->data.buf = CHECKED_XMALLOC(unsigned char, v->len);
		    memmove (v->data.buf, buf+idx, v->len);
		}

		idx += pad_to_4byte(v->len);
		v++;
		break;

	    case szMAPI_NULL:	
	    case szMAPI_ERROR:
	    case szMAPI_UNSPECIFIED:
		fprintf (stderr,
			 ""Invalid attribute, input file may be corrupted\n"");
		if (!ENCODE_SKIP) exit (1);

		return NULL;

	    default:		
		fprintf (stderr,
			 ""Undefined attribute, input file may be corrupted\n"");
		if (!ENCODE_SKIP) exit (1);

		return NULL;

	    }
	    if (DEBUG_ON) mapi_attr_dump (attrs[i]);
	}
    }
    attrs[i] = NULL;

    return attrs;
}
","1. mapi_attr_read (size_t len, unsigned char *buf)
2. if (!attrs) return NULL;
for (i = 0; i < num_properties; i++)
3. CHECKINT16(idx, len); a->type = GETINT16(buf+idx); idx += 2;
4. if (a->num_names > 0)
5. size_t i;
6. for (i = 0; i < a->num_names; i++)
7. assert((idx+(a->names[i].len*2)) <= len);
8. idx += pad_to_4byte(a->names[i].len);
9. {
10. a->type == szMAPI_OBJECT ||
a->type == szMAPI_BINARY)
11. {
12. if (a->type & MULTI_VALUE_FLAG)
13. switch (a->type)
14. case szMAPI_SHORT:
15. CHECKINT16(idx, len); v->data.bytes2 = GETINT16(buf+idx);
idx += 4;
16. case szMAPI_FLOAT:
17. v->len = 4;
18. v->len = 8;
19. idx += 8;
v++;
break;
20. case szMAPI_DOUBLE:
21. case szMAPI_INT8BYTE:
22. idx += v->len;
23. case szMAPI_CLSID:
24. copy_guid_from_buf(&v->data.guid, buf+idx, len);
25. if (a->type == szMAPI_UNICODE_STRING)
26. assert(v->len != 0);
v->data.buf = (unsigned char*)unicode_to_utf8(v->len, buf+idx);
27. {
28. v++;
break;
29. case szMAPI_UNSPECIFIED:
30. if (!ENCODE_SKIP) exit (1);
31. return NULL;
32. ""Undefined attribute, input file may be corrupted\n"");
if (!ENCODE_SKIP) exit (1);
33. return NULL;","2
13-14
19
31
34
38
47
53
57
70-71
77
82
92
94
96-97
107
109
115
118-120
122
125
129
132
134
146
148-149
152
158-159
163
166
168
172-173
175","CWE-362,CWE-200,CWE-125,CWE-189"
__udf_read_inode," static void __udf_read_inode(struct inode *inode)
 {
 	struct buffer_head *bh = NULL;
	struct fileEntry *fe;
	struct extendedFileEntry *efe;
	uint16_t ident;
 	struct udf_inode_info *iinfo = UDF_I(inode);
 	struct udf_sb_info *sbi = UDF_SB(inode->i_sb);
 	unsigned int link_count;
	unsigned int indirections = 0;
 
reread:
 	
	bh = udf_read_ptagged(inode->i_sb, &iinfo->i_location, 0, &ident);
	if (!bh) {
		udf_err(inode->i_sb, ""(ino %ld) failed !bh\n"", inode->i_ino);
		make_bad_inode(inode);
		return;
	}

	if (ident != TAG_IDENT_FE && ident != TAG_IDENT_EFE &&
	    ident != TAG_IDENT_USE) {
		udf_err(inode->i_sb, ""(ino %ld) failed ident=%d\n"",
			inode->i_ino, ident);
		brelse(bh);
		make_bad_inode(inode);
		return;
	}

	fe = (struct fileEntry *)bh->b_data;
	efe = (struct extendedFileEntry *)bh->b_data;

	if (fe->icbTag.strategyType == cpu_to_le16(4096)) {
		struct buffer_head *ibh;

 		ibh = udf_read_ptagged(inode->i_sb, &iinfo->i_location, 1,
 					&ident);
 		if (ident == TAG_IDENT_IE && ibh) {
 			struct kernel_lb_addr loc;
 			struct indirectEntry *ie;
 
 			ie = (struct indirectEntry *)ibh->b_data;
 			loc = lelb_to_cpu(ie->indirectICB.extLocation);
 
			if (ie->indirectICB.extLength) {
				brelse(bh);
				brelse(ibh);
				memcpy(&iinfo->i_location, &loc,
				       sizeof(struct kernel_lb_addr));
				if (++indirections > UDF_MAX_ICB_NESTING) {
					udf_err(inode->i_sb,
						""too many ICBs in ICB hierarchy""
						"" (max %d supported)\n"",
						UDF_MAX_ICB_NESTING);
					make_bad_inode(inode);
 					return;
 				}
				goto reread;
 			}
 		}
 		brelse(ibh);
	} else if (fe->icbTag.strategyType != cpu_to_le16(4)) {
		udf_err(inode->i_sb, ""unsupported strategy type: %d\n"",
			le16_to_cpu(fe->icbTag.strategyType));
		brelse(bh);
		make_bad_inode(inode);
		return;
	}
	if (fe->icbTag.strategyType == cpu_to_le16(4))
		iinfo->i_strat4096 = 0;
	else 
		iinfo->i_strat4096 = 1;

	iinfo->i_alloc_type = le16_to_cpu(fe->icbTag.flags) &
							ICBTAG_FLAG_AD_MASK;
	iinfo->i_unique = 0;
	iinfo->i_lenEAttr = 0;
	iinfo->i_lenExtents = 0;
	iinfo->i_lenAlloc = 0;
	iinfo->i_next_alloc_block = 0;
	iinfo->i_next_alloc_goal = 0;
	if (fe->descTag.tagIdent == cpu_to_le16(TAG_IDENT_EFE)) {
		iinfo->i_efe = 1;
		iinfo->i_use = 0;
		if (udf_alloc_i_data(inode, inode->i_sb->s_blocksize -
					sizeof(struct extendedFileEntry))) {
			make_bad_inode(inode);
			return;
		}
		memcpy(iinfo->i_ext.i_data,
		       bh->b_data + sizeof(struct extendedFileEntry),
		       inode->i_sb->s_blocksize -
					sizeof(struct extendedFileEntry));
	} else if (fe->descTag.tagIdent == cpu_to_le16(TAG_IDENT_FE)) {
		iinfo->i_efe = 0;
		iinfo->i_use = 0;
		if (udf_alloc_i_data(inode, inode->i_sb->s_blocksize -
						sizeof(struct fileEntry))) {
			make_bad_inode(inode);
			return;
		}
		memcpy(iinfo->i_ext.i_data,
		       bh->b_data + sizeof(struct fileEntry),
		       inode->i_sb->s_blocksize - sizeof(struct fileEntry));
	} else if (fe->descTag.tagIdent == cpu_to_le16(TAG_IDENT_USE)) {
		iinfo->i_efe = 0;
		iinfo->i_use = 1;
		iinfo->i_lenAlloc = le32_to_cpu(
				((struct unallocSpaceEntry *)bh->b_data)->
				 lengthAllocDescs);
		if (udf_alloc_i_data(inode, inode->i_sb->s_blocksize -
					sizeof(struct unallocSpaceEntry))) {
			make_bad_inode(inode);
			return;
		}
		memcpy(iinfo->i_ext.i_data,
		       bh->b_data + sizeof(struct unallocSpaceEntry),
		       inode->i_sb->s_blocksize -
					sizeof(struct unallocSpaceEntry));
		return;
	}

	read_lock(&sbi->s_cred_lock);
	i_uid_write(inode, le32_to_cpu(fe->uid));
	if (!uid_valid(inode->i_uid) ||
	    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_UID_IGNORE) ||
	    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_UID_SET))
		inode->i_uid = UDF_SB(inode->i_sb)->s_uid;

	i_gid_write(inode, le32_to_cpu(fe->gid));
	if (!gid_valid(inode->i_gid) ||
	    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_GID_IGNORE) ||
	    UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_GID_SET))
		inode->i_gid = UDF_SB(inode->i_sb)->s_gid;

	if (fe->icbTag.fileType != ICBTAG_FILE_TYPE_DIRECTORY &&
			sbi->s_fmode != UDF_INVALID_MODE)
		inode->i_mode = sbi->s_fmode;
	else if (fe->icbTag.fileType == ICBTAG_FILE_TYPE_DIRECTORY &&
			sbi->s_dmode != UDF_INVALID_MODE)
		inode->i_mode = sbi->s_dmode;
	else
		inode->i_mode = udf_convert_permissions(fe);
	inode->i_mode &= ~sbi->s_umask;
	read_unlock(&sbi->s_cred_lock);

	link_count = le16_to_cpu(fe->fileLinkCount);
	if (!link_count)
		link_count = 1;
	set_nlink(inode, link_count);

	inode->i_size = le64_to_cpu(fe->informationLength);
	iinfo->i_lenExtents = inode->i_size;

	if (iinfo->i_efe == 0) {
		inode->i_blocks = le64_to_cpu(fe->logicalBlocksRecorded) <<
			(inode->i_sb->s_blocksize_bits - 9);

		if (!udf_disk_stamp_to_time(&inode->i_atime, fe->accessTime))
			inode->i_atime = sbi->s_record_time;

		if (!udf_disk_stamp_to_time(&inode->i_mtime,
					    fe->modificationTime))
			inode->i_mtime = sbi->s_record_time;

		if (!udf_disk_stamp_to_time(&inode->i_ctime, fe->attrTime))
			inode->i_ctime = sbi->s_record_time;

		iinfo->i_unique = le64_to_cpu(fe->uniqueID);
		iinfo->i_lenEAttr = le32_to_cpu(fe->lengthExtendedAttr);
		iinfo->i_lenAlloc = le32_to_cpu(fe->lengthAllocDescs);
		iinfo->i_checkpoint = le32_to_cpu(fe->checkpoint);
	} else {
		inode->i_blocks = le64_to_cpu(efe->logicalBlocksRecorded) <<
		    (inode->i_sb->s_blocksize_bits - 9);

		if (!udf_disk_stamp_to_time(&inode->i_atime, efe->accessTime))
			inode->i_atime = sbi->s_record_time;

		if (!udf_disk_stamp_to_time(&inode->i_mtime,
					    efe->modificationTime))
			inode->i_mtime = sbi->s_record_time;

		if (!udf_disk_stamp_to_time(&iinfo->i_crtime, efe->createTime))
			iinfo->i_crtime = sbi->s_record_time;

		if (!udf_disk_stamp_to_time(&inode->i_ctime, efe->attrTime))
			inode->i_ctime = sbi->s_record_time;

		iinfo->i_unique = le64_to_cpu(efe->uniqueID);
		iinfo->i_lenEAttr = le32_to_cpu(efe->lengthExtendedAttr);
		iinfo->i_lenAlloc = le32_to_cpu(efe->lengthAllocDescs);
		iinfo->i_checkpoint = le32_to_cpu(efe->checkpoint);
	}

	switch (fe->icbTag.fileType) {
	case ICBTAG_FILE_TYPE_DIRECTORY:
		inode->i_op = &udf_dir_inode_operations;
		inode->i_fop = &udf_dir_operations;
		inode->i_mode |= S_IFDIR;
		inc_nlink(inode);
		break;
	case ICBTAG_FILE_TYPE_REALTIME:
	case ICBTAG_FILE_TYPE_REGULAR:
	case ICBTAG_FILE_TYPE_UNDEF:
	case ICBTAG_FILE_TYPE_VAT20:
		if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)
			inode->i_data.a_ops = &udf_adinicb_aops;
		else
			inode->i_data.a_ops = &udf_aops;
		inode->i_op = &udf_file_inode_operations;
		inode->i_fop = &udf_file_operations;
		inode->i_mode |= S_IFREG;
		break;
	case ICBTAG_FILE_TYPE_BLOCK:
		inode->i_mode |= S_IFBLK;
		break;
	case ICBTAG_FILE_TYPE_CHAR:
		inode->i_mode |= S_IFCHR;
		break;
	case ICBTAG_FILE_TYPE_FIFO:
		init_special_inode(inode, inode->i_mode | S_IFIFO, 0);
		break;
	case ICBTAG_FILE_TYPE_SOCKET:
		init_special_inode(inode, inode->i_mode | S_IFSOCK, 0);
		break;
	case ICBTAG_FILE_TYPE_SYMLINK:
		inode->i_data.a_ops = &udf_symlink_aops;
		inode->i_op = &udf_symlink_inode_operations;
		inode->i_mode = S_IFLNK | S_IRWXUGO;
		break;
	case ICBTAG_FILE_TYPE_MAIN:
		udf_debug(""METADATA FILE-----\n"");
		break;
	case ICBTAG_FILE_TYPE_MIRROR:
		udf_debug(""METADATA MIRROR FILE-----\n"");
		break;
	case ICBTAG_FILE_TYPE_BITMAP:
		udf_debug(""METADATA BITMAP FILE-----\n"");
		break;
	default:
		udf_err(inode->i_sb, ""(ino %ld) failed unknown file type=%d\n"",
			inode->i_ino, fe->icbTag.fileType);
		make_bad_inode(inode);
		return;
	}
	if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {
		struct deviceSpec *dsea =
			(struct deviceSpec *)udf_get_extendedattr(inode, 12, 1);
		if (dsea) {
			init_special_inode(inode, inode->i_mode,
				MKDEV(le32_to_cpu(dsea->majorDeviceIdent),
				      le32_to_cpu(dsea->minorDeviceIdent)));
			
		} else
			make_bad_inode(inode);
	}
	brelse(bh);
}
","1. struct buffer_head *bh = NULL;
2. struct extendedFileEntry *efe;
3. struct udf_inode_info *iinfo = UDF_I(inode);
4. make_bad_inode(inode);
5. brelse(bh);
6. efe = (struct extendedFileEntry *)bh->b_data;
7. if (fe->icbTag.strategyType == cpu_to_le16(4096)) {
8. if (ident == TAG_IDENT_IE && ibh) {
9. struct indirectEntry *ie;
10. brelse(ibh);
11. if (++indirections > UDF_MAX_ICB_NESTING) {
12. ""too many ICBs in ICB hierarchy""
13. make_bad_inode(inode);
return;
14. } else if (fe->icbTag.strategyType != cpu_to_le16(4)) {
15. le16_to_cpu(fe->icbTag.strategyType));
16. return;
17. iinfo->i_alloc_type = le16_to_cpu(fe->icbTag.flags) &
18. iinfo->i_unique = 0;
19. iinfo->i_lenExtents = 0;
iinfo->i_lenAlloc = 0;
20. iinfo->i_efe = 1;
21. if (udf_alloc_i_data(inode, inode->i_sb->s_blocksize -
sizeof(struct extendedFileEntry))) {
make_bad_inode(inode);
22. bh->b_data + sizeof(struct extendedFileEntry),
inode->i_sb->s_blocksize -
23. iinfo->i_efe = 0;
iinfo->i_use = 0;
24. return;
25. } else if (fe->descTag.tagIdent == cpu_to_le16(TAG_IDENT_USE)) {
26. iinfo->i_use = 1;
27. ((struct unallocSpaceEntry *)bh->b_data)->
28. if (udf_alloc_i_data(inode, inode->i_sb->s_blocksize -
29. return;
30. memcpy(iinfo->i_ext.i_data,
31. read_lock(&sbi->s_cred_lock);
32. i_gid_write(inode, le32_to_cpu(fe->gid));
if (!gid_valid(inode->i_gid) ||
UDF_QUERY_FLAG(inode->i_sb, UDF_FLAG_GID_IGNORE) ||
33. else if (fe->icbTag.fileType == ICBTAG_FILE_TYPE_DIRECTORY &&
34. inode->i_mode &= ~sbi->s_umask;
read_unlock(&sbi->s_cred_lock);
35. link_count = 1;
36. if (iinfo->i_efe == 0) {
37. iinfo->i_unique = le64_to_cpu(fe->uniqueID);
iinfo->i_lenEAttr = le32_to_cpu(fe->lengthExtendedAttr);
38. (inode->i_sb->s_blocksize_bits - 9);
39. efe->modificationTime))
inode->i_mtime = sbi->s_record_time;
40. inode->i_ctime = sbi->s_record_time;
41. iinfo->i_lenEAttr = le32_to_cpu(efe->lengthExtendedAttr);
42. inc_nlink(inode);
43. case ICBTAG_FILE_TYPE_UNDEF:
44. if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)
inode->i_data.a_ops = &udf_adinicb_aops;
45. inode->i_mode |= S_IFCHR;
break;
case ICBTAG_FILE_TYPE_FIFO:
46. break;
47. inode->i_op = &udf_symlink_inode_operations;
48. break;
49. break;
50. if (dsea) {","3
5
7
28
36
42
44
49
51
58
61
63
66-67
73
75
78
85
87
89-90
94
96-98
102-103
106-107
111
116
118
120
122
125
127
134
141-143
150
155-156
160
166
180-181
186
192-193
199
202
212
216
218-219
230-232
237
240
245
251
261","CWE-189,CWE-399,CWE-119"
udf_get_filename-213245640441342,"int udf_get_filename(struct super_block *sb, uint8_t *sname, int slen,
		     uint8_t *dname, int dlen)
{
	struct ustr *filename, *unifilename;
	int len = 0;

	filename = kmalloc(sizeof(struct ustr), GFP_NOFS);
	if (!filename)
		return 0;

	unifilename = kmalloc(sizeof(struct ustr), GFP_NOFS);
	if (!unifilename)
		goto out1;

	if (udf_build_ustr_exact(unifilename, sname, slen))
		goto out2;

	if (UDF_QUERY_FLAG(sb, UDF_FLAG_UTF8)) {
		if (!udf_CS0toUTF8(filename, unifilename)) {
			udf_debug(""Failed in udf_get_filename: sname = %s\n"",
				  sname);
			goto out2;
		}
	} else if (UDF_QUERY_FLAG(sb, UDF_FLAG_NLS_MAP)) {
		if (!udf_CS0toNLS(UDF_SB(sb)->s_nls_map, filename,
				  unifilename)) {
			udf_debug(""Failed in udf_get_filename: sname = %s\n"",
				  sname);
			goto out2;
		}
	} else
		goto out2;

	len = udf_translate_to_linux(dname, dlen,
				     filename->u_name, filename->u_len,
				     unifilename->u_name, unifilename->u_len);
out2:
	kfree(unifilename);
out1:
	kfree(filename);
	return len;
}
","1. filename = kmalloc(sizeof(struct ustr), GFP_NOFS);
if (!filename)
2. len = udf_translate_to_linux(dname, dlen,
3. out1:","7-8
34
39","CWE-295,CWE-200,CWE-189,CWE-416"
fp54_exp_dig-19673824189897,"void fp54_exp_dig(fp54_t c, const fp54_t a, dig_t b) {
	bn_t _b;
	fp54_t t, v;
	int8_t u, naf[RLC_DIG + 1];
	size_t l;

	if (b == 0) {
		fp54_set_dig(c, 1);
		return;
	}

	bn_null(_b);
	fp54_null(t);
	fp54_null(v);

	RLC_TRY {
		bn_new(_b);
		fp54_new(t);
		fp54_new(v);

		fp54_copy(t, a);

		if (fp54_test_cyc(a)) {
			fp54_inv_cyc(v, a);
			bn_set_dig(_b, b);

			l = RLC_DIG + 1;
			bn_rec_naf(naf, &l, _b, 2);

			for (int i = bn_bits(_b) - 2; i >= 0; i--) {
				fp54_sqr_cyc(t, t);

				u = naf[i];
				if (u > 0) {
					fp54_mul(t, t, a);
				} else if (u < 0) {
					fp54_mul(t, t, v);
				}
			}
		} else {
			for (int i = util_bits_dig(b) - 2; i >= 0; i--) {
				fp54_sqr(t, t);
				if (b & ((dig_t)1 << i)) {
					fp54_mul(t, t, a);
				}
			}
		}

		fp54_copy(c, t);
	}
	RLC_CATCH_ANY {
		RLC_THROW(ERR_CAUGHT);
	}
	RLC_FINALLY {
		bn_free(_b);
		fp54_free(t);
		fp54_free(v);
	}
}
",1. size_t l;,5,CWE-190
msp430_op-227084067760162,"
#define RAnal
#define RAnalOp
#define RAnalOpMask

static int msp430_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *buf, int len, RAnalOpMask mask) {
	struct msp430_cmd cmd = {0};
	op->size = -1;
	op->nopcode = 1;
	op->type = R_ANAL_OP_TYPE_UNK;
	op->family = R_ANAL_OP_FAMILY_CPU;

	int ret = op->size = msp430_decode_command (buf, len, &cmd);
	if (mask & R_ANAL_OP_MASK_DISASM) {
		if (ret < 1) {
			op->mnemonic = strdup (""invalid"");
		} else if (ret > 0) {
			if (cmd.operands[0]) {
				op->mnemonic = r_str_newf (""%s %s"",cmd.instr, cmd.operands);
			} else {
				op->mnemonic = strdup (cmd.instr);
			}
		}
		{ 
			char *ba = op->mnemonic;
			r_str_replace_ch (ba, '#', 0, 1);
			
			r_str_replace_ch (ba, '&', 0, 1);
			r_str_replace_ch (ba, '%', 0, 1);
		}
	}

	if (ret < 0) {
		return ret;
	}

	op->addr = addr;

	switch (cmd.type) {
	case MSP430_ONEOP:
		switch (cmd.opcode) {
		case MSP430_RRA:
		case MSP430_RRC:
			op->type = R_ANAL_OP_TYPE_ROR;
			break;
		case MSP430_PUSH:
			op->type = R_ANAL_OP_TYPE_PUSH;
			break;
		case MSP430_CALL:
			op->type = R_ANAL_OP_TYPE_CALL;
			op->fail = addr + op->size;
			if (len > 4) {
				op->jump = r_read_at_le16 (buf, 2);
			}
			break;
		case MSP430_RETI:
			op->type = R_ANAL_OP_TYPE_RET;
			break;
		}
		break;
	case MSP430_TWOOP:
		switch (cmd.opcode) {
		case MSP430_BIT:
		case MSP430_BIC:
		case MSP430_BIS:
		case MSP430_MOV:
			op->type = R_ANAL_OP_TYPE_MOV;
			if ((cmd.instr)[0] == 'b' && (cmd.instr)[1] == 'r') {
				
				op->type = R_ANAL_OP_TYPE_UJMP;
			}
			break;
		case MSP430_DADD:
		case MSP430_ADDC:
		case MSP430_ADD: op->type = R_ANAL_OP_TYPE_ADD; break;
		case MSP430_SUBC:
		case MSP430_SUB: op->type = R_ANAL_OP_TYPE_SUB; break;
		case MSP430_CMP: op->type = R_ANAL_OP_TYPE_CMP; break;
		case MSP430_XOR: op->type = R_ANAL_OP_TYPE_XOR; break;
		case MSP430_AND: op->type = R_ANAL_OP_TYPE_AND; break;
		}
		break;
	case MSP430_JUMP:
		if (cmd.jmp_cond == MSP430_JMP) {
			op->type = R_ANAL_OP_TYPE_JMP;
		} else {
			op->type = R_ANAL_OP_TYPE_CJMP;
		}
		op->jump = addr + cmd.jmp_addr;
		op->fail = addr + 2;
		break;
	case MSP430_INV:
		op->type = R_ANAL_OP_TYPE_ILL;
		break;
	default:
		op->type = R_ANAL_OP_TYPE_UNK;
		break;
	}
	return ret;
}
","1. if (ret < 1) {
2. op->mnemonic = strdup (cmd.instr);
3. char *ba = op->mnemonic;
4. if (ret < 0) {
5. break;
6. break;
7. case MSP430_AND: op->type = R_ANAL_OP_TYPE_AND; break;","15
21
25
33
55
58
80","CWE-476,CWE-362,CWE-416"
tmx_check_pretran-165279644832706,"int tmx_check_pretran(sip_msg_t *msg)
{
	unsigned int chid;
	unsigned int slotid;
	int dsize;
	struct via_param *vbr;
	str scallid;
	str scseqmet;
	str scseqnum;
	str sftag;
	str svbranch = {NULL, 0};
	pretran_t *it;

	if(_tmx_ptran_table==NULL) {
		LM_ERR(""pretran hash table not initialized yet\n"");
		return -1;
	}
	if(get_route_type()!=REQUEST_ROUTE) {
		LM_ERR(""invalid usage - not in request route\n"");
		return -1;
	}
	if(msg->first_line.type!=SIP_REQUEST) {
		LM_ERR(""invalid usage - not a sip request\n"");
		return -1;
	}
	if(parse_headers(msg, HDR_FROM_F|HDR_VIA1_F|HDR_CALLID_F|HDR_CSEQ_F, 0)<0) {
		LM_ERR(""failed to parse required headers\n"");
		return -1;
	}
	if(msg->cseq==NULL || msg->cseq->parsed==NULL) {
		LM_ERR(""failed to parse cseq headers\n"");
		return -1;
	}
	if(get_cseq(msg)->method_id==METHOD_ACK
			|| get_cseq(msg)->method_id==METHOD_CANCEL) {
		LM_DBG(""no pre-transaction management for ACK or CANCEL\n"");
		return -1;
	}
	if (msg->via1==0) {
		LM_ERR(""failed to get Via header\n"");
		return -1;
	}
	if (parse_from_header(msg)<0 || get_from(msg)->tag_value.len==0) {
		LM_ERR(""failed to get From header\n"");
		return -1;
	}
	if (msg->callid==NULL || msg->callid->body.s==NULL) {
		LM_ERR(""failed to parse callid headers\n"");
		return -1;
	}

	vbr = msg->via1->branch;

	scallid = msg->callid->body;
	trim(&scallid);
	scseqmet = get_cseq(msg)->method;
	trim(&scseqmet);
	scseqnum = get_cseq(msg)->number;
	trim(&scseqnum);
	sftag = get_from(msg)->tag_value;
	trim(&sftag);

	chid = get_hash1_raw(msg->callid->body.s, msg->callid->body.len);
	slotid = chid & (_tmx_ptran_size-1);

	if(unlikely(_tmx_proc_ptran == NULL)) {
		_tmx_proc_ptran = (pretran_t*)shm_malloc(sizeof(pretran_t));
		if(_tmx_proc_ptran == NULL) {
			LM_ERR(""not enough memory for pretran structure\n"");
			return -1;
		}
		memset(_tmx_proc_ptran, 0, sizeof(pretran_t));
		_tmx_proc_ptran->pid = my_pid();
	}
	dsize = scallid.len + scseqnum.len + scseqmet.len
		+ sftag.len + 4;
	if(likely(vbr!=NULL)) {
		svbranch = vbr->value;
		trim(&svbranch);
		dsize += svbranch.len + 1;
	}
	if(dsize<256) dsize = 256;

	tmx_pretran_unlink();

	if(dsize > _tmx_proc_ptran->dbuf.len) {
		if(_tmx_proc_ptran->dbuf.s) shm_free(_tmx_proc_ptran->dbuf.s);
		_tmx_proc_ptran->dbuf.s = (char*)shm_malloc(dsize);
		if(_tmx_proc_ptran->dbuf.s==NULL) {
			LM_ERR(""not enough memory for pretran data\n"");
			return -1;
		}
		_tmx_proc_ptran->dbuf.len = dsize;
	}
	_tmx_proc_ptran->hid = chid;
	_tmx_proc_ptran->cseqmetid = (get_cseq(msg))->method_id;

	_tmx_proc_ptran->callid.s = _tmx_proc_ptran->dbuf.s;
	memcpy(_tmx_proc_ptran->callid.s, scallid.s, scallid.len);
	_tmx_proc_ptran->callid.len = scallid.len;
	_tmx_proc_ptran->callid.s[_tmx_proc_ptran->callid.len] = '\0';

	_tmx_proc_ptran->ftag.s = _tmx_proc_ptran->callid.s
		+ _tmx_proc_ptran->callid.len + 1;
	memcpy(_tmx_proc_ptran->ftag.s, sftag.s, sftag.len);
	_tmx_proc_ptran->ftag.len = sftag.len;
	_tmx_proc_ptran->ftag.s[_tmx_proc_ptran->ftag.len] = '\0';

	_tmx_proc_ptran->cseqnum.s = _tmx_proc_ptran->ftag.s
		+ _tmx_proc_ptran->ftag.len + 1;
	memcpy(_tmx_proc_ptran->cseqnum.s, scseqnum.s, scseqnum.len);
	_tmx_proc_ptran->cseqnum.len = scseqnum.len;
	_tmx_proc_ptran->cseqnum.s[_tmx_proc_ptran->cseqnum.len] = '\0';

	_tmx_proc_ptran->cseqmet.s = _tmx_proc_ptran->cseqnum.s
		+ _tmx_proc_ptran->cseqnum.len + 1;
	memcpy(_tmx_proc_ptran->cseqmet.s, scseqmet.s, scseqmet.len);
	_tmx_proc_ptran->cseqmet.len = scseqmet.len;
	_tmx_proc_ptran->cseqmet.s[_tmx_proc_ptran->cseqmet.len] = '\0';

	if(likely(vbr!=NULL)) {
		_tmx_proc_ptran->vbranch.s = _tmx_proc_ptran->cseqmet.s
			+ _tmx_proc_ptran->cseqmet.len + 1;
		memcpy(_tmx_proc_ptran->vbranch.s, svbranch.s, svbranch.len);
		_tmx_proc_ptran->vbranch.len = svbranch.len;
		_tmx_proc_ptran->vbranch.s[_tmx_proc_ptran->vbranch.len] = '\0';
	} else {
		_tmx_proc_ptran->vbranch.s = NULL;
		_tmx_proc_ptran->vbranch.len = 0;
	}

	lock_get(&_tmx_ptran_table[slotid].lock);
	it = _tmx_ptran_table[slotid].plist;
	tmx_pretran_link_safe(slotid);
	for(; it!=NULL; it=it->next) {
		if(_tmx_proc_ptran->hid != it->hid
				|| _tmx_proc_ptran->cseqmetid != it->cseqmetid
				|| _tmx_proc_ptran->callid.len != it->callid.len
				|| _tmx_proc_ptran->ftag.len != it->ftag.len
				|| _tmx_proc_ptran->cseqmet.len != it->cseqmet.len
				|| _tmx_proc_ptran->cseqnum.len != it->cseqnum.len)
			continue;
		if(_tmx_proc_ptran->vbranch.s != NULL && it->vbranch.s != NULL) {
			if(_tmx_proc_ptran->vbranch.len != it->vbranch.len)
				continue;
			
			if(_tmx_proc_ptran->vbranch.s[it->vbranch.len-1]
					!= it->vbranch.s[it->vbranch.len-1])
				continue;
			if(memcmp(_tmx_proc_ptran->vbranch.s,
						it->vbranch.s, it->vbranch.len)!=0)
				continue;
			
		}
		if(memcmp(_tmx_proc_ptran->callid.s,
					it->callid.s, it->callid.len)!=0
				|| memcmp(_tmx_proc_ptran->ftag.s,
					it->ftag.s, it->ftag.len)!=0
				|| memcmp(_tmx_proc_ptran->cseqnum.s,
					it->cseqnum.s, it->cseqnum.len)!=0)
			continue;
		if((it->cseqmetid==METHOD_OTHER || it->cseqmetid==METHOD_UNDEF)
				&& memcmp(_tmx_proc_ptran->cseqmet.s,
					it->cseqmet.s, it->cseqmet.len)!=0)
			continue;
		LM_DBG(""matched another pre-transaction by pid %d for [%.*s]\n"",
				it->pid, it->callid.len, it->callid.s);
		lock_release(&_tmx_ptran_table[slotid].lock);
		return 1;
	}
	lock_release(&_tmx_ptran_table[slotid].lock);
	return 0;
}
","1. unsigned int slotid;
2. LM_ERR(""invalid usage - not in request route\n"");
3. scseqnum = get_cseq(msg)->number;
4. memcpy(_tmx_proc_ptran->cseqnum.s, scseqnum.s, scseqnum.len);
5. + _tmx_proc_ptran->cseqnum.len + 1;
6. || memcmp(_tmx_proc_ptran->ftag.s,","4
19
58
111
116
164","CWE-20,CWE-824,CWE-190,CWE-787,CWE-119"
bnep_net_setup-121653235543986,"void bnep_net_setup(struct net_device *dev)
{

	memset(dev->broadcast, 0xff, ETH_ALEN);
	dev->addr_len = ETH_ALEN;

	ether_setup(dev);
	dev->priv_flags &= ~IFF_TX_SKB_SHARING;
	dev->netdev_ops = &bnep_netdev_ops;

	dev->watchdog_timeo  = HZ * 2;
}
","1. dev->addr_len = ETH_ALEN;
2. ether_setup(dev);
dev->priv_flags &= ~IFF_TX_SKB_SHARING;
dev->netdev_ops = &bnep_netdev_ops;","5
7-9","CWE-264,CWE-399"
proc_sys_readdir,"static int proc_sys_readdir(struct file *file, struct dir_context *ctx)
{
	struct ctl_table_header *head = grab_header(file_inode(file));
	struct ctl_table_header *h = NULL;
	struct ctl_table *entry;
	struct ctl_dir *ctl_dir;
	unsigned long pos;

	if (IS_ERR(head))
		return PTR_ERR(head);

 	ctl_dir = container_of(head, struct ctl_dir, header);
 
 	if (!dir_emit_dots(file, ctx))
		goto out;
 
 	pos = 2;
 
	for (first_entry(ctl_dir, &h, &entry); h; next_entry(&h, &entry)) {
		if (!scan(h, entry, &pos, file, ctx)) {
			sysctl_head_finish(h);
 			break;
 		}
 	}
out:
 	sysctl_head_finish(head);
 	return 0;
 }
","1. struct ctl_dir *ctl_dir;
2. pos = 2;
3. for (first_entry(ctl_dir, &h, &entry); h; next_entry(&h, &entry)) {","6
17
19","CWE-362,CWE-20,CWE-264,CWE-787"
sequential_row," sequential_row(standard_display *dp, png_structp pp, png_infop pi,
    const int iImage, const int iDisplay)
 {
   const int         npasses = dp->npasses;
   const int         do_interlace = dp->do_interlace &&
       dp->interlace_type == PNG_INTERLACE_ADAM7;
   const png_uint_32 height = standard_height(pp, dp->id);
   const png_uint_32 width = standard_width(pp, dp->id);
   const png_store*  ps = dp->ps;
    int pass;
 
    for (pass=0; pass<npasses; ++pass)
 {
      png_uint_32 y;
      png_uint_32 wPass = PNG_PASS_COLS(width, pass);

 for (y=0; y<height; ++y)
 {
 if (do_interlace)
 {
 
 if (wPass > 0 && PNG_ROW_IN_INTERLACE_PASS(y, pass))
 {
 
               png_byte row[STANDARD_ROWMAX], display[STANDARD_ROWMAX];

 
               memset(row, 0xc5, sizeof row);
               memset(display, 0x5c, sizeof display);

               png_read_row(pp, row, display);

 
                if (iImage >= 0)
                   deinterlace_row(store_image_row(ps, pp, iImage, y), row,
                     dp->pixel_size, dp->w, pass, dp->littleendian);
 
                if (iDisplay >= 0)
                   deinterlace_row(store_image_row(ps, pp, iDisplay, y), display,
                     dp->pixel_size, dp->w, pass, dp->littleendian);
             }
          }
          else
            png_read_row(pp,
               iImage >= 0 ? store_image_row(ps, pp, iImage, y) : NULL,
               iDisplay >= 0 ? store_image_row(ps, pp, iDisplay, y) : NULL);
 }
 }

 
   png_read_end(pp, pi);
}
","1. sequential_row(standard_display *dp, png_structp pp, png_infop pi,
const int iImage, const int iDisplay)
2. const int         npasses = dp->npasses;
const int         do_interlace = dp->do_interlace &&
dp->interlace_type == PNG_INTERLACE_ADAM7;
const png_uint_32 height = standard_height(pp, dp->id);
const png_uint_32 width = standard_width(pp, dp->id);
const png_store*  ps = dp->ps;
int pass;
3. for (pass=0; pass<npasses; ++pass)
4. memset(row, 0xc5, sizeof row);
5. png_read_row(pp, row, display);
6. if (iImage >= 0)
7. dp->pixel_size, dp->w, pass, dp->littleendian);
8. deinterlace_row(store_image_row(ps, pp, iDisplay, y), display,
9. png_read_row(pp,
iImage >= 0 ? store_image_row(ps, pp, iImage, y) : NULL,
10. png_read_end(pp, pi);","1-2
4-10
12
37
40
43
45
48
53-54
62","CWE-20,CWE-125,CWE-285"
concat_hash_string_1-13682808784916,"static u_int16_t concat_hash_string_1(struct ndpi_packet_struct *packet,
				   char *buf, u_int8_t client_hash) {
  u_int32_t offset = 22, buf_out_len = 0;
  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)
    goto invalid_payload;
  u_int32_t len = ntohl(*(u_int32_t*)&packet->payload[offset]);
  offset += 4;

  
  if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))
    goto invalid_payload;

  
  strncpy(buf, (const char *)&packet->payload[offset], buf_out_len = len);
  buf[buf_out_len++] = ';';
  offset += len;

  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)
    goto invalid_payload;
  
  len = ntohl(*(u_int32_t*)&packet->payload[offset]);
  if (len > UINT32_MAX - 4 - offset)
    goto invalid_payload;
  offset += 4 + len;

  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)
    goto invalid_payload;
  
  len = ntohl(*(u_int32_t*)&packet->payload[offset]);

  offset += 4;
  if(client_hash) {
    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))
      goto invalid_payload;

    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);
    buf_out_len += len;
    buf[buf_out_len++] = ';';
  }
  if (len > UINT32_MAX - offset)
    goto invalid_payload;
  offset += len;

  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)
    goto invalid_payload;
  
  len = ntohl(*(u_int32_t*)&packet->payload[offset]);

  offset += 4;
  if(!client_hash) {
    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))
      goto invalid_payload;

    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);
    buf_out_len += len;
    buf[buf_out_len++] = ';';
  }
  if (len > UINT32_MAX - offset)
    goto invalid_payload;
  offset += len;

  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)
    goto invalid_payload;
  
  len = ntohl(*(u_int32_t*)&packet->payload[offset]);

  offset += 4;
  if(client_hash) {
    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))
      goto invalid_payload;

    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);
    buf_out_len += len;
    buf[buf_out_len++] = ';';
  }
  if (len > UINT32_MAX - offset)
    goto invalid_payload;
  offset += len;

  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)
    goto invalid_payload;
  
  len = ntohl(*(u_int32_t*)&packet->payload[offset]);

  offset += 4;
  if(!client_hash) {
    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))
      goto invalid_payload;

    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);
    buf_out_len += len;
    buf[buf_out_len++] = ';';
  }
  if (len > UINT32_MAX - offset)
    goto invalid_payload;
  offset += len;

  
  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)
    goto invalid_payload;
  len = ntohl(*(u_int32_t*)&packet->payload[offset]);

  offset += 4;
  if(client_hash) {
    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))
      goto invalid_payload;

    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);
    buf_out_len += len;
  }
  if (len > UINT32_MAX - offset)
    goto invalid_payload;
  offset += len;

  if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)
    goto invalid_payload;
  
  len = ntohl(*(u_int32_t*)&packet->payload[offset]);

  offset += 4;
  if(!client_hash) {
    if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))
      goto invalid_payload;

    strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);
    buf_out_len += len;
  }
  if (len > UINT32_MAX - offset)
    goto invalid_payload;
  offset += len;

  

  

#ifdef SSH_DEBUG
  printf(""[SSH] %s\n"", buf);
#endif

  return(buf_out_len);

invalid_payload:

#ifdef SSH_DEBUG
  printf(""[SSH] Invalid packet payload\n"");
#endif

  return(0);
}
","1. static u_int16_t concat_hash_string_1(struct ndpi_packet_struct *packet,
char *buf, u_int8_t client_hash) {
2. if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)
3. goto invalid_payload;
4. strncpy(buf, (const char *)&packet->payload[offset], buf_out_len = len);
5. len = ntohl(*(u_int32_t*)&packet->payload[offset]);
if (len > UINT32_MAX - 4 - offset)
goto invalid_payload;
offset += 4 + len;
6. len = ntohl(*(u_int32_t*)&packet->payload[offset]);
7. offset += 4;
8. goto invalid_payload;
9. goto invalid_payload;
10. if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)
11. offset += 4;
if(!client_hash) {
12. goto invalid_payload;
13. buf_out_len += len;
14. goto invalid_payload;
15. goto invalid_payload;
16. offset += 4;
if(client_hash) {
17. goto invalid_payload;
18. strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);
19. if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))
goto invalid_payload;
20. goto invalid_payload;
21. goto invalid_payload;
22. offset += 4;
23. if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))
24. strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len);
buf_out_len += len;
25. if (len > UINT32_MAX - offset)
goto invalid_payload;
offset += len;
26. if(offset+sizeof(u_int32_t) >= packet->payload_packet_len)
27. len = ntohl(*(u_int32_t*)&packet->payload[offset]);
28. offset += 4;
29. if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1))
goto invalid_payload;
30. return(0);","1-2
4
11
14
21-24
29
31
34
41
44
49-50
52
55
59
63
67-68
70
72
87-88
95
100
103
105
108-109
111-113
115
118
120
122-123
148","CWE-19,CWE-189,CWE-119"
squashfs_opendir-201816087549526,"static struct dir *squashfs_opendir(unsigned int block_start, unsigned int offset,
	struct inode **i)
{
	squashfs_dir_header_2 dirh;
	char buffer[sizeof(squashfs_dir_entry_2) + SQUASHFS_NAME_LEN + 1]
		__attribute__((aligned));
	squashfs_dir_entry_2 *dire = (squashfs_dir_entry_2 *) buffer;
	long long start;
	int bytes;
	int dir_count, size;
	struct dir_ent *new_dir;
	struct dir *dir;

	TRACE(""squashfs_opendir: inode start block %d, offset %d\n"",
		block_start, offset);

	*i = read_inode(block_start, offset);

	dir = malloc(sizeof(struct dir));
	if(dir == NULL)
		EXIT_UNSQUASH(""squashfs_opendir: malloc failed!\n"");

	dir->dir_count = 0;
	dir->cur_entry = 0;
	dir->mode = (*i)->mode;
	dir->uid = (*i)->uid;
	dir->guid = (*i)->gid;
	dir->mtime = (*i)->time;
	dir->xattr = (*i)->xattr;
	dir->dirs = NULL;

	if ((*i)->data == 0)
		
		return dir;
		
	start = sBlk.s.directory_table_start + (*i)->start;
	bytes = lookup_entry(directory_table_hash, start);
	if(bytes == -1)
		EXIT_UNSQUASH(""squashfs_opendir: directory block %d not ""
			""found!\n"", block_start);

	bytes += (*i)->offset;
	size = (*i)->data + bytes;

	while(bytes < size) {			
		if(swap) {
			squashfs_dir_header_2 sdirh;
			memcpy(&sdirh, directory_table + bytes, sizeof(sdirh));
			SQUASHFS_SWAP_DIR_HEADER_2(&dirh, &sdirh);
		} else
			memcpy(&dirh, directory_table + bytes, sizeof(dirh));
	
		dir_count = dirh.count + 1;
		TRACE(""squashfs_opendir: Read directory header @ byte position ""
			""%d, %d directory entries\n"", bytes, dir_count);
		bytes += sizeof(dirh);

		
		if(dir_count > SQUASHFS_DIR_COUNT) {
			ERROR(""File system corrupted: too many entries in directory\n"");
			goto corrupted;
		}

		while(dir_count--) {
			if(swap) {
				squashfs_dir_entry_2 sdire;
				memcpy(&sdire, directory_table + bytes,
					sizeof(sdire));
				SQUASHFS_SWAP_DIR_ENTRY_2(dire, &sdire);
			} else
				memcpy(dire, directory_table + bytes,
					sizeof(*dire));
			bytes += sizeof(*dire);

			
			if(dire->size >= SQUASHFS_NAME_LEN) {
				ERROR(""File system corrupted: filename too long\n"");
				goto corrupted;
			}

			memcpy(dire->name, directory_table + bytes,
				dire->size + 1);
			dire->name[dire->size + 1] = '\0';

			
			if(check_name(dire->name, dire->size + 1) == FALSE) {
				ERROR(""File system corrupted: invalid characters in name\n"");
				goto corrupted;
			}

			TRACE(""squashfs_opendir: directory entry %s, inode ""
				""%d:%d, type %d\n"", dire->name,
				dirh.start_block, dire->offset, dire->type);
			if((dir->dir_count % DIR_ENT_SIZE) == 0) {
				new_dir = realloc(dir->dirs, (dir->dir_count +
					DIR_ENT_SIZE) * sizeof(struct dir_ent));
				if(new_dir == NULL)
					EXIT_UNSQUASH(""squashfs_opendir: ""
						""realloc failed!\n"");
				dir->dirs = new_dir;
			}
			strcpy(dir->dirs[dir->dir_count].name, dire->name);
			dir->dirs[dir->dir_count].start_block =
				dirh.start_block;
			dir->dirs[dir->dir_count].offset = dire->offset;
			dir->dirs[dir->dir_count].type = dire->type;
			dir->dir_count ++;
			bytes += dire->size + 1;
		}
	}

	return dir;

corrupted:
	free(dir->dirs);
	free(dir);
	return NULL;
}
","1. struct inode **i)
2. char buffer[sizeof(squashfs_dir_entry_2) + SQUASHFS_NAME_LEN + 1]
3. squashfs_dir_entry_2 *dire = (squashfs_dir_entry_2 *) buffer;
4. struct dir_ent *new_dir;
5. TRACE(""squashfs_opendir: inode start block %d, offset %d\n"",
6. *i = read_inode(block_start, offset);
7. dir->dir_count = 0;
8. dir->uid = (*i)->uid;
9. dir->xattr = (*i)->xattr;
10. start = sBlk.s.directory_table_start + (*i)->start;
11. if(bytes == -1)
12. bytes += (*i)->offset;
size = (*i)->data + bytes;
13. memcpy(&dirh, directory_table + bytes, sizeof(dirh));
14. memcpy(&sdire, directory_table + bytes,
15. bytes += sizeof(*dire);
16. dire->size + 1);
17. ERROR(""File system corrupted: invalid characters in name\n"");
18. dirh.start_block, dire->offset, dire->type);
19. if(new_dir == NULL)
20. dir->dirs = new_dir;
21. strcpy(dir->dirs[dir->dir_count].name, dire->name);
dir->dirs[dir->dir_count].start_block =
22. dir->dirs[dir->dir_count].offset = dire->offset;
23. bytes += dire->size + 1;
24. return dir;
25. corrupted:","2
5
7
11
14
17
23
26
29
41
43
47-48
56
72
78
87
92
98
102
105
107-108
110
113
117
119","CWE-22,CWE-287"
pmcraid_ioctl_passthrough-173586695433970,"static long pmcraid_ioctl_passthrough(
	struct pmcraid_instance *pinstance,
	unsigned int ioctl_cmd,
	unsigned int buflen,
	unsigned long arg
)
{
	struct pmcraid_passthrough_ioctl_buffer *buffer;
	struct pmcraid_ioarcb *ioarcb;
	struct pmcraid_cmd *cmd;
	struct pmcraid_cmd *cancel_cmd;
	unsigned long request_buffer;
	unsigned long request_offset;
	unsigned long lock_flags;
	void *ioasa;
	u32 ioasc;
	int request_size;
	int buffer_size;
	u8 access, direction;
	int rc = 0;

	
	if (pinstance->ioa_reset_in_progress) {
		rc = wait_event_interruptible_timeout(
				pinstance->reset_wait_q,
				!pinstance->ioa_reset_in_progress,
				msecs_to_jiffies(10000));

		if (!rc)
			return -ETIMEDOUT;
		else if (rc < 0)
			return -ERESTARTSYS;
	}

	
	if (pinstance->ioa_state != IOA_STATE_OPERATIONAL) {
		pmcraid_err(""IOA is not operational\n"");
		return -ENOTTY;
	}

	buffer_size = sizeof(struct pmcraid_passthrough_ioctl_buffer);
	buffer = kmalloc(buffer_size, GFP_KERNEL);

	if (!buffer) {
		pmcraid_err(""no memory for passthrough buffer\n"");
		return -ENOMEM;
	}

	request_offset =
	    offsetof(struct pmcraid_passthrough_ioctl_buffer, request_buffer);

	request_buffer = arg + request_offset;

	rc = __copy_from_user(buffer,
			     (struct pmcraid_passthrough_ioctl_buffer *) arg,
			     sizeof(struct pmcraid_passthrough_ioctl_buffer));

	ioasa =
	(void *)(arg +
		offsetof(struct pmcraid_passthrough_ioctl_buffer, ioasa));

	if (rc) {
		pmcraid_err(""ioctl: can't copy passthrough buffer\n"");
		rc = -EFAULT;
		goto out_free_buffer;
	}

	request_size = buffer->ioarcb.data_transfer_length;

	if (buffer->ioarcb.request_flags0 & TRANSFER_DIR_WRITE) {
		access = VERIFY_READ;
		direction = DMA_TO_DEVICE;
	} else {
		access = VERIFY_WRITE;
		direction = DMA_FROM_DEVICE;
	}

	if (request_size > 0) {
		rc = access_ok(access, arg, request_offset + request_size);

		if (!rc) {
			rc = -EFAULT;
			goto out_free_buffer;
		}
	} else if (request_size < 0) {
		rc = -EINVAL;
		goto out_free_buffer;
	}

	
	if (buffer->ioarcb.add_cmd_param_length > PMCRAID_ADD_CMD_PARAM_LEN) {
		rc = -EINVAL;
		goto out_free_buffer;
	}

	cmd = pmcraid_get_free_cmd(pinstance);

	if (!cmd) {
		pmcraid_err(""free command block is not available\n"");
		rc = -ENOMEM;
		goto out_free_buffer;
	}

	cmd->scsi_cmd = NULL;
	ioarcb = &(cmd->ioa_cb->ioarcb);

	
	ioarcb->resource_handle = buffer->ioarcb.resource_handle;
	ioarcb->data_transfer_length = buffer->ioarcb.data_transfer_length;
	ioarcb->cmd_timeout = buffer->ioarcb.cmd_timeout;
	ioarcb->request_type = buffer->ioarcb.request_type;
	ioarcb->request_flags0 = buffer->ioarcb.request_flags0;
	ioarcb->request_flags1 = buffer->ioarcb.request_flags1;
	memcpy(ioarcb->cdb, buffer->ioarcb.cdb, PMCRAID_MAX_CDB_LEN);

	if (buffer->ioarcb.add_cmd_param_length) {
		ioarcb->add_cmd_param_length =
			buffer->ioarcb.add_cmd_param_length;
		ioarcb->add_cmd_param_offset =
			buffer->ioarcb.add_cmd_param_offset;
		memcpy(ioarcb->add_data.u.add_cmd_params,
			buffer->ioarcb.add_data.u.add_cmd_params,
			buffer->ioarcb.add_cmd_param_length);
	}

	
	ioarcb->hrrq_id = atomic_add_return(1, &(pinstance->last_message_id)) %
			  pinstance->num_hrrq;

	if (request_size) {
		rc = pmcraid_build_passthrough_ioadls(cmd,
						      request_size,
						      direction);
		if (rc) {
			pmcraid_err(""couldn't build passthrough ioadls\n"");
			goto out_free_buffer;
		}
	} else if (request_size < 0) {
		rc = -EINVAL;
		goto out_free_buffer;
	}

	
	if (direction == DMA_TO_DEVICE && request_size > 0) {
		rc = pmcraid_copy_sglist(cmd->sglist,
					 request_buffer,
					 request_size,
					 direction);
		if (rc) {
			pmcraid_err(""failed to copy user buffer\n"");
			goto out_free_sglist;
		}
	}

	
	cmd->cmd_done = pmcraid_internal_done;
	init_completion(&cmd->wait_for_completion);
	cmd->completion_req = 1;

	pmcraid_info(""command(%d) (CDB[0] = %x) for %x\n"",
		     le32_to_cpu(cmd->ioa_cb->ioarcb.response_handle) >> 2,
		     cmd->ioa_cb->ioarcb.cdb[0],
		     le32_to_cpu(cmd->ioa_cb->ioarcb.resource_handle));

	spin_lock_irqsave(pinstance->host->host_lock, lock_flags);
	_pmcraid_fire_command(cmd);
	spin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);

	
	buffer->ioarcb.cmd_timeout = 0;

	
	if (buffer->ioarcb.cmd_timeout == 0) {
		wait_for_completion(&cmd->wait_for_completion);
	} else if (!wait_for_completion_timeout(
			&cmd->wait_for_completion,
			msecs_to_jiffies(buffer->ioarcb.cmd_timeout * 1000))) {

		pmcraid_info(""aborting cmd %d (CDB[0] = %x) due to timeout\n"",
			le32_to_cpu(cmd->ioa_cb->ioarcb.response_handle >> 2),
			cmd->ioa_cb->ioarcb.cdb[0]);

		spin_lock_irqsave(pinstance->host->host_lock, lock_flags);
		cancel_cmd = pmcraid_abort_cmd(cmd);
		spin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);

		if (cancel_cmd) {
			wait_for_completion(&cancel_cmd->wait_for_completion);
			ioasc = cancel_cmd->ioa_cb->ioasa.ioasc;
			pmcraid_return_cmd(cancel_cmd);

			
			if (ioasc == PMCRAID_IOASC_IOA_WAS_RESET ||
			    PMCRAID_IOASC_SENSE_KEY(ioasc) == 0x00) {
				if (ioasc != PMCRAID_IOASC_GC_IOARCB_NOTFOUND)
					rc = -ETIMEDOUT;
				goto out_handle_response;
			}
		}

		
		if (!wait_for_completion_timeout(
			&cmd->wait_for_completion,
			msecs_to_jiffies(150 * 1000))) {
			pmcraid_reset_bringup(cmd->drv_inst);
			rc = -ETIMEDOUT;
		}
	}

out_handle_response:
	
	if (copy_to_user(ioasa, &cmd->ioa_cb->ioasa,
		sizeof(struct pmcraid_ioasa))) {
		pmcraid_err(""failed to copy ioasa buffer to user\n"");
		rc = -EFAULT;
	}

	
	else if (direction == DMA_FROM_DEVICE && request_size > 0) {
		rc = pmcraid_copy_sglist(cmd->sglist,
					 request_buffer,
					 request_size,
					 direction);
		if (rc) {
			pmcraid_err(""failed to copy user buffer\n"");
			rc = -EFAULT;
		}
	}

out_free_sglist:
	pmcraid_release_passthrough_ioadls(cmd, request_size, direction);
	pmcraid_return_cmd(cmd);

out_free_buffer:
	kfree(buffer);

	return rc;
}
","1. unsigned long request_buffer;
2. buffer_size = sizeof(struct pmcraid_passthrough_ioctl_buffer);
3. access = VERIFY_WRITE;
4. goto out_free_buffer;
5. if (!cmd) {
6. memcpy(ioarcb->cdb, buffer->ioarcb.cdb, PMCRAID_MAX_CDB_LEN);
7. spin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);
8. pmcraid_info(""aborting cmd %d (CDB[0] = %x) due to timeout\n"",
9. spin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);
10. ioasc = cancel_cmd->ioa_cb->ioasa.ioasc;
11. else if (direction == DMA_FROM_DEVICE && request_size > 0) {
12. out_free_sglist:
13. out_free_buffer:","12
41
74
83
98
114
175
195
201
205
248
259
263","CWE-189,CWE-125,CWE-119,CWE-17,CWE-399"
hidp_setup_hid-86337834722986,"static int hidp_setup_hid(struct hidp_session *session,
				struct hidp_connadd_req *req)
{
	struct hid_device *hid;
	int err;

	session->rd_data = kzalloc(req->rd_size, GFP_KERNEL);
	if (!session->rd_data)
		return -ENOMEM;

	if (copy_from_user(session->rd_data, req->rd_data, req->rd_size)) {
		err = -EFAULT;
		goto fault;
	}
	session->rd_size = req->rd_size;

	hid = hid_allocate_device();
	if (IS_ERR(hid)) {
		err = PTR_ERR(hid);
		goto fault;
	}

	session->hid = hid;

	hid->driver_data = session;

	hid->bus     = BUS_BLUETOOTH;
	hid->vendor  = req->vendor;
	hid->product = req->product;
	hid->version = req->version;
	hid->country = req->country;

	strncpy(hid->name, req->name, sizeof(req->name) - 1);

	snprintf(hid->phys, sizeof(hid->phys), ""%pMR"",
		 &bt_sk(session->ctrl_sock->sk)->src);

	snprintf(hid->uniq, sizeof(hid->uniq), ""%pMR"",
		 &bt_sk(session->ctrl_sock->sk)->dst);

	hid->dev.parent = &session->conn->dev;
	hid->ll_driver = &hidp_hid_driver;

	hid->hid_get_raw_report = hidp_get_raw_report;
	hid->hid_output_raw_report = hidp_output_raw_report;

	
	if (hid_ignore(hid)) {
		hid_destroy_device(session->hid);
		session->hid = NULL;
		return -ENODEV;
	}

	return 0;

fault:
	kfree(session->rd_data);
	session->rd_data = NULL;

	return err;
}
","1. if (!session->rd_data)
2. goto fault;
3. &bt_sk(session->ctrl_sock->sk)->dst);
4. hid->dev.parent = &session->conn->dev;
5. kfree(session->rd_data);
session->rd_data = NULL;","8
13
39
41
57-58","CWE-134,CWE-200,CWE-400,CWE-119,CWE-125"
init_syntax_once-23846676397498,"static void
init_syntax_once ()
{
   register int c;
   static int done = 0;

   if (done)
     return;
   bzero (re_syntax_table, sizeof re_syntax_table);

   for (c = 0; c < CHAR_SET_SIZE; ++c)
     if (ISALNUM (c))
	re_syntax_table[c] = Sword;

   re_syntax_table['_'] = Sword;

   done = 1;
}
","1. for (c = 0; c < CHAR_SET_SIZE; ++c)
2. done = 1;","11
17","CWE-476,CWE-190,CWE-122"
SetUp_11," virtual void SetUp_11() {

     fwd_txfm_ = GET_PARAM(0);
     inv_txfm_ = GET_PARAM(1);
     tx_type_  = GET_PARAM(2);
    bit_depth_ = GET_PARAM(3);
     pitch_    = 16;
     fwd_txfm_ref = fdct16x16_ref;
    inv_txfm_ref = idct16x16_ref;
    mask_ = (1 << bit_depth_) - 1;
#if CONFIG_VP9_HIGHBITDEPTH
    switch (bit_depth_) {
      case VPX_BITS_10:
        inv_txfm_ref = idct16x16_10_ref;
        break;
      case VPX_BITS_12:
        inv_txfm_ref = idct16x16_12_ref;
        break;
      default:
        inv_txfm_ref = idct16x16_ref;
        break;
    }
#else
    inv_txfm_ref = idct16x16_ref;
#endif
   }
","1. virtual void SetUp_11() {
2. mask_ = (1 << bit_depth_) - 1;","1
10","CWE-416,CWE-284,CWE-119"
snd_ctl_add_1-145710281826120,"int snd_ctl_add_1(struct snd_card *card, struct snd_kcontrol *kcontrol)
{
	struct snd_ctl_elem_id id;
	unsigned int idx;
	unsigned int count;
	int err = -EINVAL;

	if (! kcontrol)
		return err;
	if (snd_BUG_ON(!card || !kcontrol->info))
		goto error;
	id = kcontrol->id;
	if (id.index > UINT_MAX - kcontrol->count)
		goto error;

	down_write(&card->controls_rwsem);
	if (snd_ctl_find_id(card, &id)) {
		up_write(&card->controls_rwsem);
		dev_err(card->dev, ""control %i:%i:%i:%s:%i is already present\n"",
					id.iface,
					id.device,
					id.subdevice,
					id.name,
					id.index);
		err = -EBUSY;
		goto error;
	}
	if (snd_ctl_find_hole(card, kcontrol->count) < 0) {
		up_write(&card->controls_rwsem);
		err = -ENOMEM;
		goto error;
	}
	list_add_tail(&kcontrol->list, &card->controls);
	card->controls_count += kcontrol->count;
	kcontrol->id.numid = card->last_numid + 1;
	card->last_numid += kcontrol->count;
	count = kcontrol->count;
	up_write(&card->controls_rwsem);
	for (idx = 0; idx < count; idx++, id.index++, id.numid++)
		snd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_ADD, &id);
	return 0;

 error:
	snd_ctl_free_one(kcontrol);
	return err;
}
","1. struct snd_ctl_elem_id id;
unsigned int idx;
2. return err;
if (snd_BUG_ON(!card || !kcontrol->info))
goto error;
3. if (id.index > UINT_MAX - kcontrol->count)
4. up_write(&card->controls_rwsem);
5. id.iface,
6. err = -EBUSY;
7. if (snd_ctl_find_hole(card, kcontrol->count) < 0) {
8. kcontrol->id.numid = card->last_numid + 1;
9. for (idx = 0; idx < count; idx++, id.index++, id.numid++)
10. error:","3-4
9-11
13
18
20
25
28
35
39
43","CWE-190,CWE-415,CWE-125,CWE-189"
stl_fix_normal_directions-109598304657211,"void
stl_fix_normal_directions(stl_file *stl) {
  char *norm_sw;
  
  
  int checked = 0;
  int facet_num;
  
  int i;
  int j;
  struct stl_normal {
    int               facet_num;
    struct stl_normal *next;
  };
  struct stl_normal *head;
  struct stl_normal *tail;
  struct stl_normal *newn;
  struct stl_normal *temp;

  if (stl->error) return;

  
  head = (struct stl_normal*)malloc(sizeof(struct stl_normal));
  if(head == NULL) perror(""stl_fix_normal_directions"");
  tail = (struct stl_normal*)malloc(sizeof(struct stl_normal));
  if(tail == NULL) perror(""stl_fix_normal_directions"");
  head->next = tail;
  tail->next = tail;

  
  norm_sw = (char*)calloc(stl->stats.number_of_facets, sizeof(char));
  if(norm_sw == NULL) perror(""stl_fix_normal_directions"");


  facet_num = 0;
  
  if(stl_check_normal_vector(stl, 0, 0) == 2)
    stl_reverse_facet(stl, 0);

  
  norm_sw[facet_num] = 1;
  checked++;

  for(;;) {
    
    for(j = 0; j < 3; j++) {
      
      if(stl->neighbors_start[facet_num].which_vertex_not[j] > 2) {
        
        if(stl->neighbors_start[facet_num].neighbor[j] != -1) {
          stl_reverse_facet
          (stl, stl->neighbors_start[facet_num].neighbor[j]);
        }
      }
      
      if(stl->neighbors_start[facet_num].neighbor[j] != -1 &&
         stl->neighbors_start[facet_num].neighbor[j] < stl->stats.number_of_facets*sizeof(char)) {
        
        if(norm_sw[stl->neighbors_start[facet_num].neighbor[j]] != 1) {
          
          newn = (struct stl_normal*)malloc(sizeof(struct stl_normal));
          if(newn == NULL) perror(""stl_fix_normal_directions"");
          newn->facet_num = stl->neighbors_start[facet_num].neighbor[j];
          newn->next = head->next;
          head->next = newn;
        }
      }
    }
    
    if(head->next != tail) {
      facet_num = head->next->facet_num;
      if(norm_sw[facet_num] != 1) { 
        norm_sw[facet_num] = 1; 
        checked++;
      }
      temp = head->next;	
      head->next = head->next->next;
      free(temp);
    } else { 
      
      stl->stats.number_of_parts += 1;
      if(checked >= stl->stats.number_of_facets) {
        
        break;
      } else {
        
        for(i = 0; i < stl->stats.number_of_facets; i++) {
          if(norm_sw[i] == 0) {
            
            facet_num = i;
            if(stl_check_normal_vector(stl, i, 0) == 2) {
              stl_reverse_facet(stl, i);
            }

            norm_sw[facet_num] = 1;
            checked++;
            break;
          }
        }
      }
    }
  }
  free(head);
  free(tail);
  free(norm_sw);
}
","1. (stl, stl->neighbors_start[facet_num].neighbor[j]);
2. stl_reverse_facet(stl, i);
3. checked++;
break;
4. free(norm_sw);","55
95
99-100
108","CWE-190,CWE-399,CWE-119"
main_49," int main_49()
{
    check_file(""heap_overflow_1.tga"");
    check_file(""heap_overflow_2.tga"");

    return gdNumFailures();
}


static void check_file(char *basename)
 {
     gdImagePtr im;
     char *buffer;
     size_t size;
 
    size = read_test_file(&buffer, basename);
     im = gdImageCreateFromTgaPtr(size, (void *) buffer);
     gdTestAssert(im == NULL);
     free(buffer);
 }
","1. int main_49()
2. check_file(""heap_overflow_1.tga"");
check_file(""heap_overflow_2.tga"");
3. return gdNumFailures();","1
3-4
6","CWE-706,CWE-200,CWE-787,CWE-125,CWE-399"
pci_lintr_release-269828223107342,"void
pci_lintr_release(struct pci_vdev *dev)
{
	struct businfo *bi;
	struct slotinfo *si;
	int pin;

	bi = pci_businfo[dev->bus];
	if (bi == NULL) {
		pr_err(""%s: pci [%s] has wrong bus %d info!\n"", __func__, dev->name, dev->bus);
		return;
	}

	si = &bi->slotinfo[dev->slot];

	for (pin = 1; pin < 4; pin++) {
		si->si_intpins[pin].ii_count = 0;
		si->si_intpins[pin].ii_pirq_pin = 0;
		si->si_intpins[pin].ii_ioapic_irq = 0;
	}
}
","1. pci_lintr_release(struct pci_vdev *dev)
2. struct slotinfo *si;
int pin;
3. pr_err(""%s: pci [%s] has wrong bus %d info!\n"", __func__, dev->name, dev->bus);
return;
4. si = &bi->slotinfo[dev->slot];
5. si->si_intpins[pin].ii_count = 0;","2
5-6
10-11
14
17","CWE-617,CWE-476,CWE-125"
ref_pic_list_struct-197736494727726,"
#define EVCParserSPS
#define GetBitContext
#define RefPicListStruct

static int ref_pic_list_struct(EVCParserSPS *sps, GetBitContext *gb, RefPicListStruct *rpl)
{
    uint32_t delta_poc_st, strp_entry_sign_flag = 0;
    rpl->ref_pic_num = get_ue_golomb_long(gb);

    if ((unsigned)rpl->ref_pic_num  > sps->sps_max_dec_pic_buffering_minus1)
        return AVERROR_INVALIDDATA;

    if (rpl->ref_pic_num > 0) {
        delta_poc_st = get_ue_golomb_long(gb);

        rpl->ref_pics[0] = delta_poc_st;
        if (rpl->ref_pics[0] != 0) {
            strp_entry_sign_flag = get_bits(gb, 1);

            rpl->ref_pics[0] *= 1 - (strp_entry_sign_flag << 1);
        }
    }

    for (int i = 1; i < rpl->ref_pic_num; ++i) {
        delta_poc_st = get_ue_golomb_long(gb);
        if (delta_poc_st != 0)
            strp_entry_sign_flag = get_bits(gb, 1);
        rpl->ref_pics[i] = rpl->ref_pics[i - 1] + delta_poc_st * (1 - (strp_entry_sign_flag << 1));
    }

    return 0;
}
","1. rpl->ref_pic_num = get_ue_golomb_long(gb);
2. if (rpl->ref_pics[0] != 0) {","9
18","CWE-345,CWE-20,CWE-19,CWE-119"
rs_filter_graph-92673998796366,"
#define RSFilter

void
rs_filter_graph(RSFilter *filter)
{
	g_return_if_fail(RS_IS_FILTER(filter));
	gchar *dot_filename;
	gchar *png_filename;
	gchar *command_line;
	GString *str = g_string_new(""digraph G {\n"");

	rs_filter_graph_helper(str, filter);

	g_string_append_printf(str, ""}\n"");

	
	dot_filename = g_strdup_printf(""/tmp/rs-filter-graph.%u"", g_random_int());
	png_filename = g_strdup_printf(""%s.%u.png"", dot_filename, g_random_int());

	g_file_set_contents(dot_filename, str->str, str->len, NULL);

	command_line = g_strdup_printf(""dot -Tpng >%s <%s"", png_filename, dot_filename);
	if (0 != system(command_line))
		g_warning(""Calling dot failed"");
	g_free(command_line);

	command_line = g_strdup_printf(""gnome-open %s"", png_filename);
	if (0 != system(command_line))
		g_warning(""Calling gnome-open failed."");
	g_free(command_line);

	g_free(dot_filename);
	g_free(png_filename);
	g_string_free(str, TRUE);
}
","1. g_return_if_fail(RS_IS_FILTER(filter));
2. rs_filter_graph_helper(str, filter);
3. png_filename = g_strdup_printf(""%s.%u.png"", dot_filename, g_random_int());
4. g_warning(""Calling dot failed"");
5. g_warning(""Calling gnome-open failed."");","7
13
19
25
30","CWE-552,CWE-264,CWE-119,CWE-400,CWE-59"
SendNotImplementedError,"void SendNotImplementedError(struct mg_connection* connection,
                             const struct mg_request_info* request_info,
                             void* user_data) {
  std::string body = base::StringPrintf(
      ""{\""status\"":%d,\""value\"":{\""message\"":""
      ""\""Command has not been implemented yet: %s %s\""}}"",
      kUnknownCommand, request_info->request_method, request_info->uri);

  std::string header = base::StringPrintf(
      ""HTTP/1.1 501 Not Implemented\r\n""
      ""Content-Type:application/json\r\n""
       ""Content-Length:%"" PRIuS ""\r\n""
       ""\r\n"", body.length());
 
   mg_write(connection, header.data(), header.length());
   mg_write(connection, body.data(), body.length());
 }
","1. void SendNotImplementedError(struct mg_connection* connection,
const struct mg_request_info* request_info,
2. std::string body = base::StringPrintf(
3. std::string header = base::StringPrintf(","1-2
4
9","CWE-20,CWE-362,CWE-416,CWE-190,CWE-787"
snd_seq_create_port-193882008675681,"struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,
						int port)
{
	unsigned long flags;
	struct snd_seq_client_port *new_port, *p;
	int num = -1;
	
	
	if (snd_BUG_ON(!client))
		return NULL;

	if (client->num_ports >= SNDRV_SEQ_MAX_PORTS) {
		pr_warn(""ALSA: seq: too many ports for client %d\n"", client->number);
		return NULL;
	}

	
	new_port = kzalloc(sizeof(*new_port), GFP_KERNEL);
	if (!new_port)
		return NULL;	
	
	new_port->addr.client = client->number;
	new_port->addr.port = -1;
	new_port->owner = THIS_MODULE;
	sprintf(new_port->name, ""port-%d"", num);
	snd_use_lock_init(&new_port->use_lock);
	port_subs_info_init(&new_port->c_src);
	port_subs_info_init(&new_port->c_dest);
	snd_use_lock_use(&new_port->use_lock);

	num = port >= 0 ? port : 0;
	mutex_lock(&client->ports_mutex);
	write_lock_irqsave(&client->ports_lock, flags);
	list_for_each_entry(p, &client->ports_list_head, list) {
		if (p->addr.port > num)
			break;
		if (port < 0) 
			num = p->addr.port + 1;
	}
	
	list_add_tail(&new_port->list, &p->list);
	client->num_ports++;
	new_port->addr.port = num;	
	sprintf(new_port->name, ""port-%d"", num);
	write_unlock_irqrestore(&client->ports_lock, flags);
	mutex_unlock(&client->ports_mutex);

	return new_port;
}
","1. struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,
int port)
2. unsigned long flags;
3. return NULL;
4. new_port->addr.port = -1;
5. sprintf(new_port->name, ""port-%d"", num);
6. port_subs_info_init(&new_port->c_src);
7. mutex_lock(&client->ports_mutex);
8. break;
9. return new_port;","1-2
4
20
23
25
27
32
36
48","CWE-362,CWE-200,CWE-116,CWE-401"
tee_mmu_check_access_rights-220397055665388,"TEE_Result tee_mmu_check_access_rights(const struct user_ta_ctx *utc,
				       uint32_t flags, uaddr_t uaddr,
				       size_t len)
{
	uaddr_t a;
	uaddr_t end_addr = 0;
	size_t addr_incr = MIN(CORE_MMU_USER_CODE_SIZE,
			       CORE_MMU_USER_PARAM_SIZE);

	if (ADD_OVERFLOW(uaddr, len, &end_addr))
		return TEE_ERROR_ACCESS_DENIED;

	if ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&
	    (flags & TEE_MEMORY_ACCESS_SECURE))
		return TEE_ERROR_ACCESS_DENIED;

	
	if (!(flags & TEE_MEMORY_ACCESS_ANY_OWNER) &&
	   !tee_mmu_is_vbuf_inside_ta_private(utc, (void *)uaddr, len))
		return TEE_ERROR_ACCESS_DENIED;

	for (a = ROUNDDOWN(uaddr, addr_incr); a < end_addr; a += addr_incr) {
		uint32_t attr;
		TEE_Result res;

		res = tee_mmu_user_va2pa_attr(utc, (void *)a, NULL, &attr);
		if (res != TEE_SUCCESS)
			return res;

		if ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&
		    (attr & TEE_MATTR_SECURE))
			return TEE_ERROR_ACCESS_DENIED;

		if ((flags & TEE_MEMORY_ACCESS_SECURE) &&
		    !(attr & TEE_MATTR_SECURE))
			return TEE_ERROR_ACCESS_DENIED;

		if ((flags & TEE_MEMORY_ACCESS_WRITE) && !(attr & TEE_MATTR_UW))
			return TEE_ERROR_ACCESS_DENIED;
		if ((flags & TEE_MEMORY_ACCESS_READ) && !(attr & TEE_MATTR_UR))
			return TEE_ERROR_ACCESS_DENIED;
	}

	return TEE_SUCCESS;
}
","1. TEE_Result tee_mmu_check_access_rights(const struct user_ta_ctx *utc,
2. uaddr_t a;
uaddr_t end_addr = 0;
size_t addr_incr = MIN(CORE_MMU_USER_CODE_SIZE,
CORE_MMU_USER_PARAM_SIZE);
3. if (ADD_OVERFLOW(uaddr, len, &end_addr))
4. !tee_mmu_is_vbuf_inside_ta_private(utc, (void *)uaddr, len))
return TEE_ERROR_ACCESS_DENIED;
5. uint32_t attr;
6. if (res != TEE_SUCCESS)
7. (attr & TEE_MATTR_SECURE))
return TEE_ERROR_ACCESS_DENIED;
8. if ((flags & TEE_MEMORY_ACCESS_SECURE) &&
9. return TEE_SUCCESS;","1
5-8
10
22-23
26
30
34-35
37
47","CWE-190,CWE-20,CWE-264,CWE-119"
xps_begin_opacity,"xps_begin_opacity(xps_document *doc, const fz_matrix *ctm, const fz_rect *area,
	char *base_uri, xps_resource *dict,
	char *opacity_att, fz_xml *opacity_mask_tag)
{
	float opacity;

	if (!opacity_att && !opacity_mask_tag)
		return;

	opacity = 1;
	if (opacity_att)
		opacity = fz_atof(opacity_att);

	if (opacity_mask_tag && !strcmp(fz_xml_tag(opacity_mask_tag), ""SolidColorBrush""))
	{
		char *scb_opacity_att = fz_xml_att(opacity_mask_tag, ""Opacity"");
		char *scb_color_att = fz_xml_att(opacity_mask_tag, ""Color"");
		if (scb_opacity_att)
			opacity = opacity * fz_atof(scb_opacity_att);
                if (scb_color_att)
                {
                        fz_colorspace *colorspace;
                       float samples[FZ_MAX_COLORS];
                        xps_parse_color(doc, base_uri, scb_color_att, &colorspace, samples);
                        opacity = opacity * samples[0];
                }
		opacity_mask_tag = NULL;
	}

	if (doc->opacity_top + 1 < nelem(doc->opacity))
	{
		doc->opacity[doc->opacity_top + 1] = doc->opacity[doc->opacity_top] * opacity;
		doc->opacity_top++;
	}

	if (opacity_mask_tag)
	{
		fz_begin_mask(doc->dev, area, 0, NULL, NULL);
		xps_parse_brush(doc, ctm, area, base_uri, dict, opacity_mask_tag);
		fz_end_mask(doc->dev);
	}
}
","1. char *opacity_att, fz_xml *opacity_mask_tag)
2. opacity = 1;
3. if (scb_opacity_att)
4. doc->opacity[doc->opacity_top + 1] = doc->opacity[doc->opacity_top] * opacity;
5. xps_parse_brush(doc, ctm, area, base_uri, dict, opacity_mask_tag);","3
10
18
32
39","CWE-476,CWE-264,CWE-125,CWE-189"
lldp_decode-187202039030160,"int
lldp_decode(struct lldpd *cfg, char *frame, int s,
    struct lldpd_hardware *hardware,
    struct lldpd_chassis **newchassis, struct lldpd_port **newport)
{
	struct lldpd_chassis *chassis;
	struct lldpd_port *port;
	const char lldpaddr[] = LLDP_MULTICAST_ADDR;
	const char dot1[] = LLDP_TLV_ORG_DOT1;
	const char dot3[] = LLDP_TLV_ORG_DOT3;
	const char med[] = LLDP_TLV_ORG_MED;
	const char dcbx[] = LLDP_TLV_ORG_DCBX;
	unsigned char orgid[3];
	int length, gotend = 0, ttl_received = 0;
	int tlv_size, tlv_type, tlv_subtype;
	u_int8_t *pos, *tlv;
	char *b;
#ifdef ENABLE_DOT1
	struct lldpd_vlan *vlan = NULL;
	int vlan_len;
	struct lldpd_ppvid *ppvid;
	struct lldpd_pi *pi = NULL;
#endif
	struct lldpd_mgmt *mgmt;
	int af;
	u_int8_t addr_str_length, addr_str_buffer[32];
	u_int8_t addr_family, addr_length, *addr_ptr, iface_subtype;
	u_int32_t iface_number, iface;
#ifdef ENABLE_CUSTOM
	struct lldpd_custom *custom = NULL;
#endif

	log_debug(""lldp"", ""receive LLDP PDU on %s"",
	    hardware->h_ifname);

	if ((chassis = calloc(1, sizeof(struct lldpd_chassis))) == NULL) {
		log_warn(""lldp"", ""failed to allocate remote chassis"");
		return -1;
	}
	TAILQ_INIT(&chassis->c_mgmt);
	if ((port = calloc(1, sizeof(struct lldpd_port))) == NULL) {
		log_warn(""lldp"", ""failed to allocate remote port"");
		free(chassis);
		return -1;
	}
#ifdef ENABLE_DOT1
	TAILQ_INIT(&port->p_vlans);
	TAILQ_INIT(&port->p_ppvids);
	TAILQ_INIT(&port->p_pids);
#endif
#ifdef ENABLE_CUSTOM
	TAILQ_INIT(&port->p_custom_list);
#endif

	length = s;
	pos = (u_int8_t*)frame;

	if (length < 2*ETHER_ADDR_LEN + sizeof(u_int16_t)) {
		log_warnx(""lldp"", ""too short frame received on %s"", hardware->h_ifname);
		goto malformed;
	}
	if (PEEK_CMP(lldpaddr, ETHER_ADDR_LEN) != 0) {
		log_info(""lldp"", ""frame not targeted at LLDP multicast address received on %s"",
		    hardware->h_ifname);
		goto malformed;
	}
	PEEK_DISCARD(ETHER_ADDR_LEN);	
	if (PEEK_UINT16 != ETHERTYPE_LLDP) {
		log_info(""lldp"", ""non LLDP frame received on %s"",
		    hardware->h_ifname);
		goto malformed;
	}

	while (length && (!gotend)) {
		if (length < 2) {
			log_warnx(""lldp"", ""tlv header too short received on %s"",
			    hardware->h_ifname);
			goto malformed;
		}
		tlv_size = PEEK_UINT16;
		tlv_type = tlv_size >> 9;
		tlv_size = tlv_size & 0x1ff;
		(void)PEEK_SAVE(tlv);
		if (length < tlv_size) {
			log_warnx(""lldp"", ""frame too short for tlv received on %s"",
			    hardware->h_ifname);
			goto malformed;
		}
		switch (tlv_type) {
		case LLDP_TLV_END:
			if (tlv_size != 0) {
				log_warnx(""lldp"", ""lldp end received with size not null on %s"",
				    hardware->h_ifname);
				goto malformed;
			}
			if (length)
				log_debug(""lldp"", ""extra data after lldp end on %s"",
				    hardware->h_ifname);
			gotend = 1;
			break;
		case LLDP_TLV_CHASSIS_ID:
		case LLDP_TLV_PORT_ID:
			CHECK_TLV_SIZE(2, ""Port Id"");
			tlv_subtype = PEEK_UINT8;
			if ((tlv_subtype == 0) || (tlv_subtype > 7)) {
				log_warnx(""lldp"", ""unknown subtype for tlv id received on %s"",
				    hardware->h_ifname);
				goto malformed;
			}
			if ((b = (char *)calloc(1, tlv_size - 1)) == NULL) {
				log_warn(""lldp"", ""unable to allocate memory for id tlv ""
				    ""received on %s"",
				    hardware->h_ifname);
				goto malformed;
			}
			PEEK_BYTES(b, tlv_size - 1);
			if (tlv_type == LLDP_TLV_PORT_ID) {
				port->p_id_subtype = tlv_subtype;
				port->p_id = b;
				port->p_id_len = tlv_size - 1;
			} else {
				chassis->c_id_subtype = tlv_subtype;
				chassis->c_id = b;
				chassis->c_id_len = tlv_size - 1;
			}
			break;
		case LLDP_TLV_TTL:
			CHECK_TLV_SIZE(2, ""TTL"");
			chassis->c_ttl = PEEK_UINT16;
			ttl_received = 1;
			break;
		case LLDP_TLV_PORT_DESCR:
		case LLDP_TLV_SYSTEM_NAME:
		case LLDP_TLV_SYSTEM_DESCR:
			if (tlv_size < 1) {
				log_debug(""lldp"", ""empty tlv received on %s"",
				    hardware->h_ifname);
				break;
			}
			if ((b = (char *)calloc(1, tlv_size + 1)) == NULL) {
				log_warn(""lldp"", ""unable to allocate memory for string tlv ""
				    ""received on %s"",
				    hardware->h_ifname);
				goto malformed;
			}
			PEEK_BYTES(b, tlv_size);
			if (tlv_type == LLDP_TLV_PORT_DESCR)
				port->p_descr = b;
			else if (tlv_type == LLDP_TLV_SYSTEM_NAME)
				chassis->c_name = b;
			else chassis->c_descr = b;
			break;
		case LLDP_TLV_SYSTEM_CAP:
			CHECK_TLV_SIZE(4, ""System capabilities"");
			chassis->c_cap_available = PEEK_UINT16;
			chassis->c_cap_enabled = PEEK_UINT16;
			break;
		case LLDP_TLV_MGMT_ADDR:
			CHECK_TLV_SIZE(1, ""Management address"");
			addr_str_length = PEEK_UINT8;
			if (addr_str_length > sizeof(addr_str_buffer)) {
				log_warnx(""lldp"", ""too large management address on %s"",
				    hardware->h_ifname);
				goto malformed;
			}
			CHECK_TLV_SIZE(1 + addr_str_length, ""Management address"");
			PEEK_BYTES(addr_str_buffer, addr_str_length);
			addr_length = addr_str_length - 1;
			addr_family = addr_str_buffer[0];
			addr_ptr = &addr_str_buffer[1];
			CHECK_TLV_SIZE(1 + addr_str_length + 5, ""Management address"");
			iface_subtype = PEEK_UINT8;
			iface_number = PEEK_UINT32;

			af = lldpd_af_from_lldp_proto(addr_family);
			if (af == LLDPD_AF_UNSPEC)
				break;
			if (iface_subtype == LLDP_MGMT_IFACE_IFINDEX)
				iface = iface_number;
			else
				iface = 0;
			mgmt = lldpd_alloc_mgmt(af, addr_ptr, addr_length, iface);
			if (mgmt == NULL) {
				assert(errno == ENOMEM);
				log_warn(""lldp"", ""unable to allocate memory ""
							""for management address"");
						goto malformed;
			}
			TAILQ_INSERT_TAIL(&chassis->c_mgmt, mgmt, m_entries);
			break;
		case LLDP_TLV_ORG:
			CHECK_TLV_SIZE(1 + (int)sizeof(orgid), ""Organisational"");
			PEEK_BYTES(orgid, sizeof(orgid));
			tlv_subtype = PEEK_UINT8;
			if (memcmp(dot1, orgid, sizeof(orgid)) == 0) {
#ifndef ENABLE_DOT1
				hardware->h_rx_unrecognized_cnt++;
#else
				
				switch (tlv_subtype) {
				case LLDP_TLV_DOT1_VLANNAME:
					CHECK_TLV_SIZE(7, ""VLAN"");
					if ((vlan = (struct lldpd_vlan *)calloc(1,
						    sizeof(struct lldpd_vlan))) == NULL) {
						log_warn(""lldp"", ""unable to alloc vlan ""
						    ""structure for ""
						    ""tlv received on %s"",
						    hardware->h_ifname);
						goto malformed;
					}
					vlan->v_vid = PEEK_UINT16;
					vlan_len = PEEK_UINT8;
					CHECK_TLV_SIZE(7 + vlan_len, ""VLAN"");
					if ((vlan->v_name =
						(char *)calloc(1, vlan_len + 1)) == NULL) {
						log_warn(""lldp"", ""unable to alloc vlan name for ""
						    ""tlv received on %s"",
						    hardware->h_ifname);
						goto malformed;
					}
					PEEK_BYTES(vlan->v_name, vlan_len);
					TAILQ_INSERT_TAIL(&port->p_vlans,
					    vlan, v_entries);
					vlan = NULL;
					break;
				case LLDP_TLV_DOT1_PVID:
					CHECK_TLV_SIZE(6, ""PVID"");
					port->p_pvid = PEEK_UINT16;
					break;
				case LLDP_TLV_DOT1_PPVID:
					CHECK_TLV_SIZE(7, ""PPVID"");
					
					
					
					
					if ((ppvid = (struct lldpd_ppvid *)calloc(1,
						    sizeof(struct lldpd_ppvid))) == NULL) {
						log_warn(""lldp"", ""unable to alloc ppvid ""
						    ""structure for ""
						    ""tlv received on %s"",
						    hardware->h_ifname);
						goto malformed;
					}
					ppvid->p_cap_status = PEEK_UINT8;
					ppvid->p_ppvid = PEEK_UINT16;	
					TAILQ_INSERT_TAIL(&port->p_ppvids,
					    ppvid, p_entries);
					break;
				case LLDP_TLV_DOT1_PI:
					
					
					CHECK_TLV_SIZE(5, ""PI"");
					if ((pi = (struct lldpd_pi *)calloc(1,
						    sizeof(struct lldpd_pi))) == NULL) {
						log_warn(""lldp"", ""unable to alloc PI ""
						    ""structure for ""
						    ""tlv received on %s"",
						    hardware->h_ifname);
						goto malformed;
					}
					pi->p_pi_len = PEEK_UINT8;
					CHECK_TLV_SIZE(5 + pi->p_pi_len, ""PI"");
					if ((pi->p_pi =
						(char *)calloc(1, pi->p_pi_len)) == NULL) {
						log_warn(""lldp"", ""unable to alloc pid name for ""
						    ""tlv received on %s"",
						    hardware->h_ifname);
						goto malformed;
					}
					PEEK_BYTES(pi->p_pi, pi->p_pi_len);
					TAILQ_INSERT_TAIL(&port->p_pids,
					    pi, p_entries);
					pi = NULL;
					break;
				default:
					
					hardware->h_rx_unrecognized_cnt++;
				}
#endif
			} else if (memcmp(dot3, orgid, sizeof(orgid)) == 0) {
#ifndef ENABLE_DOT3
				hardware->h_rx_unrecognized_cnt++;
#else
				
				switch (tlv_subtype) {
				case LLDP_TLV_DOT3_MAC:
					CHECK_TLV_SIZE(9, ""MAC/PHY"");
					port->p_macphy.autoneg_support = PEEK_UINT8;
					port->p_macphy.autoneg_enabled =
					    (port->p_macphy.autoneg_support & 0x2) >> 1;
					port->p_macphy.autoneg_support =
					    port->p_macphy.autoneg_support & 0x1;
					port->p_macphy.autoneg_advertised =
					    PEEK_UINT16;
					port->p_macphy.mau_type = PEEK_UINT16;
					break;
				case LLDP_TLV_DOT3_LA:
					CHECK_TLV_SIZE(9, ""Link aggregation"");
					PEEK_DISCARD_UINT8;
					port->p_aggregid = PEEK_UINT32;
					break;
				case LLDP_TLV_DOT3_MFS:
					CHECK_TLV_SIZE(6, ""MFS"");
					port->p_mfs = PEEK_UINT16;
					break;
				case LLDP_TLV_DOT3_POWER:
					CHECK_TLV_SIZE(7, ""Power"");
					port->p_power.devicetype = PEEK_UINT8;
					port->p_power.supported =
						(port->p_power.devicetype & 0x2) >> 1;
					port->p_power.enabled =
						(port->p_power.devicetype & 0x4) >> 2;
					port->p_power.paircontrol =
						(port->p_power.devicetype & 0x8) >> 3;
					port->p_power.devicetype =
						(port->p_power.devicetype & 0x1)?
						LLDP_DOT3_POWER_PSE:LLDP_DOT3_POWER_PD;
					port->p_power.pairs = PEEK_UINT8;
					port->p_power.class = PEEK_UINT8;
					
					if (tlv_size >= 12) {
						port->p_power.powertype = PEEK_UINT8;
						port->p_power.source =
						    (port->p_power.powertype & (1<<5 | 1<<4)) >> 4;
						port->p_power.priority =
						    (port->p_power.powertype & (1<<1 | 1<<0));
						port->p_power.powertype =
						    (port->p_power.powertype & (1<<7))?
						    LLDP_DOT3_POWER_8023AT_TYPE1:
						    LLDP_DOT3_POWER_8023AT_TYPE2;
						port->p_power.requested = PEEK_UINT16;
						port->p_power.allocated = PEEK_UINT16;
					} else
						port->p_power.powertype =
						    LLDP_DOT3_POWER_8023AT_OFF;
					break;
				default:
					
					hardware->h_rx_unrecognized_cnt++;
				}
#endif
			} else if (memcmp(med, orgid, sizeof(orgid)) == 0) {
				
#ifndef ENABLE_LLDPMED
				hardware->h_rx_unrecognized_cnt++;
#else
				u_int32_t policy;
				unsigned loctype;
				unsigned power;

				switch (tlv_subtype) {
				case LLDP_TLV_MED_CAP:
					CHECK_TLV_SIZE(7, ""LLDP-MED capabilities"");
					chassis->c_med_cap_available = PEEK_UINT16;
					chassis->c_med_type = PEEK_UINT8;
					port->p_med_cap_enabled |=
					    LLDP_MED_CAP_CAP;
					break;
				case LLDP_TLV_MED_POLICY:
					CHECK_TLV_SIZE(8, ""LLDP-MED policy"");
					policy = PEEK_UINT32;
					if (((policy >> 24) < 1) ||
					    ((policy >> 24) > LLDP_MED_APPTYPE_LAST)) {
						log_info(""lldp"", ""unknown policy field %d ""
						    ""received on %s"",
						    policy,
						    hardware->h_ifname);
						break;
					}
					port->p_med_policy[(policy >> 24) - 1].type =
					    (policy >> 24);
					port->p_med_policy[(policy >> 24) - 1].unknown =
					    ((policy & 0x800000) != 0);
					port->p_med_policy[(policy >> 24) - 1].tagged =
					    ((policy & 0x400000) != 0);
					port->p_med_policy[(policy >> 24) - 1].vid =
					    (policy & 0x001FFE00) >> 9;
					port->p_med_policy[(policy >> 24) - 1].priority =
					    (policy & 0x1C0) >> 6;
					port->p_med_policy[(policy >> 24) - 1].dscp =
					    policy & 0x3F;
					port->p_med_cap_enabled |=
					    LLDP_MED_CAP_POLICY;
					break;
				case LLDP_TLV_MED_LOCATION:
					CHECK_TLV_SIZE(5, ""LLDP-MED Location"");
					loctype = PEEK_UINT8;
					if ((loctype < 1) ||
					    (loctype > LLDP_MED_LOCFORMAT_LAST)) {
						log_info(""lldp"", ""unknown location type ""
						    ""received on %s"",
						    hardware->h_ifname);
						break;
					}
					if ((port->p_med_location[loctype - 1].data =
						(char*)malloc(tlv_size - 5)) == NULL) {
						log_warn(""lldp"", ""unable to allocate memory ""
						    ""for LLDP-MED location for ""
						    ""frame received on %s"",
						    hardware->h_ifname);
						goto malformed;
					}
					PEEK_BYTES(port->p_med_location[loctype - 1].data,
					    tlv_size - 5);
					port->p_med_location[loctype - 1].data_len =
					    tlv_size - 5;
					port->p_med_location[loctype - 1].format = loctype;
					port->p_med_cap_enabled |=
					    LLDP_MED_CAP_LOCATION;
					break;
				case LLDP_TLV_MED_MDI:
					CHECK_TLV_SIZE(7, ""LLDP-MED PoE-MDI"");
					power = PEEK_UINT8;
					switch (power & 0xC0) {
					case 0x0:
						port->p_med_power.devicetype = LLDP_MED_POW_TYPE_PSE;
						port->p_med_cap_enabled |=
						    LLDP_MED_CAP_MDI_PSE;
						switch (power & 0x30) {
						case 0x0:
							port->p_med_power.source =
							    LLDP_MED_POW_SOURCE_UNKNOWN;
							break;
						case 0x10:
							port->p_med_power.source =
							    LLDP_MED_POW_SOURCE_PRIMARY;
							break;
						case 0x20:
							port->p_med_power.source =
							    LLDP_MED_POW_SOURCE_BACKUP;
							break;
						default:
							port->p_med_power.source =
							    LLDP_MED_POW_SOURCE_RESERVED;
						}
						break;
					case 0x40:
						port->p_med_power.devicetype = LLDP_MED_POW_TYPE_PD;
						port->p_med_cap_enabled |=
						    LLDP_MED_CAP_MDI_PD;
						switch (power & 0x30) {
						case 0x0:
							port->p_med_power.source =
							    LLDP_MED_POW_SOURCE_UNKNOWN;
							break;
						case 0x10:
							port->p_med_power.source =
							    LLDP_MED_POW_SOURCE_PSE;
							break;
						case 0x20:
							port->p_med_power.source =
							    LLDP_MED_POW_SOURCE_LOCAL;
							break;
						default:
							port->p_med_power.source =
							    LLDP_MED_POW_SOURCE_BOTH;
						}
						break;
					default:
						port->p_med_power.devicetype =
						    LLDP_MED_POW_TYPE_RESERVED;
					}
					if ((power & 0x0F) > LLDP_MED_POW_PRIO_LOW)
						port->p_med_power.priority =
						    LLDP_MED_POW_PRIO_UNKNOWN;
					else
						port->p_med_power.priority =
						    power & 0x0F;
					port->p_med_power.val = PEEK_UINT16;
					break;
				case LLDP_TLV_MED_IV_HW:
				case LLDP_TLV_MED_IV_SW:
				case LLDP_TLV_MED_IV_FW:
				case LLDP_TLV_MED_IV_SN:
				case LLDP_TLV_MED_IV_MANUF:
				case LLDP_TLV_MED_IV_MODEL:
				case LLDP_TLV_MED_IV_ASSET:
					if (tlv_size <= 4)
						b = NULL;
					else {
						if ((b = (char*)malloc(tlv_size - 3)) ==
						    NULL) {
							log_warn(""lldp"", ""unable to allocate ""
							    ""memory for LLDP-MED ""
							    ""inventory for frame ""
							    ""received on %s"",
							    hardware->h_ifname);
							goto malformed;
						}
						PEEK_BYTES(b, tlv_size - 4);
						b[tlv_size - 4] = '\0';
					}
					switch (tlv_subtype) {
					case LLDP_TLV_MED_IV_HW:
						chassis->c_med_hw = b;
						break;
					case LLDP_TLV_MED_IV_FW:
						chassis->c_med_fw = b;
						break;
					case LLDP_TLV_MED_IV_SW:
						chassis->c_med_sw = b;
						break;
					case LLDP_TLV_MED_IV_SN:
						chassis->c_med_sn = b;
						break;
					case LLDP_TLV_MED_IV_MANUF:
						chassis->c_med_manuf = b;
						break;
					case LLDP_TLV_MED_IV_MODEL:
						chassis->c_med_model = b;
						break;
					case LLDP_TLV_MED_IV_ASSET:
						chassis->c_med_asset = b;
						break;
					}
					port->p_med_cap_enabled |=
					    LLDP_MED_CAP_IV;
					break;
				default:
					
					hardware->h_rx_unrecognized_cnt++;
				}
#endif 
			} else if (memcmp(dcbx, orgid, sizeof(orgid)) == 0) {
				log_debug(""lldp"", ""unsupported DCBX tlv received on %s - ignore"",
				    hardware->h_ifname);
				hardware->h_rx_unrecognized_cnt++;
			} else {
				log_debug(""lldp"", ""unknown org tlv [%02x:%02x:%02x] received on %s"",
				    orgid[0], orgid[1], orgid[2],
				    hardware->h_ifname);
				hardware->h_rx_unrecognized_cnt++;
#ifdef ENABLE_CUSTOM
				custom = (struct lldpd_custom*)calloc(1, sizeof(struct lldpd_custom));
				if (!custom) {
					log_warn(""lldp"",
					    ""unable to allocate memory for custom TLV"");
					goto malformed;
				}
				custom->oui_info_len = tlv_size > 4 ? tlv_size - 4 : 0;
				memcpy(custom->oui, orgid, sizeof(custom->oui));
				custom->subtype = tlv_subtype;
				if (custom->oui_info_len > 0) {
					custom->oui_info = malloc(custom->oui_info_len);
					if (!custom->oui_info) {
						log_warn(""lldp"",
						    ""unable to allocate memory for custom TLV data"");
						goto malformed;
					}
					PEEK_BYTES(custom->oui_info, custom->oui_info_len);
				}
				TAILQ_INSERT_TAIL(&port->p_custom_list, custom, next);
				custom = NULL;
#endif
			}
			break;
		default:
			log_warnx(""lldp"", ""unknown tlv (%d) received on %s"",
			    tlv_type, hardware->h_ifname);
			goto malformed;
		}
		if (pos > tlv + tlv_size) {
			log_warnx(""lldp"", ""BUG: already past TLV!"");
			goto malformed;
		}
		PEEK_DISCARD(tlv + tlv_size - pos);
	}

	
	if ((chassis->c_id == NULL) ||
	    (port->p_id == NULL) ||
	    (!ttl_received) ||
	    (gotend == 0)) {
		log_warnx(""lldp"", ""some mandatory tlv are missing for frame received on %s"",
		    hardware->h_ifname);
		goto malformed;
	}
	*newchassis = chassis;
	*newport = port;
	return 1;
malformed:
#ifdef ENABLE_CUSTOM
	free(custom);
#endif
#ifdef ENABLE_DOT1
	free(vlan);
	free(pi);
#endif
	lldpd_chassis_cleanup(chassis, 1);
	lldpd_port_cleanup(port, 1);
	free(port);
	return -1;
}
","1. free(chassis);
2. if (tlv_size < 1) {
log_debug(""lldp"", ""empty tlv received on %s"",
3. else if (tlv_type == LLDP_TLV_SYSTEM_NAME)
4. addr_length = addr_str_length - 1;
5. break;
6. hardware->h_rx_unrecognized_cnt++;
7. hardware->h_ifname);","43
135-136
149
168
190
288
537","CWE-617,CWE-862,CWE-119,CWE-189"
get_registers,"
#define __u16

 static int get_registers(pegasus_t *pegasus, __u16 indx, __u16 size, void *data)
 {
	u8 *buf;
 	int ret;
 
	buf = kmalloc(size, GFP_NOIO);
	if (!buf)
		return -ENOMEM;

 	ret = usb_control_msg(pegasus->usb, usb_rcvctrlpipe(pegasus->usb, 0),
 			      PEGASUS_REQ_GET_REGS, PEGASUS_REQT_READ, 0,
			      indx, buf, size, 1000);
 	if (ret < 0)
 		netif_dbg(pegasus, drv, pegasus->net,
 			  ""%s returned %d\n"", __func__, ret);
	else if (ret <= size)
		memcpy(data, buf, ret);
	kfree(buf);
 	return ret;
 }
","1. static int get_registers(pegasus_t *pegasus, __u16 indx, __u16 size, void *data)
2. if (!buf)
return -ENOMEM;
3. ret = usb_control_msg(pegasus->usb, usb_rcvctrlpipe(pegasus->usb, 0),
PEGASUS_REQ_GET_REGS, PEGASUS_REQT_READ, 0,
4. if (ret < 0)
netif_dbg(pegasus, drv, pegasus->net,
""%s returned %d\n"", __func__, ret);
else if (ret <= size)
memcpy(data, buf, ret);
kfree(buf);
return ret;","4
10-11
13-14
16-22",CWE-119
try_read_command_1,"static int try_read_command_1(conn *c) {
    assert(c != NULL);
    assert(c->rcurr <= (c->rbuf + c->rsize));
    assert(c->rbytes > 0);

    if (c->protocol == negotiating_prot || c->transport == udp_transport)  {
        if ((unsigned char)c->rbuf[0] == (unsigned char)PROTOCOL_BINARY_REQ) {
            c->protocol = binary_prot;
        } else {
            c->protocol = ascii_prot;
        }

        if (settings.verbose > 1) {
            fprintf(stderr, ""%d: Client using the %s protocol\n"", c->sfd,
                    prot_text(c->protocol));
        }
    }

    if (c->protocol == binary_prot) {
        
        if (c->rbytes < sizeof(c->binary_header)) {
            
            return 0;
        } else {
#ifdef NEED_ALIGN
            if (((long)(c->rcurr)) % 8 != 0) {
                
                memmove(c->rbuf, c->rcurr, c->rbytes);
                c->rcurr = c->rbuf;
                if (settings.verbose > 1) {
                    fprintf(stderr, ""%d: Realign input buffer\n"", c->sfd);
                }
            }
#endif
            protocol_binary_request_header* req;
            req = (protocol_binary_request_header*)c->rcurr;

            if (settings.verbose > 1) {
                
                int ii;
                fprintf(stderr, ""<%d Read binary protocol data:"", c->sfd);
                for (ii = 0; ii < sizeof(req->bytes); ++ii) {
                    if (ii % 4 == 0) {
                        fprintf(stderr, ""\n<%d   "", c->sfd);
                    }
                    fprintf(stderr, "" 0x%02x"", req->bytes[ii]);
                }
                fprintf(stderr, ""\n"");
            }

            c->binary_header = *req;
            c->binary_header.request.keylen = ntohs(req->request.keylen);
            c->binary_header.request.bodylen = ntohl(req->request.bodylen);
            c->binary_header.request.cas = ntohll(req->request.cas);

            if (c->binary_header.request.magic != PROTOCOL_BINARY_REQ) {
                if (settings.verbose) {
                    fprintf(stderr, ""Invalid magic:  %x\n"",
                            c->binary_header.request.magic);
                }
                conn_set_state(c, conn_closing);
                return -1;
            }

            c->msgcurr = 0;
            c->msgused = 0;
            c->iovused = 0;
            if (add_msghdr(c) != 0) {
                out_string(c, ""SERVER_ERROR out of memory"");
                return 0;
            }

            c->cmd = c->binary_header.request.opcode;
            c->keylen = c->binary_header.request.keylen;
            c->opaque = c->binary_header.request.opaque;
            
            c->cas = 0;

            dispatch_bin_command(c);

            c->rbytes -= sizeof(c->binary_header);
            c->rcurr += sizeof(c->binary_header);
        }
    } else {
        char *el, *cont;
 
         if (c->rbytes == 0)
             return 0;

         el = memchr(c->rcurr, '\n', c->rbytes);
        if (!el) {
            if (c->rbytes > 1024) {
                
                char *ptr = c->rcurr;
                while (*ptr == ' ') { 
                    ++ptr;
                }

                if (strcmp(ptr, ""get "") && strcmp(ptr, ""gets "")) {
                    conn_set_state(c, conn_closing);
                    return 1;
                }
            }

             return 0;
        }
         cont = el + 1;
         if ((el - c->rcurr) > 1 && *(el - 1) == '\r') {
             el--;
        }
        *el = '\0';

        assert(cont <= (c->rcurr + c->rbytes));

        process_command(c, c->rcurr);

        c->rbytes -= (cont - c->rcurr);
        c->rcurr = cont;

        assert(c->rcurr <= (c->rbuf + c->rsize));
    }

    return 1;
}
","1. if ((unsigned char)c->rbuf[0] == (unsigned char)PROTOCOL_BINARY_REQ) {
2. } else {
3. if (add_msghdr(c) != 0) {
4. c->cas = 0;
5. if (strcmp(ptr, ""get "") && strcmp(ptr, ""gets "")) {
6. *el = '\0';
7. c->rcurr = cont;
8. assert(c->rcurr <= (c->rbuf + c->rsize));","7
9
68
77
102
114
121
123","CWE-476,CWE-264,CWE-20,CWE-125"
add_mibdir-225173042640169,"int
add_mibdir(const char *dirname)
{
    const char     *oldFile = File;
    char          **filenames;
    int             count = 0;
    int             filename_count, i;

    DEBUGMSGTL((""parse-mibs"", ""Scanning directory %s\n"", dirname));

    filename_count = scan_directory(&filenames, dirname);

    if (filename_count >= 0) {
        for (i = 0; i < filename_count; i++) {
            if (add_mibfile(filenames[i], strrchr(filenames[i], '/')) == 0)
                count++;
	    free(filenames[i]);
        }
        File = oldFile;
        free(filenames);
        return (count);
    }
    else
        DEBUGMSGTL((""parse-mibs"",""cannot open MIB directory %s\n"", dirname));

    return (-1);
}
","1. const char     *oldFile = File;
char          **filenames;
2. int             filename_count, i;
3. if (add_mibfile(filenames[i], strrchr(filenames[i], '/')) == 0)
count++;","4-5
7
15-16","CWE-20,CWE-264,CWE-125,CWE-119"
parse_io-206140466111735,"
#define VALUE

static VALUE
parse_io(VALUE klass, VALUE io, VALUE encoding)
{
  xmlParserCtxtPtr ctxt;
  xmlCharEncoding enc = (xmlCharEncoding)NUM2INT(encoding);

  if (!rb_respond_to(io, id_read)) {
    rb_raise(rb_eTypeError, ""argument expected to respond to :read"");
  }

  ctxt = xmlCreateIOParserCtxt(NULL, NULL,
                               (xmlInputReadCallback)noko_io_read,
                               (xmlInputCloseCallback)noko_io_close,
                               (void *)io, enc);
  if (ctxt->sax) {
    xmlFree(ctxt->sax);
    ctxt->sax = NULL;
  }

  return Data_Wrap_Struct(klass, NULL, deallocate, ctxt);
}
","1. parse_io(VALUE klass, VALUE io, VALUE encoding)
2. xmlCharEncoding enc = (xmlCharEncoding)NUM2INT(encoding);
3. if (!rb_respond_to(io, id_read)) {
4. ctxt = xmlCreateIOParserCtxt(NULL, NULL,","5
8
10
14","CWE-476,CWE-20,CWE-125,CWE-416"
test_parser-252029888423070,"void test_parser(void) {
	test_parser_param(0);
}
",1. void test_parser(void) {,1,"CWE-416,CWE-125,CWE-119"
jas_stream_write-277072906234997,"int jas_stream_write(jas_stream_t *stream, const void *buf, int cnt)
{
	int n;
	const char *bufptr;

	if (cnt < 0) {
		jas_deprecated(""negative count for jas_stream_write"");
	}

	bufptr = buf;

	n = 0;
	while (n < cnt) {
		if (jas_stream_putc(stream, *bufptr) == EOF) {
			return n;
		}
		++bufptr;
		++n;
	}

	return n;
}
","1. jas_deprecated(""negative count for jas_stream_write"");
2. n = 0;
while (n < cnt) {
if (jas_stream_putc(stream, *bufptr) == EOF) {
3. ++n;","7
12-14
18","CWE-190,CWE-264"
kvm_pin_pages," static pfn_t kvm_pin_pages(struct kvm_memory_slot *slot, gfn_t gfn,
			   unsigned long npages)
 {
 	gfn_t end_gfn;
 	pfn_t pfn;
 
 	pfn     = gfn_to_pfn_memslot(slot, gfn);
	end_gfn = gfn + npages;
 	gfn    += 1;
 
 	if (is_error_noslot_pfn(pfn))
		return pfn;

	while (gfn < end_gfn)
		gfn_to_pfn_memslot(slot, gfn++);

	return pfn;
}
","1. unsigned long npages)
2. pfn     = gfn_to_pfn_memslot(slot, gfn);
3. if (is_error_noslot_pfn(pfn))
return pfn;
4. while (gfn < end_gfn)
5. return pfn;","2
7
11-12
14
17","CWE-190,CWE-20,CWE-125,CWE-119"
isofs_iget-142566535675471,"static inline struct inode *isofs_iget(struct super_block *sb,
				       unsigned long block,
				       unsigned long offset)
{
	return __isofs_iget(sb, block, offset, 0);
}
","1. static inline struct inode *isofs_iget(struct super_block *sb,
unsigned long block,",1-2,"CWE-190,CWE-20,CWE-254,CWE-416"
pp_mil_k48-97671689929348,"static void pp_mil_k48(fp48_t r, const fp8_t qx, const fp8_t qy, const ep_t p,
		const bn_t a) {
	fp48_t l;
	ep_t _p;
	fp8_t rx, ry, rz, qn;
	size_t len = bn_bits(a) + 1;
	int i;
	int8_t s[RLC_FP_BITS + 1];

	fp48_null(l);
	ep_null(_p);
	fp8_null(rx);
	fp8_null(ry);
	fp8_null(rz);
	fp8_null(qn);

	RLC_TRY {
		fp48_new(l);
		ep_new(_p);
		fp8_new(rx);
		fp8_new(ry);
		fp8_new(rz);
		fp8_new(qn);

		fp48_zero(l);
		fp8_copy(rx, qx);
		fp8_copy(ry, qy);
		fp8_set_dig(rz, 1);
#if EP_ADD == BASIC
		ep_neg(_p, p);
#else
		fp_add(_p->x, p->x, p->x);
		fp_add(_p->x, _p->x, p->x);
		fp_neg(_p->y, p->y);
#endif
		fp8_neg(qn, qy);

		bn_rec_naf(s, &len, a, 2);
		for (i = len - 2; i >= 0; i--) {
			fp48_sqr(r, r);
			pp_dbl_k48(l, rx, ry, rz, _p);
			fp48_mul_dxs(r, r, l);
			if (s[i] > 0) {
				pp_add_k48(l, rx, ry, rz, qx, qy, p);
				fp48_mul_dxs(r, r, l);
			}
			if (s[i] < 0) {
				pp_add_k48(l, rx, ry, rz, qx, qn, p);
				fp48_mul_dxs(r, r, l);
			}
		}
	}
	RLC_CATCH_ANY {
		RLC_THROW(ERR_CAUGHT);
	}
	RLC_FINALLY {
		fp48_free(l);
		ep_free(_p);
		fp8_free(rx);
		fp8_free(ry);
		fp8_free(rz);
		fp8_free(qn);
	}
}
","1. fp8_new(rz);
2. fp8_copy(rx, qx);
3. fp8_neg(qn, qy);
4. bn_rec_naf(s, &len, a, 2);
5. if (s[i] > 0) {
6. fp48_mul_dxs(r, r, l);
7. fp8_free(rx);","22
26
36
38
43
45
59","CWE-190,CWE-125"
setv4key_principal_2_svc-131298436463723,"generic_ret *
setv4key_principal_2_svc(setv4key_arg *arg, struct svc_req *rqstp)
{
    static generic_ret              ret;
    char                            *prime_arg;
    gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;
    gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;
    OM_uint32                       minor_stat;
    kadm5_server_handle_t           handle;
    const char                      *errmsg = NULL;

    xdr_free(xdr_generic_ret, &ret);

    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))
        goto exit_func;

    if ((ret.code = check_handle((void *)handle)))
        goto exit_func;

    ret.api_version = handle->api_version;

    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {
        ret.code = KADM5_FAILURE;
        goto exit_func;
    }
    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {
        ret.code = KADM5_BAD_PRINCIPAL;
        goto exit_func;
    }

    if (!(CHANGEPW_SERVICE(rqstp)) &&
        kadm5int_acl_check(handle->context, rqst2name(rqstp),
                           ACL_SETKEY, arg->princ, NULL)) {
        ret.code = kadm5_setv4key_principal((void *)handle, arg->princ,
                                            arg->keyblock);
    } else {
        log_unauth(""kadm5_setv4key_principal"", prime_arg,
                   &client_name, &service_name, rqstp);
        ret.code = KADM5_AUTH_SETKEY;
    }

    if(ret.code != KADM5_AUTH_SETKEY) {
        if( ret.code != 0 )
            errmsg = krb5_get_error_message(handle->context, ret.code);

        log_done(""kadm5_setv4key_principal"", prime_arg, errmsg,
                 &client_name, &service_name, rqstp);

        if (errmsg != NULL)
            krb5_free_error_message(handle->context, errmsg);
    }

    free(prime_arg);
exit_func:
    gss_release_buffer(&minor_stat, &client_name);
    gss_release_buffer(&minor_stat, &service_name);
    free_server_handle(handle);
    return &ret;
}
","1. kadm5_server_handle_t           handle;
2. if ((ret.code = check_handle((void *)handle)))
goto exit_func;
3. arg->keyblock);
} else {
4. ret.code = KADM5_AUTH_SETKEY;
5. errmsg = krb5_get_error_message(handle->context, ret.code);
6. &client_name, &service_name, rqstp);
7. krb5_free_error_message(handle->context, errmsg);","9
17-18
35-36
39
44
47
50","CWE-772,CWE-119"
xmlPushInput-38863455773738,"int
xmlPushInput(xmlParserCtxtPtr ctxt, xmlParserInputPtr input) {
    int ret;
    if (input == NULL) return(-1);

    if (xmlParserDebugEntities) {
	if ((ctxt->input != NULL) && (ctxt->input->filename))
	    xmlGenericError(xmlGenericErrorContext,
		    ""%s(%d): "", ctxt->input->filename,
		    ctxt->input->line);
	xmlGenericError(xmlGenericErrorContext,
		""Pushing input %d : %.30s\n"", ctxt->inputNr+1, input->cur);
    }
    if (((ctxt->inputNr > 40) && ((ctxt->options & XML_PARSE_HUGE) == 0)) ||
        (ctxt->inputNr > 1024)) {
        xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
        while (ctxt->inputNr > 1)
            xmlFreeInputStream(inputPop(ctxt));
	return(-1);
    }
    ret = inputPush(ctxt, input);
    if (ctxt->instate == XML_PARSER_EOF)
        return(-1);
    GROW;
    return(ret);
}
","1. int
xmlPushInput(xmlParserCtxtPtr ctxt, xmlParserInputPtr input) {
int ret;
2. if (xmlParserDebugEntities) {
3. xmlGenericError(xmlGenericErrorContext,
4. if (((ctxt->inputNr > 40) && ((ctxt->options & XML_PARSE_HUGE) == 0)) ||
5. xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
while (ctxt->inputNr > 1)
6. ret = inputPush(ctxt, input);
if (ctxt->instate == XML_PARSER_EOF)
return(-1);
7. return(ret);","1-3
6
11
14
16-17
21-23
25","CWE-119,CWE-787,CWE-835"
vc_handle_exitcode-252137589370878,"static enum es_result vc_handle_exitcode(struct es_em_ctxt *ctxt,
					 struct ghcb *ghcb,
					 unsigned long exit_code)
{
	enum es_result result = vc_check_opcode_bytes(ctxt, exit_code);

	if (result != ES_OK)
		return result;

	switch (exit_code) {
	case SVM_EXIT_READ_DR7:
		result = vc_handle_dr7_read(ghcb, ctxt);
		break;
	case SVM_EXIT_WRITE_DR7:
		result = vc_handle_dr7_write(ghcb, ctxt);
		break;
	case SVM_EXIT_EXCP_BASE + X86_TRAP_AC:
		result = vc_handle_trap_ac(ghcb, ctxt);
		break;
	case SVM_EXIT_RDTSC:
	case SVM_EXIT_RDTSCP:
		result = vc_handle_rdtsc(ghcb, ctxt, exit_code);
		break;
	case SVM_EXIT_RDPMC:
		result = vc_handle_rdpmc(ghcb, ctxt);
		break;
	case SVM_EXIT_INVD:
		pr_err_ratelimited(""#VC exception for INVD??? Seriously???\n"");
		result = ES_UNSUPPORTED;
		break;
	case SVM_EXIT_CPUID:
		result = vc_handle_cpuid(ghcb, ctxt);
		break;
	case SVM_EXIT_IOIO:
		result = vc_handle_ioio(ghcb, ctxt);
		break;
	case SVM_EXIT_MSR:
		result = vc_handle_msr(ghcb, ctxt);
		break;
	case SVM_EXIT_VMMCALL:
		result = vc_handle_vmmcall(ghcb, ctxt);
		break;
	case SVM_EXIT_WBINVD:
		result = vc_handle_wbinvd(ghcb, ctxt);
		break;
	case SVM_EXIT_MONITOR:
		result = vc_handle_monitor(ghcb, ctxt);
		break;
	case SVM_EXIT_MWAIT:
		result = vc_handle_mwait(ghcb, ctxt);
		break;
	case SVM_EXIT_NPF:
		result = vc_handle_mmio(ghcb, ctxt);
		break;
	default:
		
		result = ES_UNSUPPORTED;
	}

	return result;
}
","1. switch (exit_code) {
2. result = vc_handle_msr(ghcb, ctxt);
3. result = vc_handle_vmmcall(ghcb, ctxt);","10
38
41","CWE-264,CWE-404,CWE-119"
rand_gen-280838322055399,"static void rand_gen(uint8_t *out, size_t out_len) {
	int m = RLC_CEIL(out_len, RLC_MD_LEN);
	uint8_t hash[RLC_MD_LEN], data[(RLC_RAND_SIZE - 1)/2];
	ctx_t *ctx = core_get();

	
	memcpy(data, ctx->rand + 1, (RLC_RAND_SIZE - 1)/2);
	for (int i = 0; i < m; i++) {
		
		md_map(hash, data, sizeof(data));
		
		memcpy(out, hash, RLC_MIN(RLC_MD_LEN, out_len));
		out += RLC_MD_LEN;
		out_len -= RLC_MD_LEN;
		
		rand_inc(data, (RLC_RAND_SIZE - 1)/2, 1);
	}
}
","1. static void rand_gen(uint8_t *out, size_t out_len) {
2. uint8_t hash[RLC_MD_LEN], data[(RLC_RAND_SIZE - 1)/2];
ctx_t *ctx = core_get();
3. md_map(hash, data, sizeof(data));
4. out += RLC_MD_LEN;
out_len -= RLC_MD_LEN;
5. rand_inc(data, (RLC_RAND_SIZE - 1)/2, 1);","1
3-4
10
13-14
16","CWE-476,CWE-190,CWE-284"
ion_handle_get_by_id-4049132794849,"struct ion_handle *ion_handle_get_by_id(struct ion_client *client,
						int id)
{
	struct ion_handle *handle;

	mutex_lock(&client->lock);
	handle = ion_handle_get_by_id_nolock(client, id);
	mutex_unlock(&client->lock);

	return handle;
}
","1. int id)
2. struct ion_handle *handle;
3. handle = ion_handle_get_by_id_nolock(client, id);
4. return handle;","2
4
7
10","CWE-20,CWE-264,CWE-416"
MBMotionComp,"
#define CBP
#define VideoDecData

void MBMotionComp(
 VideoDecData *video,
 int CBP
)
{

 
 
 Vop *prev = video->prevVop;

 
 int mbnum = video->mbnum;

 
 int MB_in_width = video->nMBPerRow;
 int ypos, xpos;
    PIXEL *c_comp, *c_prev;
    PIXEL *cu_comp, *cu_prev;
    PIXEL *cv_comp, *cv_prev;
 int height, width, pred_width;
 int imv, mvwidth;
 int32 offset;
 uint8 mode;
 uint8 *pred_block, *pred;

 
 int dx, dy;

    MOT px[4], py[4];
 int xpred, ypred;
 int xsum;
 int round1;
#ifdef PV_POSTPROC_ON 
 
 int32 size = (int32) video->nTotalMB << 8;
 uint8 *pp_dec_y, *pp_dec_u;
 int ll[4];
 int tmp = 0;
 uint8 msk_deblock = 0;
#endif
 
 
 
    round1 = (int)(1 - video->currVop->roundingType);

 
    width = video->width;

 
    height = video->height;

 
    mvwidth = MB_in_width << 1;

 
    ypos = video->mbnum_row << 4 ;
 
    xpos = video->mbnum_col << 4 ;

 
 
 
    offset = (int32)ypos * width + xpos;

 
    mode = video->headerInfo.Mode[mbnum];

 
 
    imv = (offset >> 6) - (xpos >> 6) + (xpos >> 3);
 if (mode & INTER_1VMASK)
 {
        dx = px[0] = px[1] = px[2] = px[3] = video->motX[imv];
        dy = py[0] = py[1] = py[2] = py[3] = video->motY[imv];
 if ((dx & 3) == 0)
 {
            dx = dx >> 1;
 }
 else
 {
 
            dx = (dx >> 1) | 1;
 }

 
 
 if ((dy & 3) == 0)
 {
            dy = dy >> 1;
 }
 else
 {
 
            dy = (dy >> 1) | 1;
 }
 }
 else
 {
        px[0] = video->motX[imv];
        px[1] = video->motX[imv+1];
        px[2] = video->motX[imv+mvwidth];
        px[3] = video->motX[imv+mvwidth+1];
        xsum = px[0] + px[1] + px[2] + px[3];
        dx = PV_SIGN(xsum) * (roundtab16[(PV_ABS(xsum)) & 0xF] +
 (((PV_ABS(xsum)) >> 4) << 1));
        py[0] = video->motY[imv];
        py[1] = video->motY[imv+1];
        py[2] = video->motY[imv+mvwidth];
        py[3] = video->motY[imv+mvwidth+1];
        xsum = py[0] + py[1] + py[2] + py[3];
        dy = PV_SIGN(xsum) * (roundtab16[(PV_ABS(xsum)) & 0xF] +
 (((PV_ABS(xsum)) >> 4) << 1));
 }

 
     
     c_prev  = prev->yChan;
    if (!c_prev) {
        ALOGE(""b/35269635"");
        android_errorWriteLog(0x534e4554, ""35269635"");
        return;
    }
 
     pred_block = video->mblock->pred_block;
 
 
 
 
 



 
 
    c_comp = video->currVop->yChan + offset;


    xpred = (int)((xpos << 1) + px[0]);
    ypred = (int)((ypos << 1) + py[0]);

 if ((CBP >> 5)&1)
 {
        pred = pred_block;
        pred_width = 16;
 }
 else
 {
        pred = c_comp;
        pred_width = width;
 }

 
 if (xpred >= 0 && xpred <= ((width << 1) - (2*B_SIZE)) &&
            ypred >= 0 && ypred <= ((height << 1) - (2*B_SIZE)))
 { 
 
 
 ;
 GetPredAdvBTable[ypred&1][xpred&1](c_prev + (xpred >> 1) + ((ypred >> 1)*width),
                                           pred, width, (pred_width << 1) | round1);
 }
 else
 { 
 
 
 GetPredOutside(xpred, ypred, c_prev,
                       pred, width, height, round1, pred_width);
 }


 
 
 
    xpred = (int)(((xpos + B_SIZE) << 1) + px[1]);
    ypred = (int)((ypos << 1) + py[1]);

 if ((CBP >> 4)&1)
 {
        pred = pred_block + 8;
        pred_width = 16;
 }
 else
 {
        pred = c_comp + 8;
        pred_width = width;
 }

 
 if (xpred >= 0 && xpred <= ((width << 1) - (2*B_SIZE)) &&
            ypred >= 0 && ypred <= ((height << 1) - (2*B_SIZE)))
 { 
 
 
 GetPredAdvBTable[ypred&1][xpred&1](c_prev + (xpred >> 1) + ((ypred >> 1)*width),
                                           pred, width, (pred_width << 1) | round1);
 }
 else
 { 
 
 
 GetPredOutside(xpred, ypred, c_prev,
                       pred, width, height, round1, pred_width);
 }



 
 
 
    xpred = (int)((xpos << 1) + px[2]);
    ypred = (int)(((ypos + B_SIZE) << 1) + py[2]);

 if ((CBP >> 3)&1)
 {
        pred = pred_block + 128;
        pred_width = 16;
 }
 else
 {
        pred = c_comp + (width << 3);
        pred_width = width;
 }

 
 if (xpred >= 0 && xpred <= ((width << 1) - (2*B_SIZE)) &&
            ypred >= 0 && ypred <= ((height << 1) - (2*B_SIZE)))
 { 
 
 
 GetPredAdvBTable[ypred&1][xpred&1](c_prev + (xpred >> 1) + ((ypred >> 1)*width),
                                           pred, width, (pred_width << 1) | round1);
 }
 else
 { 
 
 
 GetPredOutside(xpred, ypred, c_prev,
                       pred, width, height, round1, pred_width);
 }



 
 
 
 
    xpred = (int)(((xpos + B_SIZE) << 1) + px[3]);
    ypred = (int)(((ypos + B_SIZE) << 1) + py[3]);

 if ((CBP >> 2)&1)
 {
        pred = pred_block + 136;
        pred_width = 16;
 }
 else
 {
        pred = c_comp + (width << 3) + 8;
        pred_width = width;
 }

 
 if (xpred >= 0 && xpred <= ((width << 1) - (2*B_SIZE)) &&
            ypred >= 0 && ypred <= ((height << 1) - (2*B_SIZE)))
 { 
 
 
 GetPredAdvBTable[ypred&1][xpred&1](c_prev + (xpred >> 1) + ((ypred >> 1)*width),
                                           pred, width, (pred_width << 1) | round1);
 }
 else
 { 
 
 
 GetPredOutside(xpred, ypred, c_prev,
                       pred, width, height, round1, pred_width);
 }
 
 

#ifdef PV_POSTPROC_ON
 if (video->postFilterType != PV_NO_POST_PROC)
 {
 if (mode&INTER_1VMASK)
 {
            pp_dec_y = video->pstprcTypCur + imv;
            ll[0] = 1;
            ll[1] = mvwidth - 1;
            ll[2] = 1;
            ll[3] = -mvwidth - 1;
            msk_deblock = pp_semaphore_luma(xpred, ypred, pp_dec_y,
                                            video->pstprcTypPrv, ll, &tmp, px[0], py[0], mvwidth,
                                            width, height);

            pp_dec_u = video->pstprcTypCur + (size >> 6) +
 ((imv + (xpos >> 3)) >> 2);

            pp_semaphore_chroma_inter(xpred, ypred, pp_dec_u,
                                      video->pstprcTypPrv, dx, dy, mvwidth, height, size,
                                      tmp, msk_deblock);
 }
 else
 {
 
 
            pp_dec_y = video->pstprcTypCur + imv;
 *pp_dec_y = 4;
 *(pp_dec_y + 1) = 4;
 *(pp_dec_y + mvwidth) = 4;
 *(pp_dec_y + mvwidth + 1) = 4;
            pp_dec_u = video->pstprcTypCur + (size >> 6) +
 ((imv + (xpos >> 3)) >> 2);
 *pp_dec_u = 4;
            pp_dec_u[size>>8] = 4;
 }
 }
#endif


 
 

 
 
    width >>= 1;

 
    height >>= 1;

 
    cu_prev = prev->uChan;

 
    cv_prev = prev->vChan;

 
 
 
    xpred = xpos + dx;

 
 
 
    ypred = ypos + dy;

    cu_comp = video->currVop->uChan + (offset >> 2) + (xpos >> 2);
    cv_comp = video->currVop->vChan + (offset >> 2) + (xpos >> 2);

 
 
 if (xpred >= 0 && xpred <= ((width << 1) - (2*B_SIZE)) && ypred >= 0 &&
            ypred <= ((height << 1) - (2*B_SIZE)))
 {
 
 
 
 if ((CBP >> 1)&1)
 {
            pred = pred_block + 256;
            pred_width = 16;
 }
 else
 {
            pred = cu_comp;
            pred_width = width;
 }

 
 GetPredAdvBTable[ypred&1][xpred&1](cu_prev + (xpred >> 1) + ((ypred >> 1)*width),
                                           pred, width, (pred_width << 1) | round1);

 if (CBP&1)
 {
            pred = pred_block + 264;
            pred_width = 16;
 }
 else
 {
            pred = cv_comp;
            pred_width = width;
 }
 
 GetPredAdvBTable[ypred&1][xpred&1](cv_prev + (xpred >> 1) + ((ypred >> 1)*width),
                                           pred, width, (pred_width << 1) | round1);

 return ;
 }
 else
 {
 
 
 
 if ((CBP >> 1)&1)
 {
            pred = pred_block + 256;
            pred_width = 16;
 }
 else
 {
            pred = cu_comp;
            pred_width = width;
 }

 
 GetPredOutside(xpred, ypred,    cu_prev,
                       pred, width, height, round1, pred_width);

 if (CBP&1)
 {
            pred = pred_block + 264;
            pred_width = 16;
 }
 else
 {
            pred = cv_comp;
            pred_width = width;
 }

 
 GetPredOutside(xpred, ypred,    cv_prev,
                       pred, width, height, round1, pred_width);

 return ;
 }

}
","1. void MBMotionComp(
VideoDecData *video,
2. int MB_in_width = video->nMBPerRow;
int ypos, xpos;
PIXEL *c_comp, *c_prev;
3. uint8 mode;
uint8 *pred_block, *pred;
4. height = video->height;
5. xpos = video->mbnum_col << 4 ;
6. if (mode & INTER_1VMASK)
7. if ((dx & 3) == 0)
8. dx = dx >> 1;
9. {
10. px[2] = video->motX[imv+mvwidth];
11. dx = PV_SIGN(xsum) * (roundtab16[(PV_ABS(xsum)) & 0xF] +
12. pred_block = video->mblock->pred_block;
13. ypred = (int)((ypos << 1) + py[0]);
14. {
15. if (xpred >= 0 && xpred <= ((width << 1) - (2*B_SIZE)) &&
16. GetPredOutside(xpred, ypred, c_prev,
pred, width, height, round1, pred_width);
17. xpred = (int)(((xpos + B_SIZE) << 1) + px[1]);
18. pred = pred_block + 8;
19. pred = c_comp + 8;
20. pred, width, (pred_width << 1) | round1);
21. if ((CBP >> 3)&1)
22. pred = pred_block + 128;
23. pred, width, height, round1, pred_width);
24. pred = pred_block + 136;
pred_width = 16;
25. pred_width = width;
26. if (xpred >= 0 && xpred <= ((width << 1) - (2*B_SIZE)) &&
27. {
28. width >>= 1;
29. height >>= 1;
30. cu_comp = video->currVop->uChan + (offset >> 2) + (xpos >> 2);
31. if ((CBP >> 1)&1)
32. GetPredAdvBTable[ypred&1][xpred&1](cu_prev + (xpred >> 1) + ((ypred >> 1)*width),
pred, width, (pred_width << 1) | round1);
33. if (CBP&1)
34. pred_width = 16;
35. {
36. if ((CBP >> 1)&1)
37. pred_width = 16;
38. pred = cv_comp;
39. pred, width, height, round1, pred_width);
40. return ;","5-6
21-23
29-30
58
66
79
83
85
100
109
112
132
149
157
163
176-177
184
189
194
205
223
225
248
262-263
268
272
281
334
337
355
368
380-381
383
386
389
404
422
426
432
434","CWE-17,CWE-125,CWE-787,CWE-119"
snd_compr_allocate_buffer-69110486704050,"static int snd_compr_allocate_buffer(struct snd_compr_stream *stream,
		struct snd_compr_params *params)
{
	unsigned int buffer_size;
	void *buffer;

	if (params->buffer.fragment_size == 0 ||
	    params->buffer.fragments > SIZE_MAX / params->buffer.fragment_size)
		return -EINVAL;

	buffer_size = params->buffer.fragment_size * params->buffer.fragments;
	if (stream->ops->copy) {
		buffer = NULL;
		
	} else {
		buffer = kmalloc(buffer_size, GFP_KERNEL);
		if (!buffer)
			return -ENOMEM;
	}
	stream->runtime->fragment_size = params->buffer.fragment_size;
	stream->runtime->fragments = params->buffer.fragments;
	stream->runtime->buffer = buffer;
	stream->runtime->buffer_size = buffer_size;
	return 0;
}
","1. static int snd_compr_allocate_buffer(struct snd_compr_stream *stream,
2. if (params->buffer.fragment_size == 0 ||
3. return -EINVAL;
4. return -ENOMEM;","1
7
9
20","CWE-190,CWE-203,CWE-125,CWE-119"
mark_source_chains-150781629746811,"static int mark_source_chains(const struct xt_table_info *newinfo,
			      unsigned int valid_hooks, void *entry0)
{
	unsigned int hook;

	
	for (hook = 0; hook < NF_ARP_NUMHOOKS; hook++) {
		unsigned int pos = newinfo->hook_entry[hook];
		struct arpt_entry *e
			= (struct arpt_entry *)(entry0 + pos);

		if (!(valid_hooks & (1 << hook)))
			continue;

		
		e->counters.pcnt = pos;

		for (;;) {
			const struct xt_standard_target *t
				= (void *)arpt_get_target_c(e);
			int visited = e->comefrom & (1 << hook);

			if (e->comefrom & (1 << NF_ARP_NUMHOOKS)) {
				pr_notice(""arptables: loop hook %u pos %u %08X.\n"",
				       hook, pos, e->comefrom);
				return 0;
			}
			e->comefrom
				|= ((1 << hook) | (1 << NF_ARP_NUMHOOKS));

			
			if ((unconditional(e) &&
			     (strcmp(t->target.u.user.name,
				     XT_STANDARD_TARGET) == 0) &&
			     t->verdict < 0) || visited) {
				unsigned int oldpos, size;

				if ((strcmp(t->target.u.user.name,
					    XT_STANDARD_TARGET) == 0) &&
				    t->verdict < -NF_MAX_VERDICT - 1) {
					duprintf(""mark_source_chains: bad ""
						""negative verdict (%i)\n"",
								t->verdict);
					return 0;
				}

				
				do {
					e->comefrom ^= (1<<NF_ARP_NUMHOOKS);
					oldpos = pos;
					pos = e->counters.pcnt;
					e->counters.pcnt = 0;

					
					if (pos == oldpos)
						goto next;

					e = (struct arpt_entry *)
						(entry0 + pos);
				} while (oldpos == pos + e->next_offset);

				
				size = e->next_offset;
				e = (struct arpt_entry *)
					(entry0 + pos + size);
				e->counters.pcnt = pos;
				pos += size;
			} else {
				int newpos = t->verdict;

				if (strcmp(t->target.u.user.name,
					   XT_STANDARD_TARGET) == 0 &&
				    newpos >= 0) {
					if (newpos > newinfo->size -
						sizeof(struct arpt_entry)) {
						duprintf(""mark_source_chains: ""
							""bad verdict (%i)\n"",
								newpos);
						return 0;
					}

					
					duprintf(""Jump rule %u -> %u\n"",
						 pos, newpos);
				} else {
					
					newpos = pos + e->next_offset;
				}
				e = (struct arpt_entry *)
					(entry0 + newpos);
				e->counters.pcnt = pos;
				pos = newpos;
			}
		}
next:
		duprintf(""Finished chain %u\n"", hook);
	}
	return 1;
}
","1. unsigned int hook;
2. const struct xt_standard_target *t
3. hook, pos, e->comefrom);
4. if ((unconditional(e) &&
5. XT_STANDARD_TARGET) == 0) &&
t->verdict < 0) || visited) {
6. XT_STANDARD_TARGET) == 0) &&
t->verdict < -NF_MAX_VERDICT - 1) {
7. if (pos == oldpos)
8. (entry0 + pos + size);
9. pos += size;
10. XT_STANDARD_TARGET) == 0 &&
11. duprintf(""mark_source_chains: ""
12. next:
13. return 1;","4
21
27
34
36-37
41-42
59
69
71
76
80
99
102",CWE-119
fsck_gitmodules_fn_1-12575285286765,"static int fsck_gitmodules_fn_1(const char *var, const char *value, void *vdata)
{
	struct fsck_gitmodules_data *data = vdata;
	const char *subsection, *key;
	int subsection_len;
	char *name;

	if (parse_config_key(var, ""submodule"", &subsection, &subsection_len, &key) < 0 ||
	    !subsection)
		return 0;

	name = xmemdupz(subsection, subsection_len);
	if (check_submodule_name(name) < 0)
		data->ret |= report(data->options, data->obj,
				    FSCK_MSG_GITMODULES_NAME,
				    ""disallowed submodule name: %s"",
				    name);
	if (!strcmp(key, ""url"") && value &&
	    looks_like_command_line_option(value))
		data->ret |= report(data->options, data->obj,
				    FSCK_MSG_GITMODULES_URL,
				    ""disallowed submodule url: %s"",
				    value);
	if (!strcmp(key, ""path"") && value &&
	    looks_like_command_line_option(value))
		data->ret |= report(data->options, data->obj,
				    FSCK_MSG_GITMODULES_PATH,
				    ""disallowed submodule path: %s"",
				    value);
	free(name);

	return 0;
}
","1. struct fsck_gitmodules_data *data = vdata;
2. char *name;
3. if (parse_config_key(var, ""submodule"", &subsection, &subsection_len, &key) < 0 ||
!subsection)
return 0;
4. if (check_submodule_name(name) < 0)
data->ret |= report(data->options, data->obj,
FSCK_MSG_GITMODULES_NAME,
5. name);
6. looks_like_command_line_option(value))
7. FSCK_MSG_GITMODULES_URL,
""disallowed submodule url: %s"",
value);
8. looks_like_command_line_option(value))
9. ""disallowed submodule path: %s"",
10. free(name);
11. return 0;","3
6
8-10
13-15
17
19
21-23
25
28
30
32","CWE-20,CWE-770,CWE-276,CWE-88,CWE-125"
install_process_keyring_to_cred," int install_process_keyring_to_cred(struct cred *new)
 {
 	struct key *keyring;
 
 	if (new->process_keyring)
		return 0;
 
 	keyring = keyring_alloc(""_pid"", new->uid, new->gid, new,
 				KEY_POS_ALL | KEY_USR_VIEW,
				KEY_ALLOC_QUOTA_OVERRUN,
				NULL, NULL);
	if (IS_ERR(keyring))
		return PTR_ERR(keyring);

	new->process_keyring = keyring;
	return 0;
 }
","1. int install_process_keyring_to_cred(struct cred *new)
2. if (new->process_keyring)
return 0;
3. keyring = keyring_alloc(""_pid"", new->uid, new->gid, new,
KEY_POS_ALL | KEY_USR_VIEW,","1
5-6
8-9","CWE-122,CWE-200,CWE-404"
ext4_zero_range,"static long ext4_zero_range(struct file *file, loff_t offset,
			    loff_t len, int mode)
{
	struct inode *inode = file_inode(file);
	handle_t *handle = NULL;
	unsigned int max_blocks;
	loff_t new_size = 0;
	int ret = 0;
	int flags;
	int credits;
 	int partial_begin, partial_end;
 	loff_t start, end;
 	ext4_lblk_t lblk;
 	unsigned int blkbits = inode->i_blkbits;
 
 	trace_ext4_zero_range(inode, offset, len, mode);

	if (!S_ISREG(inode->i_mode))
		return -EINVAL;

	
	if (ext4_should_journal_data(inode)) {
		ret = ext4_force_commit(inode->i_sb);
		if (ret)
 			return ret;
 	}
 
 	
	start = round_up(offset, 1 << blkbits);
	end = round_down((offset + len), 1 << blkbits);

	if (start < offset || end > offset + len)
		return -EINVAL;
	partial_begin = offset & ((1 << blkbits) - 1);
	partial_end = (offset + len) & ((1 << blkbits) - 1);

	lblk = start >> blkbits;
	max_blocks = (end >> blkbits);
	if (max_blocks < lblk)
		max_blocks = 0;
	else
		max_blocks -= lblk;

	mutex_lock(&inode->i_mutex);

	
	if (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))) {
		ret = -EOPNOTSUPP;
		goto out_mutex;
	}

	if (!(mode & FALLOC_FL_KEEP_SIZE) &&
	     offset + len > i_size_read(inode)) {
		new_size = offset + len;
		ret = inode_newsize_ok(inode, new_size);
		if (ret)
			goto out_mutex;
	}

	flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT;
	if (mode & FALLOC_FL_KEEP_SIZE)
		flags |= EXT4_GET_BLOCKS_KEEP_SIZE;

	
	if (partial_begin || partial_end) {
		ret = ext4_alloc_file_blocks(file,
				round_down(offset, 1 << blkbits) >> blkbits,
				(round_up((offset + len), 1 << blkbits) -
				 round_down(offset, 1 << blkbits)) >> blkbits,
				new_size, flags, mode);
		if (ret)
			goto out_mutex;

	}

	
	if (max_blocks > 0) {
 		flags |= (EXT4_GET_BLOCKS_CONVERT_UNWRITTEN |
 			  EXT4_EX_NOCACHE);
 
 		
 		ext4_inode_block_unlocked_dio(inode);
 		inode_dio_wait(inode);
 
		
		down_write(&EXT4_I(inode)->i_mmap_sem);
		
		truncate_pagecache_range(inode, start, end - 1);
		inode->i_mtime = inode->i_ctime = ext4_current_time(inode);

 		ret = ext4_alloc_file_blocks(file, lblk, max_blocks, new_size,
 					     flags, mode);
		up_write(&EXT4_I(inode)->i_mmap_sem);
 		if (ret)
 			goto out_dio;
 	}
	if (!partial_begin && !partial_end)
		goto out_dio;

	
	credits = (2 * ext4_ext_index_trans_blocks(inode, 2)) + 1;
	if (ext4_should_journal_data(inode))
		credits += 2;
	handle = ext4_journal_start(inode, EXT4_HT_MISC, credits);
	if (IS_ERR(handle)) {
		ret = PTR_ERR(handle);
		ext4_std_error(inode->i_sb, ret);
		goto out_dio;
	}

	inode->i_mtime = inode->i_ctime = ext4_current_time(inode);
	if (new_size) {
		ext4_update_inode_size(inode, new_size);
	} else {
		
		if ((offset + len) > i_size_read(inode))
			ext4_set_inode_flag(inode, EXT4_INODE_EOFBLOCKS);
	}
	ext4_mark_inode_dirty(handle, inode);

	
	ret = ext4_zero_partial_blocks(handle, inode, offset, len);

	if (file->f_flags & O_SYNC)
		ext4_handle_sync(handle);

	ext4_journal_stop(handle);
out_dio:
	ext4_inode_resume_unlocked_dio(inode);
out_mutex:
	mutex_unlock(&inode->i_mutex);
	return ret;
}
","1. static long ext4_zero_range(struct file *file, loff_t offset,
2. struct inode *inode = file_inode(file);
handle_t *handle = NULL;
unsigned int max_blocks;
3. if (!S_ISREG(inode->i_mode))
return -EINVAL;
4. ret = ext4_force_commit(inode->i_sb);
5. return ret;
6. end = round_down((offset + len), 1 << blkbits);
7. partial_begin = offset & ((1 << blkbits) - 1);
8. lblk = start >> blkbits;
9. if (max_blocks < lblk)
10. ret = -EOPNOTSUPP;
11. if (!(mode & FALLOC_FL_KEEP_SIZE) &&
12. ret = inode_newsize_ok(inode, new_size);
if (ret)
goto out_mutex;
13. if (mode & FALLOC_FL_KEEP_SIZE)
flags |= EXT4_GET_BLOCKS_KEEP_SIZE;
14. if (partial_begin || partial_end) {
15. round_down(offset, 1 << blkbits) >> blkbits,
16. new_size, flags, mode);
if (ret)
17. down_write(&EXT4_I(inode)->i_mmap_sem);
18. truncate_pagecache_range(inode, start, end - 1);
19. flags, mode);
20. credits = (2 * ext4_ext_index_trans_blocks(inode, 2)) + 1;
if (ext4_should_journal_data(inode))
21. if (IS_ERR(handle)) {
22. ext4_std_error(inode->i_sb, ret);
goto out_dio;
23. if (new_size) {
24. if ((offset + len) > i_size_read(inode))
ext4_set_inode_flag(inode, EXT4_INODE_EOFBLOCKS);
25. ret = ext4_zero_partial_blocks(handle, inode, offset, len);
26. ext4_handle_sync(handle);
27. out_mutex:
mutex_unlock(&inode->i_mutex);","1
4-6
18-19
23
25
35
39
42
44
55
59
62-64
68-69
72
74
77-78
96
98
102
114-115
118
120-121
125
132-133
138
141
146-147","CWE-362,CWE-17,CWE-19"
find_callno-169484798712343,"static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {

	return __find_callno(callno, dcallno, sin, new, sockfd, 0, full_frame);
}
","1. static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {
2. return __find_callno(callno, dcallno, sin, new, sockfd, 0, full_frame);","1
3",CWE-287
filter_average_block2d_8_c,"
#define HFilter
#define VFilter

void filter_average_block2d_8_c(const uint8_t *src_ptr,
 const unsigned int src_stride,
 const int16_t *HFilter,
 const int16_t *VFilter,
 uint8_t *dst_ptr,

                                 unsigned int dst_stride,
                                 unsigned int output_width,
                                 unsigned int output_height) {
  uint8_t tmp[kMaxDimension * kMaxDimension];
 
  assert(output_width <= kMaxDimension);
  assert(output_height <= kMaxDimension);
   filter_block2d_8_c(src_ptr, src_stride, HFilter, VFilter, tmp, 64,
                      output_width, output_height);
   block2d_average_c(tmp, 64, dst_ptr, dst_stride,
                     output_width, output_height);
 }
","1. unsigned int output_height) {
2. block2d_average_c(tmp, 64, dst_ptr, dst_stride,
output_width, output_height);","13
20-21","CWE-319,CWE-264,CWE-120,CWE-119"
exif_mnote_data_fuji_load_1-116597327575703,"
#define ExifMnoteData

static void
exif_mnote_data_fuji_load_1 (ExifMnoteData *en,
	const unsigned char *buf, unsigned int buf_size)
{
	ExifMnoteDataFuji *n = (ExifMnoteDataFuji*) en;
	ExifLong c;
	size_t i, tcount, o, datao;

	if (!n || !buf || !buf_size) {
		exif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,
			  ""ExifMnoteDataFuji"", ""Short MakerNote"");
		return;
	}
	datao = 6 + n->offset;
	if (CHECKOVERFLOW(datao, buf_size, 12)) {
		exif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,
			  ""ExifMnoteDataFuji"", ""Short MakerNote"");
		return;
	}

	n->order = EXIF_BYTE_ORDER_INTEL;

	datao += exif_get_long (buf + datao + 8, EXIF_BYTE_ORDER_INTEL);
	if (CHECKOVERFLOW(datao, buf_size, 2)) {
		exif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,
			  ""ExifMnoteDataFuji"", ""Short MakerNote"");
		return;
	}

	
	c = exif_get_short (buf + datao, EXIF_BYTE_ORDER_INTEL);
	datao += 2;

	
	exif_mnote_data_fuji_clear (n);

	
	n->entries = exif_mem_alloc (en->mem, sizeof (MnoteFujiEntry) * c);
	if (!n->entries) {
		EXIF_LOG_NO_MEMORY(en->log, ""ExifMnoteDataFuji"", sizeof (MnoteFujiEntry) * c);
		return;
	}

	
	tcount = 0;
	for (i = c, o = datao; i; --i, o += 12) {
		size_t s;

		memset(&n->entries[tcount], 0, sizeof(MnoteFujiEntry));
		if (CHECKOVERFLOW(o, buf_size, 12)) {
			exif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,
				  ""ExifMnoteDataFuji"", ""Short MakerNote"");
			break;
		}

		n->entries[tcount].tag        = exif_get_short (buf + o, n->order);
		n->entries[tcount].format     = exif_get_short (buf + o + 2, n->order);
		n->entries[tcount].components = exif_get_long (buf + o + 4, n->order);
		n->entries[tcount].order      = n->order;

		exif_log (en->log, EXIF_LOG_CODE_DEBUG, ""ExifMnoteDataFuji"",
			  ""Loading entry 0x%x ('%s')..."", n->entries[tcount].tag,
			  mnote_fuji_tag_get_name (n->entries[tcount].tag));

		
		if (	exif_format_get_size (n->entries[tcount].format) &&
			buf_size / exif_format_get_size (n->entries[tcount].format) < n->entries[tcount].components
		) {
			exif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,
					  ""ExifMnoteDataFuji"", ""Tag size overflow detected (%u * %lu)"", exif_format_get_size (n->entries[tcount].format), n->entries[tcount].components);
			continue;
		}
		
		s = exif_format_get_size (n->entries[tcount].format) * n->entries[tcount].components;
		n->entries[tcount].size = s;
		if (s) {
			size_t dataofs = o + 8;
			if (s > 4)
				
				dataofs = exif_get_long (buf + dataofs, n->order) + 6 + n->offset;

			if (CHECKOVERFLOW(dataofs, buf_size, s)) {
				exif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,
						  ""ExifMnoteDataFuji"", ""Tag data past end of ""
					  ""buffer (%u >= %u)"", (unsigned)(dataofs + s), buf_size);
				continue;
			}

			n->entries[tcount].data = exif_mem_alloc (en->mem, s);
			if (!n->entries[tcount].data) {
				EXIF_LOG_NO_MEMORY(en->log, ""ExifMnoteDataFuji"", s);
				continue;
			}
			memcpy (n->entries[tcount].data, buf + dataofs, s);
		}

		
		++tcount;
	}
	
	n->count = tcount;
}
","1. static void
2. const unsigned char *buf, unsigned int buf_size)
3. ExifLong c;
size_t i, tcount, o, datao;
4. if (!n || !buf || !buf_size) {
5. return;
6. return;
7. datao += exif_get_long (buf + datao + 8, EXIF_BYTE_ORDER_INTEL);
8. exif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,
9. datao += 2;
10. n->entries = exif_mem_alloc (en->mem, sizeof (MnoteFujiEntry) * c);
if (!n->entries) {
EXIF_LOG_NO_MEMORY(en->log, ""ExifMnoteDataFuji"", sizeof (MnoteFujiEntry) * c);
11. tcount = 0;
for (i = c, o = datao; i; --i, o += 12) {
12. ""ExifMnoteDataFuji"", ""Short MakerNote"");
break;
13. ""Loading entry 0x%x ('%s')..."", n->entries[tcount].tag,
14. if (	exif_format_get_size (n->entries[tcount].format) &&
buf_size / exif_format_get_size (n->entries[tcount].format) < n->entries[tcount].components
15. ""ExifMnoteDataFuji"", ""Tag size overflow detected (%u * %lu)"", exif_format_get_size (n->entries[tcount].format), n->entries[tcount].components);
16. if (s) {
17. if (s > 4)
18. if (CHECKOVERFLOW(dataofs, buf_size, s)) {
19. ""ExifMnoteDataFuji"", ""Tag data past end of ""
20. n->entries[tcount].data = exif_mem_alloc (en->mem, s);
if (!n->entries[tcount].data) {
EXIF_LOG_NO_MEMORY(en->log, ""ExifMnoteDataFuji"", s);
21. ++tcount;
22. n->count = tcount;","4
6
9-10
12
15
21
26
28
35
41-43
48-49
55-56
65
70-71
74
83
85
89
91
96-98
105
108","CWE-362,CWE-125"
armv7pmu_handle_irq,"static irqreturn_t armv7pmu_handle_irq(int irq_num, void *dev)
{
	unsigned long pmnc;
	struct perf_sample_data data;
	struct cpu_hw_events *cpuc;
	struct pt_regs *regs;
	int idx;

	
	pmnc = armv7_pmnc_getreset_flags();

	
	if (!armv7_pmnc_has_overflowed(pmnc))
		return IRQ_NONE;

	
	regs = get_irq_regs();

	perf_sample_data_init(&data, 0);

	cpuc = &__get_cpu_var(cpu_hw_events);
	for (idx = 0; idx <= armpmu->num_events; ++idx) {
		struct perf_event *event = cpuc->events[idx];
		struct hw_perf_event *hwc;

		if (!test_bit(idx, cpuc->active_mask))
			continue;

		
		if (!armv7_pmnc_counter_has_overflowed(pmnc, idx))
			continue;

		hwc = &event->hw;
		armpmu_event_update(event, hwc, idx, 1);
		data.period = event->hw.last_period;
 		if (!armpmu_event_set_period(event, hwc, idx))
 			continue;
 
		if (perf_event_overflow(event, &data, regs))
 			armpmu->disable(hwc, idx);
 	}
 
	
	irq_work_run();

	return IRQ_HANDLED;
}
","1. struct perf_sample_data data;
2. struct pt_regs *regs;
3. for (idx = 0; idx <= armpmu->num_events; ++idx) {
struct perf_event *event = cpuc->events[idx];
4. hwc = &event->hw;
5. if (perf_event_overflow(event, &data, regs))","4
6
28-29
42
48","CWE-399,CWE-400"
gdImageWBMPCtx," void gdImageWBMPCtx (gdImagePtr image, int fg, gdIOCtx * out)
{
	_gdImageWBMPCtx(image, fg, out);
}


static int _gdImageWBMPCtx(gdImagePtr image, int fg, gdIOCtx *out)
 {
 	int x, y, pos;
 	Wbmp *wbmp;
 
 	
 	if ((wbmp = createwbmp (gdImageSX (image), gdImageSY (image), WBMP_WHITE)) == NULL) {
 		gd_error(""Could not create WBMP"");
		return 1;
 	}
 
 	
	pos = 0;
	for (y = 0; y < gdImageSY(image); y++) {
		for (x = 0; x < gdImageSX(image); x++) {
			if (gdImageGetPixel (image, x, y) == fg) {
				wbmp->bitmap[pos] = WBMP_BLACK;
			}
			pos++;
		}
	}
 
 	
 	if (writewbmp (wbmp, &gd_putout, out)) {
		freewbmp(wbmp);
 		gd_error(""Could not save WBMP"");
		return 1;
 	}
 	
 	freewbmp(wbmp);
}
","1. void gdImageWBMPCtx (gdImagePtr image, int fg, gdIOCtx * out)
2. _gdImageWBMPCtx(image, fg, out);","1
3",CWE-415
readContigTilesIntoBuffer,"
#define TIFF

static int readContigTilesIntoBuffer (TIFF* in, uint8* buf, 
                                      uint32 imagelength, 
                                      uint32 imagewidth, 
                                      uint32 tw, uint32 tl,
                                      tsample_t spp, uint16 bps)
  {
  int status = 1;
  tsample_t sample = 0;
  tsample_t count = spp; 
  uint32 row, col, trow;
  uint32 nrow, ncol;
  uint32 dst_rowsize, shift_width;
  uint32 bytes_per_sample, bytes_per_pixel;
  uint32 trailing_bits, prev_trailing_bits;
  uint32 tile_rowsize  = TIFFTileRowSize(in);
  uint32 src_offset, dst_offset;
  uint32 row_offset, col_offset;
  uint8 *bufp = (uint8*) buf;
  unsigned char *src = NULL;
  unsigned char *dst = NULL;
  tsize_t tbytes = 0, tile_buffsize = 0;
  tsize_t tilesize = TIFFTileSize(in);
  unsigned char *tilebuf = NULL;

  bytes_per_sample = (bps + 7) / 8; 
  bytes_per_pixel  = ((bps * spp) + 7) / 8;

  if ((bps % 8) == 0)
    shift_width = 0;
  else
    {
    if (bytes_per_pixel < (bytes_per_sample + 1))
      shift_width = bytes_per_pixel;
    else
      shift_width = bytes_per_sample + 1;
    }

  tile_buffsize = tilesize;
  if (tilesize == 0 || tile_rowsize == 0)
  {
     TIFFError(""readContigTilesIntoBuffer"", ""Tile size or tile rowsize is zero"");
     exit(-1);
  }

  if (tilesize < (tsize_t)(tl * tile_rowsize))
    {
#ifdef DEBUG2
    TIFFError(""readContigTilesIntoBuffer"",
	      ""Tilesize %lu is too small, using alternate calculation %u"",
              tilesize, tl * tile_rowsize);
#endif
    tile_buffsize = tl * tile_rowsize;
    if (tl != (tile_buffsize / tile_rowsize))
    {
    	TIFFError(""readContigTilesIntoBuffer"", ""Integer overflow when calculating buffer size."");
        exit(-1);
     }
     }
 
  
  if( tile_buffsize > 0xFFFFFFFFU - 3 )
  {
      TIFFError(""readContigTilesIntoBuffer"", ""Integer overflow when calculating buffer size."");
      exit(-1);
  }
  tilebuf = _TIFFmalloc(tile_buffsize + 3);
   if (tilebuf == 0)
     return 0;
  tilebuf[tile_buffsize] = 0;
  tilebuf[tile_buffsize+1] = 0;
  tilebuf[tile_buffsize+2] = 0;
 
   dst_rowsize = ((imagewidth * bps * spp) + 7) / 8;  
   for (row = 0; row < imagelength; row += tl)
    {
    nrow = (row + tl > imagelength) ? imagelength - row : tl;
    for (col = 0; col < imagewidth; col += tw)
      {
      tbytes = TIFFReadTile(in, tilebuf, col, row, 0, 0);
      if (tbytes < tilesize  && !ignore)
        {
	TIFFError(TIFFFileName(in),
		  ""Error, can't read tile at row %lu col %lu, Read %lu bytes of %lu"",
		  (unsigned long) col, (unsigned long) row, (unsigned long)tbytes,
                  (unsigned long)tilesize);
		  status = 0;
                  _TIFFfree(tilebuf);
		  return status;
	}
      
      row_offset = row * dst_rowsize;
      col_offset = ((col * bps * spp) + 7)/ 8;
      bufp = buf + row_offset + col_offset;

      if (col + tw > imagewidth)
	ncol = imagewidth - col;
      else
        ncol = tw;

      
      
      if (((bps % 8) == 0) && (count == spp))
        {
	for (trow = 0; trow < nrow; trow++)
          {
	  src_offset = trow * tile_rowsize;
	  _TIFFmemcpy (bufp, tilebuf + src_offset, (ncol * spp * bps) / 8);
          bufp += (imagewidth * bps * spp) / 8;
	  }
        }
      else
        {
	
        prev_trailing_bits = trailing_bits = 0;
        trailing_bits = (ncol * bps * spp) % 8;

	
	for (trow = 0; trow < nrow; trow++)
          {
	  src_offset = trow * tile_rowsize;
          src = tilebuf + src_offset;
	  dst_offset = (row + trow) * dst_rowsize;
          dst = buf + dst_offset + col_offset;
          switch (shift_width)
            {
            case 0: if (extractContigSamplesBytes (src, dst, ncol, sample,
                                                   spp, bps, count, 0, ncol))
                      {
		      TIFFError(""readContigTilesIntoBuffer"",
                                ""Unable to extract row %d from tile %lu"", 
				row, (unsigned long)TIFFCurrentTile(in));
		      return 1;
		      }
		    break;
            case 1: if (bps == 1)
                      { 
                      if (extractContigSamplesShifted8bits (src, dst, ncol,
                                                            sample, spp,
                                                            bps, count,
                                                            0, ncol,
                                                            prev_trailing_bits))
                        {
		        TIFFError(""readContigTilesIntoBuffer"",
                                  ""Unable to extract row %d from tile %lu"", 
				  row, (unsigned long)TIFFCurrentTile(in));
		        return 1;
		        }
		      break;
		      }
                    else
                      if (extractContigSamplesShifted16bits (src, dst, ncol,
                                                             sample, spp,
                                                             bps, count,
                                                             0, ncol,
                                                             prev_trailing_bits))
                        {
		        TIFFError(""readContigTilesIntoBuffer"",
                                  ""Unable to extract row %d from tile %lu"", 
			  	  row, (unsigned long)TIFFCurrentTile(in));
		        return 1;
		        }
	            break;
            case 2: if (extractContigSamplesShifted24bits (src, dst, ncol,
                                                           sample, spp,
                                                           bps, count,
                                                           0, ncol,
                                                           prev_trailing_bits))
                      {
		      TIFFError(""readContigTilesIntoBuffer"",
                                ""Unable to extract row %d from tile %lu"", 
		  	        row, (unsigned long)TIFFCurrentTile(in));
		      return 1;
		      }
		    break;
            case 3:
            case 4:
            case 5: if (extractContigSamplesShifted32bits (src, dst, ncol,
                                                           sample, spp,
                                                           bps, count,
                                                           0, ncol,
                                                           prev_trailing_bits))
                      {
		      TIFFError(""readContigTilesIntoBuffer"",
                                ""Unable to extract row %d from tile %lu"", 
			        row, (unsigned long)TIFFCurrentTile(in));
		      return 1;
		      }
		    break;
            default: TIFFError(""readContigTilesIntoBuffer"", ""Unsupported bit depth %d"", bps);
		     return 1;
	    }
          }
        prev_trailing_bits += trailing_bits;
        
	
	}
      }
    }

  _TIFFfree(tilebuf);
  return status;
  }
","1. uint32 trailing_bits, prev_trailing_bits;
uint32 tile_rowsize  = TIFFTileRowSize(in);
2. unsigned char *dst = NULL;
3. tsize_t tilesize = TIFFTileSize(in);
4. shift_width = 0;
5. tile_buffsize = tilesize;
6. exit(-1);
7. ncol = tw;
8. {
9. case 0: if (extractContigSamplesBytes (src, dst, ncol, sample,
10. 0, ncol,
11. 0, ncol,
12. row, (unsigned long)TIFFCurrentTile(in));
13. case 3:
case 4:
case 5: if (extractContigSamplesShifted32bits (src, dst, ncol,
sample, spp,
bps, count,
0, ncol,
14. TIFFError(""readContigTilesIntoBuffer"",
""Unable to extract row %d from tile %lu"",
15. return 1;
16. prev_trailing_bits += trailing_bits;
17. _TIFFfree(tilebuf);","17-18
23
25
32
41
45
101
119
133
147
161
178
182-187
190-191
193
200
207","CWE-400,CWE-787,CWE-119,CWE-17,CWE-399"
compat_get_timex-135522880601539,"
#define __user

int compat_get_timex(struct timex *txc, const struct compat_timex __user *utp)
{
	struct compat_timex tx32;

	memset(txc, 0, sizeof(struct timex));
	if (copy_from_user(&tx32, utp, sizeof(struct compat_timex)))
		return -EFAULT;

	txc->modes = tx32.modes;
	txc->offset = tx32.offset;
	txc->freq = tx32.freq;
	txc->maxerror = tx32.maxerror;
	txc->esterror = tx32.esterror;
	txc->status = tx32.status;
	txc->constant = tx32.constant;
	txc->precision = tx32.precision;
	txc->tolerance = tx32.tolerance;
	txc->time.tv_sec = tx32.time.tv_sec;
	txc->time.tv_usec = tx32.time.tv_usec;
	txc->tick = tx32.tick;
	txc->ppsfreq = tx32.ppsfreq;
	txc->jitter = tx32.jitter;
	txc->shift = tx32.shift;
	txc->stabil = tx32.stabil;
	txc->jitcnt = tx32.jitcnt;
	txc->calcnt = tx32.calcnt;
	txc->errcnt = tx32.errcnt;
	txc->stbcnt = tx32.stbcnt;

	return 0;
}
","1. txc->time.tv_usec = tx32.time.tv_usec;
2. txc->stabil = tx32.stabil;
3. txc->calcnt = tx32.calcnt;","22
27
29","CWE-476,CWE-190,CWE-200"
mem_write," static int mem_write(jas_stream_obj_t *obj, char *buf, int cnt)
 {
	size_t n;
 	int ret;
 	jas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;
	size_t newbufsize;
	size_t newpos;
 
 	assert(buf);
 	assert(cnt >= 0);

	JAS_DBGLOG(100, (""mem_write(%p, %p, %d)\n"", obj, buf, cnt));
	newpos = m->pos_ + cnt;
 	if (newpos > m->bufsize_ && m->growable_) {
 		newbufsize = m->bufsize_;
 		while (newbufsize < newpos) {
			
			if (!jas_safe_size_mul(newbufsize, 2, &newbufsize)) {
				JAS_DBGLOG(100, (""new buffer size would cause overflow\n""));
				return -1;
			}
 		}
		JAS_DBGLOG(100, (""mem_write resizing from %d to %zu\n"", m->bufsize_,
 		  newbufsize));
		assert(newbufsize > 0);
 		if (mem_resize(m, newbufsize)) {
 			return -1;
 		}
	}
	if (m->pos_ > m->len_) {
		
		n = JAS_MIN(m->pos_, m->bufsize_) - m->len_;
		if (n > 0) {
			memset(&m->buf_[m->len_], 0, n);
			m->len_ += n;
		}
		if (m->pos_ != m->len_) {
			
			return 0;
		}
	}
	n = m->bufsize_ - m->pos_;
	ret = JAS_MIN(n, cnt);
	if (ret > 0) {
		memcpy(&m->buf_[m->pos_], buf, ret);
		m->pos_ += ret;
	}
	if (m->pos_ > m->len_) {
		m->len_ = m->pos_;
	}
	assert(ret == cnt);
	return ret;
}
","1. int ret;
jas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;
size_t newbufsize;
size_t newpos;
2. assert(cnt >= 0);
3. JAS_DBGLOG(100, (""mem_write(%p, %p, %d)\n"", obj, buf, cnt));
4. if (newpos > m->bufsize_ && m->growable_) {
5. if (!jas_safe_size_mul(newbufsize, 2, &newbufsize)) {
6. newbufsize));
7. return -1;
8. if (m->pos_ > m->len_) {
9. memset(&m->buf_[m->len_], 0, n);
m->len_ += n;
10. ret = JAS_MIN(n, cnt);
if (ret > 0) {
11. m->pos_ += ret;
12. if (m->pos_ > m->len_) {
13. return ret;","4-7
10
12
14
18
24
27
30
35-36
44-45
47
49
53","CWE-190,CWE-22,CWE-125,CWE-284"
jpc_tsfb_synthesize-229778378557286,"int jpc_tsfb_synthesize(jpc_tsfb_t *tsfb, jas_seq2d_t *a)
{
	return (tsfb->numlvls > 0 && jas_seq2d_size(a)) ?
	  jpc_tsfb_synthesize2(tsfb,
	  jas_seq2d_getref(a, jas_seq2d_xstart(a), jas_seq2d_ystart(a)),
	  jas_seq2d_xstart(a), jas_seq2d_ystart(a), jas_seq2d_width(a),
	  jas_seq2d_height(a), jas_seq2d_rowstep(a), tsfb->numlvls - 1) : 0;
}
","1. int jpc_tsfb_synthesize(jpc_tsfb_t *tsfb, jas_seq2d_t *a)
2. return (tsfb->numlvls > 0 && jas_seq2d_size(a)) ?
jpc_tsfb_synthesize2(tsfb,
jas_seq2d_getref(a, jas_seq2d_xstart(a), jas_seq2d_ystart(a)),
jas_seq2d_xstart(a), jas_seq2d_ystart(a), jas_seq2d_width(a),
jas_seq2d_height(a), jas_seq2d_rowstep(a), tsfb->numlvls - 1) : 0;","1
3-7","CWE-476,CWE-125,CWE-119"
flac_buffer_copy,"
#define SF_PRIVATE

flac_buffer_copy (SF_PRIVATE *psf)
{	FLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;
	const FLAC__Frame *frame = pflac->frame ;
	const int32_t* const *buffer = pflac->wbuffer ;
	unsigned i = 0, j, offset, channels, len ;

	
	if (frame->header.blocksize > FLAC__MAX_BLOCK_SIZE)
	{	psf_log_printf (psf, ""Ooops : frame->header.blocksize (%d) > FLAC__MAX_BLOCK_SIZE (%d)\n"", __func__, __LINE__, frame->header.blocksize, FLAC__MAX_BLOCK_SIZE) ;
		psf->error = SFE_INTERNAL ;
		return 0 ;
		} ;

	if (frame->header.channels > FLAC__MAX_CHANNELS)
		psf_log_printf (psf, ""Ooops : frame->header.channels (%d) > FLAC__MAX_BLOCK_SIZE (%d)\n"", __func__, __LINE__, frame->header.channels, FLAC__MAX_CHANNELS) ;

	channels = SF_MIN (frame->header.channels, FLAC__MAX_CHANNELS) ;
 
 	if (pflac->ptr == NULL)
 	{	
 		for (i = 0 ; i < channels ; i++)
 		{
 			if (pflac->rbuffer [i] == NULL)
				pflac->rbuffer [i] = calloc (FLAC__MAX_BLOCK_SIZE, sizeof (int32_t)) ;

			memcpy (pflac->rbuffer [i], buffer [i], frame->header.blocksize * sizeof (int32_t)) ;
			} ;
		pflac->wbuffer = (const int32_t* const*) pflac->rbuffer ;

		return 0 ;
		} ;

 
 	len = SF_MIN (pflac->len, frame->header.blocksize) ;
 
	if (pflac->remain % channels != 0)
	{	psf_log_printf (psf, ""Error: pflac->remain %u    channels %u\n"", pflac->remain, channels) ;
		return 0 ;
		} ;

 	switch (pflac->pcmtype)
 	{	case PFLAC_PCM_SHORT :
 			{	short *retpcm = (short*) pflac->ptr ;
				int shift = 16 - frame->header.bits_per_sample ;
				if (shift < 0)
				{	shift = abs (shift) ;
					for (i = 0 ; i < len && pflac->remain > 0 ; i++)
					{	offset = pflac->pos + i * channels ;

						if (pflac->bufferpos >= frame->header.blocksize)
							break ;

						if (offset + channels > pflac->len)
							break ;

						for (j = 0 ; j < channels ; j++)
							retpcm [offset + j] = buffer [j][pflac->bufferpos] >> shift ;
						pflac->remain -= channels ;
						pflac->bufferpos++ ;
						}
					}
				else
				{	for (i = 0 ; i < len && pflac->remain > 0 ; i++)
					{	offset = pflac->pos + i * channels ;

						if (pflac->bufferpos >= frame->header.blocksize)
							break ;

						if (offset + channels > pflac->len)
							break ;

						for (j = 0 ; j < channels ; j++)
							retpcm [offset + j] = ((uint16_t) buffer [j][pflac->bufferpos]) << shift ;

						pflac->remain -= channels ;
						pflac->bufferpos++ ;
						} ;
					} ;
				} ;
			break ;

		case PFLAC_PCM_INT :
			{	int *retpcm = (int*) pflac->ptr ;
				int shift = 32 - frame->header.bits_per_sample ;
				for (i = 0 ; i < len && pflac->remain > 0 ; i++)
				{	offset = pflac->pos + i * channels ;

					if (pflac->bufferpos >= frame->header.blocksize)
						break ;

					if (offset + channels > pflac->len)
						break ;

					for (j = 0 ; j < channels ; j++)
						retpcm [offset + j] = ((uint32_t) buffer [j][pflac->bufferpos]) << shift ;
					pflac->remain -= channels ;
					pflac->bufferpos++ ;
					} ;
				} ;
			break ;

		case PFLAC_PCM_FLOAT :
			{	float *retpcm = (float*) pflac->ptr ;
				float norm = (psf->norm_float == SF_TRUE) ? 1.0 / (1 << (frame->header.bits_per_sample - 1)) : 1.0 ;

				for (i = 0 ; i < len && pflac->remain > 0 ; i++)
				{	offset = pflac->pos + i * channels ;

					if (pflac->bufferpos >= frame->header.blocksize)
						break ;

					if (offset + channels > pflac->len)
						break ;

					for (j = 0 ; j < channels ; j++)
						retpcm [offset + j] = buffer [j][pflac->bufferpos] * norm ;
					pflac->remain -= channels ;
					pflac->bufferpos++ ;
					} ;
				} ;
			break ;

		case PFLAC_PCM_DOUBLE :
			{	double *retpcm = (double*) pflac->ptr ;
				double norm = (psf->norm_double == SF_TRUE) ? 1.0 / (1 << (frame->header.bits_per_sample - 1)) : 1.0 ;

				for (i = 0 ; i < len && pflac->remain > 0 ; i++)
				{	offset = pflac->pos + i * channels ;

					if (pflac->bufferpos >= frame->header.blocksize)
						break ;

					if (offset + channels > pflac->len)
						break ;

					for (j = 0 ; j < channels ; j++)
						retpcm [offset + j] = buffer [j][pflac->bufferpos] * norm ;
					pflac->remain -= channels ;
					pflac->bufferpos++ ;
					} ;
				} ;
			break ;

		default :
			return 0 ;
		} ;

	offset = i * channels ;
	pflac->pos += i * channels ;

	return offset ;
} 
","1. {	FLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;
2. {	psf_log_printf (psf, ""Ooops : frame->header.blocksize (%d) > FLAC__MAX_BLOCK_SIZE (%d)\n"", __func__, __LINE__, frame->header.blocksize, FLAC__MAX_BLOCK_SIZE) ;
3. for (i = 0 ; i < channels ; i++)
4. len = SF_MIN (pflac->len, frame->header.blocksize) ;
5. {	case PFLAC_PCM_SHORT :
{	short *retpcm = (short*) pflac->ptr ;
6. if (pflac->bufferpos >= frame->header.blocksize)
break ;
7. break ;
8. for (j = 0 ; j < channels ; j++)
9. pflac->remain -= channels ;
10. {	for (i = 0 ; i < len && pflac->remain > 0 ; i++)
11. for (j = 0 ; j < channels ; j++)
12. pflac->bufferpos++ ;
13. break ;
14. for (i = 0 ; i < len && pflac->remain > 0 ; i++)
15. break ;
16. float norm = (psf->norm_float == SF_TRUE) ? 1.0 / (1 << (frame->header.bits_per_sample - 1)) : 1.0 ;
17. for (i = 0 ; i < len && pflac->remain > 0 ; i++)
{	offset = pflac->pos + i * channels ;
18. if (offset + channels > pflac->len)
break ;
19. for (j = 0 ; j < channels ; j++)
20. pflac->remain -= channels ;
21. double norm = (psf->norm_double == SF_TRUE) ? 1.0 / (1 << (frame->header.bits_per_sample - 1)) : 1.0 ;
22. break ;
23. pflac->remain -= channels ;
24. default :
25. pflac->pos += i * channels ;","5
16
31
44
52-53
60-61
64
66
68
73
82
86
90
95
99
114
116-117
122-123
125
127
135
141
148
154
159","CWE-20,CWE-189,CWE-190,CWE-787,CWE-119"
nfsd_mountpoint," int nfsd_mountpoint(struct dentry *dentry, struct svc_export *exp)
 {
	if (!d_inode(dentry))
		return 0;
	if (exp->ex_flags & NFSEXP_V4ROOT)
 		return 1;
 	if (nfsd4_is_junction(dentry))
 		return 1;
	if (d_mountpoint(dentry))
		
		return 2;
	return 0;
 }
","1. int nfsd_mountpoint(struct dentry *dentry, struct svc_export *exp)
2. return 0;
if (exp->ex_flags & NFSEXP_V4ROOT)
3. if (nfsd4_is_junction(dentry))
4. return 2;
return 0;","1
4-5
7
14-15","CWE-20,CWE-59,CWE-189,CWE-369"
cipso_v4_validate_1-3542923807629,"static inline int cipso_v4_validate_1(const struct sk_buff *skb,
				    unsigned char **option)
{
	unsigned char *opt = *option;
	unsigned char err_offset = 0;
	u8 opt_len = opt[1];
	u8 opt_iter;
	u8 tag_len;

	if (opt_len < 8) {
		err_offset = 1;
		goto out;
	}

	if (get_unaligned_be32(&opt[2]) == 0) {
		err_offset = 2;
		goto out;
	}

	for (opt_iter = 6; opt_iter < opt_len;) {
		tag_len = opt[opt_iter + 1];
		if ((tag_len == 0) || (opt[opt_iter + 1] > (opt_len - opt_iter))) {
			err_offset = opt_iter + 1;
			goto out;
		}
		opt_iter += tag_len;
	}

out:
	*option = opt + err_offset;
	return err_offset;

}
",1. return err_offset;,31,CWE-20
dce112_clock_source_create-89001728242014,"struct clock_source *dce112_clock_source_create(
	struct dc_context *ctx,
	struct dc_bios *bios,
	enum clock_source_id id,
	const struct dce110_clk_src_regs *regs,
	bool dp_clk_src)
{
	struct dce110_clk_src *clk_src =
		kzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);

	if (!clk_src)
		return NULL;

	if (dce112_clk_src_construct(clk_src, ctx, bios, id,
			regs, &cs_shift, &cs_mask)) {
		clk_src->base.dp_clk_src = dp_clk_src;
		return &clk_src->base;
	}

	kfree(clk_src);
	BREAK_TO_DEBUGGER();
	return NULL;
}
","1. struct dc_context *ctx,
2. kfree(clk_src);
BREAK_TO_DEBUGGER();","2
20-21",CWE-401
process_tx_desc-123738904429019,"
#define E1000State

static void
process_tx_desc(E1000State *s, struct e1000_tx_desc *dp)
{
    PCIDevice *d = PCI_DEVICE(s);
    uint32_t txd_lower = le32_to_cpu(dp->lower.data);
    uint32_t dtype = txd_lower & (E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D);
    unsigned int split_size = txd_lower & 0xffff, bytes, sz;
    unsigned int msh = 0xfffff;
    uint64_t addr;
    struct e1000_context_desc *xp = (struct e1000_context_desc *)dp;
    struct e1000_tx *tp = &s->tx;

    s->mit_ide |= (txd_lower & E1000_TXD_CMD_IDE);
    if (dtype == E1000_TXD_CMD_DEXT) {    
        if (le32_to_cpu(xp->cmd_and_length) & E1000_TXD_CMD_TSE) {
            e1000x_read_tx_ctx_descr(xp, &tp->tso_props);
            s->use_tso_for_migration = 1;
            tp->tso_frames = 0;
        } else {
            e1000x_read_tx_ctx_descr(xp, &tp->props);
            s->use_tso_for_migration = 0;
        }
        return;
    } else if (dtype == (E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D)) {
        
        if (tp->size == 0) {
            tp->sum_needed = le32_to_cpu(dp->upper.data) >> 8;
        }
        tp->cptse = (txd_lower & E1000_TXD_CMD_TSE) ? 1 : 0;
    } else {
        
        tp->cptse = 0;
    }

    if (e1000x_vlan_enabled(s->mac_reg) &&
        e1000x_is_vlan_txd(txd_lower) &&
        (tp->cptse || txd_lower & E1000_TXD_CMD_EOP)) {
        tp->vlan_needed = 1;
        stw_be_p(tp->vlan_header,
                      le16_to_cpu(s->mac_reg[VET]));
        stw_be_p(tp->vlan_header + 2,
                      le16_to_cpu(dp->upper.fields.special));
    }

    addr = le64_to_cpu(dp->buffer_addr);
    if (tp->cptse) {
        msh = tp->tso_props.hdr_len + tp->tso_props.mss;
        do {
            bytes = split_size;
            if (tp->size >= msh) {
                goto eop;
            }
            if (tp->size + bytes > msh)
                bytes = msh - tp->size;

            bytes = MIN(sizeof(tp->data) - tp->size, bytes);
            pci_dma_read(d, addr, tp->data + tp->size, bytes);
            sz = tp->size + bytes;
            if (sz >= tp->tso_props.hdr_len
                && tp->size < tp->tso_props.hdr_len) {
                memmove(tp->header, tp->data, tp->tso_props.hdr_len);
            }
            tp->size = sz;
            addr += bytes;
            if (sz == msh) {
                xmit_seg(s);
                memmove(tp->data, tp->header, tp->tso_props.hdr_len);
                tp->size = tp->tso_props.hdr_len;
            }
            split_size -= bytes;
        } while (bytes && split_size);
    } else {
        split_size = MIN(sizeof(tp->data) - tp->size, split_size);
        pci_dma_read(d, addr, tp->data + tp->size, split_size);
        tp->size += split_size;
    }

eop:
    if (!(txd_lower & E1000_TXD_CMD_EOP))
        return;
    if (!(tp->cptse && tp->size < tp->tso_props.hdr_len)) {
        xmit_seg(s);
    }
    tp->tso_frames = 0;
    tp->sum_needed = 0;
    tp->vlan_needed = 0;
    tp->size = 0;
    tp->cptse = 0;
}
","1. static void
2. uint32_t dtype = txd_lower & (E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D);
unsigned int split_size = txd_lower & 0xffff, bytes, sz;
3. struct e1000_context_desc *xp = (struct e1000_context_desc *)dp;
4. if (dtype == E1000_TXD_CMD_DEXT) {
5. tp->tso_frames = 0;
} else {
e1000x_read_tx_ctx_descr(xp, &tp->props);
6. tp->cptse = (txd_lower & E1000_TXD_CMD_TSE) ? 1 : 0;
7. le16_to_cpu(s->mac_reg[VET]));
stw_be_p(tp->vlan_header + 2,
8. goto eop;
9. pci_dma_read(d, addr, tp->data + tp->size, bytes);
10. tp->size += split_size;","4
9-10
13
17
21-23
32
43-44
54
60
78","CWE-129,CWE-787,CWE-399"
ReadIPLImage,"
#define ExceptionInfo
#define ImageInfo

static Image *ReadIPLImage(const ImageInfo *image_info,ExceptionInfo *exception)
{

  
  Image *image;

  MagickBooleanType status;
  register PixelPacket *q;
  unsigned char magick[12], *pixels;
  ssize_t count;
  ssize_t y;
  size_t t_count=0;
  size_t length;
  IPLInfo
    ipl_info;
  QuantumFormatType
    quantum_format;
  QuantumInfo
    *quantum_info;
  QuantumType
    quantum_type;

  

  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  if ( image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent, GetMagickModule(), ""%s"",
                image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickSignature);
  image=AcquireImage(image_info);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
  {
    image=DestroyImageList(image);
    return((Image *) NULL);
  }

  

  
  count=ReadBlob(image,4,magick);
  (void) count;
  if((LocaleNCompare((char *) magick,""iiii"",4) == 0))
    image->endian=LSBEndian;
  else{
    if((LocaleNCompare((char *) magick,""mmmm"",4) == 0))
      image->endian=MSBEndian;
    else{
      ThrowReaderException(CorruptImageError, ""ImproperImageHeader"");
    }
  }
  
  count=ReadBlob(image, 8, magick);
  
  count=ReadBlob(image,4,magick);
  if((LocaleNCompare((char *) magick,""data"",4) != 0))
    ThrowReaderException(CorruptImageError, ""ImproperImageHeader"");
  ipl_info.size=ReadBlobLong(image);
  ipl_info.width=ReadBlobLong(image);
  ipl_info.height=ReadBlobLong(image);
  if((ipl_info.width == 0UL) || (ipl_info.height == 0UL))
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  ipl_info.colors=ReadBlobLong(image);
  if(ipl_info.colors == 3){ SetImageColorspace(image,sRGBColorspace);}
  else { image->colorspace = GRAYColorspace; }
  ipl_info.z=ReadBlobLong(image);
  ipl_info.time=ReadBlobLong(image);

  ipl_info.byteType=ReadBlobLong(image);


  

  switch (ipl_info.byteType) {
    case 0:
      ipl_info.depth=8;
      quantum_format = UnsignedQuantumFormat;
      break;
    case 1:
      ipl_info.depth=16;
      quantum_format = SignedQuantumFormat;
      break;
    case 2:
      ipl_info.depth=16;
      quantum_format = UnsignedQuantumFormat;
      break;
    case 3:
      ipl_info.depth=32;
      quantum_format = SignedQuantumFormat;
      break;
    case 4: ipl_info.depth=32;
      quantum_format = FloatingPointQuantumFormat;
      break;
    case 5:
      ipl_info.depth=8;
      quantum_format = UnsignedQuantumFormat;
      break;
    case 6:
      ipl_info.depth=16;
      quantum_format = UnsignedQuantumFormat;
      break;
    case 10:
      ipl_info.depth=64;
      quantum_format = FloatingPointQuantumFormat;
      break;
    default:
      ipl_info.depth=16;
      quantum_format = UnsignedQuantumFormat;
      break;
  }

  

  SetHeaderFromIPL(image, &ipl_info);

  
  if (image_info->ping != MagickFalse)
  {
    (void) CloseBlob(image);
    return(GetFirstImageInList(image));
  }
  length=image->columns;
  quantum_type=GetQuantumType(image,exception);
 do
   {
     SetHeaderFromIPL(image, &ipl_info);
 
    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))
       if (image->scene >= (image_info->scene+image_info->number_scenes-1))
         break;
    status=SetImageExtent(image,image->columns,image->rows);
    if (status == MagickFalse)
      {
        InheritException(exception,&image->exception);
        return(DestroyImageList(image));
      }
 
     quantum_info=AcquireQuantumInfo(image_info,image);
     if (quantum_info == (QuantumInfo *) NULL)
       ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
     status=SetQuantumFormat(image,quantum_info,quantum_format);
     if (status == MagickFalse)
       ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
     pixels=GetQuantumPixels(quantum_info);
     if(image->columns != ipl_info.width){

     }

    

  if(ipl_info.colors == 1){
      for(y = 0; y < (ssize_t) image->rows; y++){
        (void) ReadBlob(image, length*image->depth/8, pixels);
        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
        if (q == (PixelPacket *) NULL)
                break;
        (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
          GrayQuantum,pixels,exception);
        if (SyncAuthenticPixels(image,exception) == MagickFalse)
          break;
    }
  }
  else{
      for(y = 0; y < (ssize_t) image->rows; y++){
        (void) ReadBlob(image, length*image->depth/8, pixels);
        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
        if (q == (PixelPacket *) NULL)
                break;
        (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
          RedQuantum,pixels,exception);
        if (SyncAuthenticPixels(image,exception) == MagickFalse)
          break;
      }
      for(y = 0; y < (ssize_t) image->rows; y++){
        (void) ReadBlob(image, length*image->depth/8, pixels);
        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
        if (q == (PixelPacket *) NULL)
          break;
        (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
          GreenQuantum,pixels,exception);
        if (SyncAuthenticPixels(image,exception) == MagickFalse)
          break;
      }
      for(y = 0; y < (ssize_t) image->rows; y++){
        (void) ReadBlob(image, length*image->depth/8, pixels);
        q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
        if (q == (PixelPacket *) NULL)
          break;
        (void) ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,
          BlueQuantum,pixels,exception);
        if (SyncAuthenticPixels(image,exception) == MagickFalse)
          break;
      }
   }
   SetQuantumImageType(image,quantum_type);

    t_count++;
  quantum_info = DestroyQuantumInfo(quantum_info);

    if (EOFBlob(image) != MagickFalse)
    {
      ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
                 image->filename);
      break;
    }
   if(t_count < ipl_info.z * ipl_info.time){
      
      AcquireNextImage(image_info, image);
      if (GetNextImageInList(image) == (Image *) NULL)
      {
        image=DestroyImageList(image);
        return((Image *) NULL);
      }
      image=SyncNextImageInList(image);
      status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
        GetBlobSize(image));
      if (status == MagickFalse)
        break;
    }
  } while (t_count < ipl_info.z*ipl_info.time);
  CloseBlob(image);
  return(GetFirstImageInList(image));
}
","1. static Image *ReadIPLImage(const ImageInfo *image_info,ExceptionInfo *exception)
2. ssize_t count;
3. *quantum_info;
4. return((Image *) NULL);
5. if((LocaleNCompare((char *) magick,""iiii"",4) == 0))
6. ThrowReaderException(CorruptImageError, ""ImproperImageHeader"");
7. ipl_info.width=ReadBlobLong(image);
8. case 0:
9. break;
10. ipl_info.depth=8;
11. ipl_info.depth=16;
12. if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))
13. break;
status=SetImageExtent(image,image->columns,image->rows);
if (status == MagickFalse)
14. if (quantum_info == (QuantumInfo *) NULL)
15. GrayQuantum,pixels,exception);
16. break;
17. if (SyncAuthenticPixels(image,exception) == MagickFalse)
18. quantum_info = DestroyQuantumInfo(quantum_info);
19. image->filename);
20. status=SetImageProgress(image,LoadImagesTag,TellBlob(image),","5
16
25
45
58
64
76
92
99
112
116
147
149-151
161
185
199
208
225
230
244",CWE-119
tls1_mac,"
#define SSL
#define SSL3_RECORD

int tls1_mac(SSL *ssl, SSL3_RECORD *rec, unsigned char *md, int send)
{
    unsigned char *seq;
    EVP_MD_CTX *hash;
    size_t md_size;
    int i;
    EVP_MD_CTX *hmac = NULL, *mac_ctx;
    unsigned char header[13];
    int stream_mac = (send ? (ssl->mac_flags & SSL_MAC_FLAG_WRITE_MAC_STREAM)
                      : (ssl->mac_flags & SSL_MAC_FLAG_READ_MAC_STREAM));
    int t;

    if (send) {
        seq = RECORD_LAYER_get_write_sequence(&ssl->rlayer);
        hash = ssl->write_hash;
    } else {
        seq = RECORD_LAYER_get_read_sequence(&ssl->rlayer);
        hash = ssl->read_hash;
    }

    t = EVP_MD_CTX_size(hash);
    OPENSSL_assert(t >= 0);
    md_size = t;

    
    if (stream_mac) {
        mac_ctx = hash;
    } else {
        hmac = EVP_MD_CTX_new();
        if (hmac == NULL || !EVP_MD_CTX_copy(hmac, hash))
            return -1;
        mac_ctx = hmac;
    }

    if (SSL_IS_DTLS(ssl)) {
        unsigned char dtlsseq[8], *p = dtlsseq;

        s2n(send ? DTLS_RECORD_LAYER_get_w_epoch(&ssl->rlayer) :
            DTLS_RECORD_LAYER_get_r_epoch(&ssl->rlayer), p);
        memcpy(p, &seq[2], 6);

        memcpy(header, dtlsseq, 8);
    } else
        memcpy(header, seq, 8);

    header[8] = rec->type;
    header[9] = (unsigned char)(ssl->version >> 8);
    header[10] = (unsigned char)(ssl->version);
     header[11] = (rec->length) >> 8;
     header[12] = (rec->length) & 0xff;
 
    if (!send && !SSL_READ_ETM(ssl) &&
         EVP_CIPHER_CTX_mode(ssl->enc_read_ctx) == EVP_CIPH_CBC_MODE &&
         ssl3_cbc_record_digest_supported(mac_ctx)) {
         
        
        if (ssl3_cbc_digest_record(mac_ctx,
                                   md, &md_size,
                                   header, rec->input,
                                   rec->length + md_size, rec->orig_len,
                                   ssl->s3->read_mac_secret,
                                   ssl->s3->read_mac_secret_size, 0) <= 0) {
            EVP_MD_CTX_free(hmac);
            return -1;
        }
    } else {
        if (EVP_DigestSignUpdate(mac_ctx, header, sizeof(header)) <= 0
            || EVP_DigestSignUpdate(mac_ctx, rec->input, rec->length) <= 0
            || EVP_DigestSignFinal(mac_ctx, md, &md_size) <= 0) {
             EVP_MD_CTX_free(hmac);
             return -1;
         }
        if (!send && !SSL_READ_ETM(ssl) && FIPS_mode())
             if (!tls_fips_digest_extra(ssl->enc_read_ctx,
                                        mac_ctx, rec->input,
                                        rec->length, rec->orig_len)) {
                EVP_MD_CTX_free(hmac);
                return -1;
            }
    }

    EVP_MD_CTX_free(hmac);

#ifdef SSL_DEBUG
    fprintf(stderr, ""seq="");
    {
        int z;
        for (z = 0; z < 8; z++)
            fprintf(stderr, ""%02X "", seq[z]);
        fprintf(stderr, ""\n"");
    }
    fprintf(stderr, ""rec="");
    {
        unsigned int z;
        for (z = 0; z < rec->length; z++)
            fprintf(stderr, ""%02X "", rec->data[z]);
        fprintf(stderr, ""\n"");
    }
#endif

    if (!SSL_IS_DTLS(ssl)) {
        for (i = 7; i >= 0; i--) {
            ++seq[i];
            if (seq[i] != 0)
                break;
        }
    }
#ifdef SSL_DEBUG
    {
        unsigned int z;
        for (z = 0; z < md_size; z++)
            fprintf(stderr, ""%02X "", md[z]);
        fprintf(stderr, ""\n"");
    }
#endif
    return (md_size);
}
","1. unsigned char *seq;
2. size_t md_size;
3. int stream_mac = (send ? (ssl->mac_flags & SSL_MAC_FLAG_WRITE_MAC_STREAM)
4. if (stream_mac) {
mac_ctx = hash;
5. hmac = EVP_MD_CTX_new();
6. return -1;
7. s2n(send ? DTLS_RECORD_LAYER_get_w_epoch(&ssl->rlayer) :
8. header[9] = (unsigned char)(ssl->version >> 8);
9. header[11] = (rec->length) >> 8;
10. if (!send && !SSL_READ_ETM(ssl) &&
11. EVP_MD_CTX_free(hmac);
return -1;
12. if (!SSL_IS_DTLS(ssl)) {","7
9
13
30-31
33
35
42
51
53
56
78-79
109","CWE-362,CWE-20,CWE-399,CWE-287"
aio_read_events_ring-244509003137441,"
#define __user

static long aio_read_events_ring(struct kioctx *ctx,
				 struct io_event __user *event, long nr)
{
	struct aio_ring *ring;
	unsigned head, tail, pos;
	long ret = 0;
	int copy_ret;

	mutex_lock(&ctx->ring_lock);

	
	ring = kmap_atomic(ctx->ring_pages[0]);
	head = ring->head;
	tail = ring->tail;
	kunmap_atomic(ring);

	pr_debug(""h%u t%u m%u\n"", head, tail, ctx->nr_events);

	if (head == tail)
		goto out;

	head %= ctx->nr_events;
	tail %= ctx->nr_events;

	while (ret < nr) {
		long avail;
		struct io_event *ev;
		struct page *page;

		avail = (head <= tail ?  tail : ctx->nr_events) - head;
		if (head == tail)
			break;

		avail = min(avail, nr - ret);
		avail = min_t(long, avail, AIO_EVENTS_PER_PAGE -
			    ((head + AIO_EVENTS_OFFSET) % AIO_EVENTS_PER_PAGE));

		pos = head + AIO_EVENTS_OFFSET;
		page = ctx->ring_pages[pos / AIO_EVENTS_PER_PAGE];
		pos %= AIO_EVENTS_PER_PAGE;

		ev = kmap(page);
		copy_ret = copy_to_user(event + ret, ev + pos,
					sizeof(*ev) * avail);
		kunmap(page);

		if (unlikely(copy_ret)) {
			ret = -EFAULT;
			goto out;
		}

		ret += avail;
		head += avail;
		head %= ctx->nr_events;
	}

	ring = kmap_atomic(ctx->ring_pages[0]);
	ring->head = head;
	kunmap_atomic(ring);
	flush_dcache_page(ctx->ring_pages[0]);

	pr_debug(""%li  h%u t%u\n"", ret, head, tail);
out:
	mutex_unlock(&ctx->ring_lock);

	return ret;
}
","1. struct aio_ring *ring;
2. tail = ring->tail;
3. long avail;
struct io_event *ev;
4. if (head == tail)
break;
5. pos %= AIO_EVENTS_PER_PAGE;
6. sizeof(*ev) * avail);
7. if (unlikely(copy_ret)) {
8. ret += avail;
head += avail;
9. ring->head = head;
10. flush_dcache_page(ctx->ring_pages[0]);","7
17
29-30
34-35
43
47
50
55-56
61
63","CWE-362,CWE-17,CWE-125,CWE-189"
stellaris_enet_init-246888453285835,"
#define SysBusDevice

static int stellaris_enet_init(SysBusDevice *sbd)
{
    DeviceState *dev = DEVICE(sbd);
    stellaris_enet_state *s = STELLARIS_ENET(dev);

    memory_region_init_io(&s->mmio, OBJECT(s), &stellaris_enet_ops, s,
                          ""stellaris_enet"", 0x1000);
    sysbus_init_mmio(sbd, &s->mmio);
    sysbus_init_irq(sbd, &s->irq);
    qemu_macaddr_default_if_unset(&s->conf.macaddr);

    s->nic = qemu_new_nic(&net_stellaris_enet_info, &s->conf,
                          object_get_typename(OBJECT(dev)), dev->id, s);
    qemu_format_nic_info_str(qemu_get_queue(s->nic), s->conf.macaddr.a);

    stellaris_enet_reset(s);
    return 0;
}
","1. static int stellaris_enet_init(SysBusDevice *sbd)
2. ""stellaris_enet"", 0x1000);
3. s->nic = qemu_new_nic(&net_stellaris_enet_info, &s->conf,
4. qemu_format_nic_info_str(qemu_get_queue(s->nic), s->conf.macaddr.a);
5. stellaris_enet_reset(s);","4
10
15
17
19","CWE-667,CWE-20,CWE-399,CWE-119"
nfs4_open_confirm_release-96093297386335,"static void nfs4_open_confirm_release(void *calldata)
{
	struct nfs4_opendata *data = calldata;
	struct nfs4_state *state = NULL;

	
	if (data->cancelled == 0)
		goto out_free;
	
	if (!data->rpc_done)
		goto out_free;
	state = nfs4_opendata_to_nfs4_state(data);
	if (!IS_ERR(state))
		nfs4_close_state(&data->path, state, data->o_arg.fmode);
out_free:
	nfs4_opendata_put(data);
}
","1. struct nfs4_opendata *data = calldata;
2. if (data->cancelled == 0)
3. if (!data->rpc_done)
4. if (!IS_ERR(state))
5. out_free:","3
7
10
13
15","CWE-476,CWE-79,CWE-284,CWE-399"
control_work_handler-204087053107687,"static void control_work_handler(struct work_struct *work)
{
	struct ports_device *portdev;
	struct virtqueue *vq;
	struct port_buffer *buf;
	unsigned int len;

	portdev = container_of(work, struct ports_device, control_work);
	vq = portdev->c_ivq;

	spin_lock(&portdev->c_ivq_lock);
	while ((buf = virtqueue_get_buf(vq, &len))) {
		spin_unlock(&portdev->c_ivq_lock);

		buf->len = min_t(size_t, len, buf->size);
		buf->offset = 0;

		handle_control_message(vq->vdev, portdev, buf);

		spin_lock(&portdev->c_ivq_lock);
		if (add_inbuf(portdev->c_ivq, buf) < 0) {
			dev_warn(&portdev->vdev->dev,
				 ""Error adding buffer to queue\n"");
			free_buf(buf, false);
		}
	}
	spin_unlock(&portdev->c_ivq_lock);
}
","1. struct virtqueue *vq;
2. vq = portdev->c_ivq;
3. spin_lock(&portdev->c_ivq_lock);
4. if (add_inbuf(portdev->c_ivq, buf) < 0) {
5. ""Error adding buffer to queue\n"");","4
9
11
21
23","CWE-125,CWE-59,CWE-119"
find_high_bit,"static int find_high_bit(unsigned int x)
 {
 	int i;
 	for(i=31;i>=0;i--) {
		if(x&(1U<<(unsigned int)i)) return i;
 	}
 	return 0;
 }
","1. static int find_high_bit(unsigned int x)
2. int i;
3. if(x&(1U<<(unsigned int)i)) return i;","1
3
5","CWE-476,CWE-190,CWE-682"
ihevcd_decode_1,"WORD32 ihevcd_decode_1(iv_obj_t *ps_codec_obj, void *pv_api_ip, void *pv_api_op)
{
    WORD32 ret = IV_SUCCESS;
 codec_t *ps_codec = (codec_t *)(ps_codec_obj->pv_codec_handle);
 ivd_video_decode_ip_t *ps_dec_ip;
 ivd_video_decode_op_t *ps_dec_op;

    WORD32 proc_idx = 0;
    WORD32 prev_proc_idx = 0;

 
    ps_codec->i4_error_code = 0;

    ps_dec_ip = (ivd_video_decode_ip_t *)pv_api_ip;
    ps_dec_op = (ivd_video_decode_op_t *)pv_api_op;

 {
        UWORD32 u4_size = ps_dec_op->u4_size;
        memset(ps_dec_op, 0, sizeof(ivd_video_decode_op_t));
        ps_dec_op->u4_size = u4_size; 
 }
 if(ps_codec->i4_init_done != 1)
 {
        ps_dec_op->u4_error_code |= 1 << IVD_FATALERROR;
        ps_dec_op->u4_error_code |= IHEVCD_INIT_NOT_DONE;
 return IV_FAIL;
 }

 if(ps_codec->u4_pic_cnt >= NUM_FRAMES_LIMIT)
 {
        ps_dec_op->u4_error_code |= 1 << IVD_FATALERROR;
        ps_dec_op->u4_error_code |= IHEVCD_NUM_FRAMES_LIMIT_REACHED;
 return IV_FAIL;
 }

 
 if(ps_codec->i4_reset_flag)
 {
        ps_codec->i4_flush_mode = 1;
 }

 
 
 if(0 == ps_codec->i4_flush_mode)
 {
 if(ps_dec_ip->pv_stream_buffer == NULL)
 {
            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
            ps_dec_op->u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL;
 return IV_FAIL;
 }
 if(ps_dec_ip->u4_num_Bytes <= MIN_START_CODE_LEN)
 {
 if((WORD32)ps_dec_ip->u4_num_Bytes > 0)
                ps_dec_op->u4_num_bytes_consumed = ps_dec_ip->u4_num_Bytes;
 else
                ps_dec_op->u4_num_bytes_consumed = 0;

            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
            ps_dec_op->u4_error_code |= IVD_DEC_NUMBYTES_INV;
 return IV_FAIL;

 }
 }

#ifdef APPLY_CONCEALMENT
 {
        WORD32 num_mbs;

        num_mbs = (ps_codec->i4_wd * ps_codec->i4_ht + 255) >> 8;
 
        ps_codec->mb_count = 0;
        memset(ps_codec->mb_map, 0, ((num_mbs + 7) >> 3));
 }
#endif

 if(0 == ps_codec->i4_share_disp_buf && ps_codec->i4_header_mode == 0)
 {
        UWORD32 i;
 if(ps_dec_ip->s_out_buffer.u4_num_bufs == 0)
 {
            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
            ps_dec_op->u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS;
 return IV_FAIL;
 }

 for(i = 0; i < ps_dec_ip->s_out_buffer.u4_num_bufs; i++)
 {
 if(ps_dec_ip->s_out_buffer.pu1_bufs[i] == NULL)
 {
                ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                ps_dec_op->u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL;
 return IV_FAIL;
 }

 if(ps_dec_ip->s_out_buffer.u4_min_out_buf_size[i] == 0)
 {
                ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;
                ps_dec_op->u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUF_SIZE;
 return IV_FAIL;
 }
 }
 }

    ps_codec->ps_out_buffer = &ps_dec_ip->s_out_buffer;
    ps_codec->u4_ts = ps_dec_ip->u4_ts;
 if(ps_codec->i4_flush_mode)
 {

        ps_dec_op->u4_pic_wd = ps_codec->i4_disp_wd;
        ps_dec_op->u4_pic_ht = ps_codec->i4_disp_ht;

        ps_dec_op->u4_new_seq = 0;

        ps_codec->ps_disp_buf = (pic_buf_t *)ihevc_disp_mgr_get(
 (disp_mgr_t *)ps_codec->pv_disp_buf_mgr, &ps_codec->i4_disp_buf_id);
 
 
 if((ps_codec->ps_disp_buf)
 && ((0 == ps_codec->i4_share_disp_buf)
 || (IV_YUV_420P
 == ps_codec->e_chroma_fmt)))
 {

 process_ctxt_t *ps_proc = &ps_codec->as_process[prev_proc_idx];
 if(0 == ps_proc->i4_init_done)
 {
                ihevcd_init_proc_ctxt(ps_proc, 0);
 }

 
            ret = ihevcd_check_out_buf_size(ps_codec);
            RETURN_IF((ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS), ret);

 
            ret = ihevcd_fmt_conv(ps_codec, &ps_codec->as_process[prev_proc_idx],
                                  ps_dec_ip->s_out_buffer.pu1_bufs[0],
                                  ps_dec_ip->s_out_buffer.pu1_bufs[1],
                                  ps_dec_ip->s_out_buffer.pu1_bufs[2], 0,
                                  ps_codec->i4_disp_ht);

            ihevc_buf_mgr_release((buf_mgr_t *)ps_codec->pv_pic_buf_mgr,
                                  ps_codec->i4_disp_buf_id, BUF_MGR_DISP);
 }

        ihevcd_fill_outargs(ps_codec, ps_dec_ip, ps_dec_op);

 if(1 == ps_dec_op->u4_output_present)
 {
            WORD32 xpos = ps_codec->i4_disp_wd - 32 - LOGO_WD;
            WORD32 ypos = ps_codec->i4_disp_ht - 32 - LOGO_HT;

 if(ypos < 0)
                ypos = 0;

 if(xpos < 0)
                xpos = 0;

            INSERT_LOGO(ps_dec_ip->s_out_buffer.pu1_bufs[0],
                        ps_dec_ip->s_out_buffer.pu1_bufs[1],
                        ps_dec_ip->s_out_buffer.pu1_bufs[2], ps_codec->i4_disp_strd,
                        xpos,
                        ypos,
                        ps_codec->e_chroma_fmt,
                        ps_codec->i4_disp_wd,
                        ps_codec->i4_disp_ht);
 }


 if(NULL == ps_codec->ps_disp_buf)
 {
 
 if(ps_codec->i4_reset_flag)
 {
                ihevcd_init(ps_codec);
 }
 return (IV_FAIL);
 }

 return (IV_SUCCESS);

 }
 
 if((0 == ps_codec->i4_header_mode) && (1 == ps_codec->i4_share_disp_buf))
 {
        WORD32 buf_status;
        buf_status = 1;
 if(ps_codec->pv_pic_buf_mgr)
            buf_status = ihevc_buf_mgr_check_free((buf_mgr_t *)ps_codec->pv_pic_buf_mgr);

 
 if(0 == buf_status)
 {
            ps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;
            ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);
 return IV_FAIL;
 }
 }
    ps_codec->i4_bytes_remaining = ps_dec_ip->u4_num_Bytes;
    ps_codec->pu1_inp_bitsbuf = (UWORD8 *)ps_dec_ip->pv_stream_buffer;
    ps_codec->s_parse.i4_end_of_frame = 0;

    ps_codec->i4_pic_present = 0;
    ps_codec->i4_slice_error = 0;
    ps_codec->ps_disp_buf = NULL;

 if(ps_codec->i4_num_cores > 1)
 {
        ithread_set_affinity(0);
 }
 while(MIN_START_CODE_LEN < ps_codec->i4_bytes_remaining)
 {
        WORD32 nal_len;
        WORD32 nal_ofst;
        WORD32 bits_len;

 if(ps_codec->i4_slice_error)
 {
 slice_header_t *ps_slice_hdr_next = ps_codec->s_parse.ps_slice_hdr_base + (ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1));
            WORD32 next_slice_addr = ps_slice_hdr_next->i2_ctb_x +
                            ps_slice_hdr_next->i2_ctb_y * ps_codec->s_parse.ps_sps->i2_pic_wd_in_ctb;
 if(ps_codec->s_parse.i4_next_ctb_indx == next_slice_addr)
                ps_codec->i4_slice_error = 0;
 }

 if(ps_codec->pu1_bitsbuf_dynamic)
 {
            ps_codec->pu1_bitsbuf = ps_codec->pu1_bitsbuf_dynamic;
            ps_codec->u4_bitsbuf_size = ps_codec->u4_bitsbuf_size_dynamic;
 }
 else
 {
            ps_codec->pu1_bitsbuf = ps_codec->pu1_bitsbuf_static;
            ps_codec->u4_bitsbuf_size = ps_codec->u4_bitsbuf_size_static;
 }

        nal_ofst = ihevcd_nal_search_start_code(ps_codec->pu1_inp_bitsbuf,
                                                ps_codec->i4_bytes_remaining);

        ps_codec->i4_nal_ofst = nal_ofst;
 {
            WORD32 bytes_remaining = ps_codec->i4_bytes_remaining - nal_ofst;

            bytes_remaining = MIN((UWORD32)bytes_remaining, ps_codec->u4_bitsbuf_size);
            ihevcd_nal_remv_emuln_bytes(ps_codec->pu1_inp_bitsbuf + nal_ofst,
                                        ps_codec->pu1_bitsbuf,
                                        bytes_remaining,
 &nal_len, &bits_len);

 
 
 if(bits_len < (WORD32)(ps_codec->u4_bitsbuf_size - 8))
 {
                memset(ps_codec->pu1_bitsbuf + bits_len, 0, 2 * sizeof(UWORD32));
 }
 }
 
        ps_codec->i4_num_emln_bytes = nal_len - bits_len;
        ps_codec->i4_nal_len = nal_len;

        ihevcd_bits_init(&ps_codec->s_parse.s_bitstrm, ps_codec->pu1_bitsbuf,
                         bits_len);

        ret = ihevcd_nal_unit(ps_codec);

 
 if(ps_codec->i4_pic_present &&
 (ps_codec->s_parse.i4_next_ctb_indx != ps_codec->s_parse.ps_sps->i4_pic_size_in_ctb))
 {
 if((ps_codec->i4_bytes_remaining - (nal_len + nal_ofst) <= MIN_START_CODE_LEN) ||
 (ps_codec->i4_header_in_slice_mode))
 {
 slice_header_t *ps_slice_hdr_next;

                ps_codec->s_parse.i4_cur_slice_idx--;
 if(ps_codec->s_parse.i4_cur_slice_idx < 0)
                    ps_codec->s_parse.i4_cur_slice_idx = 0;

                ps_slice_hdr_next = ps_codec->s_parse.ps_slice_hdr_base + ((ps_codec->s_parse.i4_cur_slice_idx + 1) & (MAX_SLICE_HDR_CNT - 1));
                ps_slice_hdr_next->i2_ctb_x = 0;
                ps_slice_hdr_next->i2_ctb_y = ps_codec->s_parse.ps_sps->i2_pic_ht_in_ctb;
                ps_codec->i4_slice_error = 1;
 continue;
 }
 }

 
         if(IHEVCD_IGNORE_SLICE == ret)
         {
             ps_codec->pu1_inp_bitsbuf += (nal_ofst + nal_len);
             ps_codec->i4_bytes_remaining -= (nal_ofst + nal_len);
 
 continue;
 }

 if((IVD_RES_CHANGED == ret) ||
 (IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED == ret))
 {
 break;
 }

 
 
 
 
 if(ret != IHEVCD_SLICE_IN_HEADER_MODE)
 {
 if((0 == ps_codec->i4_slice_error) ||
 (ps_codec->i4_bytes_remaining - (nal_len + nal_ofst) <= MIN_START_CODE_LEN))
 {
                ps_codec->pu1_inp_bitsbuf += (nal_ofst + nal_len);
                ps_codec->i4_bytes_remaining -= (nal_ofst + nal_len);
 }
 if(ret != IHEVCD_SUCCESS)
 break;

 if(ps_codec->s_parse.i4_end_of_frame)
 break;
 }
 else
 {
            ret = IHEVCD_SUCCESS;
 break;
 }

 
 if((ps_codec->u4_allocate_dynamic_done == 0) && ps_codec->i4_sps_done)
 {
            WORD32 ret;
            ret = ihevcd_allocate_dynamic_bufs(ps_codec);
 if(ret != IV_SUCCESS)
 {
 
                ihevcd_free_dynamic_bufs(ps_codec);
                ps_codec->i4_error_code = IVD_MEM_ALLOC_FAILED;
                ps_dec_op->u4_error_code |= 1 << IVD_FATALERROR;
                ps_dec_op->u4_error_code |= IVD_MEM_ALLOC_FAILED;

 return IV_FAIL;
 }
 }

        BREAK_AFTER_SLICE_NAL();
 }

 if((ps_codec->u4_pic_cnt == 0) && (ret != IHEVCD_SUCCESS))
 {
        ps_codec->i4_error_code = ret;

        ihevcd_fill_outargs(ps_codec, ps_dec_ip, ps_dec_op);
 return IV_FAIL;
 }

 if(1 == ps_codec->i4_pic_present)
 {
        WORD32 i;
 sps_t *ps_sps = ps_codec->s_parse.ps_sps;
        ps_codec->i4_first_pic_done = 1;

 
 if(ps_codec->i4_num_cores > 1 && ps_codec->s_parse.i4_end_of_frame)
 {

 
 
 process_ctxt_t *ps_proc;

 
            ps_proc = &ps_codec->as_process[ps_codec->i4_num_cores - 1];

 if((ps_codec->ps_disp_buf) &&
 ((0 == ps_codec->i4_share_disp_buf) || (IV_YUV_420P == ps_codec->e_chroma_fmt)))
 {
 
 if((0 == ps_codec->u4_enable_fmt_conv_ahead) ||
 (ps_codec->i4_disp_buf_id == ps_proc->i4_cur_pic_buf_id))
 for(i = 0; i < ps_sps->i2_pic_ht_in_ctb; i++)
 {
 proc_job_t s_job;
                        IHEVCD_ERROR_T ret;
                        s_job.i4_cmd = CMD_FMTCONV;
                        s_job.i2_ctb_cnt = 0;
                        s_job.i2_ctb_x = 0;
                        s_job.i2_ctb_y = i;
                        s_job.i2_slice_idx = 0;
                        s_job.i4_tu_coeff_data_ofst = 0;
                        ret = ihevcd_jobq_queue((jobq_t *)ps_codec->s_parse.pv_proc_jobq,
 &s_job, sizeof(proc_job_t), 1);
 if(ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS)
 return (WORD32)ret;
 }
 }
 
 
            ret = ihevcd_jobq_terminate((jobq_t *)ps_codec->s_parse.pv_proc_jobq);

 while(1)
 {
                IHEVCD_ERROR_T ret;
 proc_job_t s_job;
 process_ctxt_t *ps_proc;

 
                ps_proc = &ps_codec->as_process[ps_codec->i4_num_cores - 1];

                ret = ihevcd_jobq_dequeue((jobq_t *)ps_proc->pv_proc_jobq, &s_job,
 sizeof(proc_job_t), 1);
 if((IHEVCD_ERROR_T)IHEVCD_SUCCESS != ret)
 break;

                ps_proc->i4_ctb_cnt = s_job.i2_ctb_cnt;
                ps_proc->i4_ctb_x = s_job.i2_ctb_x;
                ps_proc->i4_ctb_y = s_job.i2_ctb_y;
                ps_proc->i4_cur_slice_idx = s_job.i2_slice_idx;

 if(CMD_PROCESS == s_job.i4_cmd)
 {
                    ihevcd_init_proc_ctxt(ps_proc, s_job.i4_tu_coeff_data_ofst);

                    ihevcd_process(ps_proc);
 }
 else if(CMD_FMTCONV == s_job.i4_cmd)
 {
 sps_t *ps_sps = ps_codec->s_parse.ps_sps;
                    WORD32 num_rows = 1 << ps_sps->i1_log2_ctb_size;
 if(0 == ps_proc->i4_init_done)
 {
                        ihevcd_init_proc_ctxt(ps_proc, 0);
 }

                    num_rows = MIN(num_rows, (ps_codec->i4_disp_ht - (s_job.i2_ctb_y << ps_sps->i1_log2_ctb_size)));
 if(num_rows < 0)
                        num_rows = 0;

                    ihevcd_fmt_conv(ps_codec, ps_proc,
                                    ps_dec_ip->s_out_buffer.pu1_bufs[0],
                                    ps_dec_ip->s_out_buffer.pu1_bufs[1],
                                    ps_dec_ip->s_out_buffer.pu1_bufs[2],
                                    s_job.i2_ctb_y << ps_sps->i1_log2_ctb_size,
                                    num_rows);
 }
 }
 }
 
 
 else if((ps_codec->ps_disp_buf) && ((0 == ps_codec->i4_share_disp_buf) ||
 (IV_YUV_420P == ps_codec->e_chroma_fmt)) &&
 (ps_codec->s_parse.i4_end_of_frame))
 {
 process_ctxt_t *ps_proc = &ps_codec->as_process[proc_idx];
 
            ps_codec->s_fmt_conv.i4_num_rows = ps_codec->i4_disp_ht
 - ps_codec->s_fmt_conv.i4_cur_row;
 if(0 == ps_proc->i4_init_done)
 {
                ihevcd_init_proc_ctxt(ps_proc, 0);
 }

 if(ps_codec->s_fmt_conv.i4_num_rows < 0)
                ps_codec->s_fmt_conv.i4_num_rows = 0;

            ret = ihevcd_fmt_conv(ps_codec, ps_proc,
                                  ps_dec_ip->s_out_buffer.pu1_bufs[0],
                                  ps_dec_ip->s_out_buffer.pu1_bufs[1],
                                  ps_dec_ip->s_out_buffer.pu1_bufs[2],
                                  ps_codec->s_fmt_conv.i4_cur_row,
                                  ps_codec->s_fmt_conv.i4_num_rows);
            ps_codec->s_fmt_conv.i4_cur_row += ps_codec->s_fmt_conv.i4_num_rows;

 }


        DEBUG_DUMP_MV_MAP(ps_codec);

 
        ihevc_buf_mgr_set_status((buf_mgr_t *)ps_codec->pv_mv_buf_mgr,
                                 ps_codec->as_process[proc_idx].i4_cur_mv_bank_buf_id,
                                 BUF_MGR_REF);

 
        ihevc_buf_mgr_set_status((buf_mgr_t *)ps_codec->pv_pic_buf_mgr,
                                 ps_codec->as_process[proc_idx].i4_cur_pic_buf_id,
                                 BUF_MGR_REF);

 
        ihevc_buf_mgr_set_status((buf_mgr_t *)ps_codec->pv_pic_buf_mgr,
                                 ps_codec->as_process[proc_idx].i4_cur_pic_buf_id,
                                 BUF_MGR_DISP);

 
        ihevc_dpb_mgr_insert_ref((dpb_mgr_t *)ps_codec->pv_dpb_mgr,
                                 ps_codec->as_process[proc_idx].ps_cur_pic,
                                 ps_codec->as_process[proc_idx].i4_cur_pic_buf_id);

 
 if((0 == ps_codec->i4_share_disp_buf) && (ps_codec->ps_disp_buf))
            ihevc_buf_mgr_release((buf_mgr_t *)ps_codec->pv_pic_buf_mgr,
                                  ps_codec->i4_disp_buf_id, BUF_MGR_DISP);

 
 for(i = 0; i < (ps_codec->i4_num_cores - 1); i++)
 {
 if(ps_codec->ai4_process_thread_created[i])
 {
                ithread_join(ps_codec->apv_process_thread_handle[i], NULL);
                ps_codec->ai4_process_thread_created[i] = 0;
 }
 }

        DEBUG_VALIDATE_PADDED_REGION(&ps_codec->as_process[proc_idx]);
 if(ps_codec->u4_pic_cnt > 0)
 {
            DEBUG_DUMP_PIC_PU(ps_codec);
 }
        DEBUG_DUMP_PIC_BUFFERS(ps_codec);

 
        ps_codec->u4_pic_cnt++;
 }
    ihevcd_fill_outargs(ps_codec, ps_dec_ip, ps_dec_op);

 if(1 == ps_dec_op->u4_output_present)
 {
        WORD32 xpos = ps_codec->i4_disp_wd - 32 - LOGO_WD;
        WORD32 ypos = ps_codec->i4_disp_ht - 32 - LOGO_HT;

 if(ypos < 0)
            ypos = 0;

 if(xpos < 0)
            xpos = 0;

        INSERT_LOGO(ps_dec_ip->s_out_buffer.pu1_bufs[0],
                    ps_dec_ip->s_out_buffer.pu1_bufs[1],
                    ps_dec_ip->s_out_buffer.pu1_bufs[2], ps_codec->i4_disp_strd,
                    xpos,
                    ypos,
                    ps_codec->e_chroma_fmt,
                    ps_codec->i4_disp_wd,
                    ps_codec->i4_disp_ht);
 }


 return ret;
}
","1. ps_dec_op->u4_num_bytes_consumed = 0;
2. if(ret != IHEVCD_SLICE_IN_HEADER_MODE)","57
309","CWE-190,CWE-264,CWE-119"
strupper_talloc_n_handle_1,"
#define TALLOC_CTX

_PUBLIC_ char *strupper_talloc_n_handle_1(struct smb_iconv_handle *iconv_handle,
					TALLOC_CTX *ctx, const char *src, size_t n)
{
	size_t size=0;
	char *dest;

	if (!src) {
		return NULL;
	}

	
	dest = talloc_array(ctx, char, 2*(n+1));
	if (dest == NULL) {
                return NULL;
        }
 
       while (n && *src) {
                size_t c_size;
                codepoint_t c = next_codepoint_handle_ext(iconv_handle, src, n,
                                                          CH_UNIX, &c_size);
                src += c_size;
               n -= c_size;
 
                c = toupper_m(c);
		if (c_size == -1) {
			talloc_free(dest);
			return NULL;
		}
		size += c_size;
	}

	dest[size] = 0;

	
	dest = talloc_realloc(ctx, dest, char, size+1);

	talloc_set_name_const(dest, dest);

	return dest;
}
","1. size_t size=0;
2. src += c_size;
3. dest[size] = 0;","7
25
36","CWE-200,CWE-276,CWE-125,CWE-119"
lldp_private_8023_print,"lldp_private_8023_print(netdissect_options *ndo,
                        const u_char *tptr, u_int tlv_len)
{
    int subtype, hexdump = FALSE;

    if (tlv_len < 4) {
        return hexdump;
    }
    subtype = *(tptr+3);

    ND_PRINT((ndo, ""\n\t  %s Subtype (%u)"",
           tok2str(lldp_8023_subtype_values, ""unknown"", subtype),
           subtype));

    switch (subtype) {
    case LLDP_PRIVATE_8023_SUBTYPE_MACPHY:
        if (tlv_len < 9) {
            return hexdump;
        }
        ND_PRINT((ndo, ""\n\t    autonegotiation [%s] (0x%02x)"",
               bittok2str(lldp_8023_autonegotiation_values, ""none"", *(tptr+4)),
               *(tptr + 4)));
        ND_PRINT((ndo, ""\n\t    PMD autoneg capability [%s] (0x%04x)"",
               bittok2str(lldp_pmd_capability_values,""unknown"", EXTRACT_16BITS(tptr+5)),
               EXTRACT_16BITS(tptr + 5)));
        ND_PRINT((ndo, ""\n\t    MAU type %s (0x%04x)"",
               tok2str(lldp_mau_types_values, ""unknown"", EXTRACT_16BITS(tptr+7)),
               EXTRACT_16BITS(tptr + 7)));
        break;

    case LLDP_PRIVATE_8023_SUBTYPE_MDIPOWER:
        if (tlv_len < 7) {
            return hexdump;
        }
        ND_PRINT((ndo, ""\n\t    MDI power support [%s], power pair %s, power class %s"",
               bittok2str(lldp_mdi_values, ""none"", *(tptr+4)),
               tok2str(lldp_mdi_power_pairs_values, ""unknown"", *(tptr+5)),
               tok2str(lldp_mdi_power_class_values, ""unknown"", *(tptr + 6))));
        break;

    case LLDP_PRIVATE_8023_SUBTYPE_LINKAGGR:
        if (tlv_len < 9) {
            return hexdump;
        }
        ND_PRINT((ndo, ""\n\t    aggregation status [%s], aggregation port ID %u"",
               bittok2str(lldp_aggregation_values, ""none"", *(tptr+4)),
               EXTRACT_32BITS(tptr + 5)));
         break;
 
     case LLDP_PRIVATE_8023_SUBTYPE_MTU:
        if (tlv_len < 6) {
            return hexdump;
        }
         ND_PRINT((ndo, ""\n\t    MTU size %u"", EXTRACT_16BITS(tptr + 4)));
         break;
 
    default:
        hexdump = TRUE;
        break;
    }

    return hexdump;
}
","1. lldp_private_8023_print(netdissect_options *ndo,
2. return hexdump;
3. subtype));
4. EXTRACT_16BITS(tptr + 5)));
5. tok2str(lldp_mau_types_values, ""unknown"", EXTRACT_16BITS(tptr+7)),
6. break;
7. case LLDP_PRIVATE_8023_SUBTYPE_MDIPOWER:
if (tlv_len < 7) {
8. ND_PRINT((ndo, ""\n\t    MDI power support [%s], power pair %s, power class %s"",
9. tok2str(lldp_mdi_power_pairs_values, ""unknown"", *(tptr+5)),
tok2str(lldp_mdi_power_class_values, ""unknown"", *(tptr + 6))));
10. case LLDP_PRIVATE_8023_SUBTYPE_LINKAGGR:
11. bittok2str(lldp_aggregation_values, ""none"", *(tptr+4)),
12. default:
13. return hexdump;","1
7
13
25
27
29
31-32
35
37-38
41
46
57
62","CWE-264,CWE-125,CWE-401"
queue_push,"
#define Queue

void queue_push(register Queue *qp, size_t extra_length, char const *info)
{
    register char *cp;
    size_t memory_length;
    size_t available_length;
    size_t begin_length;
    size_t n_begin;
    size_t q_length;

    if (!extra_length)
        return;

    memory_length    = qp->d_memory_end - qp->d_memory;

    q_length = 
        qp->d_read <= qp->d_write ?
            (size_t)(qp->d_write - qp->d_read)
        :
            memory_length - (qp->d_read - qp->d_write);

    available_length = memory_length - q_length - 1;
                            
                            

    if (message_show(MSG_INFO))
        message(""push_front %u bytes in `%s'"", (unsigned)extra_length, info);
 
     if (extra_length > available_length)
     {
        size_t original_length = memory_length;

                                                    
         memory_length += extra_length - available_length + BLOCK_QUEUE;

         cp = new_memory(memory_length, sizeof(char));
 
         if (message_show(MSG_INFO))
            message(""Reallocating queue at %p to %p"", qp->d_memory, cp);

        if (qp->d_read > qp->d_write)               
        {
            size_t tail_len = qp->d_memory_end - qp->d_read;
            memcpy(cp, qp->d_read, tail_len);       
                                                    
            memcpy(cp + tail_len, qp->d_memory, 
                                    (size_t)(qp->d_write - qp->d_memory));
            qp->d_write = cp + q_length;
            qp->d_read = cp;
         }
         else                                        
         {
            memcpy(cp, qp->d_memory, original_length);
             qp->d_read = cp + (qp->d_read - qp->d_memory);
             qp->d_write = cp + (qp->d_write - qp->d_memory);
         }

        free(qp->d_memory);                         
        qp->d_memory_end = cp + memory_length;      
        qp->d_memory = cp;                          
    }

    

                                                
    begin_length = qp->d_read - qp->d_memory;   

    n_begin = extra_length <= begin_length ?    
                    extra_length                
                :
                    begin_length;

    memcpy                                      
    (                                           
        qp->d_read -= n_begin,
        info + extra_length - n_begin,
        n_begin
    );

    if (extra_length > begin_length)            
    {
        
        

        extra_length -= begin_length;           


        memcpy                                  
        (                                       
            qp->d_read = qp->d_memory_end - extra_length,
            info,
            extra_length
        );
    }
}
","1. size_t available_length;
size_t begin_length;
2. return;
3. (size_t)(qp->d_write - qp->d_read)
4. available_length = memory_length - q_length - 1;
5. message(""push_front %u bytes in `%s'"", (unsigned)extra_length, info);
6. memory_length += extra_length - available_length + BLOCK_QUEUE;
7. qp->d_read = cp;
8. qp->d_write = cp + (qp->d_write - qp->d_memory);
9. qp->d_memory = cp;
10. n_begin = extra_length <= begin_length ?
extra_length
11. begin_length;
12. info + extra_length - n_begin,","8-9
14
20
24
29
36
51
57
62
79-80
82
87","CWE-193,CWE-787,CWE-189,CWE-119"
crypto_report_cipher_1,"static int crypto_report_cipher_1(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_cipher_1 rcipher;
 
	strncpy(rcipher.type, ""cipher"", sizeof(rcipher.type));
 
 	rcipher.blocksize = alg->cra_blocksize;
 	rcipher.min_keysize = alg->cra_cipher.cia_min_keysize;
	rcipher.max_keysize = alg->cra_cipher.cia_max_keysize;

	if (nla_put(skb, CRYPTOCFGA_REPORT_CIPHER,
		    sizeof(struct crypto_report_cipher_1), &rcipher))
		goto nla_put_failure;
	return 0;

nla_put_failure:
	return -EMSGSIZE;
}
","1. strncpy(rcipher.type, ""cipher"", sizeof(rcipher.type));
2. if (nla_put(skb, CRYPTOCFGA_REPORT_CIPHER,
sizeof(struct crypto_report_cipher_1), &rcipher))
3. return -EMSGSIZE;","5
11-12
17","CWE-310,CWE-200"
daemon_AuthUserPwd,"daemon_AuthUserPwd(char *username, char *password, char *errbuf)
{
#ifdef _WIN32
	
	HANDLE Token;
	if (LogonUser(username, ""."", password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &Token) == 0)
	{
		pcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,
		    GetLastError(), ""LogonUser() failed"");
		return -1;
	}

	if (ImpersonateLoggedOnUser(Token) == 0)
	{
		pcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,
		    GetLastError(), ""ImpersonateLoggedOnUser() failed"");
		CloseHandle(Token);
		return -1;
	}

	CloseHandle(Token);
	return 0;

#else
	
	struct passwd *user;
	char *user_password;
 #ifdef HAVE_GETSPNAM
 	struct spwd *usersp;
 #endif
	char *crypt_password;
 
 	if ((user = getpwnam(username)) == NULL)
	{
		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed: user name or password incorrect"");
		return -1;
	}

#ifdef HAVE_GETSPNAM
	if ((usersp = getspnam(username)) == NULL)
	{
		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed: user name or password incorrect"");
		return -1;
	}
	user_password = usersp->sp_pwdp;
#else
	
 	user_password = user->pw_passwd;
 #endif
 
	crypt_password = crypt(password, user_password);
	if (crypt_password == NULL)
	{
		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed"");
		return -1;
	}
	if (strcmp(user_password, crypt_password) != 0)
 	{
 		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed: user name or password incorrect"");
 		return -1;
	}

	if (setuid(user->pw_uid))
	{
		pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
		    errno, ""setuid"");
		return -1;
	}


	return 0;

#endif

}
","1. daemon_AuthUserPwd(char *username, char *password, char *errbuf)
2. if ((user = getpwnam(username)) == NULL)
3. return -1;
4. if (setuid(user->pw_uid))
5. pcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,
6. return -1;","1
68
104
107
109
111","CWE-20,CWE-22,CWE-252,CWE-120,CWE-200"
ParseCaffHeaderConfig_1-59023761861757,"
#define FILE
#define WavpackConfig
#define WavpackContext

int ParseCaffHeaderConfig_1 (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)
{
    uint32_t chan_chunk = 0, desc_chunk = 0, channel_layout = 0, bcount;
    unsigned char *channel_identities = NULL;
    unsigned char *channel_reorder = NULL;
    int64_t total_samples = 0, infilesize;
    CAFFileHeader caf_file_header;
    CAFChunkHeader caf_chunk_header;
    CAFAudioFormat caf_audio_format;
    int i;

    infilesize = DoGetFileSize (infile);
    memcpy (&caf_file_header, fourcc, 4);

    if ((!DoReadFile (infile, ((char *) &caf_file_header) + 4, sizeof (CAFFileHeader) - 4, &bcount) ||
        bcount != sizeof (CAFFileHeader) - 4)) {
            error_line (""%s is not a valid .CAF file!"", infilename);
            return WAVPACK_SOFT_ERROR;
    }
    else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
        !WavpackAddWrapper (wpc, &caf_file_header, sizeof (CAFFileHeader))) {
            error_line (""%s"", WavpackGetErrorMessage (wpc));
            return WAVPACK_SOFT_ERROR;
    }

    WavpackBigEndianToNative (&caf_file_header, CAFFileHeaderFormat);

    if (caf_file_header.mFileVersion != 1) {
        error_line (""%s: can't handle version %d .CAF files!"", infilename, caf_file_header.mFileVersion);
        return WAVPACK_SOFT_ERROR;
    }

    
    

    while (1) {
        if (!DoReadFile (infile, &caf_chunk_header, sizeof (CAFChunkHeader), &bcount) ||
            bcount != sizeof (CAFChunkHeader)) {
                error_line (""%s is not a valid .CAF file!"", infilename);
                return WAVPACK_SOFT_ERROR;
        }
        else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
            !WavpackAddWrapper (wpc, &caf_chunk_header, sizeof (CAFChunkHeader))) {
                error_line (""%s"", WavpackGetErrorMessage (wpc));
                return WAVPACK_SOFT_ERROR;
        }

        WavpackBigEndianToNative (&caf_chunk_header, CAFChunkHeaderFormat);

        
        

        if (!strncmp (caf_chunk_header.mChunkType, ""desc"", 4)) {
            int supported = TRUE;

            if (caf_chunk_header.mChunkSize != sizeof (CAFAudioFormat) ||
                !DoReadFile (infile, &caf_audio_format, (uint32_t) caf_chunk_header.mChunkSize, &bcount) ||
                bcount != caf_chunk_header.mChunkSize) {
                    error_line (""%s is not a valid .CAF file!"", infilename);
                    return WAVPACK_SOFT_ERROR;
            }
            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, &caf_audio_format, (uint32_t) caf_chunk_header.mChunkSize)) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    return WAVPACK_SOFT_ERROR;
            }

            WavpackBigEndianToNative (&caf_audio_format, CAFAudioFormatFormat);
            desc_chunk = 1;

            if (debug_logging_mode) {
                char formatstr [5];

                memcpy (formatstr, caf_audio_format.mFormatID, 4);
                formatstr [4] = 0;
                error_line (""format = %s, flags = %x, sampling rate = %g"",
                    formatstr, caf_audio_format.mFormatFlags, caf_audio_format.mSampleRate);
                error_line (""packet = %d bytes and %d frames"",
                    caf_audio_format.mBytesPerPacket, caf_audio_format.mFramesPerPacket);
                error_line (""channels per frame = %d, bits per channel = %d"",
                    caf_audio_format.mChannelsPerFrame, caf_audio_format.mBitsPerChannel);
            }

            if (strncmp (caf_audio_format.mFormatID, ""lpcm"", 4) || (caf_audio_format.mFormatFlags & ~3))
                supported = FALSE;
            else if (caf_audio_format.mSampleRate < 1.0 || caf_audio_format.mSampleRate > 16777215.0 ||
                caf_audio_format.mSampleRate != floor (caf_audio_format.mSampleRate))
                    supported = FALSE;
            else if (!caf_audio_format.mChannelsPerFrame || caf_audio_format.mChannelsPerFrame > 256)
                supported = FALSE;
            else if (caf_audio_format.mBitsPerChannel < 1 || caf_audio_format.mBitsPerChannel > 32 ||
                ((caf_audio_format.mFormatFlags & CAF_FORMAT_FLOAT) && caf_audio_format.mBitsPerChannel != 32))
                    supported = FALSE;
            else if (caf_audio_format.mFramesPerPacket != 1 ||
                caf_audio_format.mBytesPerPacket / caf_audio_format.mChannelsPerFrame < (caf_audio_format.mBitsPerChannel + 7) / 8 ||
                caf_audio_format.mBytesPerPacket / caf_audio_format.mChannelsPerFrame > 4 ||
                caf_audio_format.mBytesPerPacket % caf_audio_format.mChannelsPerFrame)
                    supported = FALSE;

            if (!supported) {
                error_line (""%s is an unsupported .CAF format!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            config->bytes_per_sample = caf_audio_format.mBytesPerPacket / caf_audio_format.mChannelsPerFrame;
            config->float_norm_exp = (caf_audio_format.mFormatFlags & CAF_FORMAT_FLOAT) ? 127 : 0;
            config->bits_per_sample = caf_audio_format.mBitsPerChannel;
            config->num_channels = caf_audio_format.mChannelsPerFrame;
            config->sample_rate = (int) caf_audio_format.mSampleRate;

            if (!(caf_audio_format.mFormatFlags & CAF_FORMAT_LITTLE_ENDIAN) && config->bytes_per_sample > 1)
                config->qmode |= QMODE_BIG_ENDIAN;

            if (config->bytes_per_sample == 1)
                config->qmode |= QMODE_SIGNED_BYTES;

            if (debug_logging_mode) {
                if (config->float_norm_exp == 127)
                    error_line (""data format: 32-bit %s-endian floating point"", (config->qmode & QMODE_BIG_ENDIAN) ? ""big"" : ""little"");
                else
                    error_line (""data format: %d-bit %s-endian integers stored in %d byte(s)"",
                        config->bits_per_sample, (config->qmode & QMODE_BIG_ENDIAN) ? ""big"" : ""little"", config->bytes_per_sample);
            }
        }
        else if (!strncmp (caf_chunk_header.mChunkType, ""chan"", 4)) {
            CAFChannelLayout *caf_channel_layout;

            if (caf_chunk_header.mChunkSize < 0 || caf_chunk_header.mChunkSize > 1024 ||
                caf_chunk_header.mChunkSize < sizeof (CAFChannelLayout)) {
                    error_line (""this .CAF file has an invalid 'chan' chunk!"");
                    return WAVPACK_SOFT_ERROR;
            }

            if (debug_logging_mode)
                error_line (""'chan' chunk is %d bytes"", (int) caf_chunk_header.mChunkSize);

            caf_channel_layout = malloc ((size_t) caf_chunk_header.mChunkSize);

            if (!DoReadFile (infile, caf_channel_layout, (uint32_t) caf_chunk_header.mChunkSize, &bcount) ||
                bcount != caf_chunk_header.mChunkSize) {
                    error_line (""%s is not a valid .CAF file!"", infilename);
                    free (caf_channel_layout);
                    return WAVPACK_SOFT_ERROR;
            }
            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, caf_channel_layout, (uint32_t) caf_chunk_header.mChunkSize)) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    free (caf_channel_layout);
                    return WAVPACK_SOFT_ERROR;
            }

            WavpackBigEndianToNative (caf_channel_layout, CAFChannelLayoutFormat);
            chan_chunk = 1;

            if (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED)) {
                error_line (""this CAF file already has channel order information!"");
                free (caf_channel_layout);
                return WAVPACK_SOFT_ERROR;
            }

            switch (caf_channel_layout->mChannelLayoutTag) {
                case kCAFChannelLayoutTag_UseChannelDescriptions:
                    {
                        CAFChannelDescription *descriptions = (CAFChannelDescription *) (caf_channel_layout + 1);
                        int num_descriptions = caf_channel_layout->mNumberChannelDescriptions;
                        int label, cindex = 0, idents = 0;

                        if (caf_chunk_header.mChunkSize != sizeof (CAFChannelLayout) + sizeof (CAFChannelDescription) * num_descriptions ||
                            num_descriptions != config->num_channels) {
                                error_line (""channel descriptions in 'chan' chunk are the wrong size!"");
                                free (caf_channel_layout);
                                return WAVPACK_SOFT_ERROR;
                        }

                        if (num_descriptions >= 256) {
                            error_line (""%d channel descriptions is more than we can handle...ignoring!"");
                            break;
                        }

                        
                        
                        

                        channel_reorder = malloc (num_descriptions);
                        memset (channel_reorder, -1, num_descriptions);
                        channel_identities = malloc (num_descriptions+1);

                        

                        for (i = 0; i < num_descriptions; ++i) {
                            WavpackBigEndianToNative (descriptions + i, CAFChannelDescriptionFormat);

                            if (debug_logging_mode)
                                error_line (""chan %d --> %d"", i + 1, descriptions [i].mChannelLabel);
                        }

                        

                        for (label = 1; label <= 18; ++label)
                            for (i = 0; i < num_descriptions; ++i)
                                if (descriptions [i].mChannelLabel == label) {
                                    config->channel_mask |= 1 << (label - 1);
                                    channel_reorder [i] = cindex++;
                                    break;
                                }

                        

                        for (i = 0; i < num_descriptions; ++i)
                            if (channel_reorder [i] == (unsigned char) -1) {
                                uint32_t clabel = descriptions [i].mChannelLabel;

                                if (clabel == 0 || clabel == 0xffffffff || clabel == 100)
                                    channel_identities [idents++] = 0xff;
                                else if ((clabel >= 33 && clabel <= 44) || (clabel >= 200 && clabel <= 207) || (clabel >= 301 && clabel <= 305))
                                    channel_identities [idents++] = clabel >= 301 ? clabel - 80 : clabel;
                                else {
                                    error_line (""warning: unknown channel descriptions label: %d"", clabel);
                                    channel_identities [idents++] = 0xff;
                                }

                                channel_reorder [i] = cindex++;
                            }

                        

                        for (i = 0; i < num_descriptions; ++i)
                            if (channel_reorder [i] != i)
                                break;

                        if (i == num_descriptions) {
                            free (channel_reorder);                 
                            channel_reorder = NULL;
                        }
                        else {
                            config->qmode |= QMODE_REORDERED_CHANS; 
                            channel_layout = num_descriptions;
                        }

                        if (!idents) {                              
                            free (channel_identities);
                            channel_identities = NULL;
                        }
                        else
                            channel_identities [idents] = 0;        

                        if (debug_logging_mode) {
                            error_line (""layout_tag = 0x%08x, so generated bitmap of 0x%08x from %d descriptions, %d non-MS"",
                                caf_channel_layout->mChannelLayoutTag, config->channel_mask,
                                caf_channel_layout->mNumberChannelDescriptions, idents);

                            

                            if (channel_reorder && num_descriptions <= 8) {
                                char reorder_string [] = ""12345678"";

                                for (i = 0; i < num_descriptions; ++i)
                                    reorder_string [i] = channel_reorder [i] + '1';

                                reorder_string [i] = 0;
                                error_line (""reordering string = \""%s\""\n"", reorder_string);
                            }
                        }
                    }

                    break;

                case kCAFChannelLayoutTag_UseChannelBitmap:
                    config->channel_mask = caf_channel_layout->mChannelBitmap;

                    if (debug_logging_mode)
                        error_line (""layout_tag = 0x%08x, so using supplied bitmap of 0x%08x"",
                            caf_channel_layout->mChannelLayoutTag, caf_channel_layout->mChannelBitmap);

                    break;

                default:
                    for (i = 0; i < NUM_LAYOUTS; ++i)
                        if (caf_channel_layout->mChannelLayoutTag == layouts [i].mChannelLayoutTag) {
                            config->channel_mask = layouts [i].mChannelBitmap;
                            channel_layout = layouts [i].mChannelLayoutTag;

                            if (layouts [i].mChannelReorder) {
                                channel_reorder = (unsigned char *) strdup (layouts [i].mChannelReorder);
                                config->qmode |= QMODE_REORDERED_CHANS;
                            }

                            if (layouts [i].mChannelIdentities)
                                channel_identities = (unsigned char *) strdup (layouts [i].mChannelIdentities);

                            if (debug_logging_mode)
                                error_line (""layout_tag 0x%08x found in table, bitmap = 0x%08x, reorder = %s, identities = %s"",
                                    channel_layout, config->channel_mask, channel_reorder ? ""yes"" : ""no"", channel_identities ? ""yes"" : ""no"");

                            break;
                        }

                    if (i == NUM_LAYOUTS && debug_logging_mode)
                        error_line (""layout_tag 0x%08x not found in table...all channels unassigned"",
                            caf_channel_layout->mChannelLayoutTag);

                    break;
            }

            free (caf_channel_layout);
        }
        else if (!strncmp (caf_chunk_header.mChunkType, ""data"", 4)) {     
            uint32_t mEditCount;

            if (!desc_chunk || !DoReadFile (infile, &mEditCount, sizeof (mEditCount), &bcount) ||
                bcount != sizeof (mEditCount)) {
                    error_line (""%s is not a valid .CAF file!"", infilename);
                    return WAVPACK_SOFT_ERROR;
            }
            else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, &mEditCount, sizeof (mEditCount))) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    return WAVPACK_SOFT_ERROR;
            }

            if ((config->qmode & QMODE_IGNORE_LENGTH) || caf_chunk_header.mChunkSize == -1) {
                config->qmode |= QMODE_IGNORE_LENGTH;

                if (infilesize && DoGetFilePosition (infile) != -1)
                    total_samples = (infilesize - DoGetFilePosition (infile)) / caf_audio_format.mBytesPerPacket;
                else
                    total_samples = -1;
            }
            else {
                if (infilesize && infilesize - caf_chunk_header.mChunkSize > 16777216) {
                    error_line ("".CAF file %s has over 16 MB of extra CAFF data, probably is corrupt!"", infilename);
                    return WAVPACK_SOFT_ERROR;
                }

                if ((caf_chunk_header.mChunkSize - 4) % caf_audio_format.mBytesPerPacket) {
                    error_line ("".CAF file %s has an invalid data chunk size, probably is corrupt!"", infilename);
                    return WAVPACK_SOFT_ERROR;
                }

                total_samples = (caf_chunk_header.mChunkSize - 4) / caf_audio_format.mBytesPerPacket;

                if (!total_samples) {
                    error_line (""this .CAF file has no audio samples, probably is corrupt!"");
                    return WAVPACK_SOFT_ERROR;
                }

                if (total_samples > MAX_WAVPACK_SAMPLES) {
                    error_line (""%s has too many samples for WavPack!"", infilename);
                    return WAVPACK_SOFT_ERROR;
                }
            }

            break;
        }
        else {          

            uint32_t bytes_to_copy = (uint32_t) caf_chunk_header.mChunkSize;
            char *buff;

            if (caf_chunk_header.mChunkSize < 0 || caf_chunk_header.mChunkSize > 1048576) {
                error_line (""%s is not a valid .CAF file!"", infilename);
                return WAVPACK_SOFT_ERROR;
            }

            buff = malloc (bytes_to_copy);

            if (debug_logging_mode)
                error_line (""extra unknown chunk \""%c%c%c%c\"" of %d bytes"",
                    caf_chunk_header.mChunkType [0], caf_chunk_header.mChunkType [1], caf_chunk_header.mChunkType [2],
                    caf_chunk_header.mChunkType [3], caf_chunk_header.mChunkSize);

            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||
                bcount != bytes_to_copy ||
                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {
                    error_line (""%s"", WavpackGetErrorMessage (wpc));
                    free (buff);
                    return WAVPACK_SOFT_ERROR;
            }

            free (buff);
        }
    }

    if (!chan_chunk && !config->channel_mask && config->num_channels <= 2 && !(config->qmode & QMODE_CHANS_UNASSIGNED))
        config->channel_mask = 0x5 - config->num_channels;

    if (!WavpackSetConfiguration64 (wpc, config, total_samples, channel_identities)) {
        error_line (""%s"", WavpackGetErrorMessage (wpc));
        return WAVPACK_SOFT_ERROR;
    }

    if (channel_identities)
        free (channel_identities);

    if (channel_layout || channel_reorder) {
        if (!WavpackSetChannelLayout (wpc, channel_layout, channel_reorder)) {
            error_line (""problem with setting channel layout (should not happen)"");
            return WAVPACK_SOFT_ERROR;
        }

        if (channel_reorder)
            free (channel_reorder);
    }

    return WAVPACK_NO_ERROR;
}
","1. int ParseCaffHeaderConfig_1 (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config)
2. unsigned char *channel_identities = NULL;
3. infilesize = DoGetFileSize (infile);
4. WavpackBigEndianToNative (&caf_chunk_header, CAFChunkHeaderFormat);
5. bcount != caf_chunk_header.mChunkSize) {
6. if (debug_logging_mode) {
7. error_line (""format = %s, flags = %x, sampling rate = %g"",
formatstr, caf_audio_format.mFormatFlags, caf_audio_format.mSampleRate);
8. caf_audio_format.mChannelsPerFrame, caf_audio_format.mBitsPerChannel);
9. caf_audio_format.mBytesPerPacket / caf_audio_format.mChannelsPerFrame > 4 ||
caf_audio_format.mBytesPerPacket % caf_audio_format.mChannelsPerFrame)
10. config->float_norm_exp = (caf_audio_format.mFormatFlags & CAF_FORMAT_FLOAT) ? 127 : 0;
11. return WAVPACK_SOFT_ERROR;
12. !WavpackAddWrapper (wpc, caf_channel_layout, (uint32_t) caf_chunk_header.mChunkSize)) {
13. return WAVPACK_SOFT_ERROR;
14. chan_chunk = 1;
15. free (caf_channel_layout);
16. int label, cindex = 0, idents = 0;
17. error_line (""channel descriptions in 'chan' chunk are the wrong size!"");
18. if (num_descriptions >= 256) {
error_line (""%d channel descriptions is more than we can handle...ignoring!"");
19. uint32_t clabel = descriptions [i].mChannelLabel;
20. error_line (""warning: unknown channel descriptions label: %d"", clabel);
21. if (!idents) {
22. caf_channel_layout->mNumberChannelDescriptions, idents);
23. for (i = 0; i < NUM_LAYOUTS; ++i)
24. channel_layout = layouts [i].mChannelLayoutTag;
25. channel_reorder = (unsigned char *) strdup (layouts [i].mChannelReorder);
26. if (layouts [i].mChannelIdentities)
27. if (debug_logging_mode)
28. bcount != sizeof (mEditCount)) {
29. else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
30. total_samples = -1;
31. total_samples = (caf_chunk_header.mChunkSize - 4) / caf_audio_format.mBytesPerPacket;
32. if (!total_samples) {
error_line (""this .CAF file has no audio samples, probably is corrupt!"");
return WAVPACK_SOFT_ERROR;
33. error_line (""%s has too many samples for WavPack!"", infilename);
34. return WAVPACK_SOFT_ERROR;
35. (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&
36. if (channel_layout || channel_reorder) {
37. return WAVPACK_SOFT_ERROR;","6
9
17
53
63
76
81-82
86
101-102
111
136
151
154
158
162
171
175
180-181
216
223
245
255
283
286
289
293
296
316
320
332
345
347-349
353
367
379
401
404","CWE-665,CWE-125,CWE-787"
multipath_ioctl,"static int multipath_ioctl(struct dm_target *ti, unsigned int cmd,
			   unsigned long arg)
{
	struct multipath *m = (struct multipath *) ti->private;
	struct block_device *bdev = NULL;
	fmode_t mode = 0;
	unsigned long flags;
	int r = 0;

	spin_lock_irqsave(&m->lock, flags);

	if (!m->current_pgpath)
		__choose_pgpath(m, 0);

	if (m->current_pgpath) {
		bdev = m->current_pgpath->path.dev->bdev;
		mode = m->current_pgpath->path.dev->mode;
	}

	if (m->queue_io)
		r = -EAGAIN;
	else if (!bdev)
		r = -EIO;
 
 	spin_unlock_irqrestore(&m->lock, flags);
 
	
	if (!r && ti->len != i_size_read(bdev->bd_inode) >> SECTOR_SHIFT)
		r = scsi_verify_blk_ioctl(NULL, cmd);

 	return r ? : __blkdev_driver_ioctl(bdev, mode, cmd, arg);
 }
","1. unsigned long arg)
2. struct block_device *bdev = NULL;
3. unsigned long flags;
int r = 0;
4. spin_lock_irqsave(&m->lock, flags);
5. if (!m->current_pgpath)
6. bdev = m->current_pgpath->path.dev->bdev;
7. r = -EAGAIN;
8. r = -EIO;
9. spin_unlock_irqrestore(&m->lock, flags);
10. r = scsi_verify_blk_ioctl(NULL, cmd);","2
5
7-8
10
12
16
21
23
25
31","CWE-347,CWE-20,CWE-264,CWE-189"
futex_wait,"
#define __user

static int futex_wait(u32 __user *uaddr, int fshared,
		      u32 val, ktime_t *abs_time, u32 bitset, int clockrt)
{
	struct hrtimer_sleeper timeout, *to = NULL;
	struct restart_block *restart;
	struct futex_hash_bucket *hb;
	struct futex_q q;
	int ret;

	if (!bitset)
		return -EINVAL;

	q.pi_state = NULL;
	q.bitset = bitset;
	q.rt_waiter = NULL;
	q.requeue_pi_key = NULL;

	if (abs_time) {
		to = &timeout;

		hrtimer_init_on_stack(&to->timer, clockrt ? CLOCK_REALTIME :
				      CLOCK_MONOTONIC, HRTIMER_MODE_ABS);
		hrtimer_init_sleeper(to, current);
		hrtimer_set_expires_range_ns(&to->timer, *abs_time,
					     current->timer_slack_ns);
 	}
 
 retry:
	
 	ret = futex_wait_setup(uaddr, val, fshared, &q, &hb);
 	if (ret)
 		goto out;

	
	futex_wait_queue_me(hb, &q, to);
 
 	
 	ret = 0;
	
 	if (!unqueue_me(&q))
		goto out;
 	ret = -ETIMEDOUT;
 	if (to && !to->task)
		goto out;
 
 	
	if (!signal_pending(current))
 		goto retry;
 
 	ret = -ERESTARTSYS;
 	if (!abs_time)
		goto out;
 
 	restart = &current_thread_info()->restart_block;
 	restart->fn = futex_wait_restart;
	restart->futex.uaddr = (u32 *)uaddr;
	restart->futex.val = val;
	restart->futex.time = abs_time->tv64;
	restart->futex.bitset = bitset;
	restart->futex.flags = FLAGS_HAS_TIMEOUT;

	if (fshared)
		restart->futex.flags |= FLAGS_SHARED;
	if (clockrt)
		restart->futex.flags |= FLAGS_CLOCKRT;
 
 	ret = -ERESTART_RESTARTBLOCK;
 
 out:
 	if (to) {
 		hrtimer_cancel(&to->timer);
		destroy_hrtimer_on_stack(&to->timer);
	}
	return ret;
}
","1. struct restart_block *restart;
2. struct futex_q q;
int ret;
3. to = &timeout;
4. hrtimer_init_on_stack(&to->timer, clockrt ? CLOCK_REALTIME :
5. hrtimer_init_sleeper(to, current);
6. current->timer_slack_ns);
7. retry:
8. ret = futex_wait_setup(uaddr, val, fshared, &q, &hb);
9. futex_wait_queue_me(hb, &q, to);
10. ret = 0;
11. goto out;
ret = -ETIMEDOUT;
if (to && !to->task)
12. restart->futex.bitset = bitset;
13. if (clockrt)","8
10-11
22
24
26
28
31
36
41
44
47-49
68
73","CWE-416,CWE-264,CWE-119"
kernel_wait4,"
#define __user

long kernel_wait4(pid_t upid, int __user *stat_addr, int options,
		  struct rusage *ru)
{
	struct wait_opts wo;
	struct pid *pid = NULL;
	enum pid_type type;
	long ret;

	if (options & ~(WNOHANG|WUNTRACED|WCONTINUED|
 			__WNOTHREAD|__WCLONE|__WALL))
 		return -EINVAL;
 
	
	if (upid == INT_MIN)
		return -ESRCH;

 	if (upid == -1)
 		type = PIDTYPE_MAX;
 	else if (upid < 0) {
		type = PIDTYPE_PGID;
		pid = find_get_pid(-upid);
	} else if (upid == 0) {
		type = PIDTYPE_PGID;
		pid = get_task_pid(current, PIDTYPE_PGID);
	} else  {
		type = PIDTYPE_PID;
		pid = find_get_pid(upid);
	}

	wo.wo_type	= type;
	wo.wo_pid	= pid;
	wo.wo_flags	= options | WEXITED;
	wo.wo_info	= NULL;
	wo.wo_stat	= 0;
	wo.wo_rusage	= ru;
	ret = do_wait(&wo);
	put_pid(pid);
	if (ret > 0 && stat_addr && put_user(wo.wo_stat, stat_addr))
		ret = -EFAULT;

	return ret;
}
","1. long kernel_wait4(pid_t upid, int __user *stat_addr, int options,
2. enum pid_type type;
3. if (options & ~(WNOHANG|WUNTRACED|WCONTINUED|
4. if (upid == INT_MIN)
return -ESRCH;
5. type = PIDTYPE_MAX;
6. type = PIDTYPE_PGID;
7. } else if (upid == 0) {
8. pid = get_task_pid(current, PIDTYPE_PGID);
} else  {
9. wo.wo_type	= type;
wo.wo_pid	= pid;
wo.wo_flags	= options | WEXITED;
10. ret = do_wait(&wo);
11. ret = -EFAULT;","4
9
12
17-18
21
23
25
27-28
33-35
39
42","CWE-20,CWE-17,CWE-787,CWE-125"
is_exception,"static inline bool is_exception(u32 intr_info)
static inline bool is_nmi(u32 intr_info)
 {
 	return (intr_info & (INTR_INFO_INTR_TYPE_MASK | INTR_INFO_VALID_MASK))
		== (INTR_TYPE_NMI_INTR | INTR_INFO_VALID_MASK);
 }
",1. static inline bool is_exception(u32 intr_info),1,"CWE-264,CWE-189,CWE-400"
ext2_xattr_cache_insert-277231058615880,"static int ext2_xattr_cache_insert(struct mb2_cache *, struct buffer_head *);
","1. static int ext2_xattr_cache_insert(struct mb2_cache *, struct buffer_head *);",1,"CWE-787,CWE-400,CWE-19,CWE-119"
PyMemoTable_Copy-270976899220828,"
#define PyMemoTable

static PyMemoTable *
PyMemoTable_Copy(PyMemoTable *self)
{
    PyMemoTable *new = PyMemoTable_New();
    if (new == NULL)
        return NULL;

    new->mt_used = self->mt_used;
    new->mt_allocated = self->mt_allocated;
    new->mt_mask = self->mt_mask;
    
    PyMem_FREE(new->mt_table);
    new->mt_table = PyMem_NEW(PyMemoEntry, self->mt_allocated);
    if (new->mt_table == NULL) {
        PyMem_FREE(new);
        PyErr_NoMemory();
        return NULL;
    }
    for (size_t i = 0; i < self->mt_allocated; i++) {
        Py_XINCREF(self->mt_table[i].me_key);
    }
    memcpy(new->mt_table, self->mt_table,
           sizeof(PyMemoEntry) * self->mt_allocated);

    return new;
}
","1. if (new == NULL)
2. new->mt_used = self->mt_used;
3. new->mt_table = PyMem_NEW(PyMemoEntry, self->mt_allocated);
4. PyErr_NoMemory();
5. for (size_t i = 0; i < self->mt_allocated; i++) {
6. memcpy(new->mt_table, self->mt_table,
sizeof(PyMemoEntry) * self->mt_allocated);
7. return new;","8
11
17
20
23
26-27
29","CWE-522,CWE-200,CWE-119"
gru_fault-31835935124879,"vm_fault_t gru_fault(struct vm_fault *vmf)
{
	struct vm_area_struct *vma = vmf->vma;
	struct gru_thread_state *gts;
	unsigned long paddr, vaddr;
	unsigned long expires;

	vaddr = vmf->address;
	gru_dbg(grudev, ""vma %p, vaddr 0x%lx (0x%lx)\n"",
		vma, vaddr, GSEG_BASE(vaddr));
	STAT(nopfn);

	
	gts = gru_find_thread_state(vma, TSID(vaddr, vma));
	if (!gts)
		return VM_FAULT_SIGBUS;

again:
	mutex_lock(&gts->ts_ctxlock);
	preempt_disable();

	if (gru_check_context_placement(gts)) {
		preempt_enable();
		mutex_unlock(&gts->ts_ctxlock);
		gru_unload_context(gts, 1);
		return VM_FAULT_NOPAGE;
	}

	if (!gts->ts_gru) {
		STAT(load_user_context);
		if (!gru_assign_gru_context(gts)) {
			preempt_enable();
			mutex_unlock(&gts->ts_ctxlock);
			set_current_state(TASK_INTERRUPTIBLE);
			schedule_timeout(GRU_ASSIGN_DELAY);  
			expires = gts->ts_steal_jiffies + GRU_STEAL_DELAY;
			if (time_before(expires, jiffies))
				gru_steal_context(gts);
			goto again;
		}
		gru_load_context(gts);
		paddr = gseg_physical_address(gts->ts_gru, gts->ts_ctxnum);
		remap_pfn_range(vma, vaddr & ~(GRU_GSEG_PAGESIZE - 1),
				paddr >> PAGE_SHIFT, GRU_GSEG_PAGESIZE,
				vma->vm_page_prot);
	}

	preempt_enable();
	mutex_unlock(&gts->ts_ctxlock);

	return VM_FAULT_NOPAGE;
}
","1. preempt_enable();
mutex_unlock(&gts->ts_ctxlock);
2. expires = gts->ts_steal_jiffies + GRU_STEAL_DELAY;
3. goto again;
4. paddr >> PAGE_SHIFT, GRU_GSEG_PAGESIZE,","23-24
36
39
44","CWE-122,CWE-190,CWE-476,CWE-399"
bfq_idle_slice_timer_body-16669847504811,"static void
bfq_idle_slice_timer_body(struct bfq_data *bfqd, struct bfq_queue *bfqq)
{
	enum bfqq_expiration reason;
	unsigned long flags;

	spin_lock_irqsave(&bfqd->lock, flags);

	
	if (bfqq != bfqd->in_service_queue) {
		spin_unlock_irqrestore(&bfqd->lock, flags);
		return;
	}

	bfq_clear_bfqq_wait_request(bfqq);

	if (bfq_bfqq_budget_timeout(bfqq))
		
		reason = BFQQE_BUDGET_TIMEOUT;
	else if (bfqq->queued[0] == 0 && bfqq->queued[1] == 0)
		
		reason = BFQQE_TOO_IDLE;
	else
		goto schedule_dispatch;

	bfq_bfqq_expire(bfqd, bfqq, true, reason);

schedule_dispatch:
	spin_unlock_irqrestore(&bfqd->lock, flags);
	bfq_schedule_dispatch(bfqd);
}
","1. bfq_idle_slice_timer_body(struct bfq_data *bfqd, struct bfq_queue *bfqq)
2. unsigned long flags;
3. spin_lock_irqsave(&bfqd->lock, flags);
4. spin_unlock_irqrestore(&bfqd->lock, flags);
5. bfq_clear_bfqq_wait_request(bfqq);","2
5
7
17
21","CWE-264,CWE-189,CWE-190,CWE-119,CWE-125"
cg_rmdir-67915925314711,"static int cg_rmdir(const char *path)
{
	struct fuse_context *fc = fuse_get_context();
	char *fpath = NULL, *cgdir = NULL, *controller, *next = NULL;
	const char *cgroup;
	int ret;

	if (!fc)
		return -EIO;

	controller = pick_controller_from_path(fc, path);
	if (!controller)
		return -EINVAL;

	cgroup = find_cgroup_in_path(path);
	if (!cgroup)
		return -EINVAL;

	get_cgdir_and_path(cgroup, &cgdir, &fpath);
	if (!fpath) {
		ret = -EINVAL;
		goto out;
	}

	if (!caller_is_in_ancestor(fc->pid, controller, cgroup, &next)) {
		if (!fpath || strcmp(next, fpath) == 0)
			ret = -EBUSY;
		else
			ret = -ENOENT;
		goto out;
	}

	if (!fc_may_access(fc, controller, cgdir, NULL, O_WRONLY)) {
		ret = -EACCES;
		goto out;
	}
	if (!caller_is_in_ancestor(fc->pid, controller, cgroup, NULL)) {
		ret = -EACCES;
		goto out;
	}

	if (!cgfs_remove(controller, cgroup)) {
		ret = -EINVAL;
		goto out;
	}

	ret = 0;

out:
	free(cgdir);
	free(next);
	return ret;
}
","1. const char *cgroup;
int ret;
2. if (!cgroup)
3. goto out;
4. ret = -EBUSY;
5. goto out;
6. if (!fc_may_access(fc, controller, cgdir, NULL, O_WRONLY)) {
ret = -EACCES;
7. ret = -EACCES;
8. ret = -EINVAL;
9. out:
10. free(next);","5-6
16
22
27
30
33-34
38
43
49
51","CWE-362,CWE-190,CWE-264"
fit_check_format-189146256397047,"int fit_check_format(const void *fit, ulong size)
{
	int ret;

	
	ret = fdt_check_header(fit);
	if (ret) {
		log_debug(""Wrong FIT format: not a flattened device tree (err=%d)\n"",
			  ret);
		return -ENOEXEC;
	}

	if (CONFIG_IS_ENABLED(FIT_FULL_CHECK)) {
		
		if (size == IMAGE_SIZE_INVAL)
			size = fdt_totalsize(fit);
		ret = fdt_check_full(fit, size);

		if (ret) {
			log_debug(""FIT check error %d\n"", ret);
			return -EINVAL;
		}
	}

	
	if (!fdt_getprop(fit, 0, FIT_DESC_PROP, NULL)) {
		log_debug(""Wrong FIT format: no description\n"");
		return -ENOMSG;
	}

	if (IMAGE_ENABLE_TIMESTAMP) {
		
		if (!fdt_getprop(fit, 0, FIT_TIMESTAMP_PROP, NULL)) {
			log_debug(""Wrong FIT format: no timestamp\n"");
			return -ENODATA;
		}
	}

	
	if (fdt_path_offset(fit, FIT_IMAGES_PATH) < 0) {
		log_debug(""Wrong FIT format: no images parent node\n"");
		return -ENOENT;
	}

	return 0;
}
","1. int fit_check_format(const void *fit, ulong size)
2. int ret;
3. return -ENOEXEC;
4. return -ENOMSG;
5. log_debug(""Wrong FIT format: no images parent node\n"");
return -ENOENT;","1
3
10
32
45-46","CWE-362,CWE-190,CWE-20,CWE-476"
PHP_MINIT_FUNCTION,"PHP_MINIT_FUNCTION(spl_array)
{
	REGISTER_SPL_STD_CLASS_EX(ArrayObject, spl_array_object_new, spl_funcs_ArrayObject);
	REGISTER_SPL_IMPLEMENTS(ArrayObject, Aggregate);
	REGISTER_SPL_IMPLEMENTS(ArrayObject, ArrayAccess);
	REGISTER_SPL_IMPLEMENTS(ArrayObject, Serializable);
	REGISTER_SPL_IMPLEMENTS(ArrayObject, Countable);
	memcpy(&spl_handler_ArrayObject, zend_get_std_object_handlers(), sizeof(zend_object_handlers));

	spl_handler_ArrayObject.clone_obj = spl_array_object_clone;
	spl_handler_ArrayObject.read_dimension = spl_array_read_dimension;
	spl_handler_ArrayObject.write_dimension = spl_array_write_dimension;
	spl_handler_ArrayObject.unset_dimension = spl_array_unset_dimension;
	spl_handler_ArrayObject.has_dimension = spl_array_has_dimension;
	spl_handler_ArrayObject.count_elements = spl_array_object_count_elements;
 
 	spl_handler_ArrayObject.get_properties = spl_array_get_properties;
 	spl_handler_ArrayObject.get_debug_info = spl_array_get_debug_info;
	spl_handler_ArrayObject.get_gc = spl_array_get_gc;
 	spl_handler_ArrayObject.read_property = spl_array_read_property;
 	spl_handler_ArrayObject.write_property = spl_array_write_property;
 	spl_handler_ArrayObject.get_property_ptr_ptr = spl_array_get_property_ptr_ptr;
	spl_handler_ArrayObject.has_property = spl_array_has_property;
	spl_handler_ArrayObject.unset_property = spl_array_unset_property;

	spl_handler_ArrayObject.compare_objects = spl_array_compare_objects;

	REGISTER_SPL_STD_CLASS_EX(ArrayIterator, spl_array_object_new, spl_funcs_ArrayIterator);
	REGISTER_SPL_IMPLEMENTS(ArrayIterator, Iterator);
	REGISTER_SPL_IMPLEMENTS(ArrayIterator, ArrayAccess);
	REGISTER_SPL_IMPLEMENTS(ArrayIterator, SeekableIterator);
	REGISTER_SPL_IMPLEMENTS(ArrayIterator, Serializable);
	REGISTER_SPL_IMPLEMENTS(ArrayIterator, Countable);
	memcpy(&spl_handler_ArrayIterator, &spl_handler_ArrayObject, sizeof(zend_object_handlers));
	spl_ce_ArrayIterator->get_iterator = spl_array_get_iterator;

	REGISTER_SPL_SUB_CLASS_EX(RecursiveArrayIterator, ArrayIterator, spl_array_object_new, spl_funcs_RecursiveArrayIterator);
	REGISTER_SPL_IMPLEMENTS(RecursiveArrayIterator, RecursiveIterator);
	spl_ce_RecursiveArrayIterator->get_iterator = spl_array_get_iterator;

	REGISTER_SPL_CLASS_CONST_LONG(ArrayObject,   ""STD_PROP_LIST"",    SPL_ARRAY_STD_PROP_LIST);
	REGISTER_SPL_CLASS_CONST_LONG(ArrayObject,   ""ARRAY_AS_PROPS"",   SPL_ARRAY_ARRAY_AS_PROPS);

	REGISTER_SPL_CLASS_CONST_LONG(ArrayIterator, ""STD_PROP_LIST"",    SPL_ARRAY_STD_PROP_LIST);
	REGISTER_SPL_CLASS_CONST_LONG(ArrayIterator, ""ARRAY_AS_PROPS"",   SPL_ARRAY_ARRAY_AS_PROPS);

	REGISTER_SPL_CLASS_CONST_LONG(RecursiveArrayIterator, ""CHILD_ARRAYS_ONLY"", SPL_ARRAY_CHILD_ARRAYS_ONLY);

	return SUCCESS;
}
","1. spl_handler_ArrayObject.clone_obj = spl_array_object_clone;
2. spl_handler_ArrayObject.get_gc = spl_array_get_gc;
3. REGISTER_SPL_CLASS_CONST_LONG(ArrayObject,   ""STD_PROP_LIST"",    SPL_ARRAY_STD_PROP_LIST);
4. return SUCCESS;","10
19
41
49","CWE-476,CWE-190,CWE-416"
processRequest-202654730286529,"void processRequest(struct reqelem * req)
{
	ssize_t n;
	unsigned int l, m;
	unsigned char buf[2048];
	const unsigned char * p;
	int type;
	struct device * d = devlist;
	unsigned char rbuf[4096];
	unsigned char * rp = rbuf+1;
	unsigned char nrep = 0;
	time_t t;
	struct service * newserv = NULL;
	struct service * serv;

	n = read(req->socket, buf, sizeof(buf));
	if(n<0) {
		if(errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK)
			return;	
		syslog(LOG_ERR, ""(s=%d) processRequest(): read(): %m"", req->socket);
		goto error;
	}
	if(n==0) {
		syslog(LOG_INFO, ""(s=%d) request connection closed"", req->socket);
		goto error;
	}
	t = time(NULL);
	type = buf[0];
	p = buf + 1;
	DECODELENGTH_CHECKLIMIT(l, p, buf + n);
	if(p+l > buf+n) {
		syslog(LOG_WARNING, ""bad request (length encoding)"");
		goto error;
	}
	if(l == 0 && type != 3) {
		syslog(LOG_WARNING, ""bad request (length=0)"");
		goto error;
	}
	syslog(LOG_INFO, ""(s=%d) request type=%d str='%.*s'"",
	       req->socket, type, l, p);
	switch(type) {
	case 1:	
	case 2:	
	case 3:	
		while(d && (nrep < 255)) {
			if(d->t < t) {
				syslog(LOG_INFO, ""outdated device"");
			} else {
				
				if(d->headers[HEADER_LOCATION].l + d->headers[HEADER_NT].l
				  + d->headers[HEADER_USN].l + 6
				  + (rp - rbuf) >= (int)sizeof(rbuf))
					break;
				if( (type==1 && 0==memcmp(d->headers[HEADER_NT].p, p, l))
				  ||(type==2 && 0==memcmp(d->headers[HEADER_USN].p, p, l))
				  ||(type==3) ) {
					
					m = d->headers[HEADER_LOCATION].l;
					CODELENGTH(m, rp);
					memcpy(rp, d->headers[HEADER_LOCATION].p, d->headers[HEADER_LOCATION].l);
					rp += d->headers[HEADER_LOCATION].l;
					m = d->headers[HEADER_NT].l;
					CODELENGTH(m, rp);
					memcpy(rp, d->headers[HEADER_NT].p, d->headers[HEADER_NT].l);
					rp += d->headers[HEADER_NT].l;
					m = d->headers[HEADER_USN].l;
					CODELENGTH(m, rp);
					memcpy(rp, d->headers[HEADER_USN].p, d->headers[HEADER_USN].l);
					rp += d->headers[HEADER_USN].l;
					nrep++;
				}
			}
			d = d->next;
		}
		
		for(serv = servicelisthead.lh_first;
		    serv && (nrep < 255);
		    serv = serv->entries.le_next) {
			
			if(strlen(serv->location) + strlen(serv->st)
			  + strlen(serv->usn) + 6 + (rp - rbuf) >= sizeof(rbuf))
			  	break;
			if( (type==1 && 0==strncmp(serv->st, (const char *)p, l))
			  ||(type==2 && 0==strncmp(serv->usn, (const char *)p, l))
			  ||(type==3) ) {
				
				m = strlen(serv->location);
				CODELENGTH(m, rp);
				memcpy(rp, serv->location, m);
				rp += m;
				m = strlen(serv->st);
				CODELENGTH(m, rp);
				memcpy(rp, serv->st, m);
				rp += m;
				m = strlen(serv->usn);
				CODELENGTH(m, rp);
				memcpy(rp, serv->usn, m);
				rp += m;
				nrep++;
			}
		}
		rbuf[0] = nrep;
		syslog(LOG_DEBUG, ""(s=%d) response : %d device%s"",
		       req->socket, nrep, (nrep > 1) ? ""s"" : """");
		if(write(req->socket, rbuf, rp - rbuf) < 0) {
			syslog(LOG_ERR, ""(s=%d) write: %m"", req->socket);
			goto error;
		}
		break;
	case 4:	
		newserv = malloc(sizeof(struct service));
		if(!newserv) {
			syslog(LOG_ERR, ""cannot allocate memory"");
			goto error;
		}
		memset(newserv, 0, sizeof(struct service));	
		if(containsForbiddenChars(p, l)) {
			syslog(LOG_ERR, ""bad request (st contains forbidden chars)"");
			goto error;
		}
		newserv->st = malloc(l + 1);
		if(!newserv->st) {
			syslog(LOG_ERR, ""cannot allocate memory"");
			goto error;
		}
		memcpy(newserv->st, p, l);
		newserv->st[l] = '\0';
		p += l;
		if(p >= buf + n) {
			syslog(LOG_WARNING, ""bad request (missing usn)"");
			goto error;
		}
		DECODELENGTH_CHECKLIMIT(l, p, buf + n);
		if(p+l > buf+n) {
			syslog(LOG_WARNING, ""bad request (length encoding)"");
			goto error;
		}
		if(containsForbiddenChars(p, l)) {
			syslog(LOG_ERR, ""bad request (usn contains forbidden chars)"");
			goto error;
		}
		syslog(LOG_INFO, ""usn='%.*s'"", l, p);
		newserv->usn = malloc(l + 1);
		if(!newserv->usn) {
			syslog(LOG_ERR, ""cannot allocate memory"");
			goto error;
		}
		memcpy(newserv->usn, p, l);
		newserv->usn[l] = '\0';
		p += l;
		DECODELENGTH_CHECKLIMIT(l, p, buf + n);
		if(p+l > buf+n) {
			syslog(LOG_WARNING, ""bad request (length encoding)"");
			goto error;
		}
		if(containsForbiddenChars(p, l)) {
			syslog(LOG_ERR, ""bad request (server contains forbidden chars)"");
			goto error;
		}
		syslog(LOG_INFO, ""server='%.*s'"", l, p);
		newserv->server = malloc(l + 1);
		if(!newserv->server) {
			syslog(LOG_ERR, ""cannot allocate memory"");
			goto error;
		}
		memcpy(newserv->server, p, l);
		newserv->server[l] = '\0';
		p += l;
		DECODELENGTH_CHECKLIMIT(l, p, buf + n);
		if(p+l > buf+n) {
			syslog(LOG_WARNING, ""bad request (length encoding)"");
			goto error;
		}
		if(containsForbiddenChars(p, l)) {
			syslog(LOG_ERR, ""bad request (location contains forbidden chars)"");
			goto error;
		}
		syslog(LOG_INFO, ""location='%.*s'"", l, p);
		newserv->location = malloc(l + 1);
		if(!newserv->location) {
			syslog(LOG_ERR, ""cannot allocate memory"");
			goto error;
		}
		memcpy(newserv->location, p, l);
		newserv->location[l] = '\0';
		
		for(serv = servicelisthead.lh_first;
		    serv;
		    serv = serv->entries.le_next) {
			if(0 == strcmp(newserv->usn, serv->usn)
			  && 0 == strcmp(newserv->st, serv->st)) {
				syslog(LOG_INFO, ""Service allready in the list. Updating..."");
				free(newserv->st);
				free(newserv->usn);
				free(serv->server);
				serv->server = newserv->server;
				free(serv->location);
				serv->location = newserv->location;
				free(newserv);
				newserv = NULL;
				return;
			}
		}
		
		LIST_INSERT_HEAD(&servicelisthead, newserv, entries);
		newserv = NULL;
		
		break;
	default:
		syslog(LOG_WARNING, ""Unknown request type %d"", type);
		rbuf[0] = '\0';
		if(write(req->socket, rbuf, 1) < 0) {
			syslog(LOG_ERR, ""(s=%d) write: %m"", req->socket);
			goto error;
		}
	}
	return;
error:
	if(newserv) {
		free(newserv->st);
		free(newserv->usn);
		free(newserv->server);
		free(newserv->location);
		free(newserv);
		newserv = NULL;
	}
	close(req->socket);
	req->socket = -1;
	return;
}
","1. void processRequest(struct reqelem * req)
2. unsigned int l, m;
3. const unsigned char * p;
4. unsigned char * rp = rbuf+1;
5. time_t t;
6. p = buf + 1;
7. if(d->t < t) {
8. serv && (nrep < 255);
9. memcpy(rp, serv->location, m);
10. syslog(LOG_ERR, ""bad request (st contains forbidden chars)"");
11. serv;
serv = serv->entries.le_next) {
12. && 0 == strcmp(newserv->st, serv->st)) {
13. free(serv->server);
14. free(newserv->st);
15. free(newserv->location);
16. newserv = NULL;","1
4
6
10
12
29
46
80
95
124
194-195
197
201
229
232
234","CWE-20,CWE-125,CWE-388"
find_source_vc,"static int find_source_vc(char **ret_path, unsigned *ret_idx) {
        _cleanup_free_ char *path = NULL;
        int r, err = 0;
        unsigned i;

        path = new(char, sizeof(""/dev/tty63""));
        if (!path)
                return log_oom();

        for (i = 1; i <= 63; i++) {
                _cleanup_close_ int fd = -1;

                r = verify_vc_allocation(i);
                if (r < 0) {
                        if (!err)
                                err = -r;
                        continue;
                }

                sprintf(path, ""/dev/tty%u"", i);
                fd = open_terminal(path, O_RDWR|O_CLOEXEC|O_NOCTTY);
                if (fd < 0) {
                        if (!err)
                                 err = -fd;
                         continue;
                 }
                r = vt_verify_kbmode(fd);
                 if (r < 0) {
                         if (!err)
                                 err = -r;
                        continue;
                }

                
                *ret_idx = i;
                *ret_path = TAKE_PTR(path);
                return TAKE_FD(fd);
        }

        return log_error_errno(err, ""No usable source console found: %m"");
}
","1. static int find_source_vc(char **ret_path, unsigned *ret_idx) {
_cleanup_free_ char *path = NULL;
2. return log_oom();
3. for (i = 1; i <= 63; i++) {
4. if (!err)
5. if (!err)
6. continue;
7. *ret_path = TAKE_PTR(path);","1-2
8
10
23
29
31
36","CWE-119,CWE-125,CWE-416"
xps_parse_path,"xps_parse_path(xps_document *doc, const fz_matrix *ctm, char *base_uri, xps_resource *dict, fz_xml *root)
{
	fz_xml *node;

	char *fill_uri;
	char *stroke_uri;
	char *opacity_mask_uri;

	char *transform_att;
	char *clip_att;
	char *data_att;
	char *fill_att;
	char *stroke_att;
	char *opacity_att;
	char *opacity_mask_att;

	fz_xml *transform_tag = NULL;
	fz_xml *clip_tag = NULL;
	fz_xml *data_tag = NULL;
	fz_xml *fill_tag = NULL;
	fz_xml *stroke_tag = NULL;
	fz_xml *opacity_mask_tag = NULL;

	char *fill_opacity_att = NULL;
	char *stroke_opacity_att = NULL;

	char *stroke_dash_array_att;
	char *stroke_dash_cap_att;
	char *stroke_dash_offset_att;
	char *stroke_end_line_cap_att;
	char *stroke_start_line_cap_att;
	char *stroke_line_join_att;
	char *stroke_miter_limit_att;
	char *stroke_thickness_att;
	char *navigate_uri_att;
 
        fz_stroke_state *stroke = NULL;
        fz_matrix transform;
       float samples[FZ_MAX_COLORS];
        fz_colorspace *colorspace;
        fz_path *path = NULL;
        fz_path *stroke_path = NULL;
	fz_rect area;
	int fill_rule;
	int dash_len = 0;
	fz_matrix local_ctm;

	

	transform_att = fz_xml_att(root, ""RenderTransform"");
	clip_att = fz_xml_att(root, ""Clip"");
	data_att = fz_xml_att(root, ""Data"");
	fill_att = fz_xml_att(root, ""Fill"");
	stroke_att = fz_xml_att(root, ""Stroke"");
	opacity_att = fz_xml_att(root, ""Opacity"");
	opacity_mask_att = fz_xml_att(root, ""OpacityMask"");

	stroke_dash_array_att = fz_xml_att(root, ""StrokeDashArray"");
	stroke_dash_cap_att = fz_xml_att(root, ""StrokeDashCap"");
	stroke_dash_offset_att = fz_xml_att(root, ""StrokeDashOffset"");
	stroke_end_line_cap_att = fz_xml_att(root, ""StrokeEndLineCap"");
	stroke_start_line_cap_att = fz_xml_att(root, ""StrokeStartLineCap"");
	stroke_line_join_att = fz_xml_att(root, ""StrokeLineJoin"");
	stroke_miter_limit_att = fz_xml_att(root, ""StrokeMiterLimit"");
	stroke_thickness_att = fz_xml_att(root, ""StrokeThickness"");
	navigate_uri_att = fz_xml_att(root, ""FixedPage.NavigateUri"");

	for (node = fz_xml_down(root); node; node = fz_xml_next(node))
	{
		if (!strcmp(fz_xml_tag(node), ""Path.RenderTransform""))
			transform_tag = fz_xml_down(node);
		if (!strcmp(fz_xml_tag(node), ""Path.OpacityMask""))
			opacity_mask_tag = fz_xml_down(node);
		if (!strcmp(fz_xml_tag(node), ""Path.Clip""))
			clip_tag = fz_xml_down(node);
		if (!strcmp(fz_xml_tag(node), ""Path.Fill""))
			fill_tag = fz_xml_down(node);
		if (!strcmp(fz_xml_tag(node), ""Path.Stroke""))
			stroke_tag = fz_xml_down(node);
		if (!strcmp(fz_xml_tag(node), ""Path.Data""))
			data_tag = fz_xml_down(node);
	}

	fill_uri = base_uri;
	stroke_uri = base_uri;
	opacity_mask_uri = base_uri;

	xps_resolve_resource_reference(doc, dict, &data_att, &data_tag, NULL);
	xps_resolve_resource_reference(doc, dict, &clip_att, &clip_tag, NULL);
	xps_resolve_resource_reference(doc, dict, &transform_att, &transform_tag, NULL);
	xps_resolve_resource_reference(doc, dict, &fill_att, &fill_tag, &fill_uri);
	xps_resolve_resource_reference(doc, dict, &stroke_att, &stroke_tag, &stroke_uri);
	xps_resolve_resource_reference(doc, dict, &opacity_mask_att, &opacity_mask_tag, &opacity_mask_uri);

	

	if (!data_att && !data_tag)
		return;

	if (fill_tag && !strcmp(fz_xml_tag(fill_tag), ""SolidColorBrush""))
	{
		fill_opacity_att = fz_xml_att(fill_tag, ""Opacity"");
		fill_att = fz_xml_att(fill_tag, ""Color"");
		fill_tag = NULL;
	}

	if (stroke_tag && !strcmp(fz_xml_tag(stroke_tag), ""SolidColorBrush""))
	{
		stroke_opacity_att = fz_xml_att(stroke_tag, ""Opacity"");
		stroke_att = fz_xml_att(stroke_tag, ""Color"");
		stroke_tag = NULL;
	}

	if (stroke_att || stroke_tag)
	{
		if (stroke_dash_array_att)
		{
			char *s = stroke_dash_array_att;

			while (*s)
			{
				while (*s == ' ')
					s++;
				if (*s) 
					dash_len++;

				while (*s && *s != ' ')
					s++;
			}
		}
		stroke = fz_new_stroke_state_with_dash_len(doc->ctx, dash_len);
		stroke->start_cap = xps_parse_line_cap(stroke_start_line_cap_att);
		stroke->dash_cap = xps_parse_line_cap(stroke_dash_cap_att);
		stroke->end_cap = xps_parse_line_cap(stroke_end_line_cap_att);

		stroke->linejoin = FZ_LINEJOIN_MITER_XPS;
		if (stroke_line_join_att)
		{
			if (!strcmp(stroke_line_join_att, ""Miter"")) stroke->linejoin = FZ_LINEJOIN_MITER_XPS;
			if (!strcmp(stroke_line_join_att, ""Round"")) stroke->linejoin = FZ_LINEJOIN_ROUND;
			if (!strcmp(stroke_line_join_att, ""Bevel"")) stroke->linejoin = FZ_LINEJOIN_BEVEL;
		}

		stroke->miterlimit = 10;
		if (stroke_miter_limit_att)
			stroke->miterlimit = fz_atof(stroke_miter_limit_att);

		stroke->linewidth = 1;
		if (stroke_thickness_att)
			stroke->linewidth = fz_atof(stroke_thickness_att);

		stroke->dash_phase = 0;
		stroke->dash_len = 0;
		if (stroke_dash_array_att)
		{
			char *s = stroke_dash_array_att;

			if (stroke_dash_offset_att)
				stroke->dash_phase = fz_atof(stroke_dash_offset_att) * stroke->linewidth;

			while (*s)
			{
				while (*s == ' ')
					s++;
				if (*s) 
					stroke->dash_list[stroke->dash_len++] = fz_atof(s) * stroke->linewidth;
				while (*s && *s != ' ')
					s++;
			}
			stroke->dash_len = dash_len;
		}
	}

	transform = fz_identity;
	if (transform_att)
		xps_parse_render_transform(doc, transform_att, &transform);
	if (transform_tag)
		xps_parse_matrix_transform(doc, transform_tag, &transform);
	fz_concat(&local_ctm, &transform, ctm);

	if (clip_att || clip_tag)
		xps_clip(doc, &local_ctm, dict, clip_att, clip_tag);

	fill_rule = 0;
	if (data_att)
		path = xps_parse_abbreviated_geometry(doc, data_att, &fill_rule);
	else if (data_tag)
	{
		path = xps_parse_path_geometry(doc, dict, data_tag, 0, &fill_rule);
		if (stroke_att || stroke_tag)
			stroke_path = xps_parse_path_geometry(doc, dict, data_tag, 1, &fill_rule);
	}
	if (!stroke_path)
		stroke_path = path;

	if (stroke_att || stroke_tag)
	{
		fz_bound_path(doc->ctx, stroke_path, stroke, &local_ctm, &area);
		if (stroke_path != path && (fill_att || fill_tag)) {
			fz_rect bounds;
			fz_bound_path(doc->ctx, path, NULL, &local_ctm, &bounds);
			fz_union_rect(&area, &bounds);
		}
	}
	else
		fz_bound_path(doc->ctx, path, NULL, &local_ctm, &area);

	if (navigate_uri_att)
		xps_add_link(doc, &area, base_uri, navigate_uri_att);

	xps_begin_opacity(doc, &local_ctm, &area, opacity_mask_uri, dict, opacity_att, opacity_mask_tag);

	if (fill_att)
	{
		xps_parse_color(doc, base_uri, fill_att, &colorspace, samples);
		if (fill_opacity_att)
			samples[0] *= fz_atof(fill_opacity_att);
		xps_set_color(doc, colorspace, samples);

		fz_fill_path(doc->dev, path, fill_rule == 0, &local_ctm,
			doc->colorspace, doc->color, doc->alpha);
	}

	if (fill_tag)
	{
		fz_clip_path(doc->dev, path, &area, fill_rule == 0, &local_ctm);
		xps_parse_brush(doc, &local_ctm, &area, fill_uri, dict, fill_tag);
		fz_pop_clip(doc->dev);
	}

	if (stroke_att)
	{
		xps_parse_color(doc, base_uri, stroke_att, &colorspace, samples);
		if (stroke_opacity_att)
			samples[0] *= fz_atof(stroke_opacity_att);
		xps_set_color(doc, colorspace, samples);

		fz_stroke_path(doc->dev, stroke_path, stroke, &local_ctm,
			doc->colorspace, doc->color, doc->alpha);
	}

	if (stroke_tag)
	{
		fz_clip_stroke_path(doc->dev, stroke_path, &area, stroke, &local_ctm);
		xps_parse_brush(doc, &local_ctm, &area, stroke_uri, dict, stroke_tag);
		fz_pop_clip(doc->dev);
	}

	xps_end_opacity(doc, opacity_mask_uri, dict, opacity_att, opacity_mask_tag);

	if (stroke_path != path)
		fz_free_path(doc->ctx, stroke_path);
	fz_free_path(doc->ctx, path);
	path = NULL;
	fz_drop_stroke_state(doc->ctx, stroke);

	if (clip_att || clip_tag)
		fz_pop_clip(doc->dev);
}
","1. xps_parse_path(xps_document *doc, const fz_matrix *ctm, char *base_uri, xps_resource *dict, fz_xml *root)
2. char *stroke_uri;
3. char *transform_att;
4. char *data_att;
5. fz_xml *clip_tag = NULL;
6. fz_xml *stroke_tag = NULL;
7. char *fill_opacity_att = NULL;
8. char *stroke_dash_offset_att;
9. char *stroke_miter_limit_att;
10. char *navigate_uri_att;
11. fz_colorspace *colorspace;
12. int dash_len = 0;
fz_matrix local_ctm;
13. opacity_mask_att = fz_xml_att(root, ""OpacityMask"");
14. stroke_start_line_cap_att = fz_xml_att(root, ""StrokeStartLineCap"");
15. fill_tag = fz_xml_down(node);
16. xps_resolve_resource_reference(doc, dict, &stroke_att, &stroke_tag, &stroke_uri);
17. stroke_tag = NULL;
18. if (stroke_att || stroke_tag)
19. if (stroke_dash_array_att)
20. s++;
21. dash_len++;
22. stroke = fz_new_stroke_state_with_dash_len(doc->ctx, dash_len);
23. stroke->end_cap = xps_parse_line_cap(stroke_end_line_cap_att);
24. if (!strcmp(stroke_line_join_att, ""Round"")) stroke->linejoin = FZ_LINEJOIN_ROUND;
if (!strcmp(stroke_line_join_att, ""Bevel"")) stroke->linejoin = FZ_LINEJOIN_BEVEL;
25. stroke->dash_len = 0;
26. stroke->dash_list[stroke->dash_len++] = fz_atof(s) * stroke->linewidth;
27. xps_parse_render_transform(doc, transform_att, &transform);
28. xps_clip(doc, &local_ctm, dict, clip_att, clip_tag);
29. else if (data_tag)
30. fz_bound_path(doc->ctx, stroke_path, stroke, &local_ctm, &area);
31. xps_begin_opacity(doc, &local_ctm, &area, opacity_mask_uri, dict, opacity_att, opacity_mask_tag);
32. xps_parse_color(doc, base_uri, fill_att, &colorspace, samples);
33. samples[0] *= fz_atof(fill_opacity_att);
34. fz_fill_path(doc->dev, path, fill_rule == 0, &local_ctm,
35. xps_parse_brush(doc, &local_ctm, &area, fill_uri, dict, fill_tag);
36. if (stroke_opacity_att)
37. fz_stroke_path(doc->dev, stroke_path, stroke, &local_ctm,
38. fz_clip_stroke_path(doc->dev, stroke_path, &area, stroke, &local_ctm);
39. fz_drop_stroke_state(doc->ctx, stroke);","1
6
9
11
18
21
24
29
33
35
40
45-46
58
64
79
94
115
118
120
127
129
135
138
144-145
157
170
180
186
191
202
215
219
221
224
231
238
242
248
259","CWE-824,CWE-362,CWE-125,CWE-399"
sg_ioctl,"sg_ioctl(struct file *filp, unsigned int cmd_in, unsigned long arg)
{
	void __user *p = (void __user *)arg;
	int __user *ip = p;
	int result, val, read_only;
	Sg_device *sdp;
	Sg_fd *sfp;
	Sg_request *srp;
	unsigned long iflags;

	if ((!(sfp = (Sg_fd *) filp->private_data)) || (!(sdp = sfp->parentdp)))
		return -ENXIO;

	SCSI_LOG_TIMEOUT(3, sg_printk(KERN_INFO, sdp,
				   ""sg_ioctl: cmd=0x%x\n"", (int) cmd_in));
	read_only = (O_RDWR != (filp->f_flags & O_ACCMODE));

	switch (cmd_in) {
	case SG_IO:
		if (atomic_read(&sdp->detaching))
			return -ENODEV;
		if (!scsi_block_when_processing_errors(sdp->device))
			return -ENXIO;
		if (!access_ok(VERIFY_WRITE, p, SZ_SG_IO_HDR))
			return -EFAULT;
		result = sg_new_write(sfp, filp, p, SZ_SG_IO_HDR,
				 1, read_only, 1, &srp);
		if (result < 0)
			return result;
		result = wait_event_interruptible(sfp->read_wait,
			(srp_done(sfp, srp) || atomic_read(&sdp->detaching)));
		if (atomic_read(&sdp->detaching))
			return -ENODEV;
		write_lock_irq(&sfp->rq_list_lock);
		if (srp->done) {
			srp->done = 2;
			write_unlock_irq(&sfp->rq_list_lock);
			result = sg_new_read(sfp, p, SZ_SG_IO_HDR, srp);
			return (result < 0) ? result : 0;
		}
		srp->orphan = 1;
		write_unlock_irq(&sfp->rq_list_lock);
		return result;	
	case SG_SET_TIMEOUT:
		result = get_user(val, ip);
		if (result)
			return result;
		if (val < 0)
			return -EIO;
		if (val >= mult_frac((s64)INT_MAX, USER_HZ, HZ))
			val = min_t(s64, mult_frac((s64)INT_MAX, USER_HZ, HZ),
				    INT_MAX);
		sfp->timeout_user = val;
		sfp->timeout = mult_frac(val, HZ, USER_HZ);

		return 0;
	case SG_GET_TIMEOUT:	
				
		return sfp->timeout_user;
	case SG_SET_FORCE_LOW_DMA:
		
		return 0;
	case SG_GET_LOW_DMA:
		return put_user((int) sdp->device->host->unchecked_isa_dma, ip);
	case SG_GET_SCSI_ID:
		if (!access_ok(VERIFY_WRITE, p, sizeof (sg_scsi_id_t)))
			return -EFAULT;
		else {
			sg_scsi_id_t __user *sg_idp = p;

			if (atomic_read(&sdp->detaching))
				return -ENODEV;
			__put_user((int) sdp->device->host->host_no,
				   &sg_idp->host_no);
			__put_user((int) sdp->device->channel,
				   &sg_idp->channel);
			__put_user((int) sdp->device->id, &sg_idp->scsi_id);
			__put_user((int) sdp->device->lun, &sg_idp->lun);
			__put_user((int) sdp->device->type, &sg_idp->scsi_type);
			__put_user((short) sdp->device->host->cmd_per_lun,
				   &sg_idp->h_cmd_per_lun);
			__put_user((short) sdp->device->queue_depth,
				   &sg_idp->d_queue_depth);
			__put_user(0, &sg_idp->unused[0]);
			__put_user(0, &sg_idp->unused[1]);
			return 0;
		}
	case SG_SET_FORCE_PACK_ID:
		result = get_user(val, ip);
		if (result)
			return result;
		sfp->force_packid = val ? 1 : 0;
		return 0;
	case SG_GET_PACK_ID:
		if (!access_ok(VERIFY_WRITE, ip, sizeof (int)))
			return -EFAULT;
		read_lock_irqsave(&sfp->rq_list_lock, iflags);
		list_for_each_entry(srp, &sfp->rq_list, entry) {
			if ((1 == srp->done) && (!srp->sg_io_owned)) {
				read_unlock_irqrestore(&sfp->rq_list_lock,
						       iflags);
				__put_user(srp->header.pack_id, ip);
				return 0;
			}
		}
		read_unlock_irqrestore(&sfp->rq_list_lock, iflags);
		__put_user(-1, ip);
		return 0;
	case SG_GET_NUM_WAITING:
		read_lock_irqsave(&sfp->rq_list_lock, iflags);
		val = 0;
		list_for_each_entry(srp, &sfp->rq_list, entry) {
			if ((1 == srp->done) && (!srp->sg_io_owned))
				++val;
		}
		read_unlock_irqrestore(&sfp->rq_list_lock, iflags);
		return put_user(val, ip);
	case SG_GET_SG_TABLESIZE:
		return put_user(sdp->sg_tablesize, ip);
	case SG_SET_RESERVED_SIZE:
		result = get_user(val, ip);
		if (result)
			return result;
                if (val < 0)
                        return -EINVAL;
		val = min_t(int, val,
			    max_sectors_bytes(sdp->device->request_queue));
		mutex_lock(&sfp->f_mutex);
		if (val != sfp->reserve.bufflen) {
			if (sfp->mmap_called ||
			    sfp->res_in_use) {
				mutex_unlock(&sfp->f_mutex);
				return -EBUSY;
			}

			sg_remove_scat(sfp, &sfp->reserve);
			sg_build_reserve(sfp, val);
		}
		mutex_unlock(&sfp->f_mutex);
		return 0;
	case SG_GET_RESERVED_SIZE:
		val = min_t(int, sfp->reserve.bufflen,
			    max_sectors_bytes(sdp->device->request_queue));
		return put_user(val, ip);
	case SG_SET_COMMAND_Q:
		result = get_user(val, ip);
		if (result)
			return result;
		sfp->cmd_q = val ? 1 : 0;
		return 0;
	case SG_GET_COMMAND_Q:
		return put_user((int) sfp->cmd_q, ip);
	case SG_SET_KEEP_ORPHAN:
		result = get_user(val, ip);
		if (result)
			return result;
		sfp->keep_orphan = val;
		return 0;
	case SG_GET_KEEP_ORPHAN:
		return put_user((int) sfp->keep_orphan, ip);
	case SG_NEXT_CMD_LEN:
		result = get_user(val, ip);
		if (result)
			return result;
		if (val > SG_MAX_CDB_SIZE)
			return -ENOMEM;
		sfp->next_cmd_len = (val > 0) ? val : 0;
		return 0;
	case SG_GET_VERSION_NUM:
		return put_user(sg_version_num, ip);
	case SG_GET_ACCESS_COUNT:
		
		val = (sdp->device ? 1 : 0);
		return put_user(val, ip);
	case SG_GET_REQUEST_TABLE:
		if (!access_ok(VERIFY_WRITE, p, SZ_SG_REQ_INFO * SG_MAX_QUEUE))
			return -EFAULT;
 		else {
 			sg_req_info_t *rinfo;
 
			rinfo = kzalloc(SZ_SG_REQ_INFO * SG_MAX_QUEUE,
					GFP_KERNEL);
 			if (!rinfo)
 				return -ENOMEM;
 			read_lock_irqsave(&sfp->rq_list_lock, iflags);
			sg_fill_request_table(sfp, rinfo);
			read_unlock_irqrestore(&sfp->rq_list_lock, iflags);
			result = __copy_to_user(p, rinfo,
						SZ_SG_REQ_INFO * SG_MAX_QUEUE);
			result = result ? -EFAULT : 0;
			kfree(rinfo);
			return result;
		}
	case SG_EMULATED_HOST:
		if (atomic_read(&sdp->detaching))
			return -ENODEV;
		return put_user(sdp->device->host->hostt->emulated, ip);
	case SCSI_IOCTL_SEND_COMMAND:
		if (atomic_read(&sdp->detaching))
			return -ENODEV;
		if (read_only) {
			unsigned char opcode = WRITE_6;
			Scsi_Ioctl_Command __user *siocp = p;

			if (copy_from_user(&opcode, siocp->data, 1))
				return -EFAULT;
			if (sg_allow_access(filp, &opcode))
				return -EPERM;
		}
		return sg_scsi_ioctl(sdp->device->request_queue, NULL, filp->f_mode, p);
	case SG_SET_DEBUG:
		result = get_user(val, ip);
		if (result)
			return result;
		sdp->sgdebug = (char) val;
		return 0;
	case BLKSECTGET:
		return put_user(max_sectors_bytes(sdp->device->request_queue),
				ip);
	case BLKTRACESETUP:
		return blk_trace_setup(sdp->device->request_queue,
				       sdp->disk->disk_name,
				       MKDEV(SCSI_GENERIC_MAJOR, sdp->index),
				       NULL, p);
	case BLKTRACESTART:
		return blk_trace_startstop(sdp->device->request_queue, 1);
	case BLKTRACESTOP:
		return blk_trace_startstop(sdp->device->request_queue, 0);
	case BLKTRACETEARDOWN:
		return blk_trace_remove(sdp->device->request_queue);
	case SCSI_IOCTL_GET_IDLUN:
	case SCSI_IOCTL_GET_BUS_NUMBER:
	case SCSI_IOCTL_PROBE_HOST:
	case SG_GET_TRANSFORM:
	case SG_SCSI_RESET:
		if (atomic_read(&sdp->detaching))
			return -ENODEV;
		break;
	default:
		if (read_only)
			return -EPERM;	
		break;
	}

	result = scsi_ioctl_block_when_processing_errors(sdp->device,
			cmd_in, filp->f_flags & O_NDELAY);
	if (result)
		return result;
	return scsi_ioctl(sdp->device, cmd_in, p);
}
","1. switch (cmd_in) {
2. read_lock_irqsave(&sfp->rq_list_lock, iflags);
3. read_unlock_irqrestore(&sfp->rq_list_lock, iflags);
4. return put_user((int) sfp->keep_orphan, ip);","18
101
120
164","CWE-310,CWE-200,CWE-20"
main_18-86235317750654,"int
main_18(int argc, char *argv[])
{
  int i, c;
  FILE *ifp = 0, *ofp = 0;
  const char *ifp_filename = ""<stdin>"";
  const char *ofp_filename = ""<stdout>"";
  const char *set_font_name = 0;
  struct font_reader fr;
  uint32_t rfork_len;
  int raw = 0, macbinary = 1, applesingle = 0, appledouble = 0, binhex = 0;

  Clp_Parser *clp =
    Clp_NewParser(argc, (const char * const *)argv, sizeof(options) / sizeof(options[0]), options);
  program_name = Clp_ProgramName(clp);

  
  while (1) {
    int opt = Clp_Next(clp);
    switch (opt) {

     case RAW_OPT:
      raw = 1;
      macbinary = applesingle = appledouble = binhex = 0;
      break;

     case MACBINARY_OPT:
      macbinary = 1;
      raw = applesingle = appledouble = binhex = 0;
      break;

     case APPLESINGLE_OPT:
      applesingle = 1;
      raw = macbinary = appledouble = binhex = 0;
      break;

     case APPLEDOUBLE_OPT:
      appledouble = 1;
      raw = macbinary = applesingle = binhex = 0;
      break;

     case BINHEX_OPT:
      binhex = 1;
      raw = macbinary = applesingle = appledouble = 0;
      break;

     output_file:
     case OUTPUT_OPT:
      if (ofp)
	fatal_error(""output file already specified"");
      if (strcmp(clp->vstr, ""-"") == 0)
	ofp = stdout;
      else {
	ofp_filename = clp->vstr;
	ofp = fopen(ofp_filename, ""wb"");
	if (!ofp) fatal_error(""%s: %s"", ofp_filename, strerror(errno));
      }
      break;

     case FILENAME_OPT:
      if (set_font_name)
	fatal_error(""Macintosh font filename already specified"");
      set_font_name = clp->vstr;
      break;

     case HELP_OPT:
      usage();
      exit(0);
      break;

     case VERSION_OPT:
      printf(""t1mac (LCDF t1utils) %s\n"", VERSION);
      printf(""Copyright (C) 2000-2010 Eddie Kohler et al.\n\
This is free software; see the source for copying conditions.\n\
There is NO warranty, not even for merchantability or fitness for a\n\
particular purpose.\n"");
      exit(0);
      break;

     case Clp_NotOption:
      if (ifp && ofp)
	fatal_error(""too many arguments"");
      else if (ifp)
	goto output_file;
      if (strcmp(clp->vstr, ""-"") == 0)
	ifp = stdin;
      else {
	ifp_filename = clp->vstr;
	ifp = fopen(clp->vstr, ""r"");
	if (!ifp) fatal_error(""%s: %s"", clp->vstr, strerror(errno));
      }
      break;

     case Clp_Done:
      goto done;

     case Clp_BadOption:
      short_usage();
      exit(1);
      break;

    }
  }

 done:
  if (!ifp) ifp = stdin;
  if (!ofp) ofp = stdout;

#if defined(_MSDOS) || defined(_WIN32)
  
  
  _setmode(_fileno(ofp), _O_BINARY);
#endif

  
  fr.output_ascii = t1mac_output_ascii;
  fr.output_binary = t1mac_output_binary;
  fr.output_end = t1mac_output_end;

  
  rfork_f = tmpfile();
  if (!rfork_f)
    fatal_error(""cannot open temorary file: %s"", strerror(errno));
  for (i = 0; i < RFORK_HEADERLEN; i++)
    putc(0, rfork_f);
  init_current_post();

  
  c = getc(ifp);
  ungetc(c, ifp);

  
  if (c == PFB_MARKER)
    process_pfb(ifp, ifp_filename, &fr);
  else if (c == '%')
    process_pfa(ifp, ifp_filename, &fr);
  else
    fatal_error(""%s does not start with font marker (`%%' or 0x80)"", ifp_filename);
  if (ifp != stdin)
    fclose(ifp);

  
  if (nrsrc == 0)
    error(""no POST resources written -- are you sure this was a font?"");

  
  output_new_rsrc(""ICN#"", 256, 32, (const char *)icon_bw_data, 256);
  
  output_new_rsrc(""FREF"", 256, 32, ""LWFN\0\0\0"", 7);
  
  output_new_rsrc(""BNDL"", 256, 32, ""T1UT\0\0\0\1FREF\0\0\0\0\1\0ICN#\0\0\0\0\1\0"", 28);
  
  output_new_rsrc(""icl8"", 256, 32, (const char *)icon_8_data, 1024);
  output_new_rsrc(""icl4"", 256, 32, (const char *)icon_4_data, 512);
  output_new_rsrc(""ics#"", 256, 32, (const char *)small_icon_bw_data, 64);
  output_new_rsrc(""ics8"", 256, 32, (const char *)small_icon_8_data, 256);
  output_new_rsrc(""ics4"", 256, 32, (const char *)small_icon_4_data, 128);
  
  output_new_rsrc(""T1UT"", 0, 0, ""DConverted by t1mac (t1utils) \251Eddie Kohler http:

  
  rfork_len = complete_rfork();

  
  if (!set_font_name && font_name) {
    int part = 0, len = 0;
    char *x, *s;
    for (x = s = font_name; *s; s++)
      if (isupper((unsigned char) *s) || isdigit((unsigned char) *s)) {
	*x++ = *s;
	part++;
	len = 1;
      } else if (islower((unsigned char) *s)) {
	if (len < (part <= 1 ? 5 : 3))
	  *x++ = *s;
	len++;
      }
    *x++ = 0;
    set_font_name = font_name;
  } else if (!set_font_name)
    set_font_name = ""Unknown Font"";

  
  if (macbinary)
    output_macbinary(rfork_f, rfork_len, set_font_name, ofp);
  else if (raw)
    output_raw(rfork_f, rfork_len, ofp);
  else if (applesingle || appledouble)
    output_applesingle(rfork_f, rfork_len, set_font_name, ofp, appledouble);
  else if (binhex)
    output_binhex(rfork_f, rfork_len, set_font_name, ofp);
  else
    fatal_error(""strange output format"");
  fclose(rfork_f);

  if (ofp != stdout)
    fclose(ofp);
  return 0;
}
","1. appledouble = 1;
2. break;
3. short_usage();
4. error(""no POST resources written -- are you sure this was a font?"");
5. *x++ = *s;
part++;
6. else if (applesingle || appledouble)","38
45
98
144
170-171
188","CWE-252,CWE-17,CWE-22,CWE-189"
encrypted_update,"static int encrypted_update(struct key *key, struct key_preparsed_payload *prep)
{
	struct encrypted_key_payload *epayload = key->payload.data[0];
	struct encrypted_key_payload *new_epayload;
	char *buf;
	char *new_master_desc = NULL;
	const char *format = NULL;
 	size_t datalen = prep->datalen;
 	int ret = 0;
 
	if (test_bit(KEY_FLAG_NEGATIVE, &key->flags))
		return -ENOKEY;
 	if (datalen <= 0 || datalen > 32767 || !prep->data)
 		return -EINVAL;
 
	buf = kmalloc(datalen + 1, GFP_KERNEL);
	if (!buf)
		return -ENOMEM;

	buf[datalen] = 0;
	memcpy(buf, prep->data, datalen);
	ret = datablob_parse(buf, &format, &new_master_desc, NULL, NULL);
	if (ret < 0)
		goto out;

	ret = valid_master_desc(new_master_desc, epayload->master_desc);
	if (ret < 0)
		goto out;

	new_epayload = encrypted_key_alloc(key, epayload->format,
					   new_master_desc, epayload->datalen);
	if (IS_ERR(new_epayload)) {
		ret = PTR_ERR(new_epayload);
		goto out;
	}

	__ekey_init(new_epayload, epayload->format, new_master_desc,
		    epayload->datalen);

	memcpy(new_epayload->iv, epayload->iv, ivsize);
	memcpy(new_epayload->payload_data, epayload->payload_data,
	       epayload->payload_datalen);

	rcu_assign_keypointer(key, new_epayload);
	call_rcu(&epayload->rcu, encrypted_rcu_free);
out:
	kfree(buf);
	return ret;
}
","1. char *buf;
2. return -EINVAL;
3. buf[datalen] = 0;
4. epayload->payload_datalen);
5. out:","5
14
20
42
46","CWE-264,CWE-269,CWE-20"
get_empty_filp,"struct file *get_empty_filp(void)
{
	const struct cred *cred = current_cred();
	static long old_max;
	struct file *f;
	int error;

	
	if (get_nr_files() >= files_stat.max_files && !capable(CAP_SYS_ADMIN)) {
		
		if (percpu_counter_sum_positive(&nr_files) >= files_stat.max_files)
			goto over;
	}

	f = kmem_cache_zalloc(filp_cachep, GFP_KERNEL);
	if (unlikely(!f))
		return ERR_PTR(-ENOMEM);

	percpu_counter_inc(&nr_files);
	f->f_cred = get_cred(cred);
	error = security_file_alloc(f);
	if (unlikely(error)) {
		file_free(f);
 		return ERR_PTR(error);
 	}
 
 	atomic_long_set(&f->f_count, 1);
 	rwlock_init(&f->f_owner.lock);
 	spin_lock_init(&f->f_lock);
	eventpoll_init_file(f);
	
	return f;

over:
	
	if (get_nr_files() > old_max) {
		pr_info(""VFS: file-max limit %lu reached\n"", get_max_files());
		old_max = get_nr_files();
	}
	return ERR_PTR(-ENFILE);
}
","1. struct file *get_empty_filp(void)
2. if (unlikely(!f))","1
21","CWE-264,CWE-17,CWE-78,CWE-119"
user_update,"int user_update(struct key *key, struct key_preparsed_payload *prep)
{
	struct user_key_payload *upayload, *zap;
	size_t datalen = prep->datalen;
	int ret;

	ret = -EINVAL;
	if (datalen <= 0 || datalen > 32767 || !prep->data)
		goto error;

	
	ret = -ENOMEM;
	upayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);
	if (!upayload)
		goto error;

	upayload->datalen = datalen;
	memcpy(upayload->data, prep->data, datalen);

	
	zap = upayload;

	ret = key_payload_reserve(key, datalen);
 
 	if (ret == 0) {
 		
		if (!test_bit(KEY_FLAG_NEGATIVE, &key->flags))
			zap = key->payload.data[0];
		else
			zap = NULL;
 		rcu_assign_keypointer(key, upayload);
 		key->expiry = 0;
 	}

	if (zap)
		kfree_rcu(zap, rcu);

error:
	return ret;
}
","1. int ret;
2. ret = -EINVAL;
3. upayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);
if (!upayload)
4. upayload->datalen = datalen;
5. ret = key_payload_reserve(key, datalen);
6. if (ret == 0) {","5
7
13-14
17
23
25","CWE-20,CWE-78,CWE-269,CWE-200,CWE-119"
tcp_send_challenge_ack,"static void tcp_send_challenge_ack(struct sock *sk, const struct sk_buff *skb)
{
	
 	static u32 challenge_timestamp;
 	static unsigned int challenge_count;
 	struct tcp_sock *tp = tcp_sk(sk);
	u32 count, now;
 
 	
 	if (tcp_oow_rate_limited(sock_net(sk), skb,
 				 LINUX_MIB_TCPACKSKIPPEDCHALLENGE,
 				 &tp->last_oow_ack_time))
 		return;
 
	
 	now = jiffies / HZ;
 	if (now != challenge_timestamp) {
		u32 half = (sysctl_tcp_challenge_ack_limit + 1) >> 1;

 		challenge_timestamp = now;
		WRITE_ONCE(challenge_count, half +
			   prandom_u32_max(sysctl_tcp_challenge_ack_limit));
 	}
	count = READ_ONCE(challenge_count);
	if (count > 0) {
		WRITE_ONCE(challenge_count, count - 1);
 		NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPCHALLENGEACK);
 		tcp_send_ack(sk);
 	}
}
","1. static unsigned int challenge_count;
2. return;
3. tcp_send_ack(sk);","5
13
28","CWE-200,CWE-20,CWE-119"
evtchn_fifo_handle_events-96121985099877,"static void evtchn_fifo_handle_events(unsigned cpu,
				      struct evtchn_loop_ctrl *ctrl)
{
	__evtchn_fifo_handle_events(cpu, ctrl);
}
","1. static void evtchn_fifo_handle_events(unsigned cpu,
struct evtchn_loop_ctrl *ctrl)
2. __evtchn_fifo_handle_events(cpu, ctrl);","1-2
4","CWE-362,CWE-252,CWE-200,CWE-119"
parse_rock_ridge_inode-185526652887024,"int parse_rock_ridge_inode(struct iso_directory_record *de, struct inode *inode,
			   int relocated)
{
	int flags = relocated ? RR_RELOC_DE : 0;
	int result = parse_rock_ridge_inode_internal(de, inode, flags);

	
	if ((ISOFS_SB(inode->i_sb)->s_rock_offset == -1)
	    && (ISOFS_SB(inode->i_sb)->s_rock == 2)) {
		result = parse_rock_ridge_inode_internal(de, inode,
							 flags | RR_REGARD_XA);
	}
	return result;
}
","1. int parse_rock_ridge_inode(struct iso_directory_record *de, struct inode *inode,
int relocated)
2. int flags = relocated ? RR_RELOC_DE : 0;
int result = parse_rock_ridge_inode_internal(de, inode, flags);
3. if ((ISOFS_SB(inode->i_sb)->s_rock_offset == -1)
&& (ISOFS_SB(inode->i_sb)->s_rock == 2)) {
result = parse_rock_ridge_inode_internal(de, inode,
flags | RR_REGARD_XA);
4. return result;","1-2
4-5
11-14
16","CWE-787,CWE-20,CWE-19,CWE-119"
xmlParseStartTag,"xmlParseStartTag(xmlParserCtxtPtr ctxt) {
    const xmlChar *name;
    const xmlChar *attname;
    xmlChar *attvalue;
    const xmlChar **atts = ctxt->atts;
    int nbatts = 0;
    int maxatts = ctxt->maxatts;
    int i;

    if (RAW != '<') return(NULL);
    NEXT1;

    name = xmlParseName(ctxt);
    if (name == NULL) {
	xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
	     ""xmlParseStartTag: invalid element name\n"");
        return(NULL);
    }

    
     SKIP_BLANKS;
     GROW;
 
    while (((RAW != '>') && 
 	   ((RAW != '/') || (NXT(1) != '>')) &&
	   (IS_BYTE_CHAR(RAW))) && (ctxt->instate != XML_PARSER_EOF)) {
 	const xmlChar *q = CUR_PTR;
 	unsigned int cons = ctxt->input->consumed;
 
	attname = xmlParseAttribute(ctxt, &attvalue);
        if ((attname != NULL) && (attvalue != NULL)) {
	    
	    for (i = 0; i < nbatts;i += 2) {
	        if (xmlStrEqual(atts[i], attname)) {
		    xmlErrAttributeDup(ctxt, NULL, attname);
		    xmlFree(attvalue);
		    goto failed;
		}
	    }
	    
	    if (atts == NULL) {
	        maxatts = 22; 
	        atts = (const xmlChar **)
		       xmlMalloc(maxatts * sizeof(xmlChar *));
		if (atts == NULL) {
		    xmlErrMemory(ctxt, NULL);
		    if (attvalue != NULL)
			xmlFree(attvalue);
		    goto failed;
		}
		ctxt->atts = atts;
		ctxt->maxatts = maxatts;
	    } else if (nbatts + 4 > maxatts) {
	        const xmlChar **n;

	        maxatts *= 2;
	        n = (const xmlChar **) xmlRealloc((void *) atts,
					     maxatts * sizeof(const xmlChar *));
		if (n == NULL) {
		    xmlErrMemory(ctxt, NULL);
		    if (attvalue != NULL)
			xmlFree(attvalue);
		    goto failed;
		}
		atts = n;
		ctxt->atts = atts;
		ctxt->maxatts = maxatts;
	    }
	    atts[nbatts++] = attname;
	    atts[nbatts++] = attvalue;
	    atts[nbatts] = NULL;
	    atts[nbatts + 1] = NULL;
	} else {
	    if (attvalue != NULL)
		xmlFree(attvalue);
	}

failed:     

	GROW
	if ((RAW == '>') || (((RAW == '/') && (NXT(1) == '>'))))
	    break;
	if (!IS_BLANK_CH(RAW)) {
	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
			   ""attributes construct error\n"");
	}
	SKIP_BLANKS;
        if ((cons == ctxt->input->consumed) && (q == CUR_PTR) &&
            (attname == NULL) && (attvalue == NULL)) {
	    xmlFatalErrMsg(ctxt, XML_ERR_INTERNAL_ERROR,
			   ""xmlParseStartTag: problem parsing attributes\n"");
	    break;
	}
	SHRINK;
        GROW;
    }

    
    if ((ctxt->sax != NULL) && (ctxt->sax->startElement != NULL) &&
	(!ctxt->disableSAX)) {
	if (nbatts > 0)
	    ctxt->sax->startElement(ctxt->userData, name, atts);
	else
	    ctxt->sax->startElement(ctxt->userData, name, NULL);
    }

    if (atts != NULL) {
        
        for (i = 1;i < nbatts;i+=2)
	    if (atts[i] != NULL)
	       xmlFree((xmlChar *) atts[i]);
    }
    return(name);
}
","1. xmlParseStartTag(xmlParserCtxtPtr ctxt) {
2. SKIP_BLANKS;
3. while (((RAW != '>') &&
((RAW != '/') || (NXT(1) != '>')) &&
(IS_BYTE_CHAR(RAW))) && (ctxt->instate != XML_PARSER_EOF)) {
4. if ((attname != NULL) && (attvalue != NULL)) {
5. goto failed;
6. goto failed;
7. } else if (nbatts + 4 > maxatts) {
8. n = (const xmlChar **) xmlRealloc((void *) atts,
9. atts[nbatts] = NULL;
10. xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
""attributes construct error\n"");
11. SKIP_BLANKS;
12. GROW;
13. if ((ctxt->sax != NULL) && (ctxt->sax->startElement != NULL) &&
14. if (atts[i] != NULL)","1
25
28-30
35
45
59
63
67
81
94-95
97
105
111
122","CWE-59,CWE-119"
dalvik_disassemble,"
#define RAsm
#define RAsmOp

static int dalvik_disassemble (RAsm *a, RAsmOp *op, const ut8 *buf, int len) {
	int vA, vB, vC, payload = 0, i = (int) buf[0];
	int size = dalvik_opcodes[i].len;
	char str[1024], *strasm;
	ut64 offset;
	const char *flag_str; 

	op->buf_asm[0] = 0;
	if (buf[0] == 0x00) { 
		switch (buf[1]) {
		case 0x01: 
 			{
 				unsigned short array_size = buf[2] | (buf[3] << 8);
 				int first_key = buf[4] | (buf[5] << 8) | (buf[6] << 16) | (buf[7] << 24);
				snprintf (op->buf_asm, sizeof(op->buf_asm), ""packed-switch-payload %d, %d"", array_size, first_key);
 				size = 8;
 				payload = 2 * (array_size * 2);
 				len = 0;
			}
			break;
		case 0x02: 
 			{
 				unsigned short array_size = buf[2] | (buf[3] << 8);
				snprintf (op->buf_asm, sizeof (op->buf_asm), ""sparse-switch-payload %d"", array_size);
 				size = 4;
 				payload = 2 * (array_size*4);
 				len = 0;
			}
			break;
		case 0x03: 
			if (len > 7) {
				unsigned short elem_width = buf[2] | (buf[3] << 8);
				unsigned int array_size = buf[4] | (buf[5] << 8) | (buf[6] << 16) | (buf[7] << 24);
				snprintf (op->buf_asm, sizeof (op->buf_asm),
					""fill-array-data-payload %d, %d"",
					elem_width, array_size);
				payload = 2 * ((array_size * elem_width+1)/2);
			}
			size = 8;
			len = 0;
			break;
		default:
			
			break;
		}
	}
	strasm = NULL;
	if (size <= len) {
		strncpy (op->buf_asm, dalvik_opcodes[i].name, sizeof (op->buf_asm) - 1);
		strasm = strdup (op->buf_asm);
		size = dalvik_opcodes[i].len;
		switch (dalvik_opcodes[i].fmt) {
		case fmtop: break;
 		case fmtopvAvB:
 			vA = buf[1] & 0x0f;
 			vB = (buf[1] & 0xf0) >> 4;
			snprintf (str, sizeof (str), "" v%i, v%i"", vA, vB);
 			strasm = r_str_concat (strasm, str);
 			break;
 		case fmtopvAAvBBBB:
 			vA = (int) buf[1];
 			vB = (buf[3] << 8) | buf[2];
			snprintf (str, sizeof (str), "" v%i, v%i"", vA, vB);
 			strasm = r_str_concat (strasm, str);
 			break;
 		case fmtopvAAAAvBBBB: 
 			vA = (buf[3] << 8) | buf[2];
 			vB = (buf[5] << 8) | buf[4];
			snprintf (str, sizeof (str), "" v%i, v%i"", vA, vB);
 			strasm = r_str_concat (strasm, str);
 			break;
 		case fmtopvAA:
 			vA = (int) buf[1];
			snprintf (str, sizeof (str), "" v%i"", vA);
 			strasm = r_str_concat (strasm, str);
 			break;
 		case fmtopvAcB:
 			vA = buf[1] & 0x0f;
 			vB = (buf[1] & 0xf0) >> 4;
			snprintf (str, sizeof (str), "" v%i, %#x"", vA, vB);
 			strasm = r_str_concat (strasm, str);
 			break;
 		case fmtopvAAcBBBB:
 			vA = (int) buf[1];
 			{
 				short sB = (buf[3] << 8) | buf[2];
				snprintf (str, sizeof (str), "" v%i, %#04hx"", vA, sB);
 				strasm = r_str_concat (strasm, str);
 			}
 			break;
		case fmtopvAAcBBBBBBBB:
			vA = (int) buf[1];
			vB = buf[2] | (buf[3] << 8) | (buf[4] << 16) | (buf[5] << 24);
			if (buf[0] == 0x17) { 
				snprintf (str, sizeof (str), "" v%i:v%i, 0x%08x"", vA, vA + 1, vB);
			} else { 
				snprintf (str, sizeof (str), "" v%i, 0x%08x"", vA, vB);
			}
			strasm = r_str_concat (strasm, str);
			break;
		case fmtopvAAcBBBB0000:
			vA = (int) buf[1];
			vB = 0 | (buf[2] << 16) | (buf[3] << 24);
			if (buf[0] == 0x19) { 
				snprintf (str, sizeof (str), "" v%i:v%i, 0x%08x"", vA, vA + 1, vB);
			} else {
				snprintf (str, sizeof (str), "" v%i, 0x%08x"", vA, vB);
			}
			strasm = r_str_concat (strasm, str);
			break;
		case fmtopvAAcBBBBBBBBBBBBBBBB:
			vA = (int) buf[1];
			#define llint long long int
			llint lB = (llint)buf[2] | ((llint)buf[3] << 8)|
				((llint)buf[4] << 16) | ((llint)buf[5] << 24)|
 				((llint)buf[6] << 32) | ((llint)buf[7] << 40)|
 				((llint)buf[8] << 48) | ((llint)buf[9] << 56);
 			#undef llint
			snprintf (str, sizeof (str), "" v%i:v%i, 0x%""PFMT64x, vA, vA + 1, lB);
 			strasm = r_str_concat (strasm, str);
 			break;
 		case fmtopvAAvBBvCC:
 			vA = (int) buf[1];
 			vB = (int) buf[2];
 			vC = (int) buf[3];
			snprintf (str, sizeof (str), "" v%i, v%i, v%i"", vA, vB, vC);
 			strasm = r_str_concat (strasm, str);
 			break;
 		case fmtopvAAvBBcCC:
 			vA = (int) buf[1];
 			vB = (int) buf[2];
 			vC = (int) buf[3];
			snprintf (str, sizeof (str), "" v%i, v%i, %#x"", vA, vB, vC);
 			strasm = r_str_concat (strasm, str);
 			break;
 		case fmtopvAvBcCCCC:
 			vA = buf[1] & 0x0f;
 			vB = (buf[1] & 0xf0) >> 4;
 			vC = (buf[3] << 8) | buf[2];
			snprintf (str, sizeof (str), "" v%i, v%i, %#x"", vA, vB, vC);
 			strasm = r_str_concat (strasm, str);
 			break;
 		case fmtoppAA:
 			vA = (char) buf[1];
			
 			snprintf (str, sizeof (str), "" 0x%08""PFMT64x, a->pc + (vA * 2)); 
 			strasm = r_str_concat (strasm, str);
 			break;
		case fmtoppAAAA:
			vA = (short) (buf[3] << 8 | buf[2]);
			snprintf (str, sizeof (str), "" 0x%08""PFMT64x, a->pc + (vA * 2)); 
			strasm = r_str_concat (strasm, str);
			break;
 		case fmtopvAApBBBB: 
 			vA = (int) buf[1];
 			vB = (int) (buf[3] << 8 | buf[2]);
			
 			snprintf (str, sizeof (str), "" v%i, 0x%08""PFMT64x, vA, a->pc + (vB * 2));
 			strasm = r_str_concat (strasm, str);
 			break;
 		case fmtoppAAAAAAAA:
 			vA = (int) (buf[2] | (buf[3] << 8) | (buf[4] << 16) | (buf[5] << 24));
			
 			snprintf (str, sizeof (str), "" 0x%08""PFMT64x, a->pc + (vA*2)); 
 			strasm = r_str_concat (strasm, str);
 			break;
 		case fmtopvAvBpCCCC: 
 			vA = buf[1] & 0x0f;
 			vB = (buf[1] & 0xf0) >> 4;
 			vC = (int) (buf[3] << 8 | buf[2]);
			
 			snprintf (str, sizeof (str),"" v%i, v%i, 0x%08""PFMT64x, vA, vB, a->pc + (vC * 2));
 			strasm = r_str_concat (strasm, str);
 			break;
		case fmtopvAApBBBBBBBB:
			vA = (int) buf[1];
			vB = (int) (buf[2] | (buf[3] << 8) | (buf[4] << 16) | (buf[5] << 24));
			snprintf (str, sizeof (str), "" v%i, 0x%08""PFMT64x, vA, a->pc + vB); 
			strasm = r_str_concat (strasm, str);
			break;
		case fmtoptinlineI:
			vA = (int) (buf[1] & 0x0f);
			vB = (buf[3] << 8) | buf[2];
 			*str = 0;
 			switch (vA) {
 			case 1:
				snprintf (str, sizeof (str), "" {v%i}"", buf[4] & 0x0f);
 				break;
 			case 2:
				snprintf (str, sizeof (str), "" {v%i, v%i}"", buf[4] & 0x0f, (buf[4] & 0xf0) >> 4);
 				break;
 			case 3:
				snprintf (str, sizeof (str), "" {v%i, v%i, v%i}"", buf[4] & 0x0f, (buf[4] & 0xf0) >> 4, buf[5] & 0x0f);
 				break;
 			case 4:
				snprintf (str, sizeof (str), "" {v%i, v%i, v%i, v%i}"", buf[4] & 0x0f,
 						(buf[4] & 0xf0) >> 4, buf[5] & 0x0f, (buf[5] & 0xf0) >> 4);
 				break;
 			default:
				snprintf (str, sizeof (str), "" {}"");
 			}
 			strasm = r_str_concat (strasm, str);
			snprintf (str, sizeof (str), "", [%04x]"", vB);
 			strasm = r_str_concat (strasm, str);
 			break;
 		case fmtoptinlineIR:
 		case fmtoptinvokeVSR:
 			vA = (int) buf[1];
 			vB = (buf[3] << 8) | buf[2];
 			vC = (buf[5] << 8) | buf[4];
			snprintf (str, sizeof (str), "" {v%i..v%i}, [%04x]"", vC, vC + vA - 1, vB);
 			strasm = r_str_concat (strasm, str);
 			break;
 		case fmtoptinvokeVS:
 			vA = (int) (buf[1] & 0xf0) >> 4;
 			vB = (buf[3] << 8) | buf[2];
 			switch (vA) {
 			case 1:
				snprintf (str, sizeof (str), "" {v%i}"", buf[4] & 0x0f);
 				break;
 			case 2:
				snprintf (str, sizeof (str), "" {v%i, v%i}"", buf[4] & 0x0f, (buf[4] & 0xf0) >> 4);
 				break;
 			case 3:
				snprintf (str, sizeof (str), "" {v%i, v%i, v%i}"", buf[4] & 0x0f,
 						(buf[4] & 0xf0) >> 4, buf[5] & 0x0f);
 				break;
 			case 4:
				snprintf (str, sizeof (str), "" {v%i, v%i, v%i, v%i}"", buf[4] & 0x0f,
 						(buf[4] & 0xf0) >> 4, buf[5] & 0x0f, (buf[5] & 0xf0) >> 4);
 				break;
 			default:
				snprintf (str, sizeof (str), "" {}"");
 				break;
 			}
 			strasm = r_str_concat (strasm, str);
			snprintf (str, sizeof (str), "", [%04x]"", vB);
 			strasm = r_str_concat (strasm, str);
 			break;
 		case fmtopvAAtBBBB: 
			vA = (int) buf[1];
			vB = (buf[3] << 8) | buf[2];
 			if (buf[0] == 0x1a) {
 				offset = R_ASM_GET_OFFSET (a, 's', vB);
 				if (offset == -1) {
					snprintf (str, sizeof (str), "" v%i, string+%i"", vA, vB);
 				} else {
					snprintf (str, sizeof (str), "" v%i, 0x%""PFMT64x, vA, offset);
 				}
 			} else if (buf[0] == 0x1c || buf[0] == 0x1f || buf[0] == 0x22) {
 				flag_str = R_ASM_GET_NAME (a, 'c', vB);
 				if (!flag_str) {
					snprintf (str, sizeof (str), "" v%i, class+%i"", vA, vB);
 				} else {
					snprintf (str, sizeof (str), "" v%i, %s"", vA, flag_str);
 				}
 			} else {
 				flag_str = R_ASM_GET_NAME (a, 'f', vB);
 				if (!flag_str) {
					snprintf (str, sizeof (str), "" v%i, field+%i"", vA, vB);
 				} else {
					snprintf (str, sizeof (str), "" v%i, %s"", vA, flag_str);
 				}
 			}
 			strasm = r_str_concat (strasm, str);
			break;
		case fmtoptopvAvBoCCCC:
			vA = (buf[1] & 0x0f);
			vB = (buf[1] & 0xf0) >> 4;
 			vC = (buf[3]<<8) | buf[2];
 			offset = R_ASM_GET_OFFSET (a, 'o', vC);
 			if (offset == -1) {
				snprintf (str, sizeof (str), "" v%i, v%i, [obj+%04x]"", vA, vB, vC);
 			} else {
				snprintf (str, sizeof (str), "" v%i, v%i, [0x%""PFMT64x""]"", vA, vB, offset);
 			}
 			strasm = r_str_concat (strasm, str);
 			break;
		case fmtopAAtBBBB:
			vA = (int) buf[1];
 			vB = (buf[3] << 8) | buf[2];
 			offset = R_ASM_GET_OFFSET (a, 't', vB);
 			if (offset == -1) {
				snprintf (str, sizeof (str), "" v%i, thing+%i"", vA, vB);
 			} else {
				snprintf (str, sizeof (str), "" v%i, 0x%""PFMT64x, vA, offset);
 			}
 			strasm = r_str_concat (strasm, str);
 			break;
		case fmtopvAvBtCCCC:
			vA = (buf[1] & 0x0f);
			vB = (buf[1] & 0xf0) >> 4;
			vC = (buf[3] << 8) | buf[2];
 			if (buf[0] == 0x20 || buf[0] == 0x23) { 
 				flag_str = R_ASM_GET_NAME (a, 'c', vC);
 				if (flag_str) {
					snprintf (str, sizeof (str), "" v%i, v%i, %s"", vA, vB, flag_str);
 				}
 				else {
					snprintf (str, sizeof (str), "" v%i, v%i, class+%i"", vA, vB, vC);
 				}
 			} else {
 				flag_str = R_ASM_GET_NAME (a, 'f', vC);
 				if (flag_str) {
					snprintf (str, sizeof (str), "" v%i, v%i, %s"", vA, vB, flag_str);
 				}
 				else {
					snprintf (str, sizeof (str), "" v%i, v%i, field+%i"", vA, vB, vC);
 				}
 			}
 			strasm = r_str_concat (strasm, str);
			break;
		case fmtopvAAtBBBBBBBB:
			vA = (int) buf[1];
 			vB = (int) (buf[5] | (buf[4] << 8) | (buf[3] << 16) | (buf[2] << 24));
 			offset = R_ASM_GET_OFFSET (a, 's', vB);
 			if (offset == -1) {
				snprintf (str, sizeof (str), "" v%i, string+%i"", vA, vB);
 			}
 			else {
				snprintf (str, sizeof (str), "" v%i, 0x%""PFMT64x, vA, offset);
 			}
 			strasm = r_str_concat (strasm, str);
 			break;
		case fmtopvCCCCmBBBB:
			vA = (int) buf[1];
			vB = (buf[3] << 8) | buf[2];
			vC = (buf[5] << 8) | buf[4];
 			if (buf[0] == 0x25) { 
 				flag_str = R_ASM_GET_NAME (a, 'c', vB);
 				if (flag_str) {
					snprintf (str, sizeof (str), "" {v%i..v%i}, %s"", vC, vC + vA - 1, flag_str);
 				}
 				else {
					snprintf (str, sizeof (str), "" {v%i..v%i}, class+%i"", vC, vC + vA - 1, vB);
 				}
 			} else {
 				flag_str = R_ASM_GET_NAME (a, 'm', vB);
 				if (flag_str) {
					snprintf (str, sizeof (str), "" {v%i..v%i}, %s"", vC, vC + vA - 1, flag_str);
 				}
 				else {
					snprintf (str, sizeof (str), "" {v%i..v%i}, method+%i"", vC, vC + vA - 1, vB);
 				}
 			}
 			strasm = r_str_concat (strasm, str);
			break;
		case fmtopvXtBBBB:
			vA = (int) (buf[1] & 0xf0) >> 4;
 			vB = (buf[3] << 8) | buf[2];
 			switch (vA) {
 				case 1:
					snprintf (str, sizeof (str), "" {v%i}"", buf[4] & 0x0f);
 					break;
 				case 2:
					snprintf (str, sizeof (str), "" {v%i, v%i}"", buf[4] & 0x0f, (buf[4] & 0xf0) >> 4);
 					break;
 				case 3:
					snprintf (str, sizeof (str), "" {v%i, v%i, v%i}"", buf[4] & 0x0f,
 							(buf[4] & 0xf0) >> 4, buf[5] & 0x0f);
 					break;
 				case 4:
					snprintf (str, sizeof (str), "" {v%i, v%i, v%i, v%i}"", buf[4] & 0x0f,
 							(buf[4] & 0xf0) >> 4, buf[5] & 0x0f, (buf[5] & 0xf0) >> 4);
 					break;
 				case 5:
					snprintf (str, sizeof (str), "" {v%i, v%i, v%i, v%i, v%i}"", buf[4] & 0x0f,
 							(buf[4] & 0xf0) >> 4, buf[5] & 0x0f, (buf[5] & 0xf0) >> 4, buf[1] & 0x0f); 
 					break;
 				default:
					snprintf (str, sizeof (str), "" {}"");
 			}
 			strasm = r_str_concat (strasm, str);
 			if (buf[0] == 0x24) { 
 				flag_str = R_ASM_GET_NAME (a, 'c', vB);
 				if (flag_str) {
					snprintf (str, sizeof (str), "", %s ; 0x%x"", flag_str, vB);
 				} else {
					snprintf (str, sizeof (str), "", class+%i"", vB);
 				}
 			} else {
 				flag_str = R_ASM_GET_NAME (a, 'm', vB);
 				if (flag_str) {
					snprintf (str, sizeof (str), "", %s ; 0x%x"", flag_str, vB);
 				} else {
					snprintf (str, sizeof (str), "", method+%i"", vB);
 				}
 
 			}
			strasm = r_str_concat (strasm, str);
			break;
		case fmtoptinvokeI: 
		case fmtoptinvokeIR:
		case fmt00:
		default:
			strcpy (op->buf_asm, ""invalid "");
			free (strasm);
			strasm = NULL;
			size = 2;
		}
		if (strasm) {
			strncpy (op->buf_asm, strasm, sizeof (op->buf_asm) - 1);
			op->buf_asm[sizeof (op->buf_asm) - 1] = 0;
		} else {
			strcpy (op->buf_asm , ""invalid"");
		}
	} else if (len > 0) {
		strcpy (op->buf_asm, ""invalid "");
		op->size = len;
		size = len;
	}
	op->payload = payload;
	size += payload; 
	op->size = size;
	free (strasm);
	return size;
}
","1. switch (buf[1]) {
case 0x01:
2. unsigned short array_size = buf[2] | (buf[3] << 8);
3. len = 0;
4. break;
case 0x02:
5. len = 0;
6. break;
7. unsigned short elem_width = buf[2] | (buf[3] << 8);
8. ""fill-array-data-payload %d, %d"",
elem_width, array_size);
9. size = 8;
10. strasm = NULL;
if (size <= len) {
strncpy (op->buf_asm, dalvik_opcodes[i].name, sizeof (op->buf_asm) - 1);
11. switch (dalvik_opcodes[i].fmt) {
12. snprintf (str, sizeof (str), "" v%i, v%i"", vA, vB);
13. case fmtopvAAvBBBB:
14. vB = (buf[3] << 8) | buf[2];
15. break;
16. vA = (buf[3] << 8) | buf[2];
vB = (buf[5] << 8) | buf[4];
17. snprintf (str, sizeof (str), "" v%i"", vA);
strasm = r_str_concat (strasm, str);
break;
18. vA = buf[1] & 0x0f;
vB = (buf[1] & 0xf0) >> 4;
19. strasm = r_str_concat (strasm, str);
20. short sB = (buf[3] << 8) | buf[2];
21. strasm = r_str_concat (strasm, str);
22. break;
case fmtopvAAcBBBBBBBB:
23. break;
case fmtopvAAcBBBB0000:
vA = (int) buf[1];
vB = 0 | (buf[2] << 16) | (buf[3] << 24);
24. snprintf (str, sizeof (str), "" v%i:v%i, 0x%08x"", vA, vA + 1, vB);
} else {
snprintf (str, sizeof (str), "" v%i, 0x%08x"", vA, vB);
25. strasm = r_str_concat (strasm, str);
26. case fmtopvAAcBBBBBBBBBBBBBBBB:
vA = (int) buf[1];
27. vB = (int) buf[2];
28. snprintf (str, sizeof (str), "" v%i, v%i, v%i"", vA, vB, vC);
29. break;
30. vA = (int) buf[1];
vB = (int) buf[2];
vC = (int) buf[3];
snprintf (str, sizeof (str), "" v%i, v%i, %#x"", vA, vB, vC);
strasm = r_str_concat (strasm, str);
31. vA = buf[1] & 0x0f;
32. vC = (buf[3] << 8) | buf[2];
snprintf (str, sizeof (str), "" v%i, v%i, %#x"", vA, vB, vC);
strasm = r_str_concat (strasm, str);
33. case fmtoppAA:
vA = (char) buf[1];
34. strasm = r_str_concat (strasm, str);
35. case fmtopvAApBBBB:
36. case fmtoppAAAAAAAA:
37. break;
case fmtopvAvBpCCCC:
38. case fmtopvAApBBBBBBBB:
vA = (int) buf[1];
vB = (int) (buf[2] | (buf[3] << 8) | (buf[4] << 16) | (buf[5] << 24));
39. strasm = r_str_concat (strasm, str);
break;
40. *str = 0;
41. case 1:
42. snprintf (str, sizeof (str), "", [%04x]"", vB);
strasm = r_str_concat (strasm, str);
break;
case fmtoptinlineIR:
case fmtoptinvokeVSR:
vA = (int) buf[1];
vB = (buf[3] << 8) | buf[2];
vC = (buf[5] << 8) | buf[4];
43. case fmtoptinvokeVS:
44. vB = (buf[3] << 8) | buf[2];
45. case 1:
46. break;
case 3:
snprintf (str, sizeof (str), "" {v%i, v%i, v%i}"", buf[4] & 0x0f,
(buf[4] & 0xf0) >> 4, buf[5] & 0x0f);
47. case 4:
48. (buf[4] & 0xf0) >> 4, buf[5] & 0x0f, (buf[5] & 0xf0) >> 4);
49. default:
50. strasm = r_str_concat (strasm, str);
snprintf (str, sizeof (str), "", [%04x]"", vB);
51. case fmtopvAAtBBBB:
52. snprintf (str, sizeof (str), "" v%i, string+%i"", vA, vB);
} else {
53. } else if (buf[0] == 0x1c || buf[0] == 0x1f || buf[0] == 0x22) {
54. if (!flag_str) {
snprintf (str, sizeof (str), "" v%i, field+%i"", vA, vB);
} else {
snprintf (str, sizeof (str), "" v%i, %s"", vA, flag_str);
55. strasm = r_str_concat (strasm, str);
56. case fmtoptopvAvBoCCCC:
vA = (buf[1] & 0x0f);
vB = (buf[1] & 0xf0) >> 4;
57. offset = R_ASM_GET_OFFSET (a, 'o', vC);
if (offset == -1) {
58. break;
59. vB = (buf[3] << 8) | buf[2];
offset = R_ASM_GET_OFFSET (a, 't', vB);
60. } else {
61. strasm = r_str_concat (strasm, str);
break;
case fmtopvAvBtCCCC:
62. vC = (buf[3] << 8) | buf[2];
63. else {
64. if (flag_str) {
65. else {
66. strasm = r_str_concat (strasm, str);
67. vA = (int) buf[1];
68. else {
snprintf (str, sizeof (str), "" {v%i..v%i}, class+%i"", vC, vC + vA - 1, vB);
69. } else {
70. strasm = r_str_concat (strasm, str);
71. vA = (int) (buf[1] & 0xf0) >> 4;
vB = (buf[3] << 8) | buf[2];
switch (vA) {
72. break;
case 2:
73. snprintf (str, sizeof (str), "" {v%i, v%i, v%i}"", buf[4] & 0x0f,
(buf[4] & 0xf0) >> 4, buf[5] & 0x0f);
74. (buf[4] & 0xf0) >> 4, buf[5] & 0x0f, (buf[5] & 0xf0) >> 4);
break;
75. if (buf[0] == 0x24) {
76. } else {
77. if (flag_str) {
snprintf (str, sizeof (str), "", %s ; 0x%x"", flag_str, vB);
78. snprintf (str, sizeof (str), "", method+%i"", vB);
79. strasm = r_str_concat (strasm, str);
80. case fmt00:
default:
81. if (strasm) {
82. } else {
83. size = len;
84. return size;","14-15
17
22
24-25
31
33
36
39-40
43
51-53
56
61
64
66
69
71-72
78-80
82-83
85
90
92
94-95
104-107
109-111
113
115-116
128
130
132
134-138
141
143-145
147-148
151
158
165
170-171
179-181
183-184
188
190
207-214
218
220
222
227-230
232
234
236
240-241
244
250-251
254
263-266
269
271-273
275-276
282
285-286
289
292-294
297
303
308
324
327
330
338-339
341
350
353-355
358-359
363-364
368-369
378
385
387-388
390
394
398-399
405
408
414
420","CWE-476,CWE-400,CWE-787,CWE-119"
generate_password-135746444233206,"int generate_password(int length, unsigned char *password)
{
    const char pwchars[] =
    {
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd',
        'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r',
        's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F',
        'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T',
        'U', 'V', 'W', 'X', 'Y', 'Z', '%', '$'
    };

    FILE *randfp;
    unsigned char pwtemp[MAX_PASSWD_BUF];
    unsigned char *p;
    int i, n;
    int passlen;

    if ((length <= 0) || (length > MAX_PASSWD_LEN))
    {
        fprintf(stderr, ""Invalid password length specified.\n"");
        return -1;
    }

    
    if ((randfp = fopen(""/dev/urandom"", ""r"")) == NULL)
    {
        perror(""Error open /dev/urandom:"");
        return  -1;
    }

    
    if ((n = fread((char*)pwtemp, 1, length, randfp)) != length)
    {
        fprintf(stderr, ""Error: Couldn't read from /dev/urandom\n"");
        fclose(randfp);
        return  -1;
    }
    fclose(randfp);

    
    for (i = 0, p = pwtemp; i < length; i++, p++)
    {
        *p = pwchars[((int)(*p)) % 64];
    }

    
    passlen = passwd_to_utf16(pwtemp, length, MAX_PASSWD_LEN, password);

    return passlen;
}
","1. 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F',
2. 'U', 'V', 'W', 'X', 'Y', 'Z', '%', '$'
3. unsigned char *p;
4. if ((randfp = fopen(""/dev/urandom"", ""r"")) == NULL)
5. fprintf(stderr, ""Error: Couldn't read from /dev/urandom\n"");
6. *p = pwchars[((int)(*p)) % 64];
7. passlen = passwd_to_utf16(pwtemp, length, MAX_PASSWD_LEN, password);","7
9
14
25
34
43
47","CWE-476,CWE-120,CWE-125,CWE-416"
rdp_write_logon_info_v1-197175619083652,"static BOOL rdp_write_logon_info_v1(wStream* s, logon_info* info)
{
	const size_t charLen = 52 / sizeof(WCHAR);
	const size_t userCharLen = 512 / sizeof(WCHAR);

	size_t sz = 4 + 52 + 4 + 512 + 4;
	size_t len = 0;

	if (!Stream_EnsureRemainingCapacity(s, sz))
		return FALSE;

	
	WINPR_ASSERT(info);
	if (!info->domain || !info->username)
		return FALSE;

	len = strnlen(info->domain, charLen + 1);
	if (len > charLen)
		return FALSE;

	Stream_Write_UINT32(s, len * sizeof(WCHAR));
	if (Stream_Write_UTF16_String_From_UTF8(s, charLen, info->domain, len, TRUE) < 0)
		return FALSE;

	
	len = strnlen(info->username, userCharLen + 1);
	if (len > userCharLen)
		return FALSE;

	Stream_Write_UINT32(s, len * sizeof(WCHAR));
	if (Stream_Write_UTF16_String_From_UTF8(s, userCharLen, info->username, len, TRUE) < 0)
		return FALSE;

	
	Stream_Write_UINT32(s, info->sessionId);
	return TRUE;
}
","1. static BOOL rdp_write_logon_info_v1(wStream* s, logon_info* info)
2. const size_t charLen = 52 / sizeof(WCHAR);
const size_t userCharLen = 512 / sizeof(WCHAR);
3. size_t len = 0;
4. return FALSE;
5. WINPR_ASSERT(info);
if (!info->domain || !info->username)
6. return FALSE;
7. return FALSE;
8. len = strnlen(info->username, userCharLen + 1);
if (len > userCharLen)
9. if (Stream_Write_UTF16_String_From_UTF8(s, userCharLen, info->username, len, TRUE) < 0)
return FALSE;
10. return TRUE;","1
3-4
7
10
13-14
19
23
26-27
31-32
36","CWE-119,CWE-362,CWE-125,CWE-189"
main_32,"main_32 (int    argc,
       char **argv)
 {
   mode_t old_umask;
  const char *base_path = NULL;
   int clone_flags;
   char *old_cwd = NULL;
   pid_t pid;
  int event_fd = -1;
  int child_wait_fd = -1;
  int setup_finished_pipe[] = {-1, -1};
  const char *new_cwd;
  uid_t ns_uid;
  gid_t ns_gid;
  struct stat sbuf;
  uint64_t val;
  int res UNUSED;
  cleanup_free char *seccomp_data = NULL;
  size_t seccomp_len;
  struct sock_fprog seccomp_prog;
  cleanup_free char *args_data = NULL;

  
  if (argc == 2 && (strcmp (argv[1], ""--version"") == 0))
    print_version_and_exit ();

  real_uid = getuid ();
  real_gid = getgid ();

  
  acquire_privs ();

  
  if (prctl (PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) < 0)
    die_with_error (""prctl(PR_SET_NO_NEW_CAPS) failed"");

  

  read_overflowids ();

  argv0 = argv[0];

  if (isatty (1))
    host_tty_dev = ttyname (1);

  argv++;
  argc--;

  if (argc == 0)
    usage (EXIT_FAILURE, stderr);

  parse_args (&argc, (const char ***) &argv);

  
  args_data = opt_args_data;
  opt_args_data = NULL;

  if ((requested_caps[0] || requested_caps[1]) && is_privileged)
    die (""--cap-add in setuid mode can be used only by root"");

  if (opt_userns_block_fd != -1 && !opt_unshare_user)
    die (""--userns-block-fd requires --unshare-user"");

  if (opt_userns_block_fd != -1 && opt_info_fd == -1)
    die (""--userns-block-fd requires --info-fd"");

  
  if (!is_privileged && getuid () != 0)
    opt_unshare_user = TRUE;

#ifdef ENABLE_REQUIRE_USERNS
  
  if (is_privileged && getuid () != 0)
    opt_unshare_user = TRUE;
#endif

  if (opt_unshare_user_try &&
      stat (""/proc/self/ns/user"", &sbuf) == 0)
    {
      bool disabled = FALSE;

      
      if (stat (""/sys/module/user_namespace/parameters/enable"", &sbuf) == 0)
        {
          cleanup_free char *enable = NULL;
          enable = load_file_at (AT_FDCWD, ""/sys/module/user_namespace/parameters/enable"");
          if (enable != NULL && enable[0] == 'N')
            disabled = TRUE;
        }

      
      if (stat (""/proc/sys/user/max_user_namespaces"", &sbuf) == 0)
        {
          cleanup_free char *max_user_ns = NULL;
          max_user_ns = load_file_at (AT_FDCWD, ""/proc/sys/user/max_user_namespaces"");
          if (max_user_ns != NULL && strcmp(max_user_ns, ""0\n"") == 0)
            disabled = TRUE;
        }

      

      if (!disabled)
        opt_unshare_user = TRUE;
    }

  if (argc == 0)
    usage (EXIT_FAILURE, stderr);

  __debug__ ((""Creating root mount point\n""));

  if (opt_sandbox_uid == -1)
    opt_sandbox_uid = real_uid;
  if (opt_sandbox_gid == -1)
    opt_sandbox_gid = real_gid;

  if (!opt_unshare_user && opt_sandbox_uid != real_uid)
    die (""Specifying --uid requires --unshare-user"");

  if (!opt_unshare_user && opt_sandbox_gid != real_gid)
    die (""Specifying --gid requires --unshare-user"");

  if (!opt_unshare_uts && opt_sandbox_hostname != NULL)
    die (""Specifying --hostname requires --unshare-uts"");

  if (opt_as_pid_1 && !opt_unshare_pid)
    die (""Specifying --as-pid-1 requires --unshare-pid"");

  if (opt_as_pid_1 && lock_files != NULL)
    die (""Specifying --as-pid-1 and --lock-file is not permitted"");

  
  proc_fd = open (""/proc"", O_PATH);
  if (proc_fd == -1)
     die_with_error (""Can't open /proc"");
 
   
  base_path = ""/tmp"";
 
   __debug__ ((""creating new namespace\n""));
 
  if (opt_unshare_pid && !opt_as_pid_1)
    {
      event_fd = eventfd (0, EFD_CLOEXEC | EFD_NONBLOCK);
      if (event_fd == -1)
        die_with_error (""eventfd()"");
    }

  
  block_sigchild ();

  clone_flags = SIGCHLD | CLONE_NEWNS;
  if (opt_unshare_user)
    clone_flags |= CLONE_NEWUSER;
  if (opt_unshare_pid)
    clone_flags |= CLONE_NEWPID;
  if (opt_unshare_net)
    clone_flags |= CLONE_NEWNET;
  if (opt_unshare_ipc)
    clone_flags |= CLONE_NEWIPC;
  if (opt_unshare_uts)
    clone_flags |= CLONE_NEWUTS;
  if (opt_unshare_cgroup)
    {
      if (stat (""/proc/self/ns/cgroup"", &sbuf))
        {
          if (errno == ENOENT)
            die (""Cannot create new cgroup namespace because the kernel does not support it"");
          else
            die_with_error (""stat on /proc/self/ns/cgroup failed"");
        }
      clone_flags |= CLONE_NEWCGROUP;
    }
  if (opt_unshare_cgroup_try)
    if (!stat (""/proc/self/ns/cgroup"", &sbuf))
      clone_flags |= CLONE_NEWCGROUP;

  child_wait_fd = eventfd (0, EFD_CLOEXEC);
  if (child_wait_fd == -1)
    die_with_error (""eventfd()"");

  
  if (opt_json_status_fd != -1)
    {
      int ret;
      ret = pipe2 (setup_finished_pipe, O_CLOEXEC);
      if (ret == -1)
        die_with_error (""pipe2()"");
    }

  pid = raw_clone (clone_flags, NULL);
  if (pid == -1)
    {
      if (opt_unshare_user)
        {
          if (errno == EINVAL)
            die (""Creating new namespace failed, likely because the kernel does not support user namespaces.  bwrap must be installed setuid on such systems."");
          else if (errno == EPERM && !is_privileged)
            die (""No permissions to creating new namespace, likely because the kernel does not allow non-privileged user namespaces. On e.g. debian this can be enabled with 'sysctl kernel.unprivileged_userns_clone=1'."");
        }

      die_with_error (""Creating new namespace failed"");
    }

  ns_uid = opt_sandbox_uid;
  ns_gid = opt_sandbox_gid;

  if (pid != 0)
    {
      

      if (is_privileged && opt_unshare_user && opt_userns_block_fd == -1)
        {
          
          write_uid_gid_map (ns_uid, real_uid,
                             ns_gid, real_gid,
                             pid, TRUE, opt_needs_devpts);
        }

      

      
      drop_privs (FALSE);

      
      handle_die_with_parent ();

      if (opt_info_fd != -1)
        {
          cleanup_free char *output = xasprintf (""{\n    \""child-pid\"": %i\n}\n"", pid);
          dump_info (opt_info_fd, output, TRUE);
          close (opt_info_fd);
        }
      if (opt_json_status_fd != -1)
        {
          cleanup_free char *output = xasprintf (""{ \""child-pid\"": %i }\n"", pid);
          dump_info (opt_json_status_fd, output, TRUE);
        }

      if (opt_userns_block_fd != -1)
        {
          char b[1];
          (void) TEMP_FAILURE_RETRY (read (opt_userns_block_fd, b, 1));
          close (opt_userns_block_fd);
        }

      
      val = 1;
      res = write (child_wait_fd, &val, 8);
      
      close (child_wait_fd);

      return monitor_child (event_fd, pid, setup_finished_pipe[0]);
    }

  

  if (opt_info_fd != -1)
    close (opt_info_fd);

  if (opt_json_status_fd != -1)
    close (opt_json_status_fd);

  
  res = read (child_wait_fd, &val, 8);
  close (child_wait_fd);

  
  switch_to_user_with_privs ();

  if (opt_unshare_net)
    loopback_setup (); 

  ns_uid = opt_sandbox_uid;
  ns_gid = opt_sandbox_gid;
  if (!is_privileged && opt_unshare_user && opt_userns_block_fd == -1)
    {
      

      if (opt_needs_devpts)
        {
          
          ns_uid = 0;
          ns_gid = 0;
        }

      write_uid_gid_map (ns_uid, real_uid,
                         ns_gid, real_gid,
                         -1, TRUE, FALSE);
    }

  old_umask = umask (0);

  
  resolve_symlinks_in_ops ();

  
  if (mount (NULL, ""/"", NULL, MS_SLAVE | MS_REC, NULL) < 0)
    die_with_error (""Failed to make / slave"");

  
  if (mount (""tmpfs"", base_path, ""tmpfs"", MS_NODEV | MS_NOSUID, NULL) != 0)
    die_with_error (""Failed to mount tmpfs"");

  old_cwd = get_current_dir_name ();

  
  if (chdir (base_path) != 0)
    die_with_error (""chdir base_path"");

   
 
   if (mkdir (""newroot"", 0755))
     die_with_error (""Creating newroot failed"");

  if (mount (""newroot"", ""newroot"", NULL, MS_MGC_VAL | MS_BIND | MS_REC, NULL) < 0)
    die_with_error (""setting up newroot bind"");

  if (mkdir (""oldroot"", 0755))
    die_with_error (""Creating oldroot failed"");

  if (pivot_root (base_path, ""oldroot""))
    die_with_error (""pivot_root"");

  if (chdir (""/"") != 0)
    die_with_error (""chdir / (base path)"");

  if (is_privileged)
    {
      pid_t child;
      int privsep_sockets[2];

      if (socketpair (AF_UNIX, SOCK_SEQPACKET | SOCK_CLOEXEC, 0, privsep_sockets) != 0)
        die_with_error (""Can't create privsep socket"");

      child = fork ();
      if (child == -1)
        die_with_error (""Can't fork unprivileged helper"");

      if (child == 0)
        {
          
          drop_privs (FALSE);
          close (privsep_sockets[0]);
          setup_newroot (opt_unshare_pid, privsep_sockets[1]);
          exit (0);
        }
      else
        {
          int status;
          uint32_t buffer[2048];  
          uint32_t op, flags;
          const char *arg1, *arg2;
          cleanup_fd int unpriv_socket = -1;

          unpriv_socket = privsep_sockets[0];
          close (privsep_sockets[1]);

          do
            {
              op = read_priv_sec_op (unpriv_socket, buffer, sizeof (buffer),
                                     &flags, &arg1, &arg2);
              privileged_op (-1, op, flags, arg1, arg2);
              if (write (unpriv_socket, buffer, 1) != 1)
                die (""Can't write to op_socket"");
            }
          while (op != PRIV_SEP_OP_DONE);

          waitpid (child, &status, 0);
          
        }
    }
  else
    {
      setup_newroot (opt_unshare_pid, -1);
    }

  close_ops_fd ();

  
  if (mount (""oldroot"", ""oldroot"", NULL, MS_REC | MS_PRIVATE, NULL) != 0)
    die_with_error (""Failed to make old root rprivate"");

  if (umount2 (""oldroot"", MNT_DETACH))
    die_with_error (""unmount old root"");

  
  { cleanup_fd int oldrootfd = open (""/"", O_DIRECTORY | O_RDONLY);
    if (oldrootfd < 0)
      die_with_error (""can't open /"");
    if (chdir (""/newroot"") != 0)
      die_with_error (""chdir /newroot"");
    
    if (pivot_root (""."", ""."") != 0)
      die_with_error (""pivot_root(/newroot)"");
    if (fchdir (oldrootfd) < 0)
      die_with_error (""fchdir to oldroot"");
    if (umount2 (""."", MNT_DETACH) < 0)
      die_with_error (""umount old root"");
    if (chdir (""/"") != 0)
      die_with_error (""chdir /"");
  }

  if (opt_unshare_user &&
      (ns_uid != opt_sandbox_uid || ns_gid != opt_sandbox_gid) &&
      opt_userns_block_fd == -1)
    {
      

      if (unshare (CLONE_NEWUSER))
        die_with_error (""unshare user ns"");

      write_uid_gid_map (opt_sandbox_uid, ns_uid,
                         opt_sandbox_gid, ns_gid,
                         -1, FALSE, FALSE);
    }

  
  drop_privs (!is_privileged);

  if (opt_block_fd != -1)
    {
      char b[1];
      (void) TEMP_FAILURE_RETRY (read (opt_block_fd, b, 1));
      close (opt_block_fd);
    }

  if (opt_seccomp_fd != -1)
    {
      seccomp_data = load_file_data (opt_seccomp_fd, &seccomp_len);
      if (seccomp_data == NULL)
        die_with_error (""Can't read seccomp data"");

      if (seccomp_len % 8 != 0)
        die (""Invalid seccomp data, must be multiple of 8"");

      seccomp_prog.len = seccomp_len / 8;
      seccomp_prog.filter = (struct sock_filter *) seccomp_data;

      close (opt_seccomp_fd);
    }

  umask (old_umask);

  new_cwd = ""/"";
  if (opt_chdir_path)
    {
      if (chdir (opt_chdir_path))
        die_with_error (""Can't chdir to %s"", opt_chdir_path);
      new_cwd = opt_chdir_path;
    }
  else if (chdir (old_cwd) == 0)
    {
      
      new_cwd = old_cwd;
    }
  else
    {
      
      const char *home = getenv (""HOME"");
      if (home != NULL &&
          chdir (home) == 0)
        new_cwd = home;
    }
  xsetenv (""PWD"", new_cwd, 1);
  free (old_cwd);

  if (opt_new_session &&
      setsid () == (pid_t) -1)
    die_with_error (""setsid"");

  if (label_exec (opt_exec_label) == -1)
    die_with_error (""label_exec %s"", argv[0]);

  __debug__ ((""forking for child\n""));

  if (!opt_as_pid_1 && (opt_unshare_pid || lock_files != NULL || opt_sync_fd != -1))
    {
      

      pid = fork ();
      if (pid == -1)
        die_with_error (""Can't fork for pid 1"");

      if (pid != 0)
        {
          drop_all_caps (FALSE);

          
          {
            int dont_close[3];
            int j = 0;
            if (event_fd != -1)
              dont_close[j++] = event_fd;
            if (opt_sync_fd != -1)
              dont_close[j++] = opt_sync_fd;
            dont_close[j++] = -1;
            fdwalk (proc_fd, close_extra_fds, dont_close);
          }

          return do_init (event_fd, pid, seccomp_data != NULL ? &seccomp_prog : NULL);
        }
    }

  __debug__ ((""launch executable %s\n"", argv[0]));

  if (proc_fd != -1)
    close (proc_fd);

  
  if (!opt_as_pid_1)
    {
      if (opt_sync_fd != -1)
        close (opt_sync_fd);
    }

  
  unblock_sigchild ();

  
  handle_die_with_parent ();

  if (!is_privileged)
    set_ambient_capabilities ();

  
  if (seccomp_data != NULL &&
      prctl (PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &seccomp_prog) != 0)
    die_with_error (""prctl(PR_SET_SECCOMP)"");

  if (setup_finished_pipe[1] != -1)
    {
      char data = 0;
      res = write_to_fd (setup_finished_pipe[1], &data, 1);
      
    }

  if (execvp (argv[0], argv) == -1)
    {
      if (setup_finished_pipe[1] != -1)
        {
          int saved_errno = errno;
          char data = 0;
          res = write_to_fd (setup_finished_pipe[1], &data, 1);
          errno = saved_errno;
          
        }
      die_with_error (""execvp %s"", argv[0]);
    }

  return 0;
}
","1. gid_t ns_gid;
2. if (argc == 2 && (strcmp (argv[1], ""--version"") == 0))
3. if (opt_userns_block_fd != -1 && opt_info_fd == -1)
4. clone_flags = SIGCHLD | CLONE_NEWNS;
5. pid, TRUE, opt_needs_devpts);
6. if (opt_userns_block_fd != -1)
7. close (opt_userns_block_fd);
8. ns_gid = opt_sandbox_gid;
9. die_with_error (""Creating oldroot failed"");
10. op = read_priv_sec_op (unpriv_socket, buffer, sizeof (buffer),
11. (void) TEMP_FAILURE_RETRY (read (opt_block_fd, b, 1));
12. if (proc_fd != -1)","14
28
69
165
237
260
264
310
366
407
486
577","CWE-20,CWE-476,CWE-190,CWE-787,CWE-119"
f_hidg_write,"
#define __user

static ssize_t f_hidg_write(struct file *file, const char __user *buffer,
			    size_t count, loff_t *offp)
{
	struct f_hidg *hidg  = file->private_data;
	struct usb_request *req;
	unsigned long flags;
	ssize_t status = -ENOMEM;

	if (!access_ok(buffer, count))
		return -EFAULT;

	spin_lock_irqsave(&hidg->write_spinlock, flags);

#define WRITE_COND (!hidg->write_pending)
try_again:
	
	while (!WRITE_COND) {
		spin_unlock_irqrestore(&hidg->write_spinlock, flags);
		if (file->f_flags & O_NONBLOCK)
			return -EAGAIN;

		if (wait_event_interruptible_exclusive(
				hidg->write_queue, WRITE_COND))
			return -ERESTARTSYS;

		spin_lock_irqsave(&hidg->write_spinlock, flags);
	}

	hidg->write_pending = 1;
	req = hidg->req;
	count  = min_t(unsigned, count, hidg->report_length);

	spin_unlock_irqrestore(&hidg->write_spinlock, flags);
	status = copy_from_user(req->buf, buffer, count);

	if (status != 0) {
		ERROR(hidg->func.config->cdev,
			""copy_from_user error\n"");
		status = -EINVAL;
		goto release_write_pending;
	}

	spin_lock_irqsave(&hidg->write_spinlock, flags);

	
	if (!hidg->req) {
		free_ep_req(hidg->in_ep, req);
		
		goto try_again;
	}

	req->status   = 0;
	req->zero     = 0;
	req->length   = count;
 	req->complete = f_hidg_req_complete;
 	req->context  = hidg;
 
	spin_unlock_irqrestore(&hidg->write_spinlock, flags);

 	status = usb_ep_queue(hidg->in_ep, req, GFP_ATOMIC);
 	if (status < 0) {
 		ERROR(hidg->func.config->cdev,
 			""usb_ep_queue error on int endpoint %zd\n"", status);
		goto release_write_pending;
 	} else {
 		status = count;
 	}
 
 	return status;
 release_write_pending:
 	spin_lock_irqsave(&hidg->write_spinlock, flags);
 	hidg->write_pending = 0;
 	spin_unlock_irqrestore(&hidg->write_spinlock, flags);
 
	wake_up(&hidg->write_queue);

	return status;
}
","1. size_t count, loff_t *offp)
2. unsigned long flags;
3. spin_unlock_irqrestore(&hidg->write_spinlock, flags);
4. spin_lock_irqsave(&hidg->write_spinlock, flags);
5. wake_up(&hidg->write_queue);","5
9
21
77
81","CWE-667,CWE-190,CWE-119"
__rds_conn_create_2-259526122432587,"static struct rds_connection *__rds_conn_create_2(struct net *net,
						const struct in6_addr *laddr,
						const struct in6_addr *faddr,
						struct rds_transport *trans,
						gfp_t gfp, u8 tos,
						int is_outgoing,
						int dev_if)
{
	struct rds_connection *conn, *parent = NULL;
	struct hlist_head *head = rds_conn_bucket(laddr, faddr);
	struct rds_transport *loop_trans;
	unsigned long flags;
	int ret, i;
	int npaths = (trans->t_mp_capable ? RDS_MPATH_WORKERS : 1);

	rcu_read_lock();
	conn = rds_conn_lookup(net, head, laddr, faddr, trans, tos, dev_if);
	if (conn &&
	    conn->c_loopback &&
	    conn->c_trans != &rds_loop_transport &&
	    ipv6_addr_equal(laddr, faddr) &&
	    !is_outgoing) {
		
		parent = conn;
		conn = parent->c_passive;
	}
	rcu_read_unlock();
	if (conn)
		goto out;

	conn = kmem_cache_zalloc(rds_conn_slab, gfp);
	if (!conn) {
		conn = ERR_PTR(-ENOMEM);
		goto out;
	}
	conn->c_path = kcalloc(npaths, sizeof(struct rds_conn_path), gfp);
	if (!conn->c_path) {
		kmem_cache_free(rds_conn_slab, conn);
		conn = ERR_PTR(-ENOMEM);
		goto out;
	}

	INIT_HLIST_NODE(&conn->c_hash_node);
	conn->c_laddr = *laddr;
	conn->c_isv6 = !ipv6_addr_v4mapped(laddr);
	conn->c_faddr = *faddr;
	conn->c_dev_if = dev_if;
	conn->c_tos = tos;

#if IS_ENABLED(CONFIG_IPV6)
	
	if (ipv6_addr_type(laddr) & IPV6_ADDR_LINKLOCAL)
		conn->c_bound_if = dev_if;
	else
#endif
		conn->c_bound_if = 0;

	rds_conn_net_set(conn, net);

	ret = rds_cong_get_maps(conn);
	if (ret) {
		kfree(conn->c_path);
		kmem_cache_free(rds_conn_slab, conn);
		conn = ERR_PTR(ret);
		goto out;
	}

	
	loop_trans = rds_trans_get_preferred(net, faddr, conn->c_dev_if);
	if (loop_trans) {
		rds_trans_put(loop_trans);
		conn->c_loopback = 1;
		if (trans->t_prefer_loopback) {
			if (likely(is_outgoing)) {
				
				trans = &rds_loop_transport;
			} else {
				
				kfree(conn->c_path);
				kmem_cache_free(rds_conn_slab, conn);
				conn = ERR_PTR(-EOPNOTSUPP);
				goto out;
			}
		}
	}

	conn->c_trans = trans;

	init_waitqueue_head(&conn->c_hs_waitq);
	for (i = 0; i < npaths; i++) {
		__rds_conn_path_init(conn, &conn->c_path[i],
				     is_outgoing);
		conn->c_path[i].cp_index = i;
	}
	rcu_read_lock();
	if (rds_destroy_pending(conn))
		ret = -ENETDOWN;
	else
		ret = trans->conn_alloc(conn, GFP_ATOMIC);
	if (ret) {
		rcu_read_unlock();
		kfree(conn->c_path);
		kmem_cache_free(rds_conn_slab, conn);
		conn = ERR_PTR(ret);
		goto out;
	}

	rdsdebug(""allocated conn %p for %pI6c -> %pI6c over %s %s\n"",
		 conn, laddr, faddr,
		 strnlen(trans->t_name, sizeof(trans->t_name)) ?
		 trans->t_name : ""[unknown]"", is_outgoing ? ""(outgoing)"" : """");

	
	spin_lock_irqsave(&rds_conn_lock, flags);
	if (parent) {
		
		if (parent->c_passive) {
			trans->conn_free(conn->c_path[0].cp_transport_data);
			kfree(conn->c_path);
			kmem_cache_free(rds_conn_slab, conn);
			conn = parent->c_passive;
		} else {
			parent->c_passive = conn;
			rds_cong_add_conn(conn);
			rds_conn_count++;
		}
	} else {
		
		struct rds_connection *found;

		found = rds_conn_lookup(net, head, laddr, faddr, trans,
					tos, dev_if);
		if (found) {
			struct rds_conn_path *cp;
			int i;

			for (i = 0; i < npaths; i++) {
				cp = &conn->c_path[i];
				
				if (cp->cp_transport_data)
					trans->conn_free(cp->cp_transport_data);
			}
			kfree(conn->c_path);
			kmem_cache_free(rds_conn_slab, conn);
			conn = found;
		} else {
			conn->c_my_gen_num = rds_gen_num;
			conn->c_peer_gen_num = 0;
			hlist_add_head_rcu(&conn->c_hash_node, head);
			rds_cong_add_conn(conn);
			rds_conn_count++;
		}
	}
	spin_unlock_irqrestore(&rds_conn_lock, flags);
	rcu_read_unlock();

out:
	return conn;
}
","1. static struct rds_connection *__rds_conn_create_2(struct net *net,
2. gfp_t gfp, u8 tos,
3. struct hlist_head *head = rds_conn_bucket(laddr, faddr);
struct rds_transport *loop_trans;
4. conn = rds_conn_lookup(net, head, laddr, faddr, trans, tos, dev_if);
5. conn->c_loopback &&
6. if (conn)
7. goto out;
8. conn->c_isv6 = !ipv6_addr_v4mapped(laddr);
9. conn->c_dev_if = dev_if;
10. conn->c_bound_if = 0;
11. rds_conn_net_set(conn, net);
12. kfree(conn->c_path);
kmem_cache_free(rds_conn_slab, conn);
conn = ERR_PTR(-EOPNOTSUPP);
13. for (i = 0; i < npaths; i++) {
14. rcu_read_lock();
15. ret = trans->conn_alloc(conn, GFP_ATOMIC);
16. kmem_cache_free(rds_conn_slab, conn);
17. conn, laddr, faddr,
18. trans->t_name : ""[unknown]"", is_outgoing ? ""(outgoing)"" : """");
19. spin_lock_irqsave(&rds_conn_lock, flags);
20. kfree(conn->c_path);
21. conn = parent->c_passive;
22. parent->c_passive = conn;
rds_cong_add_conn(conn);
23. if (found) {
24. kfree(conn->c_path);
kmem_cache_free(rds_conn_slab, conn);
25. conn->c_peer_gen_num = 0;
26. rds_conn_count++;
27. rcu_read_unlock();","1
5
10-11
17
19
31
43
48
50
63
65
97-99
108
113
117
121
127
129
138
143
145
147-148
157
170-171
175
178
182","CWE-362,CWE-20,CWE-399"
message_add_body_amqp_data-102573125383836,"
#define BINARY_DATA
#define MESSAGE_HANDLE

int message_add_body_amqp_data(MESSAGE_HANDLE message, BINARY_DATA amqp_data)
{
    int result;

    
    if ((message == NULL) ||
        
        ((amqp_data.bytes == NULL) &&
         (amqp_data.length != 0)))
    {
        LogError(""Bad arguments: message = %p, bytes = %p, length = %u"",
            message, amqp_data.bytes, (unsigned int)amqp_data.length);
        result = MU_FAILURE;
    }
    else
    {
        MESSAGE_BODY_TYPE body_type = internal_get_body_type(message);
        if ((body_type == MESSAGE_BODY_TYPE_SEQUENCE) ||
            (body_type == MESSAGE_BODY_TYPE_VALUE))
        {
            
            LogError(""Body type already set"");
            result = MU_FAILURE;
        }
        else
        {
            size_t realloc_size = safe_add_size_t(message->body_amqp_data_count, 1);
            realloc_size = safe_multiply_size_t(sizeof(BODY_AMQP_DATA), realloc_size);

            if (realloc_size == SIZE_MAX)
            {
                LogError(""Invalid size for new_body_amqp_data_items"");
                result = MU_FAILURE;
            }
            else
            {
                
                BODY_AMQP_DATA* new_body_amqp_data_items = (BODY_AMQP_DATA*)realloc(message->body_amqp_data_items, realloc_size);
                if (new_body_amqp_data_items == NULL)
                {
                    
                    LogError(""Cannot allocate memory for body AMQP data items"");
                    result = MU_FAILURE;
                }
                else
                {
                    message->body_amqp_data_items = new_body_amqp_data_items;

                    if (amqp_data.length == 0)
                    {
                        message->body_amqp_data_items[message->body_amqp_data_count].body_data_section_bytes = NULL;
                        message->body_amqp_data_items[message->body_amqp_data_count].body_data_section_length = 0;
                        message->body_amqp_data_count++;

                        
                        result = 0;
                    }
                    else
                    {
                        message->body_amqp_data_items[message->body_amqp_data_count].body_data_section_bytes = (unsigned char*)malloc(amqp_data.length);
                        if (message->body_amqp_data_items[message->body_amqp_data_count].body_data_section_bytes == NULL)
                        {
                            
                            LogError(""Cannot allocate memory for body AMQP data to be added"");
                            result = MU_FAILURE;
                        }
                        else
                        {
                            message->body_amqp_data_items[message->body_amqp_data_count].body_data_section_length = amqp_data.length;
                            (void)memcpy(message->body_amqp_data_items[message->body_amqp_data_count].body_data_section_bytes, amqp_data.bytes, amqp_data.length);
                            message->body_amqp_data_count++;

                            
                            result = 0;
                        }
                    }
                }
            }
        }
    }

    return result;
}
","1. int result;
2. (amqp_data.length != 0)))
3. MESSAGE_BODY_TYPE body_type = internal_get_body_type(message);
4. {
5. {
6. if (amqp_data.length == 0)
7. message->body_amqp_data_items[message->body_amqp_data_count].body_data_section_bytes = NULL;
message->body_amqp_data_items[message->body_amqp_data_count].body_data_section_length = 0;
message->body_amqp_data_count++;
8. result = 0;
9. if (message->body_amqp_data_items[message->body_amqp_data_count].body_data_section_bytes == NULL)
10. result = MU_FAILURE;
11. message->body_amqp_data_items[message->body_amqp_data_count].body_data_section_length = amqp_data.length;
12. message->body_amqp_data_count++;
13. result = 0;
14. return result;","7
13
21
30
50
53
55-57
60
65
69
73
75
78
86","CWE-190,CWE-19,CWE-189,CWE-401"
tomoyo_mount_acl-39443477625656,"static int tomoyo_mount_acl(struct tomoyo_request_info *r, char *dev_name,
			    struct path *dir, char *type, unsigned long flags)
{
	struct path path;
	struct file_system_type *fstype = NULL;
	const char *requested_type = NULL;
	const char *requested_dir_name = NULL;
	const char *requested_dev_name = NULL;
	struct tomoyo_path_info rtype;
	struct tomoyo_path_info rdev;
	struct tomoyo_path_info rdir;
	int need_dev = 0;
	int error = -ENOMEM;

	
	requested_type = tomoyo_encode(type);
	if (!requested_type)
		goto out;
	rtype.name = requested_type;
	tomoyo_fill_path_info(&rtype);

	
	requested_dir_name = tomoyo_realpath_from_path(dir);
	if (!requested_dir_name) {
		error = -ENOMEM;
		goto out;
	}
	rdir.name = requested_dir_name;
	tomoyo_fill_path_info(&rdir);

	
	if (!strcmp(type, TOMOYO_MOUNT_REMOUNT_KEYWORD)) {
		
	} else if (!strcmp(type, TOMOYO_MOUNT_MAKE_UNBINDABLE_KEYWORD) ||
		   !strcmp(type, TOMOYO_MOUNT_MAKE_PRIVATE_KEYWORD) ||
		   !strcmp(type, TOMOYO_MOUNT_MAKE_SLAVE_KEYWORD) ||
		   !strcmp(type, TOMOYO_MOUNT_MAKE_SHARED_KEYWORD)) {
		
	} else if (!strcmp(type, TOMOYO_MOUNT_BIND_KEYWORD) ||
		   !strcmp(type, TOMOYO_MOUNT_MOVE_KEYWORD)) {
		need_dev = -1; 
	} else {
		fstype = get_fs_type(type);
		if (!fstype) {
			error = -ENODEV;
			goto out;
		}
		if (fstype->fs_flags & FS_REQUIRES_DEV)
			
			need_dev = 1;
	}
	if (need_dev) {
		
		if (!dev_name || kern_path(dev_name, LOOKUP_FOLLOW, &path)) {
			error = -ENOENT;
			goto out;
		}
		requested_dev_name = tomoyo_realpath_from_path(&path);
		path_put(&path);
		if (!requested_dev_name) {
			error = -ENOENT;
			goto out;
		}
	} else {
		
		if (!dev_name)
			dev_name = ""<NULL>"";
		requested_dev_name = tomoyo_encode(dev_name);
		if (!requested_dev_name) {
			error = -ENOMEM;
			goto out;
		}
	}
	rdev.name = requested_dev_name;
	tomoyo_fill_path_info(&rdev);
	r->param_type = TOMOYO_TYPE_MOUNT_ACL;
	r->param.mount.need_dev = need_dev;
	r->param.mount.dev = &rdev;
	r->param.mount.dir = &rdir;
	r->param.mount.type = &rtype;
	r->param.mount.flags = flags;
	do {
		tomoyo_check_acl(r, tomoyo_check_mount_acl);
		error = tomoyo_audit_mount_log(r);
	} while (error == TOMOYO_RETRY_REQUEST);
 out:
	kfree(requested_dev_name);
	kfree(requested_dir_name);
	if (fstype)
		put_filesystem(fstype);
	kfree(requested_type);
	return error;
}
","1. error = -ENOMEM;
2. rdir.name = requested_dir_name;
3. } else if (!strcmp(type, TOMOYO_MOUNT_MAKE_UNBINDABLE_KEYWORD) ||
4. need_dev = -1;
5. error = -ENOENT;
goto out;
6. r->param.mount.need_dev = need_dev;","25
28
34
41
55-56
77","CWE-476,CWE-190,CWE-20,CWE-189"
process_options_1-168642278376679,"static void
process_options_1(argc, argv)
int argc;
char *argv[];
{
    int i, l;

    
    while (argc > 1 && argv[1][0] == '-') {
        argv++;
        argc--;
        l = (int) strlen(*argv);
        
        if (l < 4)
            l = 4;

        switch (argv[0][1]) {
        case 'D':
        case 'd':
            if ((argv[0][1] == 'D' && !argv[0][2])
                || !strcmpi(*argv, ""-debug"")) {
                wizard = TRUE, discover = FALSE;
            } else if (!strncmpi(*argv, ""-DECgraphics"", l)) {
                load_symset(""DECGraphics"", PRIMARY);
                switch_symbols(TRUE);
            } else {
                raw_printf(""Unknown option: %.60s"", *argv);
            }
            break;
        case 'X':
            discover = TRUE, wizard = FALSE;
            break;
#ifdef NEWS
        case 'n':
            iflags.news = FALSE;
            break;
#endif
        case 'u':
            if (argv[0][2]) {
                (void) strncpy(plname, argv[0] + 2, sizeof plname - 1);
            } else if (argc > 1) {
                argc--;
                argv++;
                (void) strncpy(plname, argv[0], sizeof plname - 1);
            } else {
                raw_print(""Player name expected after -u"");
            }
            break;
        case 'I':
        case 'i':
            if (!strncmpi(*argv, ""-IBMgraphics"", l)) {
                load_symset(""IBMGraphics"", PRIMARY);
                load_symset(""RogueIBM"", ROGUESET);
                switch_symbols(TRUE);
            } else {
                raw_printf(""Unknown option: %.60s"", *argv);
            }
            break;
        case 'p': 
            if (argv[0][2]) {
                if ((i = str2role(&argv[0][2])) >= 0)
                    flags.initrole = i;
            } else if (argc > 1) {
                argc--;
                argv++;
                if ((i = str2role(argv[0])) >= 0)
                    flags.initrole = i;
            }
            break;
        case 'r': 
            if (argv[0][2]) {
                if ((i = str2race(&argv[0][2])) >= 0)
                    flags.initrace = i;
            } else if (argc > 1) {
                argc--;
                argv++;
                if ((i = str2race(argv[0])) >= 0)
                    flags.initrace = i;
            }
            break;
        case 'w': 
            config_error_init(FALSE, ""command line"", FALSE);
            choose_windows(&argv[0][2]);
            config_error_done();
            break;
        case '@':
            flags.randomall = 1;
            break;
        default:
            if ((i = str2role(&argv[0][1])) >= 0) {
                flags.initrole = i;
                break;
            }
            
        }
    }

#ifdef SYSCF
    if (argc > 1)
        raw_printf(""MAXPLAYERS are set in sysconf file.\n"");
#else
    
    if (argc > 1)
        locknum = atoi(argv[1]);
#endif
#ifdef MAX_NR_OF_PLAYERS
    
    if (!locknum || locknum > MAX_NR_OF_PLAYERS)
        locknum = MAX_NR_OF_PLAYERS;
#endif
#ifdef SYSCF
    
    if (!locknum || (sysopt.maxplayers && locknum > sysopt.maxplayers))
        locknum = sysopt.maxplayers;
#endif
}
","1. static void
2. flags.initrole = i;
3. flags.initrace = i;
4. break;
5. locknum = atoi(argv[1]);","1
64
75
94
106","CWE-476,CWE-416,CWE-310,CWE-119"
do_free_keypair-23270781302394,"static void do_free_keypair(struct rsa_keypair *key)
{
	crypto_bignum_free(&key->e);
	crypto_bignum_free(&key->d);
	crypto_bignum_free(&key->n);
	crypto_bignum_free(&key->p);
	crypto_bignum_free(&key->q);
	crypto_bignum_free(&key->qp);
	crypto_bignum_free(&key->dp);
	crypto_bignum_free(&key->dq);
}
","1. static void do_free_keypair(struct rsa_keypair *key)
2. crypto_bignum_free(&key->e);
crypto_bignum_free(&key->d);
crypto_bignum_free(&key->n);
crypto_bignum_free(&key->p);
crypto_bignum_free(&key->q);
crypto_bignum_free(&key->qp);
crypto_bignum_free(&key->dp);
crypto_bignum_free(&key->dq);","1
3-10","CWE-190,CWE-415"
nfs_find_open_context,"struct nfs_open_context *nfs_find_open_context(struct inode *inode, struct rpc_cred *cred, int mode)
struct nfs_open_context *nfs_find_open_context(struct inode *inode, struct rpc_cred *cred, fmode_t mode)
 {
 	struct nfs_inode *nfsi = NFS_I(inode);
 	struct nfs_open_context *pos, *ctx = NULL;

	spin_lock(&inode->i_lock);
	list_for_each_entry(pos, &nfsi->open_files, list) {
		if (cred != NULL && pos->cred != cred)
			continue;
		if ((pos->mode & mode) == mode) {
			ctx = get_nfs_open_context(pos);
			break;
		}
	}
	spin_unlock(&inode->i_lock);
	return ctx;
}
","1. struct nfs_open_context *nfs_find_open_context(struct inode *inode, struct rpc_cred *cred, fmode_t mode)
2. struct nfs_inode *nfsi = NFS_I(inode);
struct nfs_open_context *pos, *ctx = NULL;
3. spin_lock(&inode->i_lock);
4. continue;
if ((pos->mode & mode) == mode) {
ctx = get_nfs_open_context(pos);
break;
5. return ctx;","2
4-5
7
10-13
17","CWE-1284,CWE-285,CWE-399"
ssl_parse_server_psk_hint,"static int ssl_parse_server_psk_hint( mbedtls_ssl_context *ssl,
                                      unsigned char **p,
                                      unsigned char *end )
{
    int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
    size_t  len;
    ((void) ssl);

    
    if( (*p) > end - 2 )
    {
        MBEDTLS_SSL_DEBUG_MSG( 1, ( ""bad server key exchange message ""
                                    ""(psk_identity_hint length)"" ) );
        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );
    }
     len = (*p)[0] << 8 | (*p)[1];
     *p += 2;
 
    if( (*p) > end - len )
     {
         MBEDTLS_SSL_DEBUG_MSG( 1, ( ""bad server key exchange message ""
                                     ""(psk_identity_hint length)"" ) );
        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );
    }

    
    *p += len;
    ret = 0;

    return( ret );
}
","1. unsigned char **p,
2. MBEDTLS_SSL_DEBUG_MSG( 1, ( ""bad server key exchange message ""
3. *p += 2;","2
16
21","CWE-1284,CWE-20,CWE-134,CWE-269,CWE-119"
pkey_GOST_ECcp_decrypt-244057606127250,"
#define EVP_PKEY_CTX

static int pkey_GOST_ECcp_decrypt(EVP_PKEY_CTX *pctx, unsigned char *key,
                           size_t *key_len, const unsigned char *in,
                           size_t in_len)
{
    const unsigned char *p = in;
    EVP_PKEY *priv = EVP_PKEY_CTX_get0_pkey(pctx);
    GOST_KEY_TRANSPORT *gkt = NULL;
    int ret = 0;
    unsigned char wrappedKey[44];
    unsigned char sharedKey[32];
    gost_ctx ctx;
    const struct gost_cipher_info *param = NULL;
    EVP_PKEY *eph_key = NULL, *peerkey = NULL;
    int dgst_nid = NID_undef;

    gkt = d2i_GOST_KEY_TRANSPORT(NULL, (const unsigned char **)&p, in_len);
    if (!gkt) {
        GOSTerr(GOST_F_PKEY_GOST_ECCP_DECRYPT,
                GOST_R_ERROR_PARSING_KEY_TRANSPORT_INFO);
        return -1;
    }

    
    eph_key = X509_PUBKEY_get(gkt->key_agreement_info->ephem_key);
    if (eph_key) {
        if (EVP_PKEY_derive_set_peer(pctx, eph_key) <= 0) {
            GOSTerr(GOST_F_PKEY_GOST_ECCP_DECRYPT,
                    GOST_R_INCOMPATIBLE_PEER_KEY);
            goto err;
        }
    } else {
        
        if (EVP_PKEY_CTX_ctrl(pctx, -1, -1, EVP_PKEY_CTRL_PEER_KEY, 3, NULL)
            <= 0) {
            GOSTerr(GOST_F_PKEY_GOST_ECCP_DECRYPT, GOST_R_CTRL_CALL_FAILED);
            goto err;
        }
    }
    peerkey = EVP_PKEY_CTX_get0_peerkey(pctx);
    if (!peerkey) {
        GOSTerr(GOST_F_PKEY_GOST_ECCP_DECRYPT, GOST_R_NO_PEER_KEY);
        goto err;
    }

    param = get_encryption_params(gkt->key_agreement_info->cipher);
    if (!param) {
        goto err;
    }

    gost_init(&ctx, param->sblock);
    OPENSSL_assert(gkt->key_agreement_info->eph_iv->length == 8);
    memcpy(wrappedKey, gkt->key_agreement_info->eph_iv->data, 8);
    OPENSSL_assert(gkt->key_info->encrypted_key->length == 32);
    memcpy(wrappedKey + 8, gkt->key_info->encrypted_key->data, 32);
    OPENSSL_assert(gkt->key_info->imit->length == 4);
    memcpy(wrappedKey + 40, gkt->key_info->imit->data, 4);

    EVP_PKEY_get_default_digest_nid(priv, &dgst_nid);
    if (dgst_nid == NID_id_GostR3411_2012_512)
        dgst_nid = NID_id_GostR3411_2012_256;

    if (!VKO_compute_key(sharedKey,
                         EC_KEY_get0_public_key(EVP_PKEY_get0(peerkey)),
                         EVP_PKEY_get0(priv), wrappedKey, 8, dgst_nid)) {
        GOSTerr(GOST_F_PKEY_GOST_ECCP_DECRYPT,
                GOST_R_ERROR_COMPUTING_SHARED_KEY);
        goto err;
    }
    if (!keyUnwrapCryptoPro(&ctx, sharedKey, wrappedKey, key)) {
        GOSTerr(GOST_F_PKEY_GOST_ECCP_DECRYPT,
                GOST_R_ERROR_COMPUTING_SHARED_KEY);
        goto err;
    }

    *key_len = 32;
    ret = 1;
 err:
    OPENSSL_cleanse(sharedKey, sizeof(sharedKey));
    EVP_PKEY_free(eph_key);
    GOST_KEY_TRANSPORT_free(gkt);
    return ret;
}
","1. EVP_PKEY *priv = EVP_PKEY_CTX_get0_pkey(pctx);
2. int dgst_nid = NID_undef;
3. GOSTerr(GOST_F_PKEY_GOST_ECCP_DECRYPT,
4. if (eph_key) {
5. GOSTerr(GOST_F_PKEY_GOST_ECCP_DECRYPT,
GOST_R_INCOMPATIBLE_PEER_KEY);
6. OPENSSL_assert(gkt->key_agreement_info->eph_iv->length == 8);
7. OPENSSL_assert(gkt->key_info->encrypted_key->length == 32);
8. if (dgst_nid == NID_id_GostR3411_2012_512)
dgst_nid = NID_id_GostR3411_2012_256;
9. EVP_PKEY_get0(priv), wrappedKey, 8, dgst_nid)) {
10. *key_len = 32;
11. return ret;","9
17
21
28
30-31
54
56
62-63
67
78
84","CWE-787,CWE-399,CWE-189"
dwc3_qcom_probe-49590840058548,"static int dwc3_qcom_probe(struct platform_device *pdev)
{
	struct device_node	*np = pdev->dev.of_node;
	struct device		*dev = &pdev->dev;
	struct dwc3_qcom	*qcom;
	struct resource		*res, *parent_res = NULL;
	int			ret, i;
	bool			ignore_pipe_clk;

	qcom = devm_kzalloc(&pdev->dev, sizeof(*qcom), GFP_KERNEL);
	if (!qcom)
		return -ENOMEM;

	platform_set_drvdata(pdev, qcom);
	qcom->dev = &pdev->dev;

	if (has_acpi_companion(dev)) {
		qcom->acpi_pdata = acpi_device_get_match_data(dev);
		if (!qcom->acpi_pdata) {
			dev_err(&pdev->dev, ""no supporting ACPI device data\n"");
			return -EINVAL;
		}
	}

	qcom->resets = devm_reset_control_array_get_optional_exclusive(dev);
	if (IS_ERR(qcom->resets)) {
		ret = PTR_ERR(qcom->resets);
		dev_err(&pdev->dev, ""failed to get resets, err=%d\n"", ret);
		return ret;
	}

	ret = reset_control_assert(qcom->resets);
	if (ret) {
		dev_err(&pdev->dev, ""failed to assert resets, err=%d\n"", ret);
		return ret;
	}

	usleep_range(10, 1000);

	ret = reset_control_deassert(qcom->resets);
	if (ret) {
		dev_err(&pdev->dev, ""failed to deassert resets, err=%d\n"", ret);
		goto reset_assert;
	}

	ret = dwc3_qcom_clk_init(qcom, of_clk_get_parent_count(np));
	if (ret) {
		dev_err(dev, ""failed to get clocks\n"");
		goto reset_assert;
	}

	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);

	if (np) {
		parent_res = res;
	} else {
		parent_res = kmemdup(res, sizeof(struct resource), GFP_KERNEL);
		if (!parent_res)
			return -ENOMEM;

		parent_res->start = res->start +
			qcom->acpi_pdata->qscratch_base_offset;
		parent_res->end = parent_res->start +
			qcom->acpi_pdata->qscratch_base_size;

		if (qcom->acpi_pdata->is_urs) {
			qcom->urs_usb = dwc3_qcom_create_urs_usb_platdev(dev);
			if (IS_ERR_OR_NULL(qcom->urs_usb)) {
				dev_err(dev, ""failed to create URS USB platdev\n"");
				if (!qcom->urs_usb)
					return -ENODEV;
				else
					return PTR_ERR(qcom->urs_usb);
			}
		}
	}

	qcom->qscratch_base = devm_ioremap_resource(dev, parent_res);
	if (IS_ERR(qcom->qscratch_base)) {
		ret = PTR_ERR(qcom->qscratch_base);
		goto clk_disable;
	}

	ret = dwc3_qcom_setup_irq(pdev);
	if (ret) {
		dev_err(dev, ""failed to setup IRQs, err=%d\n"", ret);
		goto clk_disable;
	}

	
	ignore_pipe_clk = device_property_read_bool(dev,
				""qcom,select-utmi-as-pipe-clk"");
	if (ignore_pipe_clk)
		dwc3_qcom_select_utmi_clk(qcom);

	if (np)
		ret = dwc3_qcom_of_register_core(pdev);
	else
		ret = dwc3_qcom_acpi_register_core(pdev);

	if (ret) {
		dev_err(dev, ""failed to register DWC3 Core, err=%d\n"", ret);
		goto depopulate;
	}

	ret = dwc3_qcom_interconnect_init(qcom);
	if (ret)
		goto depopulate;

	qcom->mode = usb_get_dr_mode(&qcom->dwc3->dev);

	
	if (qcom->mode == USB_DR_MODE_PERIPHERAL)
		dwc3_qcom_vbus_override_enable(qcom, true);

	
	ret = dwc3_qcom_register_extcon(qcom);
	if (ret)
		goto interconnect_exit;

	device_init_wakeup(&pdev->dev, 1);
	qcom->is_suspended = false;
	pm_runtime_set_active(dev);
	pm_runtime_enable(dev);
	pm_runtime_forbid(dev);

	return 0;

interconnect_exit:
	dwc3_qcom_interconnect_exit(qcom);
depopulate:
	if (np)
		of_platform_depopulate(&pdev->dev);
	else
		platform_device_put(pdev);
clk_disable:
	for (i = qcom->num_clocks - 1; i >= 0; i--) {
		clk_disable_unprepare(qcom->clks[i]);
		clk_put(qcom->clks[i]);
	}
reset_assert:
	reset_control_assert(qcom->resets);

	return ret;
}
","1. bool			ignore_pipe_clk;
2. return -ENOMEM;
3. dev_err(&pdev->dev, ""no supporting ACPI device data\n"");
4. goto reset_assert;
5. ret = PTR_ERR(qcom->qscratch_base);
6. pm_runtime_set_active(dev);","8
12
20
43
80
126","CWE-908,CWE-125,CWE-119"
Sp_split_regexp-641021009524,"
#define J

static void Sp_split_regexp(js_State *J)
{
	js_Regexp *re;
	const char *text;
	int limit, len, k;
	const char *p, *a, *b, *c, *e;
	Resub m;

	text = checkstring(J, 0);
	re = js_toregexp(J, 1);
	limit = js_isdefined(J, 2) ? js_tointeger(J, 2) : 1 << 30;

	js_newarray(J);
	len = 0;

	e = text + strlen(text);

	
	if (e == text) {
		if (js_doregexec(J, re->prog, text, &m, 0)) {
			if (len == limit) return;
			js_pushliteral(J, """");
			js_setindex(J, -2, 0);
		}
		return;
	}

	p = a = text;
	while (a < e) {
		if (js_doregexec(J, re->prog, a, &m, a > text ? REG_NOTBOL : 0))
			break; 

		b = m.sub[0].sp;
		c = m.sub[0].ep;

		
		if (b == p) {
			++a;
			continue;
		}

		if (len == limit) return;
		js_pushlstring(J, p, b - p);
		js_setindex(J, -2, len++);

		for (k = 1; k < m.nsub; ++k) {
			if (len == limit) return;
			js_pushlstring(J, m.sub[k].sp, m.sub[k].ep - m.sub[k].sp);
			js_setindex(J, -2, len++);
		}

		a = p = c;
	}

	if (len == limit) return;
	js_pushstring(J, p);
	js_setindex(J, -2, len);
}
","1. static void Sp_split_regexp(js_State *J)
2. const char *text;
int limit, len, k;
const char *p, *a, *b, *c, *e;
3. text = checkstring(J, 0);
4. limit = js_isdefined(J, 2) ? js_tointeger(J, 2) : 1 << 30;
5. e = text + strlen(text);
6. while (a < e) {
7. b = m.sub[0].sp;
c = m.sub[0].ep;
8. continue;
9. for (k = 1; k < m.nsub; ++k) {
if (len == limit) return;
10. a = p = c;","4
7-9
12
14
19
32
36-37
42
49-50
55","CWE-20,CWE-674,CWE-264,CWE-400"
fpga_reset," int fpga_reset(void)
 {
	
 	return 0;
 }
",1. int fpga_reset(void),1,"CWE-476,CWE-200,CWE-125,CWE-119"
tcp_illinois_info,"static void tcp_illinois_info(struct sock *sk, u32 ext,
			      struct sk_buff *skb)
{
	const struct illinois *ca = inet_csk_ca(sk);

	if (ext & (1 << (INET_DIAG_VEGASINFO - 1))) {
		struct tcpvegas_info info = {
			.tcpv_enabled = 1,
 			.tcpv_rttcnt = ca->cnt_rtt,
 			.tcpv_minrtt = ca->base_rtt,
 		};
 
		if (info.tcpv_rttcnt > 0) {
			u64 t = ca->sum_rtt;
 
			do_div(t, info.tcpv_rttcnt);
			info.tcpv_rtt = t;
		}
 		nla_put(skb, INET_DIAG_VEGASINFO, sizeof(info), &info);
 	}
 }
","1. static void tcp_illinois_info(struct sock *sk, u32 ext,
2. const struct illinois *ca = inet_csk_ca(sk);
3. if (ext & (1 << (INET_DIAG_VEGASINFO - 1))) {
struct tcpvegas_info info = {
4. .tcpv_rttcnt = ca->cnt_rtt,
5. if (info.tcpv_rttcnt > 0) {
6. do_div(t, info.tcpv_rttcnt);
info.tcpv_rtt = t;
7. nla_put(skb, INET_DIAG_VEGASINFO, sizeof(info), &info);","1
4
6-7
9
13
16-17
19","CWE-200,CWE-400,CWE-189"
uv__idna_toascii-19177968414717,"ssize_t uv__idna_toascii(const char* s, const char* se, char* d, char* de) {
  const char* si;
  const char* st;
  unsigned c;
  char* ds;
  int rc;

  ds = d;

  si = s;
  while (si < se) {
    st = si;
    c = uv__utf8_decode1(&si, se);

    if (c == UINT_MAX)
      return UV_EINVAL;

    if (c != '.')
      if (c != 0x3002)  
        if (c != 0xFF0E)  
          if (c != 0xFF61)  
            continue;

    rc = uv__idna_toascii_label(s, st, &d, de);

    if (rc < 0)
      return rc;

    if (d < de)
      *d++ = '.';

    s = si;
  }

  if (s < se) {
    rc = uv__idna_toascii_label(s, se, &d, de);

    if (rc < 0)
      return rc;
  }

  if (d >= de)
    return UV_EINVAL;

  *d++ = '\0';
  return d - ds;  
}
","1. si = s;
2. st = si;
3. if (c != 0xFF61)
4. rc = uv__idna_toascii_label(s, st, &d, de);
5. rc = uv__idna_toascii_label(s, se, &d, de);
6. if (rc < 0)","10
12
21
24
36
38","CWE-918,CWE-190,CWE-264,CWE-59"
parse_bin_node,"static plist_t parse_bin_node(struct bplist_data *bplist, const char** object)
{
    uint16_t type = 0;
    uint64_t size = 0;

    if (!object)
        return NULL;

    type = (**object) & BPLIST_MASK;
    size = (**object) & BPLIST_FILL;
    (*object)++;

    if (size == BPLIST_FILL) {
        switch (type) {
        case BPLIST_DATA:
        case BPLIST_STRING:
        case BPLIST_UNICODE:
        case BPLIST_ARRAY:
        case BPLIST_SET:
        case BPLIST_DICT:
        {
            uint16_t next_size = **object & BPLIST_FILL;
            if ((**object & BPLIST_MASK) != BPLIST_UINT) {
                PLIST_BIN_ERR(""%s: invalid size node type for node type 0x%02x: found 0x%02x, expected 0x%02x\n"", __func__, type, **object & BPLIST_MASK, BPLIST_UINT);
                return NULL;
            }
            (*object)++;
            next_size = 1 << next_size;
            if (*object + next_size > bplist->offset_table) {
                PLIST_BIN_ERR(""%s: size node data bytes for node type 0x%02x point outside of valid range\n"", __func__, type);
                return NULL;
            }
            size = UINT_TO_HOST(*object, next_size);
            (*object) += next_size;
            break;
        }
        default:
            break;
        }
    }

    switch (type)
    {

    case BPLIST_NULL:
        switch (size)
        {

        case BPLIST_TRUE:
        {
            plist_data_t data = plist_new_plist_data();
            data->type = PLIST_BOOLEAN;
            data->boolval = TRUE;
            data->length = 1;
            return node_create(NULL, data);
        }

        case BPLIST_FALSE:
        {
            plist_data_t data = plist_new_plist_data();
            data->type = PLIST_BOOLEAN;
            data->boolval = FALSE;
            data->length = 1;
            return node_create(NULL, data);
        }

        case BPLIST_NULL:
        default:
            return NULL;
        }

    case BPLIST_UINT:
        if (*object + (uint64_t)(1 << size) > bplist->offset_table) {
            PLIST_BIN_ERR(""%s: BPLIST_UINT data bytes point outside of valid range\n"", __func__);
            return NULL;
        }
        return parse_uint_node(object, size);

    case BPLIST_REAL:
        if (*object + (uint64_t)(1 << size) > bplist->offset_table) {
            PLIST_BIN_ERR(""%s: BPLIST_REAL data bytes point outside of valid range\n"", __func__);
            return NULL;
        }
        return parse_real_node(object, size);

    case BPLIST_DATE:
        if (3 != size) {
            PLIST_BIN_ERR(""%s: invalid data size for BPLIST_DATE node\n"", __func__);
            return NULL;
        }
        if (*object + (uint64_t)(1 << size) > bplist->offset_table) {
            PLIST_BIN_ERR(""%s: BPLIST_DATE data bytes point outside of valid range\n"", __func__);
            return NULL;
        }
         return parse_date_node(object, size);
 
     case BPLIST_DATA:
        if (*object + size < *object || *object + size > bplist->offset_table) {
             PLIST_BIN_ERR(""%s: BPLIST_DATA data bytes point outside of valid range\n"", __func__);
             return NULL;
         }
         return parse_data_node(object, size);
 
     case BPLIST_STRING:
        if (*object + size < *object || *object + size > bplist->offset_table) {
             PLIST_BIN_ERR(""%s: BPLIST_STRING data bytes point outside of valid range\n"", __func__);
             return NULL;
         }
        return parse_string_node(object, size);

    case BPLIST_UNICODE:
        if (size*2 < size) {
             PLIST_BIN_ERR(""%s: Integer overflow when calculating BPLIST_UNICODE data size.\n"", __func__);
             return NULL;
         }
        if (*object + size*2 < *object || *object + size*2 > bplist->offset_table) {
             PLIST_BIN_ERR(""%s: BPLIST_UNICODE data bytes point outside of valid range\n"", __func__);
             return NULL;
         }
         return parse_unicode_node(object, size);
 
     case BPLIST_SET:
     case BPLIST_ARRAY:
        if (*object + size < *object || *object + size > bplist->offset_table) {
             PLIST_BIN_ERR(""%s: BPLIST_ARRAY data bytes point outside of valid range\n"", __func__);
             return NULL;
         }
        return parse_array_node(bplist, object, size);

    case BPLIST_UID:
        if (*object + size+1 > bplist->offset_table) {
            PLIST_BIN_ERR(""%s: BPLIST_UID data bytes point outside of valid range\n"", __func__);
            return NULL;
        }
         return parse_uid_node(object, size);
 
     case BPLIST_DICT:
        if (*object + size < *object || *object + size > bplist->offset_table) {
            PLIST_BIN_ERR(""%s: BPLIST_DICT data bytes point outside of valid range\n"", __func__);
             return NULL;
         }
         return parse_dict_node(bplist, object, size);

    default:
        PLIST_BIN_ERR(""%s: unexpected node type 0x%02x\n"", __func__, type);
        return NULL;
    }
    return NULL;
}
","1. static plist_t parse_bin_node(struct bplist_data *bplist, const char** object)
2. (*object)++;
3. if (size == BPLIST_FILL) {
4. case BPLIST_DATA:
5. case BPLIST_UNICODE:
case BPLIST_ARRAY:
case BPLIST_SET:
case BPLIST_DICT:
6. return NULL;
7. next_size = 1 << next_size;
8. return NULL;
9. size = UINT_TO_HOST(*object, next_size);
10. break;
11. default:
12. case BPLIST_NULL:
switch (size)
13. plist_data_t data = plist_new_plist_data();
data->type = PLIST_BOOLEAN;
data->boolval = TRUE;
data->length = 1;
14. case BPLIST_FALSE:
15. data->boolval = FALSE;
16. return NULL;
17. case BPLIST_UINT:
18. PLIST_BIN_ERR(""%s: BPLIST_UINT data bytes point outside of valid range\n"", __func__);
19. case BPLIST_REAL:
20. PLIST_BIN_ERR(""%s: BPLIST_REAL data bytes point outside of valid range\n"", __func__);
21. return parse_real_node(object, size);
22. PLIST_BIN_ERR(""%s: invalid data size for BPLIST_DATE node\n"", __func__);
23. if (*object + (uint64_t)(1 << size) > bplist->offset_table) {
24. return NULL;
25. case BPLIST_DATA:
if (*object + size < *object || *object + size > bplist->offset_table) {
26. return NULL;
27. return parse_data_node(object, size);
28. return parse_string_node(object, size);
29. if (size*2 < size) {
PLIST_BIN_ERR(""%s: Integer overflow when calculating BPLIST_UNICODE data size.\n"", __func__);
return NULL;
30. if (*object + size*2 < *object || *object + size*2 > bplist->offset_table) {
PLIST_BIN_ERR(""%s: BPLIST_UNICODE data bytes point outside of valid range\n"", __func__);
return NULL;
31. return parse_unicode_node(object, size);
32. case BPLIST_ARRAY:
if (*object + size < *object || *object + size > bplist->offset_table) {
33. return parse_uid_node(object, size);
34. case BPLIST_DICT:
if (*object + size < *object || *object + size > bplist->offset_table) {
35. return NULL;
36. return parse_dict_node(bplist, object, size);
37. default:
PLIST_BIN_ERR(""%s: unexpected node type 0x%02x\n"", __func__, type);
return NULL;
38. return NULL;","1
11
13
15
17-20
25
28
31
33
35
37
45-46
51-54
58
62
69
72
74
79
81
84
88
91
93
97-98
100
102
109
112-114
116-118
120
123-124
135
137-138
140
142
144-146
148","CWE-190,CWE-200,CWE-125,CWE-59"
ReadPICTImage_1,"
#define ExceptionInfo
#define ImageInfo

static Image *ReadPICTImage_1(const ImageInfo *image_info,
  ExceptionInfo *exception)
{
  char
    geometry[MaxTextExtent],
    header_ole[4];

  Image
    *image;

  IndexPacket
    index;

  int
    c,
    code;

  MagickBooleanType
    jpeg,
    status;

  PICTRectangle
    frame;

  PICTPixmap
    pixmap;

  register IndexPacket
    *indexes;

  register ssize_t
    x;

  register PixelPacket
    *q;

  register ssize_t
    i;

  size_t
    extent,
    length;

  ssize_t
    count,
    flags,
    j,
    version,
    y;

  StringInfo
    *profile;

  
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickSignature);
  image=AcquireImage(image_info);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  
  pixmap.bits_per_pixel=0;
  pixmap.component_count=0;
  
  header_ole[0]=ReadBlobByte(image);
  header_ole[1]=ReadBlobByte(image);
  header_ole[2]=ReadBlobByte(image);
  header_ole[3]=ReadBlobByte(image);
  if (!((header_ole[0] == 0x50) && (header_ole[1] == 0x49) &&
      (header_ole[2] == 0x43) && (header_ole[3] == 0x54)))
    for (i=0; i < 508; i++)
      (void) ReadBlobByte(image);
  (void) ReadBlobMSBShort(image);  
  if (ReadRectangle(image,&frame) == MagickFalse)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  while ((c=ReadBlobByte(image)) == 0) ;
  if (c != 0x11)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  version=ReadBlobByte(image);
  if (version == 2)
    {
      c=ReadBlobByte(image);
      if (c != 0xff)
        ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    }
  else
    if (version != 1)
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  if ((frame.left < 0) || (frame.right < 0) || (frame.top < 0) ||
      (frame.bottom < 0) || (frame.left >= frame.right) ||
      (frame.top >= frame.bottom))
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  
  flags=0;
  image->depth=8;
  image->columns=1UL*(frame.right-frame.left);
  image->rows=1UL*(frame.bottom-frame.top);
  image->x_resolution=DefaultResolution;
  image->y_resolution=DefaultResolution;
  image->units=UndefinedResolution;
  
  jpeg=MagickFalse;
  for (code=0; EOFBlob(image) == MagickFalse; )
  {
     if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))
       if (image->scene >= (image_info->scene+image_info->number_scenes-1))
         break;
    status=SetImageExtent(image,image->columns,image->rows);
    if (status == MagickFalse)
      {
        InheritException(exception,&image->exception);
        return(DestroyImageList(image));
      }
     if ((version == 1) || ((TellBlob(image) % 2) != 0))
       code=ReadBlobByte(image);
     if (version == 2)
      code=(int) ReadBlobMSBShort(image);
    if (code < 0)
      break;
    if (code > 0xa1)
      {
        if (image->debug != MagickFalse)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),""%04X:"",code);
      }
    else
      {
        if (image->debug != MagickFalse)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""  %04X %s: %s"",code,codes[code].name,codes[code].description);
        switch (code)
        {
          case 0x01:
          {
            
            length=ReadBlobMSBShort(image);
            if (length != 0x000a)
              {
                for (i=0; i < (ssize_t) (length-2); i++)
                  (void) ReadBlobByte(image);
                break;
              }
            if (ReadRectangle(image,&frame) == MagickFalse)
              ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
            if (((frame.left & 0x8000) != 0) || ((frame.top & 0x8000) != 0))
              break;
            image->columns=1UL*(frame.right-frame.left);
            image->rows=1UL*(frame.bottom-frame.top);
            (void) SetImageBackgroundColor(image);
            break;
          }
          case 0x12:
          case 0x13:
          case 0x14:
          {
            ssize_t
              pattern;

            size_t
              height,
              width;

            
            pattern=1L*ReadBlobMSBShort(image);
            for (i=0; i < 8; i++)
              (void) ReadBlobByte(image);
            if (pattern == 2)
              {
                for (i=0; i < 5; i++)
                  (void) ReadBlobByte(image);
                break;
              }
            if (pattern != 1)
              ThrowReaderException(CorruptImageError,""UnknownPatternType"");
            length=ReadBlobMSBShort(image);
            if (ReadRectangle(image,&frame) == MagickFalse)
              ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
            ReadPixmap(pixmap);
            image->depth=1UL*pixmap.component_size;
            image->x_resolution=1.0*pixmap.horizontal_resolution;
            image->y_resolution=1.0*pixmap.vertical_resolution;
            image->units=PixelsPerInchResolution;
            (void) ReadBlobMSBLong(image);
            flags=1L*ReadBlobMSBShort(image);
            length=ReadBlobMSBShort(image);
            for (i=0; i <= (ssize_t) length; i++)
              (void) ReadBlobMSBLong(image);
            width=1UL*(frame.bottom-frame.top);
            height=1UL*(frame.right-frame.left);
            if (pixmap.bits_per_pixel <= 8)
              length&=0x7fff;
            if (pixmap.bits_per_pixel == 16)
              width<<=1;
            if (length == 0)
              length=width;
            if (length < 8)
              {
                for (i=0; i < (ssize_t) (length*height); i++)
                  (void) ReadBlobByte(image);
              }
            else
              for (j=0; j < (int) height; j++)
                if (length > 200)
                  for (j=0; j < (ssize_t) ReadBlobMSBShort(image); j++)
                    (void) ReadBlobByte(image);
                else
                  for (j=0; j < (ssize_t) ReadBlobByte(image); j++)
                    (void) ReadBlobByte(image);
            break;
          }
          case 0x1b:
          {
            
            image->background_color.red=(Quantum)
              ScaleShortToQuantum(ReadBlobMSBShort(image));
            image->background_color.green=(Quantum)
              ScaleShortToQuantum(ReadBlobMSBShort(image));
            image->background_color.blue=(Quantum)
              ScaleShortToQuantum(ReadBlobMSBShort(image));
            break;
          }
          case 0x70:
          case 0x71:
          case 0x72:
          case 0x73:
          case 0x74:
          case 0x75:
          case 0x76:
          case 0x77:
          {
            
            length=ReadBlobMSBShort(image);
            for (i=0; i < (ssize_t) (length-2); i++)
              (void) ReadBlobByte(image);
            break;
          }
          case 0x90:
          case 0x91:
          case 0x98:
          case 0x99:
          case 0x9a:
          case 0x9b:
          {
            ssize_t
              bytes_per_line;

            PICTRectangle
              source,
              destination;

            register unsigned char
              *p;

            size_t
              j;

            unsigned char
              *pixels;

            Image
              *tile_image;

            
            bytes_per_line=0;
            if ((code != 0x9a) && (code != 0x9b))
              bytes_per_line=1L*ReadBlobMSBShort(image);
            else
              {
                (void) ReadBlobMSBShort(image);
                (void) ReadBlobMSBShort(image);
                (void) ReadBlobMSBShort(image);
              }
            if (ReadRectangle(image,&frame) == MagickFalse)
              ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
            
            tile_image=CloneImage(image,1UL*(frame.right-frame.left),
              1UL*(frame.bottom-frame.top),MagickTrue,exception);
            if (tile_image == (Image *) NULL)
              return((Image *) NULL);
            if ((code == 0x9a) || (code == 0x9b) ||
                ((bytes_per_line & 0x8000) != 0))
              {
                ReadPixmap(pixmap);
                tile_image->depth=1UL*pixmap.component_size;
                tile_image->matte=pixmap.component_count == 4 ?
                  MagickTrue : MagickFalse;
                tile_image->x_resolution=(double) pixmap.horizontal_resolution;
                tile_image->y_resolution=(double) pixmap.vertical_resolution;
                tile_image->units=PixelsPerInchResolution;
                if (tile_image->matte != MagickFalse)
                  image->matte=tile_image->matte;
              }
            if ((code != 0x9a) && (code != 0x9b))
              {
                
                tile_image->colors=2;
                if ((bytes_per_line & 0x8000) != 0)
                  {
                    (void) ReadBlobMSBLong(image);
                    flags=1L*ReadBlobMSBShort(image);
                    tile_image->colors=1UL*ReadBlobMSBShort(image)+1;
                  }
                status=AcquireImageColormap(tile_image,tile_image->colors);
                if (status == MagickFalse)
                  {
                    tile_image=DestroyImage(tile_image);
                    ThrowReaderException(ResourceLimitError,
                      ""MemoryAllocationFailed"");
                  }
                if ((bytes_per_line & 0x8000) != 0)
                  {
                    for (i=0; i < (ssize_t) tile_image->colors; i++)
                    {
                      j=ReadBlobMSBShort(image) % tile_image->colors;
                      if ((flags & 0x8000) != 0)
                        j=(size_t) i;
                      tile_image->colormap[j].red=(Quantum)
                        ScaleShortToQuantum(ReadBlobMSBShort(image));
                      tile_image->colormap[j].green=(Quantum)
                        ScaleShortToQuantum(ReadBlobMSBShort(image));
                      tile_image->colormap[j].blue=(Quantum)
                        ScaleShortToQuantum(ReadBlobMSBShort(image));
                    }
                  }
                else
                  {
                    for (i=0; i < (ssize_t) tile_image->colors; i++)
                    {
                      tile_image->colormap[i].red=(Quantum) (QuantumRange-
                        tile_image->colormap[i].red);
                      tile_image->colormap[i].green=(Quantum) (QuantumRange-
                        tile_image->colormap[i].green);
                      tile_image->colormap[i].blue=(Quantum) (QuantumRange-
                        tile_image->colormap[i].blue);
                    }
                  }
              }
            if (ReadRectangle(image,&source) == MagickFalse)
              ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
            if (ReadRectangle(image,&destination) == MagickFalse)
              ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
            (void) ReadBlobMSBShort(image);
            if ((code == 0x91) || (code == 0x99) || (code == 0x9b))
              {
                
                length=ReadBlobMSBShort(image);
                for (i=0; i < (ssize_t) (length-2); i++)
                  (void) ReadBlobByte(image);
              }
            if ((code != 0x9a) && (code != 0x9b) &&
                (bytes_per_line & 0x8000) == 0)
              pixels=DecodeImage(image,tile_image,1UL*bytes_per_line,1,&extent);
            else
              pixels=DecodeImage(image,tile_image,1UL*bytes_per_line,1U*
                pixmap.bits_per_pixel,&extent);
            if (pixels == (unsigned char *) NULL)
              {
                tile_image=DestroyImage(tile_image);
                ThrowReaderException(ResourceLimitError,
                  ""MemoryAllocationFailed"");
              }
            
            p=pixels;
            for (y=0; y < (ssize_t) tile_image->rows; y++)
            {
              if (p > (pixels+extent+image->columns))
                ThrowReaderException(CorruptImageError,""NotEnoughPixelData"");
              q=QueueAuthenticPixels(tile_image,0,y,tile_image->columns,1,
                exception);
              if (q == (PixelPacket *) NULL)
                break;
              indexes=GetAuthenticIndexQueue(tile_image);
              for (x=0; x < (ssize_t) tile_image->columns; x++)
              {
                if (tile_image->storage_class == PseudoClass)
                  {
                    index=ConstrainColormapIndex(tile_image,*p);
                    SetPixelIndex(indexes+x,index);
                    SetPixelRed(q,
                      tile_image->colormap[(ssize_t) index].red);
                    SetPixelGreen(q,
                      tile_image->colormap[(ssize_t) index].green);
                    SetPixelBlue(q,
                      tile_image->colormap[(ssize_t) index].blue);
                  }
                else
                  {
                    if (pixmap.bits_per_pixel == 16)
                      {
                        i=(*p++);
                        j=(*p);
                        SetPixelRed(q,ScaleCharToQuantum(
                          (unsigned char) ((i & 0x7c) << 1)));
                        SetPixelGreen(q,ScaleCharToQuantum(
                          (unsigned char) (((i & 0x03) << 6) |
                          ((j & 0xe0) >> 2))));
                        SetPixelBlue(q,ScaleCharToQuantum(
                          (unsigned char) ((j & 0x1f) << 3)));
                      }
                    else
                      if (tile_image->matte == MagickFalse)
                        {
                          if (p > (pixels+extent+2*image->columns))
                            ThrowReaderException(CorruptImageError,
                              ""NotEnoughPixelData"");
                          SetPixelRed(q,ScaleCharToQuantum(*p));
                          SetPixelGreen(q,ScaleCharToQuantum(
                            *(p+tile_image->columns)));
                          SetPixelBlue(q,ScaleCharToQuantum(
                            *(p+2*tile_image->columns)));
                        }
                      else
                        {
                          if (p > (pixels+extent+3*image->columns))
                            ThrowReaderException(CorruptImageError,
                              ""NotEnoughPixelData"");
                          SetPixelAlpha(q,ScaleCharToQuantum(*p));
                          SetPixelRed(q,ScaleCharToQuantum(
                            *(p+tile_image->columns)));
                          SetPixelGreen(q,ScaleCharToQuantum(
                            *(p+2*tile_image->columns)));
                          SetPixelBlue(q,ScaleCharToQuantum(
                            *(p+3*tile_image->columns)));
                        }
                  }
                p++;
                q++;
              }
              if (SyncAuthenticPixels(tile_image,exception) == MagickFalse)
                break;
              if ((tile_image->storage_class == DirectClass) &&
                  (pixmap.bits_per_pixel != 16))
                {
                  p+=(pixmap.component_count-1)*tile_image->columns;
                  if (p < pixels)
                    break;
                }
              status=SetImageProgress(image,LoadImageTag,y,tile_image->rows);
              if (status == MagickFalse)
                break;
            }
            pixels=(unsigned char *) RelinquishMagickMemory(pixels);
            if (jpeg == MagickFalse)
              if ((code == 0x9a) || (code == 0x9b) ||
                  ((bytes_per_line & 0x8000) != 0))
                (void) CompositeImage(image,CopyCompositeOp,tile_image,
                  destination.left,destination.top);
            tile_image=DestroyImage(tile_image);
            break;
          }
          case 0xa1:
          {
            unsigned char
              *info;

            size_t
              type;

            
            type=ReadBlobMSBShort(image);
            length=ReadBlobMSBShort(image);
            if (length == 0)
              break;
            (void) ReadBlobMSBLong(image);
            length-=4;
            if (length == 0)
              break;
            info=(unsigned char *) AcquireQuantumMemory(length,sizeof(*info));
            if (info == (unsigned char *) NULL)
              break;
            count=ReadBlob(image,length,info);
            (void) count;
            switch (type)
            {
              case 0xe0:
              {
                if (length == 0)
                  break;
                profile=BlobToStringInfo((const void *) NULL,length);
                SetStringInfoDatum(profile,info);
                status=SetImageProfile(image,""icc"",profile);
                profile=DestroyStringInfo(profile);
                if (status == MagickFalse)
                  ThrowReaderException(ResourceLimitError,
                    ""MemoryAllocationFailed"");
                break;
              }
              case 0x1f2:
              {
                if (length == 0)
                  break;
                profile=BlobToStringInfo((const void *) NULL,length);
                SetStringInfoDatum(profile,info);
                status=SetImageProfile(image,""iptc"",profile);
                if (status == MagickFalse)
                  ThrowReaderException(ResourceLimitError,
                    ""MemoryAllocationFailed"");
                profile=DestroyStringInfo(profile);
                break;
              }
              default:
                break;
            }
            info=(unsigned char *) RelinquishMagickMemory(info);
            break;
          }
          default:
          {
            
            if (code < 0)
              break;
            if (codes[code].length == -1)
              (void) ReadBlobMSBShort(image);
            else
              for (i=0; i < (ssize_t) codes[code].length; i++)
                (void) ReadBlobByte(image);
          }
        }
      }
    if (code == 0xc00)
      {
        
        for (i=0; i < 24; i++)
          (void) ReadBlobByte(image);
        continue;
      }
    if (((code >= 0xb0) && (code <= 0xcf)) ||
        ((code >= 0x8000) && (code <= 0x80ff)))
      continue;
    if (code == 0x8200)
      {
        FILE
          *file;

        Image
          *tile_image;

        ImageInfo
          *read_info;

        int
          unique_file;

        
        jpeg=MagickTrue;
        read_info=CloneImageInfo(image_info);
        SetImageInfoBlob(read_info,(void *) NULL,0);
        file=(FILE *) NULL;
        unique_file=AcquireUniqueFileResource(read_info->filename);
        if (unique_file != -1)
          file=fdopen(unique_file,""wb"");
        if ((unique_file == -1) || (file == (FILE *) NULL))
          {
            if (file != (FILE *) NULL)
              (void) fclose(file);
            (void) RelinquishUniqueFileResource(read_info->filename);
            (void) CopyMagickString(image->filename,read_info->filename,
              MaxTextExtent);
            ThrowFileException(exception,FileOpenError,
              ""UnableToCreateTemporaryFile"",image->filename);
            image=DestroyImageList(image);
            return((Image *) NULL);
          }
        length=ReadBlobMSBLong(image);
        for (i=0; i < 6; i++)
          (void) ReadBlobMSBLong(image);
        if (ReadRectangle(image,&frame) == MagickFalse)
          {
            (void) fclose(file);
            (void) RelinquishUniqueFileResource(read_info->filename);
            ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
          }
        for (i=0; i < 122; i++)
          (void) ReadBlobByte(image);
        for (i=0; i < (ssize_t) (length-154); i++)
        {
          c=ReadBlobByte(image);
          (void) fputc(c,file);
        }
        (void) fclose(file);
        (void) close(unique_file);
        tile_image=ReadImage(read_info,exception);
        (void) RelinquishUniqueFileResource(read_info->filename);
        read_info=DestroyImageInfo(read_info);
        if (tile_image == (Image *) NULL)
          continue;
        (void) FormatLocaleString(geometry,MaxTextExtent,""%.20gx%.20g"",
          (double) MagickMax(image->columns,tile_image->columns),
          (double) MagickMax(image->rows,tile_image->rows));
        (void) SetImageExtent(image,
          MagickMax(image->columns,tile_image->columns),
          MagickMax(image->rows,tile_image->rows));
        (void) TransformImageColorspace(image,tile_image->colorspace);
        (void) CompositeImage(image,CopyCompositeOp,tile_image,frame.left,
          frame.right);
        image->compression=tile_image->compression;
        tile_image=DestroyImage(tile_image);
        continue;
      }
    if ((code == 0xff) || (code == 0xffff))
      break;
    if (((code >= 0xd0) && (code <= 0xfe)) ||
        ((code >= 0x8100) && (code <= 0xffff)))
      {
        
        length=ReadBlobMSBShort(image);
        for (i=0; i < (ssize_t) length; i++)
          (void) ReadBlobByte(image);
        continue;
      }
    if ((code >= 0x100) && (code <= 0x7fff))
      {
        
        length=(size_t) ((code >> 7) & 0xff);
        for (i=0; i < (ssize_t) length; i++)
          (void) ReadBlobByte(image);
        continue;
      }
  }
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}
","1. static Image *ReadPICTImage_1(const ImageInfo *image_info,
2. code;
3. jpeg,
4. *indexes;
5. if (status == MagickFalse)
6. pixmap.bits_per_pixel=0;
7. header_ole[1]=ReadBlobByte(image);
8. header_ole[3]=ReadBlobByte(image);
9. for (i=0; i < 508; i++)
10. if (c != 0x11)
11. if (c != 0xff)
12. if (version != 1)
13. if (code < 0)
break;
14. if (image->debug != MagickFalse)
15. case 0x01:
16. ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
17. length=ReadBlobMSBShort(image);
for (i=0; i <= (ssize_t) length; i++)
18. break;
19. ScaleShortToQuantum(ReadBlobMSBShort(image));
20. for (i=0; i < (ssize_t) (length-2); i++)
21. case 0x9b:
22. (void) ReadBlobMSBShort(image);
23. image->matte=tile_image->matte;
24. ScaleShortToQuantum(ReadBlobMSBShort(image));
25. tile_image->colormap[i].blue);
26. for (i=0; i < (ssize_t) (length-2); i++)
27. pixels=DecodeImage(image,tile_image,1UL*bytes_per_line,1,&extent);
28. p=pixels;
29. for (x=0; x < (ssize_t) tile_image->columns; x++)
30. i=(*p++);
31. SetPixelBlue(q,ScaleCharToQuantum(
32. if (tile_image->matte == MagickFalse)
33. ""NotEnoughPixelData"");
34. SetPixelGreen(q,ScaleCharToQuantum(
35. *(p+2*tile_image->columns)));
36. (void) ReadBlobMSBLong(image);
37. break;
38. for (i=0; i < 24; i++)
39. unique_file;
40. file=(FILE *) NULL;
41. file=fdopen(unique_file,""wb"");
42. if (file != (FILE *) NULL)
(void) fclose(file);
43. (void) fclose(file);
44. for (i=0; i < 122; i++)
45. c=ReadBlobByte(image);
46. (void) close(unique_file);
47. (void) FormatLocaleString(geometry,MaxTextExtent,""%.20gx%.20g"",
48. if ((code == 0xff) || (code == 0xffff))","5
20
23
33
70
78
84
86
89
95
101
105
140-141
149
154
167
210-211
234
246
262
271
300
324
353
369
384
389
402
412
429
436
440
444
446
460
505
511
568
587
595
598
601-602
616
620
624
628
634
647","CWE-190,CWE-119"
mg_http_parse-236687475427463,"int mg_http_parse(const char *s, size_t len, struct mg_http_message *hm) {
  int is_response, req_len = mg_http_get_request_len((unsigned char *) s, len);
  const char *end = s == NULL ? NULL : s + req_len, *qs;  
  struct mg_str *cl;

  memset(hm, 0, sizeof(*hm));
  if (req_len <= 0) return req_len;

  hm->message.ptr = hm->head.ptr = s;
  hm->body.ptr = end;
  hm->head.len = (size_t) req_len;
  hm->chunk.ptr = end;
  hm->message.len = hm->body.len = (size_t) ~0;  

  
  s = skip(s, end, "" "", &hm->method);
  s = skip(s, end, "" "", &hm->uri);
  s = skip(s, end, ""\r\n"", &hm->proto);

  
  if (hm->method.len == 0 || hm->uri.len == 0) return -1;

  
  if ((qs = (const char *) memchr(hm->uri.ptr, '?', hm->uri.len)) != NULL) {
    hm->query.ptr = qs + 1;
    hm->query.len = (size_t) (&hm->uri.ptr[hm->uri.len] - (qs + 1));
    hm->uri.len = (size_t) (qs - hm->uri.ptr);
  }

  mg_http_parse_headers(s, end, hm->headers,
                        sizeof(hm->headers) / sizeof(hm->headers[0]));
  if ((cl = mg_http_get_header(hm, ""Content-Length"")) != NULL) {
    int64_t content_len = mg_to64(*cl);
    if(content_len < 0) return -1;
    hm->body.len = (size_t) content_len;
    hm->message.len = (size_t) req_len + hm->body.len;
  }

  
  
  
  
  
  
  
  
  
  
  
  
  is_response = mg_ncasecmp(hm->method.ptr, ""HTTP/"", 5) == 0;
  if (hm->body.len == (size_t) ~0 && !is_response &&
      mg_vcasecmp(&hm->method, ""PUT"") != 0 &&
      mg_vcasecmp(&hm->method, ""POST"") != 0) {
    hm->body.len = 0;
    hm->message.len = (size_t) req_len;
  }

  
  if (hm->body.len == (size_t) ~0 && is_response &&
      mg_vcasecmp(&hm->uri, ""204"") == 0) {
    hm->body.len = 0;
    hm->message.len = (size_t) req_len;
  }

  return req_len;
}
","1. if (req_len <= 0) return req_len;
2. int64_t content_len = mg_to64(*cl);
3. hm->message.len = (size_t) req_len + hm->body.len;
4. hm->body.len = 0;
hm->message.len = (size_t) req_len;
5. if (hm->body.len == (size_t) ~0 && is_response &&","7
33
36
55-56
60","CWE-189,CWE-476,CWE-190,CWE-200,CWE-287"
get_matching_model_microcode,"get_matching_model_microcode(int cpu, unsigned long start,
			     void *data, size_t size,
			     struct mc_saved_data *mc_saved_data,
			     unsigned long *mc_saved_in_initrd,
			     struct ucode_cpu_info *uci)
{
	u8 *ucode_ptr = data;
	unsigned int leftover = size;
	enum ucode_state state = UCODE_OK;
	unsigned int mc_size;
	struct microcode_header_intel *mc_header;
	struct microcode_intel *mc_saved_tmp[MAX_UCODE_COUNT];
 	unsigned int mc_saved_count = mc_saved_data->mc_saved_count;
 	int i;
 
	while (leftover && mc_saved_count < ARRAY_SIZE(mc_saved_tmp)) {
 		mc_header = (struct microcode_header_intel *)ucode_ptr;
 
 		mc_size = get_totalsize(mc_header);
		if (!mc_size || mc_size > leftover ||
			microcode_sanity_check(ucode_ptr, 0) < 0)
			break;

		leftover -= mc_size;

		
		if (matching_model_microcode(mc_header, uci->cpu_sig.sig) !=
			 UCODE_OK) {
			ucode_ptr += mc_size;
			continue;
		}

		_save_mc(mc_saved_tmp, ucode_ptr, &mc_saved_count);

		ucode_ptr += mc_size;
	}

	if (leftover) {
		state = UCODE_ERROR;
		goto out;
	}

	if (mc_saved_count == 0) {
		state = UCODE_NFOUND;
		goto out;
	}

	for (i = 0; i < mc_saved_count; i++)
		mc_saved_in_initrd[i] = (unsigned long)mc_saved_tmp[i] - start;

	mc_saved_data->mc_saved_count = mc_saved_count;
out:
	return state;
}
","1. void *data, size_t size,
2. mc_header = (struct microcode_header_intel *)ucode_ptr;
3. mc_saved_data->mc_saved_count = mc_saved_count;","2
17
55","CWE-476,CWE-787,CWE-400,CWE-399,CWE-415"
l2tp_ip6_bind-222442632593412,"static int l2tp_ip6_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)
{
	struct inet_sock *inet = inet_sk(sk);
	struct ipv6_pinfo *np = inet6_sk(sk);
	struct sockaddr_l2tpip6 *addr = (struct sockaddr_l2tpip6 *) uaddr;
	struct net *net = sock_net(sk);
	__be32 v4addr = 0;
	int addr_type;
	int err;

	if (addr->l2tp_family != AF_INET6)
		return -EINVAL;
	if (addr_len < sizeof(*addr))
		return -EINVAL;

	addr_type = ipv6_addr_type(&addr->l2tp_addr);

	
	if (addr_type == IPV6_ADDR_MAPPED)
		return -EADDRNOTAVAIL;

	
	if (addr_type & IPV6_ADDR_MULTICAST)
		return -EADDRNOTAVAIL;

	err = -EADDRINUSE;
	read_lock_bh(&l2tp_ip6_lock);
	if (__l2tp_ip6_bind_lookup(net, &addr->l2tp_addr,
				   sk->sk_bound_dev_if, addr->l2tp_conn_id))
		goto out_in_use;
	read_unlock_bh(&l2tp_ip6_lock);

	lock_sock(sk);

	err = -EINVAL;
	if (!sock_flag(sk, SOCK_ZAPPED))
		goto out_unlock;

	if (sk->sk_state != TCP_CLOSE)
		goto out_unlock;

	
	rcu_read_lock();
	if (addr_type != IPV6_ADDR_ANY) {
		struct net_device *dev = NULL;

		if (addr_type & IPV6_ADDR_LINKLOCAL) {
			if (addr_len >= sizeof(struct sockaddr_in6) &&
			    addr->l2tp_scope_id) {
				
				sk->sk_bound_dev_if = addr->l2tp_scope_id;
			}

			
			if (!sk->sk_bound_dev_if)
				goto out_unlock_rcu;

			err = -ENODEV;
			dev = dev_get_by_index_rcu(sock_net(sk),
						   sk->sk_bound_dev_if);
			if (!dev)
				goto out_unlock_rcu;
		}

		
		v4addr = LOOPBACK4_IPV6;
		err = -EADDRNOTAVAIL;
		if (!ipv6_chk_addr(sock_net(sk), &addr->l2tp_addr, dev, 0))
			goto out_unlock_rcu;
	}
	rcu_read_unlock();

	inet->inet_rcv_saddr = inet->inet_saddr = v4addr;
	sk->sk_v6_rcv_saddr = addr->l2tp_addr;
	np->saddr = addr->l2tp_addr;

	l2tp_ip6_sk(sk)->conn_id = addr->l2tp_conn_id;

	write_lock_bh(&l2tp_ip6_lock);
	sk_add_bind_node(sk, &l2tp_ip6_bind_table);
	sk_del_node_init(sk);
	write_unlock_bh(&l2tp_ip6_lock);

	sock_reset_flag(sk, SOCK_ZAPPED);
	release_sock(sk);
	return 0;

out_unlock_rcu:
	rcu_read_unlock();
out_unlock:
	release_sock(sk);
	return err;

out_in_use:
	read_unlock_bh(&l2tp_ip6_lock);
	return err;
}
","1. struct ipv6_pinfo *np = inet6_sk(sk);
2. if (addr->l2tp_family != AF_INET6)
3. return -EINVAL;
4. if (addr_type & IPV6_ADDR_MULTICAST)
5. if (!sk->sk_bound_dev_if)
6. sk->sk_bound_dev_if);
7. if (!ipv6_chk_addr(sock_net(sk), &addr->l2tp_addr, dev, 0))
8. return err;","4
11
14
23
58
63
73
97","CWE-362,CWE-264,CWE-19"
jp2_cmap_getdata,"static int jp2_cmap_getdata(jp2_box_t *box, jas_stream_t *in)
{
 	jp2_cmap_t *cmap = &box->data.cmap;
 	jp2_cmapent_t *ent;
 	unsigned int i;
	cmap->ents = 0;
 
 	cmap->numchans = (box->datalen) / 4;
 	if (!(cmap->ents = jas_alloc2(cmap->numchans, sizeof(jp2_cmapent_t)))) {
		return -1;
	}
	for (i = 0; i < cmap->numchans; ++i) {
		ent = &cmap->ents[i];
		if (jp2_getuint16(in, &ent->cmptno) ||
		  jp2_getuint8(in, &ent->map) ||
		  jp2_getuint8(in, &ent->pcol)) {
			return -1;
		}
	}
	
	return 0;
}
","1. jp2_cmap_t *cmap = &box->data.cmap;
jp2_cmapent_t *ent;
2. ent = &cmap->ents[i];
if (jp2_getuint16(in, &ent->cmptno) ||
3. return -1;","3-4
13-14
17","CWE-476,CWE-189,CWE-416"
nr_recvmsg_1-173498323959875,"static int nr_recvmsg_1(struct kiocb *iocb, struct socket *sock,
		      struct msghdr *msg, size_t size, int flags)
{
	struct sock *sk = sock->sk;
	struct sockaddr_ax25 *sax = (struct sockaddr_ax25 *)msg->msg_name;
	size_t copied;
	struct sk_buff *skb;
	int er;

	

	lock_sock(sk);
	if (sk->sk_state != TCP_ESTABLISHED) {
		release_sock(sk);
		return -ENOTCONN;
	}

	
	if ((skb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT, flags & MSG_DONTWAIT, &er)) == NULL) {
		release_sock(sk);
		return er;
	}

	skb_reset_transport_header(skb);
	copied     = skb->len;

	if (copied > size) {
		copied = size;
		msg->msg_flags |= MSG_TRUNC;
	}

	er = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);
	if (er < 0) {
		skb_free_datagram(sk, skb);
		release_sock(sk);
		return er;
	}

	if (sax != NULL) {
		memset(sax, 0, sizeof(*sax));
		sax->sax25_family = AF_NETROM;
		skb_copy_from_linear_data_offset(skb, 7, sax->sax25_call.ax25_call,
			      AX25_ADDR_LEN);
	}

	msg->msg_namelen = sizeof(*sax);

	skb_free_datagram(sk, skb);

	release_sock(sk);
	return copied;
}
","1. static int nr_recvmsg_1(struct kiocb *iocb, struct socket *sock,
2. struct sock *sk = sock->sk;
3. msg->msg_namelen = sizeof(*sax);","1
4
49","CWE-362,CWE-200,CWE-17"
BrokerDuplicateHandle,"
#define DWORD
#define HANDLE

bool BrokerDuplicateHandle(HANDLE source_handle,
                           DWORD target_process_id,
                            HANDLE* target_handle,
                            DWORD desired_access,
                            DWORD options) {
  
  if (::GetCurrentProcessId() == target_process_id) {
    return !!::DuplicateHandle(::GetCurrentProcess(), source_handle,
                               ::GetCurrentProcess(), target_handle,
                               desired_access, FALSE, options);
 
  }

  
  if (g_target_services &&
      g_target_services->DuplicateHandle(source_handle, target_process_id,
                                         target_handle, desired_access,
                                         options) == SBOX_ALL_OK) {
     return true;
   }
 
  
  base::win::ScopedHandle target_process;
  target_process.Set(::OpenProcess(PROCESS_DUP_HANDLE, FALSE,
                                    target_process_id));
  if (target_process.IsValid()) {
    return !!::DuplicateHandle(::GetCurrentProcess(), source_handle,
                                target_process, target_handle,
                                desired_access, FALSE, options);
  }

  return false;
 }
","1. DWORD options) {
2. if (g_target_services &&
3. options) == SBOX_ALL_OK) {","9
19
22","CWE-20,CWE-369,CWE-476,CWE-787,CWE-119"
has_byte,"static bool has_byte(const eager_reader_t *reader) {
  assert(reader != NULL);

  fd_set read_fds;
  FD_ZERO(&read_fds);
  FD_SET(reader->bytes_available_fd, &read_fds);

 struct timeval timeout;

   timeout.tv_sec = 0;
   timeout.tv_usec = 0;
 
  TEMP_FAILURE_RETRY(select(reader->bytes_available_fd + 1, &read_fds, NULL, NULL, &timeout));
   return FD_ISSET(reader->bytes_available_fd, &read_fds);
 }
","1. assert(reader != NULL);
2. FD_SET(reader->bytes_available_fd, &read_fds);
3. struct timeval timeout;
4. timeout.tv_sec = 0;","2
6
8
10","CWE-284,CWE-400,CWE-787,CWE-119,CWE-125"
armass_assemble-199944803204071,"ut32 armass_assemble(const char *str, ut64 off, int thumb) {
	int i, j;
	char buf[128];
	ArmOpcode aop = {.off = off};
	for (i = j = 0; i < sizeof (buf) - 1 && str[j]; i++, j++) {
		if (str[j] == '#') {
			i--; continue;
		}
		buf[i] = tolower ((const ut8)str[j]);
	}
	buf[i] = 0;
	arm_opcode_parse (&aop, buf);
	aop.off = off;
	if (thumb < 0 || thumb > 1) {
		return -1;
	}
	if (!assemble[thumb] (&aop, off, buf)) {
		
		return -1;
	}
	return aop.o;
}
","1. char buf[128];
ArmOpcode aop = {.off = off};
2. buf[i] = tolower ((const ut8)str[j]);
3. buf[i] = 0;
arm_opcode_parse (&aop, buf);
4. if (thumb < 0 || thumb > 1) {
return -1;","3-4
9
11-12
14-15","CWE-476,CWE-190,CWE-189"
print_summary-131645810460448,"
#define MOBIData

void print_summary(const MOBIData *m) {
    char *title = mobi_meta_get_title(m);
    if (title) {
        printf(""Title: %s\n"", title);
        free(title);
    }
    char *author = mobi_meta_get_author(m);
    if (author) {
        printf(""Author: %s\n"", author);
        free(author);
    }
    char *contributor = mobi_meta_get_contributor(m);
    uint32_t major = 0, minor = 0, build = 0;
    bool is_calibre = false;
    if (contributor) {
        const char *calibre_contributor = ""calibre ("";
        if (strncmp(contributor, calibre_contributor, strlen(calibre_contributor)) == 0) {
            is_calibre = true;
            sscanf(contributor, ""calibre (%u.%u.%u)"", &major, &minor, &build);
        } else {
            printf(""Contributor: %s\n"", contributor);
        }
        free(contributor);
    }
    char *subject = mobi_meta_get_subject(m);
    if (subject) {
        printf(""Subject: %s\n"", subject);
        free(subject);
    }
    char *publisher = mobi_meta_get_publisher(m);
    if (publisher) {
        printf(""Publisher: %s\n"", publisher);
        free(publisher);
    }
    char *date = mobi_meta_get_publishdate(m);
    if (date) {
        printf(""Publishing date: %s\n"", date);
        free(date);
    }
    char *description = mobi_meta_get_description(m);
    if (description) {
        printf(""Description: %s\n"", description);
        free(description);
    }
    char *review = mobi_meta_get_review(m);
    if (review) {
        printf(""Review: %s\n"", review);
        free(review);
    }
    char *imprint = mobi_meta_get_imprint(m);
    if (imprint) {
        printf(""Imprint: %s\n"", imprint);
        free(imprint);
    }
    char *copyright = mobi_meta_get_copyright(m);
    if (copyright) {
        printf(""Copyright: %s\n"", copyright);
        free(copyright);
    }
    char *isbn = mobi_meta_get_isbn(m);
    if (isbn) {
        printf(""ISBN: %s\n"", isbn);
        free(isbn);
    }
    char *asin = mobi_meta_get_asin(m);
    if (asin) {
        printf(""ASIN: %s\n"", asin);
        free(asin);
    }
    char *language = mobi_meta_get_language(m);
    if (language) {
        printf(""Language: %s"", language);
        free(language);
        if (m->mh && m->mh->text_encoding) {
            uint32_t encoding = *m->mh->text_encoding;
            if (encoding == MOBI_CP1252) {
                printf("" (cp1252)"");
            } else if (encoding == MOBI_UTF8) {
                printf("" (utf8)"");
            }
        }
        printf(""\n"");
    }
    if (mobi_is_dictionary(m)) {
        printf(""Dictionary"");
        if (m->mh && m->mh->dict_input_lang && m->mh->dict_output_lang &&
            *m->mh->dict_input_lang && *m->mh->dict_output_lang) {
            const char *locale_in = mobi_get_locale_string(*m->mh->dict_input_lang);
            const char *locale_out = mobi_get_locale_string(*m->mh->dict_output_lang);
            printf("": %s => %s"", locale_in ? locale_in : ""unknown"", locale_out ? locale_out : ""unknown"");
        }
        printf(""\n"");
    }
    printf(""__\n"");
    if (strcmp(m->ph->type, ""TEXt"") == 0) {
        if (strcmp(m->ph->creator, ""TlDc"") == 0) {
            printf(""TealDoc\n"");
        } else {
            printf(""PalmDoc\n"");
        }
    } else {
        printf(""Mobi version: %zu"", mobi_get_fileversion(m));
        if (mobi_is_hybrid(m)) {
            size_t version = mobi_get_fileversion(m->next);
            if (version != MOBI_NOTSET) {
                printf("" (hybrid with version %zu)"", version);
            }
        }
        printf(""\n"");
    }
    if (mobi_is_replica(m)) {
        printf(""Print Replica\n"");
    }
    if (mobi_is_encrypted(m)) {
        printf(""Document is encrypted\n"");
    }
    if (is_calibre) {
        printf(""Creator software: calibre %u.%u.%u\n"", major, minor, build);
    } else {
        MOBIExthHeader *exth = mobi_get_exthrecord_by_tag(m, EXTH_CREATORSOFT);
        if (exth) {
            printf(""Creator software: "");
            uint32_t creator = mobi_decode_exthvalue(exth->data, exth->size);
            exth = mobi_get_exthrecord_by_tag(m, EXTH_CREATORMAJOR);
            if (exth) {
                major = mobi_decode_exthvalue(exth->data, exth->size);
            }
            exth = mobi_get_exthrecord_by_tag(m, EXTH_CREATORMINOR);
            if (exth) {
                minor = mobi_decode_exthvalue(exth->data, exth->size);
            }
            exth = mobi_get_exthrecord_by_tag(m, EXTH_CREATORBUILD);
            if (exth) {
                build = mobi_decode_exthvalue(exth->data, exth->size);
            }
            exth = mobi_get_exthrecord_by_tag(m, EXTH_CREATORBUILDREV);
            if (major == 2 && minor == 9 && build == 0 && exth) {
                char *rev = mobi_decode_exthstring(m, exth->data, exth->size);
                if (rev) {
                    if (strcmp(rev, ""0730-890adc2"") == 0) {
                        is_calibre = true;
                    }
                    free(rev);
                }
            }
            switch (creator) {
                case 0:
                    printf(""mobipocket reader %u.%u.%u"", major, minor, build);
                    break;
                case 1:
                case 101:
                    printf(""mobigen %u.%u.%u"", major, minor, build);
                    break;
                case 2:
                    printf(""mobipocket creator %u.%u.%u"", major, minor, build);
                    break;
                case 200:
                    printf(""kindlegen %u.%u.%u (windows)"", major, minor, build);
                    if (is_calibre) {
                        printf("" or calibre"");
                    }
                    break;
                case 201:
                    printf(""kindlegen %u.%u.%u (linux)"", major, minor, build);
                    if ((major == 1 && minor == 2 && build == 33307) ||
                        (major == 2 && minor == 0 && build == 101) ||
                        is_calibre) {
                        printf("" or calibre"");
                    }
                    break;
                case 202:
                    printf(""kindlegen %u.%u.%u (mac)"", major, minor, build);
                    if (is_calibre) {
                        printf("" or calibre"");
                    }
                    break;
                default:
                    printf(""unknown"");
                    break;
            }
            printf(""\n"");
        }
    }
}
","1. void print_summary(const MOBIData *m) {
2. if (title) {
3. if (contributor) {
4. if (strncmp(contributor, calibre_contributor, strlen(calibre_contributor)) == 0) {
5. } else {
printf(""Contributor: %s\n"", contributor);
6. free(subject);
7. char *publisher = mobi_meta_get_publisher(m);
8. if (date) {
9. char *description = mobi_meta_get_description(m);
10. if (imprint) {
11. free(imprint);
12. char *copyright = mobi_meta_get_copyright(m);
13. if (asin) {
printf(""ASIN: %s\n"", asin);
free(asin);
14. printf(""Language: %s"", language);
free(language);
15. printf("" (cp1252)"");
16. printf("" (utf8)"");
17. printf("": %s => %s"", locale_in ? locale_in : ""unknown"", locale_out ? locale_out : ""unknown"");
18. if (strcmp(m->ph->type, ""TEXt"") == 0) {
19. if (mobi_is_encrypted(m)) {
20. if (is_calibre) {
printf(""Creator software: calibre %u.%u.%u\n"", major, minor, build);
21. if (exth) {
22. if (major == 2 && minor == 9 && build == 0 && exth) {
23. case 1:
case 101:
24. case 200:
25. if (is_calibre) {
26. printf("" or calibre"");
27. default:","4
6
18
20
23-24
31
33
39
43
54
56
58
69-71
75-76
80
82
93
98
117
120-121
132
140
153-154
160
162
171
180","CWE-476,CWE-269,CWE-119"
sf_open_virtual-124645810000022,"
#define SF_INFO
#define SF_VIRTUAL_IO

SNDFILE*
sf_open_virtual	(SF_VIRTUAL_IO *sfvirtual, int mode, SF_INFO *sfinfo, void *user_data)
{	SF_PRIVATE 	*psf ;

	
	if (sfvirtual->get_filelen == NULL || sfvirtual->seek == NULL || sfvirtual->tell == NULL)
	{	sf_errno = SFE_BAD_VIRTUAL_IO ;
		snprintf (sf_parselog, sizeof (sf_parselog), ""Bad vio_get_filelen / vio_seek / vio_tell in SF_VIRTUAL_IO struct.\n"") ;
		return NULL ;
		} ;

	if ((mode == SFM_READ || mode == SFM_RDWR) && sfvirtual->read == NULL)
	{	sf_errno = SFE_BAD_VIRTUAL_IO ;
		snprintf (sf_parselog, sizeof (sf_parselog), ""Bad vio_read in SF_VIRTUAL_IO struct.\n"") ;
		return NULL ;
		} ;

	if ((mode == SFM_WRITE || mode == SFM_RDWR) && sfvirtual->write == NULL)
	{	sf_errno = SFE_BAD_VIRTUAL_IO ;
		snprintf (sf_parselog, sizeof (sf_parselog), ""Bad vio_write in SF_VIRTUAL_IO struct.\n"") ;
		return NULL ;
		} ;

	if ((psf = psf_allocate ()) == NULL)
	{	sf_errno = SFE_MALLOC_FAILED ;
		return	NULL ;
		} ;

	psf_init_files (psf) ;

	psf->virtual_io = SF_TRUE ;
	psf->vio = *sfvirtual ;
	psf->vio_user_data = user_data ;

	psf->file.mode = mode ;

	return psf_open_file (psf, sfinfo) ;
} 
","1. sf_open_virtual	(SF_VIRTUAL_IO *sfvirtual, int mode, SF_INFO *sfinfo, void *user_data)
{	SF_PRIVATE 	*psf ;
2. if (sfvirtual->get_filelen == NULL || sfvirtual->seek == NULL || sfvirtual->tell == NULL)
{	sf_errno = SFE_BAD_VIRTUAL_IO ;
snprintf (sf_parselog, sizeof (sf_parselog), ""Bad vio_get_filelen / vio_seek / vio_tell in SF_VIRTUAL_IO struct.\n"") ;
return NULL ;
3. if ((mode == SFM_WRITE || mode == SFM_RDWR) && sfvirtual->write == NULL)
{	sf_errno = SFE_BAD_VIRTUAL_IO ;
4. if ((psf = psf_allocate ()) == NULL)
{	sf_errno = SFE_MALLOC_FAILED ;
5. psf->virtual_io = SF_TRUE ;
6. psf->vio_user_data = user_data ;
7. psf->file.mode = mode ;","6-7
10-13
22-23
28-29
35
37
39","CWE-399,CWE-119"
pci_populate_msicap-269828223107342,"int
pci_populate_msicap(struct msicap *msicap, int msgnum, int nextptr)
{
	int mmc;

	
	if (((msgnum & (msgnum - 1)) != 0) || msgnum < 1 || msgnum > 32) {
		pr_err(""%s: invalid number of msi messages!\n"", __func__);
		return -1;
	}
	mmc = ffs(msgnum) - 1;

	bzero(msicap, sizeof(struct msicap));
	msicap->capid = PCIY_MSI;
	msicap->nextptr = nextptr;
	msicap->msgctrl = PCIM_MSICTRL_64BIT | (mmc << 1);

	return 0;
}
","1. pci_populate_msicap(struct msicap *msicap, int msgnum, int nextptr)
2. int mmc;
3. pr_err(""%s: invalid number of msi messages!\n"", __func__);
return -1;
4. mmc = ffs(msgnum) - 1;
5. bzero(msicap, sizeof(struct msicap));
msicap->capid = PCIY_MSI;
msicap->nextptr = nextptr;
msicap->msgctrl = PCIM_MSICTRL_64BIT | (mmc << 1);","2
4
8-9
11
13-16","CWE-617,CWE-190,CWE-20"
mux_session_confirm,"mux_session_confirm(int id, int success, void *arg)
{
	struct mux_session_confirm_ctx *cctx = arg;
	const char *display;
	Channel *c, *cc;
	int i;
	Buffer reply;

	if (cctx == NULL)
		fatal(""%s: cctx == NULL"", __func__);
	if ((c = channel_by_id(id)) == NULL)
		fatal(""%s: no channel for id %d"", __func__, id);
	if ((cc = channel_by_id(c->ctl_chan)) == NULL)
		fatal(""%s: channel %d lacks control channel %d"", __func__,
		    id, c->ctl_chan);

	if (!success) {
		debug3(""%s: sending failure reply"", __func__);
		
		buffer_init(&reply);
		buffer_put_int(&reply, MUX_S_FAILURE);
		buffer_put_int(&reply, cctx->rid);
		buffer_put_cstring(&reply, ""Session open refused by peer"");
		goto done;
	}

	display = getenv(""DISPLAY"");
	if (cctx->want_x_fwd && options.forward_x11 && display != NULL) {
 		char *proto, *data;
 
 		
		if (client_x11_get_proto(display, options.xauth_location,
 		    options.forward_x11_trusted, options.forward_x11_timeout,
		    &proto, &data) == 0) {
			
			debug(""Requesting X11 forwarding with authentication ""
			    ""spoofing."");
			x11_request_forwarding_with_spoofing(id, display, proto,
			    data, 1);
			
			client_expect_confirm(id, ""X11 forwarding"",
			    CONFIRM_WARN);
		}
 	}
 
 	if (cctx->want_agent_fwd && options.forward_agent) {
		packet_send();
	}

	client_session2_setup(id, cctx->want_tty, cctx->want_subsys,
	    cctx->term, &cctx->tio, c->rfd, &cctx->cmd, cctx->env);

	debug3(""%s: sending success reply"", __func__);
	
	buffer_init(&reply);
	buffer_put_int(&reply, MUX_S_SESSION_OPENED);
	buffer_put_int(&reply, cctx->rid);
	buffer_put_int(&reply, c->self);

 done:
	
	buffer_put_string(&cc->output, buffer_ptr(&reply), buffer_len(&reply));
	buffer_free(&reply);

	if (cc->mux_pause <= 0)
		fatal(""%s: mux_pause %d"", __func__, cc->mux_pause);
	cc->mux_pause = 0; 
	c->open_confirm_ctx = NULL;
	buffer_free(&cctx->cmd);
	free(cctx->term);
	if (cctx->env != NULL) {
		for (i = 0; cctx->env[i] != NULL; i++)
			free(cctx->env[i]);
		free(cctx->env);
	}
	free(cctx);
}
","1. struct mux_session_confirm_ctx *cctx = arg;
const char *display;
2. if ((c = channel_by_id(id)) == NULL)
3. fatal(""%s: channel %d lacks control channel %d"", __func__,
id, c->ctl_chan);
4. goto done;
5. debug(""Requesting X11 forwarding with authentication ""
6. data, 1);
7. debug3(""%s: sending success reply"", __func__);
8. buffer_put_int(&reply, MUX_S_SESSION_OPENED);
9. buffer_put_string(&cc->output, buffer_ptr(&reply), buffer_len(&reply));
10. fatal(""%s: mux_pause %d"", __func__, cc->mux_pause);
11. if (cctx->env != NULL) {
12. free(cctx->env[i]);","3-4
11
14-15
24
36
39
53
56
62
66
71
73","CWE-200,CWE-125,CWE-134,CWE-78"
bgp_attr_unknown," bgp_attr_unknown (struct bgp_attr_parser_args *args)
 {
  bgp_size_t total = args->total;
   struct transit *transit;
   struct attr_extra *attre;
   struct peer *const peer = args->peer; 
  struct attr *const attr = args->attr;
  u_char *const startp = args->startp;
  const u_char type = args->type;
  const u_char flag = args->flags;  
  const bgp_size_t length = args->length;
  

  if (BGP_DEBUG (normal, NORMAL))
  zlog_debug (""%s Unknown attribute is received (type %d, length %d)"",
	      peer->host, type, length);
  
  if (BGP_DEBUG (events, EVENTS))
    zlog (peer->log, LOG_DEBUG, 
	  ""Unknown attribute type %d length %d is received"", type, length);

  
  stream_forward_getp (peer->ibuf, length);

  
  if (!CHECK_FLAG (flag, BGP_ATTR_FLAG_OPTIONAL))
    {
      return bgp_attr_malformed (args,
                                 BGP_NOTIFY_UPDATE_UNREC_ATTR,
                                 args->total);
    }

  
  if (! CHECK_FLAG (flag, BGP_ATTR_FLAG_TRANS))
    return BGP_ATTR_PARSE_PROCEED;

  
  SET_FLAG (*startp, BGP_ATTR_FLAG_PARTIAL);

  
  if (! ((attre = bgp_attr_extra_get(attr))->transit) )
      attre->transit = XCALLOC (MTYPE_TRANSIT, sizeof (struct transit));

  transit = attre->transit;

  if (transit->val)
    transit->val = XREALLOC (MTYPE_TRANSIT_VAL, transit->val, 
			     transit->length + total);
  else
    transit->val = XMALLOC (MTYPE_TRANSIT_VAL, total);

  memcpy (transit->val + transit->length, startp, total);
  transit->length += total;

  return BGP_ATTR_PARSE_PROCEED;
}
","1. bgp_size_t total = args->total;
2. const u_char type = args->type;
3. peer->host, type, length);
4. transit->val = XREALLOC (MTYPE_TRANSIT_VAL, transit->val,","3
9
16
54","CWE-362,CWE-264,CWE-787,CWE-119,CWE-125"
X509_cmp_time,"
#define ASN1_TIME

int X509_cmp_time(const ASN1_TIME *ctm, time_t *cmp_time)
{
    char *str;
     ASN1_TIME atm;
     long offset;
     char buff1[24], buff2[24], *p;
    int i, j, remaining;
 
     p = buff1;
    remaining = ctm->length;
     str = (char *)ctm->data;
    
     if (ctm->type == V_ASN1_UTCTIME) {
        
        int min_length = sizeof(""YYMMDDHHMMZ"") - 1;
        int max_length = sizeof(""YYMMDDHHMMSS+hhmm"") - 1;
        if (remaining < min_length || remaining > max_length)
             return 0;
         memcpy(p, str, 10);
         p += 10;
         str += 10;
        remaining -= 10;
     } else {
        
        int min_length = sizeof(""YYYYMMDDHHMMZ"") - 1;
        int max_length = sizeof(""YYYYMMDDHHMMSS.fff+hhmm"") - 1;
        if (remaining < min_length || remaining > max_length)
             return 0;
         memcpy(p, str, 12);
         p += 12;
         str += 12;
        remaining -= 12;
     }
 
     if ((*str == 'Z') || (*str == '-') || (*str == '+')) {
         *(p++) = '0';
         *(p++) = '0';
     } else {
        
        if (remaining < 2)
            return 0;
         *(p++) = *(str++);
         *(p++) = *(str++);
        remaining -= 2;
        
        if (remaining && *str == '.') {
             str++;
            remaining--;
            for (i = 0; i < 3 && remaining; i++, str++, remaining--) {
                if (*str < '0' || *str > '9')
                    break;
            }
         }
 
     }
     *(p++) = 'Z';
     *(p++) = '\0';
 
    
    if (!remaining)
        return 0;
    if (*str == 'Z') {
        if (remaining != 1)
            return 0;
         offset = 0;
    } else {
        
         if ((*str != '+') && (*str != '-'))
             return 0;
        
        if (remaining != 5)
            return 0;
        if (str[1] < '0' || str[1] > '9' || str[2] < '0' || str[2] > '9' ||
            str[3] < '0' || str[3] > '9' || str[4] < '0' || str[4] > '9')
            return 0;
         offset = ((str[1] - '0') * 10 + (str[2] - '0')) * 60;
         offset += (str[3] - '0') * 10 + (str[4] - '0');
         if (*str == '-')
            offset = -offset;
    }
    atm.type = ctm->type;
    atm.flags = 0;
    atm.length = sizeof(buff2);
    atm.data = (unsigned char *)buff2;

    if (X509_time_adj(&atm, offset * 60, cmp_time) == NULL)
        return 0;

    if (ctm->type == V_ASN1_UTCTIME) {
        i = (buff1[0] - '0') * 10 + (buff1[1] - '0');
        if (i < 50)
            i += 100;           
        j = (buff2[0] - '0') * 10 + (buff2[1] - '0');
        if (j < 50)
            j += 100;

        if (i < j)
            return -1;
        if (i > j)
            return 1;
    }
    i = strcmp(buff1, buff2);
    if (i == 0)                 
        return -1;
    else
        return i;
}
","1. char *str;
ASN1_TIME atm;
2. int i, j, remaining;
3. p = buff1;
remaining = ctm->length;
str = (char *)ctm->data;
4. int max_length = sizeof(""YYMMDDHHMMSS+hhmm"") - 1;
if (remaining < min_length || remaining > max_length)
5. p += 10;
6. remaining -= 10;
} else {
7. int min_length = sizeof(""YYYYMMDDHHMMZ"") - 1;
int max_length = sizeof(""YYYYMMDDHHMMSS.fff+hhmm"") - 1;
if (remaining < min_length || remaining > max_length)
8. memcpy(p, str, 12);
p += 12;
str += 12;
remaining -= 12;
9. if ((*str == 'Z') || (*str == '-') || (*str == '+')) {
*(p++) = '0';
*(p++) = '0';
} else {
10. if (remaining < 2)
return 0;
*(p++) = *(str++);
*(p++) = *(str++);
remaining -= 2;
11. str++;
remaining--;
12. break;
13. *(p++) = 'Z';
*(p++) = '\0';
14. if (remaining != 1)
15. offset = 0;
} else {
16. if ((*str != '+') && (*str != '-'))
return 0;
17. if (remaining != 5)
return 0;
if (str[1] < '0' || str[1] > '9' || str[2] < '0' || str[2] > '9' ||
str[3] < '0' || str[3] > '9' || str[4] < '0' || str[4] > '9')
18. offset = ((str[1] - '0') * 10 + (str[2] - '0')) * 60;
offset += (str[3] - '0') * 10 + (str[4] - '0');
19. atm.type = ctm->type;
atm.flags = 0;
atm.length = sizeof(buff2);
atm.data = (unsigned char *)buff2;
20. if (ctm->type == V_ASN1_UTCTIME) {
21. if (i < 50)
22. j = (buff2[0] - '0') * 10 + (buff2[1] - '0');
if (j < 50)
23. return -1;
if (i > j)
24. i = strcmp(buff1, buff2);
25. return -1;
26. return i;","6-7
10
12-14
24-25
28
30-31
33-35
37-40
43-46
48-52
59-60
63
68-69
75
77-78
80-81
83-86
88-89
93-96
101
103
105-106
110-111
114
116
118","CWE-20,CWE-125,CWE-119"
tcp_v6_rcv,"static int tcp_v6_rcv(struct sk_buff *skb)
{
	const struct tcphdr *th;
	const struct ipv6hdr *hdr;
	bool refcounted;
	struct sock *sk;
	int ret;
	struct net *net = dev_net(skb->dev);

	if (skb->pkt_type != PACKET_HOST)
		goto discard_it;

	
	__TCP_INC_STATS(net, TCP_MIB_INSEGS);

	if (!pskb_may_pull(skb, sizeof(struct tcphdr)))
		goto discard_it;

	th = (const struct tcphdr *)skb->data;

	if (unlikely(th->doff < sizeof(struct tcphdr)/4))
		goto bad_packet;
	if (!pskb_may_pull(skb, th->doff*4))
		goto discard_it;

	if (skb_checksum_init(skb, IPPROTO_TCP, ip6_compute_pseudo))
		goto csum_error;

	th = (const struct tcphdr *)skb->data;
	hdr = ipv6_hdr(skb);

lookup:
	sk = __inet6_lookup_skb(&tcp_hashinfo, skb, __tcp_hdrlen(th),
				th->source, th->dest, inet6_iif(skb),
				&refcounted);
	if (!sk)
		goto no_tcp_socket;

process:
	if (sk->sk_state == TCP_TIME_WAIT)
		goto do_time_wait;

	if (sk->sk_state == TCP_NEW_SYN_RECV) {
		struct request_sock *req = inet_reqsk(sk);
		struct sock *nsk;

		sk = req->rsk_listener;
		tcp_v6_fill_cb(skb, hdr, th);
		if (tcp_v6_inbound_md5_hash(sk, skb)) {
			sk_drops_add(sk, skb);
			reqsk_put(req);
			goto discard_it;
		}
		if (unlikely(sk->sk_state != TCP_LISTEN)) {
			inet_csk_reqsk_queue_drop_and_put(sk, req);
			goto lookup;
		}
		sock_hold(sk);
		refcounted = true;
		nsk = tcp_check_req(sk, skb, req, false);
		if (!nsk) {
			reqsk_put(req);
			goto discard_and_relse;
		}
		if (nsk == sk) {
			reqsk_put(req);
			tcp_v6_restore_cb(skb);
		} else if (tcp_child_process(sk, nsk, skb)) {
			tcp_v6_send_reset(nsk, skb);
			goto discard_and_relse;
		} else {
			sock_put(sk);
			return 0;
		}
	}
	if (hdr->hop_limit < inet6_sk(sk)->min_hopcount) {
		__NET_INC_STATS(net, LINUX_MIB_TCPMINTTLDROP);
		goto discard_and_relse;
	}

	if (!xfrm6_policy_check(sk, XFRM_POLICY_IN, skb))
		goto discard_and_relse;

	tcp_v6_fill_cb(skb, hdr, th);

 	if (tcp_v6_inbound_md5_hash(sk, skb))
 		goto discard_and_relse;
 
	if (tcp_filter(sk, skb))
 		goto discard_and_relse;
	th = (const struct tcphdr *)skb->data;
	hdr = ipv6_hdr(skb);
 
 	skb->dev = NULL;
 
	if (sk->sk_state == TCP_LISTEN) {
		ret = tcp_v6_do_rcv(sk, skb);
		goto put_and_return;
	}

	sk_incoming_cpu_update(sk);

	bh_lock_sock_nested(sk);
	tcp_segs_in(tcp_sk(sk), skb);
	ret = 0;
	if (!sock_owned_by_user(sk)) {
		if (!tcp_prequeue(sk, skb))
			ret = tcp_v6_do_rcv(sk, skb);
	} else if (tcp_add_backlog(sk, skb)) {
		goto discard_and_relse;
	}
	bh_unlock_sock(sk);

put_and_return:
	if (refcounted)
		sock_put(sk);
	return ret ? -1 : 0;

no_tcp_socket:
	if (!xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb))
		goto discard_it;

	tcp_v6_fill_cb(skb, hdr, th);

	if (tcp_checksum_complete(skb)) {
csum_error:
		__TCP_INC_STATS(net, TCP_MIB_CSUMERRORS);
bad_packet:
		__TCP_INC_STATS(net, TCP_MIB_INERRS);
	} else {
		tcp_v6_send_reset(NULL, skb);
	}

discard_it:
	kfree_skb(skb);
	return 0;

discard_and_relse:
	sk_drops_add(sk, skb);
	if (refcounted)
		sock_put(sk);
	goto discard_it;

do_time_wait:
	if (!xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb)) {
		inet_twsk_put(inet_twsk(sk));
		goto discard_it;
	}

	tcp_v6_fill_cb(skb, hdr, th);

	if (tcp_checksum_complete(skb)) {
		inet_twsk_put(inet_twsk(sk));
		goto csum_error;
	}

	switch (tcp_timewait_state_process(inet_twsk(sk), skb, th)) {
	case TCP_TW_SYN:
	{
		struct sock *sk2;

		sk2 = inet6_lookup_listener(dev_net(skb->dev), &tcp_hashinfo,
					    skb, __tcp_hdrlen(th),
					    &ipv6_hdr(skb)->saddr, th->source,
					    &ipv6_hdr(skb)->daddr,
					    ntohs(th->dest), tcp_v6_iif(skb));
		if (sk2) {
			struct inet_timewait_sock *tw = inet_twsk(sk);
			inet_twsk_deschedule_put(tw);
			sk = sk2;
			tcp_v6_restore_cb(skb);
			refcounted = false;
			goto process;
		}
		
	}
	case TCP_TW_ACK:
		tcp_v6_timewait_ack(sk, skb);
		break;
	case TCP_TW_RST:
		tcp_v6_restore_cb(skb);
		tcp_v6_send_reset(sk, skb);
		inet_twsk_deschedule_put(inet_twsk(sk));
		goto discard_it;
	case TCP_TW_SUCCESS:
		;
	}
	goto discard_it;
}
","1. static int tcp_v6_rcv(struct sk_buff *skb)
2. int ret;
3. if (skb->pkt_type != PACKET_HOST)
4. if (!pskb_may_pull(skb, sizeof(struct tcphdr)))
5. if (unlikely(th->doff < sizeof(struct tcphdr)/4))
goto bad_packet;
6. goto discard_it;
7. hdr = ipv6_hdr(skb);
8. if (nsk == sk) {
9. if (hdr->hop_limit < inet6_sk(sk)->min_hopcount) {
10. skb->dev = NULL;
11. goto discard_and_relse;
12. bh_unlock_sock(sk);
13. if (!xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb))
goto discard_it;
14. csum_error:
15. discard_it:
16. do_time_wait:
17. inet_twsk_put(inet_twsk(sk));
18. switch (tcp_timewait_state_process(inet_twsk(sk), skb, th)) {
case TCP_TW_SYN:
19. skb, __tcp_hdrlen(th),
20. tcp_v6_restore_cb(skb);","1
7
10
18
23-24
26
32
67
78
96
112
114
122-123
128
136
146
148
159-160
165
183","CWE-17,CWE-284,CWE-399"
udf_symlink_filler_1-23985970605335,"static int udf_symlink_filler_1(struct file *file, struct page *page)
{
	struct inode *inode = page->mapping->host;
	struct buffer_head *bh = NULL;
	unsigned char *symlink;
	int err;
	unsigned char *p = kmap(page);
	struct udf_inode_info *iinfo;
	uint32_t pos;

	
	if (inode->i_size > inode->i_sb->s_blocksize) {
		err = -ENAMETOOLONG;
		goto out_unmap;
	}

	iinfo = UDF_I(inode);
	pos = udf_block_map(inode, 0);

	down_read(&iinfo->i_data_sem);
	if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {
		symlink = iinfo->i_ext.i_data + iinfo->i_lenEAttr;
	} else {
		bh = sb_bread(inode->i_sb, pos);

		if (!bh) {
			err = -EIO;
			goto out_unlock_inode;
		}

		symlink = bh->b_data;
	}

	err = udf_pc_to_char(inode->i_sb, symlink, inode->i_size, p, PAGE_SIZE);
	brelse(bh);
	if (err)
		goto out_unlock_inode;

	up_read(&iinfo->i_data_sem);
	SetPageUptodate(page);
	kunmap(page);
	unlock_page(page);
	return 0;

out_unlock_inode:
	up_read(&iinfo->i_data_sem);
	SetPageError(page);
out_unmap:
	kunmap(page);
	unlock_page(page);
	return err;
}
","1. static int udf_symlink_filler_1(struct file *file, struct page *page)
2. struct inode *inode = page->mapping->host;
3. int err;
unsigned char *p = kmap(page);
4. err = -ENAMETOOLONG;
goto out_unmap;
5. pos = udf_block_map(inode, 0);
6. down_read(&iinfo->i_data_sem);
if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {
symlink = iinfo->i_ext.i_data + iinfo->i_lenEAttr;
7. if (!bh) {
err = -EIO;
8. symlink = bh->b_data;
9. brelse(bh);
if (err)
goto out_unlock_inode;
10. SetPageUptodate(page);
kunmap(page);
11. return 0;
12. out_unlock_inode:
up_read(&iinfo->i_data_sem);
13. out_unmap:
kunmap(page);
unlock_page(page);
return err;","1
3
6-7
13-14
18
20-22
26-27
31
35-37
40-41
43
45-46
48-51","CWE-476,CWE-120,CWE-787,CWE-119"
xmlParsePEReference_1,"xmlParsePEReference_1(xmlParserCtxtPtr ctxt)
{
    const xmlChar *name;
    xmlEntityPtr entity = NULL;
    xmlParserInputPtr input;

    if (RAW != '%')
        return;
    NEXT;
    name = xmlParseName(ctxt);
    if (name == NULL) {
	xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,
		       ""xmlParsePEReference_1: no name\n"");
	return;
    }
    if (RAW != ';') {
	xmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING, NULL);
        return;
    }

    NEXT;

    
    ctxt->nbentities++;

    
     if ((ctxt->sax != NULL) &&
 	(ctxt->sax->getParameterEntity != NULL))
	entity = ctxt->sax->getParameterEntity(ctxt->userData, name);
    if (ctxt->instate == XML_PARSER_EOF)
	return;
     if (entity == NULL) {
 	
	if ((ctxt->standalone == 1) ||
	    ((ctxt->hasExternalSubset == 0) &&
	     (ctxt->hasPErefs == 0))) {
	    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,
			      ""PEReference: %%%s; not found\n"",
			      name);
	} else {
	    
	    xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,
			  ""PEReference: %%%s; not found\n"",
			  name, NULL);
	    ctxt->valid = 0;
	}
    } else {
	
	if ((entity->etype != XML_INTERNAL_PARAMETER_ENTITY) &&
	    (entity->etype != XML_EXTERNAL_PARAMETER_ENTITY)) {
	    xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,
		  ""Internal: %%%s; is not a parameter entity\n"",
			  name, NULL);
	} else if (ctxt->input->free != deallocblankswrapper) {
	    input = xmlNewBlanksWrapperInputStream(ctxt, entity);
	    if (xmlPushInput(ctxt, input) < 0)
		return;
	} else {
	    
	    input = xmlNewEntityInputStream(ctxt, entity);
	    if (xmlPushInput(ctxt, input) < 0)
		return;
	    if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&
		(CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) &&
		(IS_BLANK_CH(NXT(5)))) {
		xmlParseTextDecl(ctxt);
		if (ctxt->errNo ==
		    XML_ERR_UNSUPPORTED_ENCODING) {
		    
		    ctxt->instate = XML_PARSER_EOF;
		    return;
		}
	    }
	}
    }
    ctxt->hasPErefs = 1;
}
","1. if (ctxt->instate == XML_PARSER_EOF)
2. name);
3. xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,
4. if (xmlPushInput(ctxt, input) < 0)
5. if (ctxt->errNo ==
6. ctxt->instate = XML_PARSER_EOF;
return;","34
50
59
84
90
96-97","CWE-617,CWE-347,CWE-843,CWE-119,CWE-125"
dissect_pktap,"dissect_pktap(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
{
	proto_tree *pktap_tree = NULL;
	proto_item *ti = NULL;
 	tvbuff_t *next_tvb;
 	int offset = 0;
 	guint32 pkt_len, rectype, dlt;
	int wtap_encap;
	struct eth_phdr eth;
	void *phdr;
 
 	col_set_str(pinfo->cinfo, COL_PROTOCOL, ""PKTAP"");
 	col_clear(pinfo->cinfo, COL_INFO);

	pkt_len = tvb_get_letohl(tvb, offset);
	col_add_fstr(pinfo->cinfo, COL_INFO, ""PKTAP, %u byte header"", pkt_len);

	
	ti = proto_tree_add_item(tree, proto_pktap, tvb, offset, pkt_len, ENC_NA);
	pktap_tree = proto_item_add_subtree(ti, ett_pktap);

	proto_tree_add_item(pktap_tree, hf_pktap_hdrlen, tvb, offset, 4,
	    ENC_LITTLE_ENDIAN);
	if (pkt_len < MIN_PKTAP_HDR_LEN) {
		proto_tree_add_expert(tree, pinfo, &ei_pktap_hdrlen_too_short,
		    tvb, offset, 4);
		return;
	}
	offset += 4;

	proto_tree_add_item(pktap_tree, hf_pktap_rectype, tvb, offset, 4,
	    ENC_LITTLE_ENDIAN);
	rectype = tvb_get_letohl(tvb, offset);
	offset += 4;
	proto_tree_add_item(pktap_tree, hf_pktap_dlt, tvb, offset, 4,
	    ENC_LITTLE_ENDIAN);
	dlt = tvb_get_letohl(tvb, offset);
	offset += 4;
	proto_tree_add_item(pktap_tree, hf_pktap_ifname, tvb, offset, 24,
	    ENC_ASCII|ENC_NA);
	offset += 24;
	proto_tree_add_item(pktap_tree, hf_pktap_flags, tvb, offset, 4,
	    ENC_LITTLE_ENDIAN);
	offset += 4;
	proto_tree_add_item(pktap_tree, hf_pktap_pfamily, tvb, offset, 4,
	    ENC_LITTLE_ENDIAN);
	offset += 4;
	proto_tree_add_item(pktap_tree, hf_pktap_llhdrlen, tvb, offset, 4,
	    ENC_LITTLE_ENDIAN);
	offset += 4;
	proto_tree_add_item(pktap_tree, hf_pktap_lltrlrlen, tvb, offset, 4,
	    ENC_LITTLE_ENDIAN);
	offset += 4;
	proto_tree_add_item(pktap_tree, hf_pktap_pid, tvb, offset, 4,
	    ENC_LITTLE_ENDIAN);
	offset += 4;
	proto_tree_add_item(pktap_tree, hf_pktap_cmdname, tvb, offset, 20,
	    ENC_UTF_8|ENC_NA);
	offset += 20;
	proto_tree_add_item(pktap_tree, hf_pktap_svc_class, tvb, offset, 4,
	    ENC_LITTLE_ENDIAN);
	offset += 4;
	proto_tree_add_item(pktap_tree, hf_pktap_iftype, tvb, offset, 2,
	    ENC_LITTLE_ENDIAN);
	offset += 2;
	proto_tree_add_item(pktap_tree, hf_pktap_ifunit, tvb, offset, 2,
	    ENC_LITTLE_ENDIAN);
	offset += 2;
	proto_tree_add_item(pktap_tree, hf_pktap_epid, tvb, offset, 4,
	    ENC_LITTLE_ENDIAN);
	offset += 4;
	proto_tree_add_item(pktap_tree, hf_pktap_ecmdname, tvb, offset, 20,
	    ENC_UTF_8|ENC_NA);
	
 
 	if (rectype == PKT_REC_PACKET) {
 		next_tvb = tvb_new_subset_remaining(tvb, pkt_len);
		wtap_encap = wtap_pcap_encap_to_wtap_encap(dlt);
		switch (wtap_encap) {

		case WTAP_ENCAP_ETHERNET:
			eth.fcs_len = -1;    
			phdr = &eth;
			break;

		default:
			phdr = NULL;
			break;
		}
		dissector_try_uint_new(wtap_encap_dissector_table,
		    wtap_encap, next_tvb, pinfo, tree, TRUE, phdr);
 	}
 }
","1. col_clear(pinfo->cinfo, COL_INFO);
2. proto_tree_add_item(pktap_tree, hf_pktap_hdrlen, tvb, offset, 4,
3. ENC_LITTLE_ENDIAN);
4. offset += 20;
5. ENC_LITTLE_ENDIAN);
6. if (rectype == PKT_REC_PACKET) {
7. eth.fcs_len = -1;
8. phdr = NULL;","13
22
55
59
67
76
82
87","CWE-20,CWE-120,CWE-416,CWE-787,CWE-17"
xsltForEach,"xsltForEach(xsltTransformContextPtr ctxt, xmlNodePtr contextNode,
	    xmlNodePtr inst, xsltStylePreCompPtr castedComp)
{
#ifdef XSLT_REFACTORED
    xsltStyleItemForEachPtr comp = (xsltStyleItemForEachPtr) castedComp;
#else
    xsltStylePreCompPtr comp = castedComp;
#endif
    int i;
    xmlXPathObjectPtr res = NULL;
    xmlNodePtr cur, curInst;
    xmlNodeSetPtr list = NULL;
    xmlNodeSetPtr oldList;
    int oldXPProximityPosition, oldXPContextSize;
    xmlNodePtr oldContextNode;
    xsltTemplatePtr oldCurTemplRule;
    xmlDocPtr oldXPDoc;
    xsltDocumentPtr oldDocInfo;
    xmlXPathContextPtr xpctxt;

    if ((ctxt == NULL) || (contextNode == NULL) || (inst == NULL)) {
	xsltGenericError(xsltGenericErrorContext,
	    ""xsltForEach(): Bad arguments.\n"");
	return;
    }

    if (comp == NULL) {
        xsltTransformError(ctxt, NULL, inst,
	    ""Internal error in xsltForEach(): ""
	    ""The XSLT 'for-each' instruction was not compiled.\n"");
        return;
    }
    if ((comp->select == NULL) || (comp->comp == NULL)) {
	xsltTransformError(ctxt, NULL, inst,
	    ""Internal error in xsltForEach(): ""
	    ""The selecting expression of the XSLT 'for-each' ""
	    ""instruction was not compiled correctly.\n"");
	return;
    }
    xpctxt = ctxt->xpathCtxt;

#ifdef WITH_XSLT_DEBUG_PROCESS
    XSLT_TRACE(ctxt,XSLT_TRACE_FOR_EACH,xsltGenericDebug(xsltGenericDebugContext,
	 ""xsltForEach: select %s\n"", comp->select));
#endif

    
    oldDocInfo = ctxt->document;
    oldList = ctxt->nodeList;
    oldContextNode = ctxt->node;
    
    oldCurTemplRule = ctxt->currentTemplateRule;
    ctxt->currentTemplateRule = NULL;

     oldXPDoc = xpctxt->doc;
     oldXPProximityPosition = xpctxt->proximityPosition;
     oldXPContextSize = xpctxt->contextSize;
 
     
    res = xsltPreCompEval(ctxt, contextNode, comp);
 
     if (res != NULL) {
 	if (res->type == XPATH_NODESET)
	    list = res->nodesetval;
	else {
	    xsltTransformError(ctxt, NULL, inst,
		""The 'select' expression does not evaluate to a node set.\n"");

#ifdef WITH_XSLT_DEBUG_PROCESS
	    XSLT_TRACE(ctxt,XSLT_TRACE_FOR_EACH,xsltGenericDebug(xsltGenericDebugContext,
		""xsltForEach: select didn't evaluate to a node list\n""));
#endif
	    goto error;
	}
    } else {
	xsltTransformError(ctxt, NULL, inst,
	    ""Failed to evaluate the 'select' expression.\n"");
	ctxt->state = XSLT_STATE_STOPPED;
	goto error;
    }

    if ((list == NULL) || (list->nodeNr <= 0))
	goto exit;

#ifdef WITH_XSLT_DEBUG_PROCESS
    XSLT_TRACE(ctxt,XSLT_TRACE_FOR_EACH,xsltGenericDebug(xsltGenericDebugContext,
 	""xsltForEach: select evaluates to %d nodes\n"", list->nodeNr));
 #endif
 
     
    ctxt->nodeList = list;
    
    curInst = inst->children;
    if (IS_XSLT_ELEM(curInst) && IS_XSLT_NAME(curInst, ""sort"")) {
	int nbsorts = 0;
	xmlNodePtr sorts[XSLT_MAX_SORT];

	sorts[nbsorts++] = curInst;

#ifdef WITH_DEBUGGER
	if (xslDebugStatus != XSLT_DEBUG_NONE)
	    xslHandleDebugger(curInst, contextNode, NULL, ctxt);
#endif

	curInst = curInst->next;
	while (IS_XSLT_ELEM(curInst) && IS_XSLT_NAME(curInst, ""sort"")) {
	    if (nbsorts >= XSLT_MAX_SORT) {
		xsltTransformError(ctxt, NULL, curInst,
		    ""The number of xsl:sort instructions exceeds the ""
		    ""maximum (%d) allowed by this processor.\n"",
		    XSLT_MAX_SORT);
		goto error;
	    } else {
		sorts[nbsorts++] = curInst;
	    }

#ifdef WITH_DEBUGGER
	    if (xslDebugStatus != XSLT_DEBUG_NONE)
		xslHandleDebugger(curInst, contextNode, NULL, ctxt);
#endif
	    curInst = curInst->next;
	}
	xsltDoSortFunction(ctxt, sorts, nbsorts);
    }
    xpctxt->contextSize = list->nodeNr;
    
    for (i = 0; i < list->nodeNr; i++) {
	cur = list->nodeTab[i];
	
	ctxt->node = cur;
	
	if ((cur->type != XML_NAMESPACE_DECL) && (cur->doc != NULL))
	    xpctxt->doc = cur->doc;

	xpctxt->proximityPosition = i + 1;

	xsltApplySequenceConstructor(ctxt, cur, curInst, NULL);
    }

exit:
error:
    if (res != NULL)
	xmlXPathFreeObject(res);
    
    ctxt->document = oldDocInfo;
    ctxt->nodeList = oldList;
    ctxt->node = oldContextNode;
    ctxt->currentTemplateRule = oldCurTemplRule;

    xpctxt->doc = oldXPDoc;
    xpctxt->contextSize = oldXPContextSize;
    xpctxt->proximityPosition = oldXPProximityPosition;
}
","1. int oldXPProximityPosition, oldXPContextSize;
xmlNodePtr oldContextNode;
2. xsltDocumentPtr oldDocInfo;
xmlXPathContextPtr xpctxt;
3. xpctxt = ctxt->xpathCtxt;
4. ctxt->nodeList = list;
5. curInst = curInst->next;
6. xpctxt->contextSize = list->nodeNr;
7. ctxt->node = oldContextNode;","14-15
18-19
40
100
134
138
169","CWE-125,CWE-119"
set_fat-182496919291496,"
#define DOS_FS

void set_fat(DOS_FS * fs, uint32_t cluster, int32_t new)
{
    unsigned char *data = NULL;
    int size;
    loff_t offs;

    if (new == -1)
	new = FAT_EOF(fs);
    else if ((long)new == -2)
	new = FAT_BAD(fs);
    switch (fs->fat_bits) {
    case 12:
	data = fs->fat + cluster * 3 / 2;
	offs = fs->fat_start + cluster * 3 / 2;
	if (cluster & 1) {
	    FAT_ENTRY prevEntry;
	    get_fat(&prevEntry, fs->fat, cluster - 1, fs);
	    data[0] = ((new & 0xf) << 4) | (prevEntry.value >> 8);
	    data[1] = new >> 4;
	} else {
	    FAT_ENTRY subseqEntry;
	    if (cluster != fs->clusters + 1)
		get_fat(&subseqEntry, fs->fat, cluster + 1, fs);
	    else
		subseqEntry.value = 0;
	    data[0] = new & 0xff;
	    data[1] = (new >> 8) | ((0xff & subseqEntry.value) << 4);
	}
	size = 2;
	break;
    case 16:
	data = fs->fat + cluster * 2;
	offs = fs->fat_start + cluster * 2;
	*(unsigned short *)data = htole16(new);
	size = 2;
	break;
    case 32:
	{
	    FAT_ENTRY curEntry;
	    get_fat(&curEntry, fs->fat, cluster, fs);

	    data = fs->fat + cluster * 4;
	    offs = fs->fat_start + cluster * 4;
	    
	    *(uint32_t *)data = htole32((new & 0xfffffff) |
					     (curEntry.reserved << 28));
	    size = 4;
	}
	break;
    default:
	die(""Bad FAT entry size: %d bits."", fs->fat_bits);
    }
    fs_write(offs, size, data);
    if (fs->nfats > 1) {
	fs_write(offs + fs->fat_size, size, data);
    }
}
","1. switch (fs->fat_bits) {
2. data[1] = new >> 4;
3. get_fat(&subseqEntry, fs->fat, cluster + 1, fs);
4. subseqEntry.value = 0;
5. data = fs->fat + cluster * 2;
6. case 32:
7. data = fs->fat + cluster * 4;","14
22
26
28
35
40
45","CWE-367,CWE-190,CWE-189"
sort_page_names_1-149563134349538,"static int
sort_page_names_1 (gconstpointer a,
                 gconstpointer b)
{
	gchar *temp1, *temp2;
	gint ret;
	temp1 = g_utf8_collate_key_for_filename (* (const char **) a, -1);
	temp2 = g_utf8_collate_key_for_filename (* (const char **) b, -1);
	ret = strcmp (temp1, temp2);

	g_free (temp1);
	g_free (temp2);
	return ret;
}
","1. static int
sort_page_names_1 (gconstpointer a,
gconstpointer b)
2. gchar *temp1, *temp2;
gint ret;
temp1 = g_utf8_collate_key_for_filename (* (const char **) a, -1);
temp2 = g_utf8_collate_key_for_filename (* (const char **) b, -1);
ret = strcmp (temp1, temp2);
3. g_free (temp1);
g_free (temp2);
return ret;","1-3
5-9
11-13","CWE-190,CWE-20,CWE-189"
mrb_realloc-5701057722757,"MRB_API void*
mrb_realloc(mrb_state *mrb, void *p, size_t len)
{
  void *p2;

  p2 = mrb_realloc_simple(mrb, p, len);
  if (len == 0) return p2;
  if (p2 == NULL) {
    mrb->gc.out_of_memory = TRUE;
    mrb_raise_nomemory(mrb);
  }
  else {
    mrb->gc.out_of_memory = FALSE;
  }

  return p2;
}
","1. mrb_realloc(mrb_state *mrb, void *p, size_t len)
2. void *p2;
3. if (len == 0) return p2;
4. mrb_raise_nomemory(mrb);
5. else {
6. return p2;","2
4
7
10
12
16","CWE-476,CWE-190,CWE-119,CWE-189"
br_mdb_fill_info-151381946993090,"static int br_mdb_fill_info(struct sk_buff *skb, struct netlink_callback *cb,
			    struct net_device *dev)
{
	struct net_bridge *br = netdev_priv(dev);
	struct net_bridge_mdb_htable *mdb;
	struct nlattr *nest, *nest2;
	int i, err = 0;
	int idx = 0, s_idx = cb->args[1];

	if (br->multicast_disabled)
		return 0;

	mdb = rcu_dereference(br->mdb);
	if (!mdb)
		return 0;

	nest = nla_nest_start(skb, MDBA_MDB);
	if (nest == NULL)
		return -EMSGSIZE;

	for (i = 0; i < mdb->max; i++) {
		struct net_bridge_mdb_entry *mp;
		struct net_bridge_port_group *p, **pp;
		struct net_bridge_port *port;

		hlist_for_each_entry_rcu(mp, &mdb->mhash[i], hlist[mdb->ver]) {
			if (idx < s_idx)
				goto skip;

			nest2 = nla_nest_start(skb, MDBA_MDB_ENTRY);
			if (nest2 == NULL) {
				err = -EMSGSIZE;
				goto out;
			}

			for (pp = &mp->ports;
			     (p = rcu_dereference(*pp)) != NULL;
			      pp = &p->next) {
				port = p->port;
				if (port) {
					struct br_mdb_entry e;
					memset(&e, 0, sizeof(e));
					e.ifindex = port->dev->ifindex;
					e.state = p->state;
					if (p->addr.proto == htons(ETH_P_IP))
						e.addr.u.ip4 = p->addr.u.ip4;
#if IS_ENABLED(CONFIG_IPV6)
					if (p->addr.proto == htons(ETH_P_IPV6))
						e.addr.u.ip6 = p->addr.u.ip6;
#endif
					e.addr.proto = p->addr.proto;
					if (nla_put(skb, MDBA_MDB_ENTRY_INFO, sizeof(e), &e)) {
						nla_nest_cancel(skb, nest2);
						err = -EMSGSIZE;
						goto out;
					}
				}
			}
			nla_nest_end(skb, nest2);
		skip:
			idx++;
		}
	}

out:
	cb->args[1] = idx;
	nla_nest_end(skb, nest);
	return err;
}
","1. struct net_bridge *br = netdev_priv(dev);
2. if (br->multicast_disabled)
return 0;
3. return 0;
4. port = p->port;
5. skip:
idx++;","4
10-11
15
39
60-61","CWE-362,CWE-787,CWE-399,CWE-119"
send_key_exchange_encrypt-161440281128623,"static status_t send_key_exchange_encrypt(private_tls_peer_t *this,
							tls_handshake_type_t *type, bio_writer_t *writer)
{
	public_key_t *public;
	rng_t *rng;
	char premaster[48];
	chunk_t encrypted;

	rng = lib->crypto->create_rng(lib->crypto, RNG_STRONG);
	if (!rng || !rng->get_bytes(rng, sizeof(premaster) - 2, premaster + 2))
	{
		DBG1(DBG_TLS, ""failed to generate TLS premaster secret"");
		this->alert->add(this->alert, TLS_FATAL, TLS_INTERNAL_ERROR);
		DESTROY_IF(rng);
		return NEED_MORE;
	}
	rng->destroy(rng);
	htoun16(premaster, this->hello_version);

	if (!this->crypto->derive_secrets(this->crypto, chunk_from_thing(premaster),
									  this->session, this->server,
									  chunk_from_thing(this->client_random),
									  chunk_from_thing(this->server_random)))
	{
		this->alert->add(this->alert, TLS_FATAL, TLS_INTERNAL_ERROR);
		return NEED_MORE;
	}

	public = tls_find_public_key(this->server_auth, this->server);
	if (!public)
	{
		DBG1(DBG_TLS, ""no TLS public key found for server '%Y'"", this->server);
		this->alert->add(this->alert, TLS_FATAL, TLS_CERTIFICATE_UNKNOWN);
		return NEED_MORE;
	}
	if (!public->encrypt(public, ENCRYPT_RSA_PKCS1, NULL,
						 chunk_from_thing(premaster), &encrypted))
	{
		public->destroy(public);
		DBG1(DBG_TLS, ""encrypting TLS premaster secret failed"");
		this->alert->add(this->alert, TLS_FATAL, TLS_BAD_CERTIFICATE);
		return NEED_MORE;
	}
	public->destroy(public);

	writer->write_data16(writer, encrypted);
	free(encrypted.ptr);

	*type = TLS_CLIENT_KEY_EXCHANGE;
	this->state = STATE_KEY_EXCHANGE_SENT;
	this->crypto->append_handshake(this->crypto, *type, writer->get_buf(writer));
	return NEED_MORE;
}
","1. static status_t send_key_exchange_encrypt(private_tls_peer_t *this,
2. public_key_t *public;
rng_t *rng;
3. chunk_t encrypted;
4. this->alert->add(this->alert, TLS_FATAL, TLS_INTERNAL_ERROR);
5. return NEED_MORE;
6. chunk_from_thing(this->client_random),
7. if (!public->encrypt(public, ENCRYPT_RSA_PKCS1, NULL,
8. return NEED_MORE;
9. *type = TLS_CLIENT_KEY_EXCHANGE;","1
4-5
7
13
15
22
36
42
49","CWE-20,CWE-189,CWE-476,CWE-119,CWE-125"
qedi_dbg_notice-122946228132671,"void
qedi_dbg_notice(struct qedi_dbg_ctx *qedi, const char *func, u32 line,
		const char *fmt, ...)
{
	va_list va;
	struct va_format vaf;

	va_start(va, fmt);

	vaf.fmt = fmt;
	vaf.va = &va;

	if (!(qedi_dbg_log & QEDI_LOG_NOTICE))
		goto ret;

	if (likely(qedi) && likely(qedi->pdev))
		pr_notice(""[%s]:[%s:%d]:%d: %pV"",
			  dev_name(&qedi->pdev->dev), func, line,
			  qedi->host_no, &vaf);
	else
		pr_notice(""[0000:00:00.0]:[%s:%d]: %pV"", func, line, &vaf);

ret:
	va_end(va);
}
","1. const char *fmt, ...)
2. struct va_format vaf;
3. vaf.fmt = fmt;
vaf.va = &va;
4. goto ret;
5. if (likely(qedi) && likely(qedi->pdev))
6. dev_name(&qedi->pdev->dev), func, line,
7. pr_notice(""[0000:00:00.0]:[%s:%d]: %pV"", func, line, &vaf);","3
6
10-11
14
16
18
21",CWE-125
trustedDecryptKeyAES-245396440263668,"void trustedDecryptKeyAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey,
                          uint64_t enc_len, char *key) {

    LOG_DEBUG(__FUNCTION__);
    INIT_ERROR_STATE

    CHECK_STATE(encryptedPrivateKey);
    CHECK_STATE(key);

    *errStatus = -9;

    int status = AES_decrypt(encryptedPrivateKey, enc_len, key, 3072);

    if (status != 0) {
        *errStatus = status;
        snprintf(errString, BUF_LEN, ""aes decrypt failed with status %d"", status);
        LOG_ERROR(errString);
        goto clean;
    }

    *errStatus = -10;

    uint64_t keyLen = strnlen(key, MAX_KEY_LENGTH);

    if (keyLen == MAX_KEY_LENGTH) {
        snprintf(errString, BUF_LEN, ""Key is not null terminated"");
        LOG_ERROR(errString);
        goto clean;
    }

    SET_SUCCESS
    clean:
    ;
}
","1. *errStatus = -9;
2. LOG_ERROR(errString);
goto clean;
3. snprintf(errString, BUF_LEN, ""Key is not null terminated"");
4. goto clean;
5. SET_SUCCESS
clean:","10
17-18
26
28
31-32","CWE-269,CWE-264,CWE-787"
kvm_vcpu_ioctl_x86_get_debugregs-973152190726,"static void kvm_vcpu_ioctl_x86_get_debugregs(struct kvm_vcpu *vcpu,
					     struct kvm_debugregs *dbgregs)
{
	unsigned long val;

	memset(dbgregs, 0, sizeof(*dbgregs));
	memcpy(dbgregs->db, vcpu->arch.db, sizeof(vcpu->arch.db));
	kvm_get_dr(vcpu, 6, &val);
	dbgregs->dr6 = val;
	dbgregs->dr7 = vcpu->arch.dr7;
}
",1. unsigned long val;,4,"CWE-264,CWE-416,CWE-476,CWE-119,CWE-400"
main_29-215869858763822,"int main_29(int argc, char *argv[] ) {
	int i, fails_count=0;
	CU_pSuite cryptoUtilsTestSuite, parserTestSuite;

	CU_pSuite *suites[] = {
		&cryptoUtilsTestSuite,
		&parserTestSuite,
		NULL
	};

	if (argc>1) {
		if (argv[1][0] == '-') {
			if (strcmp(argv[1], ""-verbose"") == 0) {
				verbose = 1;
			} else {
				printf (""Usage:\n %s [-verbose] to enable extensive logging\n"", argv[0]);
				return 1;
			}
		} else {
			printf (""Usage:\n %s [-verbose] to enable extensive logging\n"", argv[0]);
			return 1;
		}
	}
#ifdef HAVE_LIBXML2
	xmlInitParser();
#endif
	
	
	if (CUE_SUCCESS != CU_initialize_registry()) {
		return CU_get_error();
	}

	
	cryptoUtilsTestSuite = CU_add_suite(""Bzrtp Crypto Utils"", NULL, NULL);
	CU_add_test(cryptoUtilsTestSuite, ""zrtpKDF"", test_zrtpKDF);
	CU_add_test(cryptoUtilsTestSuite, ""CRC32"", test_CRC32);
	CU_add_test(cryptoUtilsTestSuite, ""algo agreement"", test_algoAgreement);
	CU_add_test(cryptoUtilsTestSuite, ""context algo setter and getter"", test_algoSetterGetter);
	CU_add_test(cryptoUtilsTestSuite, ""adding mandatory crypto algorithms if needed"", test_addMandatoryCryptoTypesIfNeeded);

	
	parserTestSuite = CU_add_suite(""Bzrtp ZRTP Packet Parser"", NULL, NULL);
	CU_add_test(parserTestSuite, ""Parse"", test_parser);
	CU_add_test(parserTestSuite, ""Parse hvi check fail"", test_parser_hvi);
	CU_add_test(parserTestSuite, ""Parse Exchange"", test_parserComplete);
	CU_add_test(parserTestSuite, ""State machine"", test_stateMachine);

	
	for(i=0; suites[i]; i++){
		CU_basic_run_suite(*suites[i]);
		fails_count += CU_get_number_of_tests_failed();
	}
	
	
	CU_cleanup_registry();

#ifdef HAVE_LIBXML2
	
	xmlCleanupParser();
#endif

	return (fails_count == 0 ? 0 : 1);
}
",1. verbose = 1;,14,"CWE-772,CWE-476,CWE-787,CWE-119,CWE-122"
isofs_read_inode-264892356198350,"static int isofs_read_inode(struct inode *, int relocated);
","1. static int isofs_read_inode(struct inode *, int relocated);",1,"CWE-362,CWE-190,CWE-264,CWE-119"
_gnutls_verify_certificate2-37047474456401,"static int _gnutls_verify_certificate2 (gnutls_x509_crt_t cert,
					const gnutls_x509_crt_t * trusted_cas,
					int tcas_size, unsigned int flags,
					unsigned int *output, gnutls_x509_crt_t* issuer);
","1. const gnutls_x509_crt_t * trusted_cas,
int tcas_size, unsigned int flags,",2-3,"CWE-362,CWE-347,CWE-20,CWE-125"
enl_ipc_get,"char *enl_ipc_get(const char *msg_data)
 {
 
 	static char *message = NULL;
	static size_t len = 0;
 	char buff[13], *ret_msg = NULL;
 	register unsigned char i;
 	unsigned char blen;

	if (msg_data == IPC_TIMEOUT) {
		return(IPC_TIMEOUT);
	}
	for (i = 0; i < 12; i++) {
		buff[i] = msg_data[i];
	}
	buff[12] = 0;
	blen = strlen(buff);
	if (message != NULL) {
		len += blen;
		message = (char *) erealloc(message, len + 1);
		strcat(message, buff);
	} else {
		len = blen;
		message = (char *) emalloc(len + 1);
		strcpy(message, buff);
	}
	if (blen < 12) {
		ret_msg = message;
		message = NULL;
		D((""Received complete reply:  \""%s\""\n"", ret_msg));
	}
	return(ret_msg);
}
","1. register unsigned char i;
2. for (i = 0; i < 12; i++) {
buff[i] = msg_data[i];
3. message = (char *) emalloc(len + 1);
4. if (blen < 12) {","7
13-14
24
27","CWE-20,CWE-323,CWE-476,CWE-787,CWE-119"
gf_avc_change_vui-67560933634601,"
#define GF_AVCConfig
#define GF_VUIInfo

GF_Err gf_avc_change_vui(GF_AVCConfig *avcc, GF_VUIInfo *vui_info)
{
	GF_BitStream *orig, *mod;
	AVCState avc;
	u32 i, bit_offset, flag;
	s32 idx;
	GF_AVCConfigSlot *slc;
	orig = NULL;

	if (!avcc)
		return GF_NON_COMPLIANT_BITSTREAM;

	memset(&avc, 0, sizeof(AVCState));
	avc.sps_active_idx = -1;

	i=0;
	while ((slc = (GF_AVCConfigSlot *)gf_list_enum(avcc->sequenceParameterSets, &i))) {
		u8 *no_emulation_buf = NULL;
		u32 no_emulation_buf_size = 0, emulation_bytes = 0;
		idx = gf_avc_read_sps(slc->data, slc->size, &avc, 0, &bit_offset);
		if (idx<0) {
			if ( orig )
				gf_bs_del(orig);
			continue;
		}

		
		no_emulation_buf = gf_malloc((slc->size - 1) * sizeof(char));
		no_emulation_buf_size = gf_media_nalu_remove_emulation_bytes(slc->data + 1, no_emulation_buf, slc->size - 1);

		orig = gf_bs_new(no_emulation_buf, no_emulation_buf_size, GF_BITSTREAM_READ);
		gf_bs_read_data(orig, no_emulation_buf, no_emulation_buf_size);
		gf_bs_seek(orig, 0);
		mod = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);

		
		assert(bit_offset >= 8);
		while (bit_offset - 8) {
			flag = gf_bs_read_int(orig, 1);
			gf_bs_write_int(mod, flag, 1);
			bit_offset--;
		}

		avc_hevc_vvc_rewrite_vui(vui_info, orig, mod, GF_CODECID_AVC);

		
		while (gf_bs_bits_available(orig)) {
			flag = gf_bs_read_int(orig, 1);
			gf_bs_write_int(mod, flag, 1);
		}
		gf_bs_del(orig);
		orig = NULL;
		gf_free(no_emulation_buf);

		
		gf_bs_get_content(mod, &no_emulation_buf, &flag);
		emulation_bytes = gf_media_nalu_emulation_bytes_add_count(no_emulation_buf, flag);
		if (flag+emulation_bytes+1>slc->size)
			slc->data = (char*)gf_realloc(slc->data, flag+emulation_bytes+1);
		slc->size = gf_media_nalu_add_emulation_bytes(no_emulation_buf, slc->data + 1, flag) + 1;

		gf_bs_del(mod);
		gf_free(no_emulation_buf);
	}
	return GF_OK;
}
","1. GF_Err gf_avc_change_vui(GF_AVCConfig *avcc, GF_VUIInfo *vui_info)
2. u32 i, bit_offset, flag;
3. gf_bs_seek(orig, 0);
mod = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
4. bit_offset--;
5. avc_hevc_vvc_rewrite_vui(vui_info, orig, mod, GF_CODECID_AVC);
6. while (gf_bs_bits_available(orig)) {
7. slc->data = (char*)gf_realloc(slc->data, flag+emulation_bytes+1);
8. return GF_OK;","5
9
37-38
45
48
51
63
69","CWE-401,CWE-787,CWE-119"
crypto_report_akcipher,"static int crypto_report_akcipher(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_akcipher rakcipher;
 
	strncpy(rakcipher.type, ""akcipher"", sizeof(rakcipher.type));
 
 	if (nla_put(skb, CRYPTOCFGA_REPORT_AKCIPHER,
 		    sizeof(struct crypto_report_akcipher), &rakcipher))
		goto nla_put_failure;
	return 0;

nla_put_failure:
	return -EMSGSIZE;
}
","1. struct crypto_report_akcipher rakcipher;
2. strncpy(rakcipher.type, ""akcipher"", sizeof(rakcipher.type));
3. sizeof(struct crypto_report_akcipher), &rakcipher))
4. return -EMSGSIZE;","3
5
8
13","CWE-310,CWE-200"
bump_cpu_timer-270926521384757,"static void bump_cpu_timer(struct k_itimer *timer, u64 now)
{
	int i;
	u64 delta, incr;

	if (timer->it.cpu.incr == 0)
		return;

	if (now < timer->it.cpu.expires)
		return;

	incr = timer->it.cpu.incr;
	delta = now + incr - timer->it.cpu.expires;

	
	for (i = 0; incr < delta - incr; i++)
		incr = incr << 1;

	for (; i >= 0; incr >>= 1, i--) {
		if (delta < incr)
			continue;

		timer->it.cpu.expires += incr;
		timer->it_overrun += 1LL << i;
		delta -= incr;
	}
}
","1. if (timer->it.cpu.incr == 0)
return;
2. return;
3. incr = incr << 1;
4. for (; i >= 0; incr >>= 1, i--) {
5. timer->it_overrun += 1LL << i;","6-7
10
17
19
24","CWE-190,CWE-120,CWE-119"
udf_symlink_filler," static int udf_symlink_filler(struct file *file, struct page *page)
{
	struct inode *inode = page->mapping->host;
	struct buffer_head *bh = NULL;
	unsigned char *symlink;
	int err;
	unsigned char *p = kmap(page);
	struct udf_inode_info *iinfo;
	uint32_t pos;

	
	if (inode->i_size > inode->i_sb->s_blocksize) {
		err = -ENAMETOOLONG;
		goto out_unmap;
	}

	iinfo = UDF_I(inode);
	pos = udf_block_map(inode, 0);

	down_read(&iinfo->i_data_sem);
	if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {
		symlink = iinfo->i_ext.i_data + iinfo->i_lenEAttr;
	} else {
		bh = sb_bread(inode->i_sb, pos);

		if (!bh) {
			err = -EIO;
			goto out_unlock_inode;
		}

 		symlink = bh->b_data;
 	}
 
	err = udf_pc_to_char(inode->i_sb, symlink, inode->i_size, p, PAGE_SIZE);
 	brelse(bh);
	if (err)
		goto out_unlock_inode;
 
 	up_read(&iinfo->i_data_sem);
 	SetPageUptodate(page);
	kunmap(page);
	unlock_page(page);
	return 0;

out_unlock_inode:
	up_read(&iinfo->i_data_sem);
	SetPageError(page);
out_unmap:
	kunmap(page);
	unlock_page(page);
	return err;
}
","1. static int udf_symlink_filler(struct file *file, struct page *page)
2. struct inode *inode = page->mapping->host;
3. int err;
unsigned char *p = kmap(page);
4. err = -ENAMETOOLONG;
goto out_unmap;
5. pos = udf_block_map(inode, 0);
6. down_read(&iinfo->i_data_sem);
if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {
symlink = iinfo->i_ext.i_data + iinfo->i_lenEAttr;
7. if (!bh) {
err = -EIO;
8. symlink = bh->b_data;
9. brelse(bh);
if (err)
goto out_unlock_inode;
10. up_read(&iinfo->i_data_sem);
SetPageUptodate(page);
kunmap(page);
11. return 0;
12. out_unlock_inode:
up_read(&iinfo->i_data_sem);
13. out_unmap:
kunmap(page);
unlock_page(page);
return err;","1
3
6-7
13-14
18
20-22
26-27
31
35-37
39-41
43
45-46
48-51","CWE-617,CWE-787,CWE-119"
jiffies_to_timespec,"jiffies_to_timespec(const unsigned long jiffies, struct timespec *value)
{
	
	u32 rem;
	value->tv_sec = div_u64_rem((u64)jiffies * TICK_NSEC,
				    NSEC_PER_SEC, &rem);
	value->tv_nsec = rem;
 }
","1. jiffies_to_timespec(const unsigned long jiffies, struct timespec *value)
2. u32 rem;
value->tv_sec = div_u64_rem((u64)jiffies * TICK_NSEC,
NSEC_PER_SEC, &rem);
value->tv_nsec = rem;","1
7-10",CWE-189
simulate_sync-144372112931193,"static int simulate_sync(struct pt_regs *regs, unsigned int opcode)
{
	if ((opcode & OPCODE) == SPEC0 && (opcode & FUNC) == SYNC) {
		perf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS,
				1, regs, 0);
		return 0;
	}

	return -1;			
}
","1. static int simulate_sync(struct pt_regs *regs, unsigned int opcode)
2. 1, regs, 0);
return 0;
3. return -1;","1
5-6
9","CWE-310,CWE-200,CWE-399"
install_process_keyring-29584780415500,"static int install_process_keyring(void)
{
	struct cred *new;
	int ret;

	new = prepare_creds();
	if (!new)
		return -ENOMEM;

	ret = install_process_keyring_to_cred(new);
	if (ret < 0) {
		abort_creds(new);
		return ret;
	}

	return commit_creds(new);
}
","1. static int install_process_keyring(void)
2. new = prepare_creds();
3. return -ENOMEM;
4. return commit_creds(new);","1
6
8
16","CWE-444,CWE-404,CWE-835"
xfrm_state_netlink-38834934736906,"static struct sk_buff *xfrm_state_netlink(struct sk_buff *in_skb,
					  struct xfrm_state *x, u32 seq)
{
	struct xfrm_dump_info info;
	struct sk_buff *skb;
	int err;

	skb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);
	if (!skb)
		return ERR_PTR(-ENOMEM);

	info.in_skb = in_skb;
	info.out_skb = skb;
	info.nlmsg_seq = seq;
	info.nlmsg_flags = 0;

	err = dump_one_state(x, 0, &info);
	if (err) {
		kfree_skb(skb);
		return ERR_PTR(err);
	}

	return skb;
}
","1. struct xfrm_state *x, u32 seq)
2. struct xfrm_dump_info info;
struct sk_buff *skb;
int err;
3. if (!skb)
return ERR_PTR(-ENOMEM);
4. info.in_skb = in_skb;
info.out_skb = skb;
5. err = dump_one_state(x, 0, &info);
if (err) {
6. return ERR_PTR(err);","2
4-6
9-10
12-13
17-18
20","CWE-20,CWE-552,CWE-416,CWE-476,CWE-399"
cypress_open,"static int cypress_open(struct tty_struct *tty, struct usb_serial_port *port)
{
	struct cypress_private *priv = usb_get_serial_port_data(port);
	struct usb_serial *serial = port->serial;
	unsigned long flags;
	int result = 0;

	if (!priv->comm_is_ok)
		return -EIO;

	
	usb_clear_halt(serial->dev, 0x81);
	usb_clear_halt(serial->dev, 0x02);

	spin_lock_irqsave(&priv->lock, flags);
	
	priv->bytes_in = 0;
	priv->bytes_out = 0;
	priv->cmd_count = 0;
	priv->rx_flags = 0;
	spin_unlock_irqrestore(&priv->lock, flags);

	
	cypress_send(port);

	if (tty)
 		cypress_set_termios(tty, port, &priv->tmp_termios);
 
 	
 	usb_fill_int_urb(port->interrupt_in_urb, serial->dev,
 		usb_rcvintpipe(serial->dev, port->interrupt_in_endpointAddress),
 		port->interrupt_in_urb->transfer_buffer,
		port->interrupt_in_urb->transfer_buffer_length,
		cypress_read_int_callback, port, priv->read_urb_interval);
	result = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);

	if (result) {
		dev_err(&port->dev,
			""%s - failed submitting read urb, error %d\n"",
							__func__, result);
		cypress_set_dead(port);
	}

	return result;
} 
","1. static int cypress_open(struct tty_struct *tty, struct usb_serial_port *port)
2. struct cypress_private *priv = usb_get_serial_port_data(port);
struct usb_serial *serial = port->serial;
unsigned long flags;
int result = 0;
3. return -EIO;
4. spin_lock_irqsave(&priv->lock, flags);
5. priv->cmd_count = 0;
6. if (tty)
7. port->interrupt_in_urb->transfer_buffer,
port->interrupt_in_urb->transfer_buffer_length,
8. result = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);
9. dev_err(&port->dev,
""%s - failed submitting read urb, error %d\n"",","1
3-6
9
15
19
26
32-33
35
38-39","CWE-264,CWE-17,CWE-284,CWE-119"
ares_parse_a_reply-101040161949617,"int ares_parse_a_reply(const unsigned char *abuf, int alen,
		       struct hostent **host)
{
  unsigned int qdcount, ancount;
  int status, i, rr_type, rr_class, rr_len, naddrs;
  long int len;
  int naliases;
  const unsigned char *aptr;
  char *hostname, *rr_name, *rr_data, **aliases;
  struct in_addr *addrs;
  struct hostent *hostent;

  
  *host = NULL;

  
  if (alen < HFIXEDSZ)
    return ARES_EBADRESP;

  
  qdcount = DNS_HEADER_QDCOUNT(abuf);
  ancount = DNS_HEADER_ANCOUNT(abuf);
  if (qdcount != 1)
    return ARES_EBADRESP;

  
  aptr = abuf + HFIXEDSZ;
  status = ares_expand_name(aptr, abuf, alen, &hostname, &len);
  if (status != ARES_SUCCESS)
    return status;
  if (aptr + len + QFIXEDSZ > abuf + alen)
    {
      free(hostname);
      return ARES_EBADRESP;
    }
  aptr += len + QFIXEDSZ;

  
  addrs = malloc(ancount * sizeof(struct in_addr));
  if (!addrs)
    {
      free(hostname);
      return ARES_ENOMEM;
    }
  aliases = malloc((ancount + 1) * sizeof(char *));
  if (!aliases)
    {
      free(hostname);
      free(addrs);
      return ARES_ENOMEM;
    }
  naddrs = 0;
  naliases = 0;

  
  for (i = 0; i < (int)ancount; i++)
    {
      
      status = ares_expand_name(aptr, abuf, alen, &rr_name, &len);
      if (status != ARES_SUCCESS)
	break;
      aptr += len;
      if (aptr + RRFIXEDSZ > abuf + alen)
	{
	  free(rr_name);
	  status = ARES_EBADRESP;
	  break;
	}
      rr_type = DNS_RR_TYPE(aptr);
      rr_class = DNS_RR_CLASS(aptr);
      rr_len = DNS_RR_LEN(aptr);
      aptr += RRFIXEDSZ;
      if (aptr + rr_len > abuf + alen)
	{
	  free(rr_name);
	  status = ARES_EBADRESP;
	  break;
	}

      if (rr_class == C_IN && rr_type == T_A
	  && rr_len == sizeof(struct in_addr)
	  && strcasecmp(rr_name, hostname) == 0)
	{
	  memcpy(&addrs[naddrs], aptr, sizeof(struct in_addr));
	  naddrs++;
	  status = ARES_SUCCESS;
	}

      if (rr_class == C_IN && rr_type == T_CNAME)
	{
	  
	  aliases[naliases] = rr_name;
	  naliases++;

	  
	  status = ares_expand_name(aptr, abuf, alen, &rr_data, &len);
	  if (status != ARES_SUCCESS)
	    break;
	  free(hostname);
	  hostname = rr_data;
	}
      else
	free(rr_name);

      aptr += rr_len;
      if (aptr > abuf + alen)
	{
	  status = ARES_EBADRESP;
	  break;
	}
    }

  if (status == ARES_SUCCESS && naddrs == 0)
    status = ARES_ENODATA;
  if (status == ARES_SUCCESS)
    {
      
      aliases[naliases] = NULL;
      hostent = malloc(sizeof(struct hostent));
      if (hostent)
	{
	  hostent->h_addr_list = malloc((naddrs + 1) * sizeof(char *));
	  if (hostent->h_addr_list)
	    {
	      
	      hostent->h_name = hostname;
	      hostent->h_aliases = aliases;
	      hostent->h_addrtype = AF_INET;
	      hostent->h_length = sizeof(struct in_addr);
	      for (i = 0; i < naddrs; i++)
		hostent->h_addr_list[i] = (char *) &addrs[i];
	      hostent->h_addr_list[naddrs] = NULL;
	      *host = hostent;
	      return ARES_SUCCESS;
	    }
	  free(hostent);
	}
      status = ARES_ENOMEM;
    }
  for (i = 0; i < naliases; i++)
    free(aliases[i]);
  free(aliases);
  free(addrs);
  free(hostname);
  return status;
}
","1. unsigned int qdcount, ancount;
2. status = ares_expand_name(aptr, abuf, alen, &hostname, &len);
if (status != ARES_SUCCESS)
3. free(hostname);
4. if (!addrs)
5. if (!aliases)
6. free(hostname);
7. break;
8. rr_class = DNS_RR_CLASS(aptr);
9. free(rr_name);
status = ARES_EBADRESP;
10. if (rr_class == C_IN && rr_type == T_CNAME)
11. status = ARES_EBADRESP;
12. hostent->h_aliases = aliases;
hostent->h_addrtype = AF_INET;
13. free(hostent);","4
28-29
33
40
46
48
67
70
75-76
89
108
127-128
136","CWE-476,CWE-1284,CWE-200,CWE-19"
messageFindArgument-258282974929101,"char *
messageFindArgument(const message *m, const char *variable)
{
	int i;
	size_t len;

	assert(m != NULL);
	assert(variable != NULL);

	len = strlen(variable);

	for(i = 0; i < m->numberOfArguments; i++) {
		const char *ptr;

		ptr = messageGetArgument(m, i);
		if((ptr == NULL) || (*ptr == '\0'))
			continue;
#ifdef	CL_DEBUG
		cli_dbgmsg(""messageFindArgument: compare %lu bytes of %s with %s\n"",
			(unsigned long)len, variable, ptr);
#endif
		if(strncasecmp(ptr, variable, len) == 0) {
			ptr = &ptr[len];
			while(isspace(*ptr))
				ptr++;
			if(*ptr != '=') {
				cli_dbgmsg(""messageFindArgument: no '=' sign found in MIME header '%s' (%s)\n"", variable, messageGetArgument(m, i));
				return NULL;
			}
			if((strlen(ptr) > 2) && (*++ptr == '""') && (strchr(&ptr[1], '""') != NULL)) {
				
				char *ret = cli_strdup(++ptr);
				char *p;

				if(ret == NULL)
					return NULL;

				
				if((p = strchr(ret, '""')) != NULL) {
					ret[strlen(ret) - 1] = '\0';
					*p = '\0';
				}
				return ret;
			}
			return cli_strdup(ptr);
		}
	}
	return NULL;
}
","1. int i;
2. ptr = messageGetArgument(m, i);
3. continue;
4. if(strncasecmp(ptr, variable, len) == 0) {
5. while(isspace(*ptr))
6. char *ret = cli_strdup(++ptr);
7. return NULL;
8. return NULL;","4
15
17
22
24
32
36
56","CWE-119,CWE-264,CWE-787,CWE-189"
rpc_type_of_NPPVariable,"int rpc_type_of_NPPVariable(int variable)
{
  int type;
  switch (variable) {
   case NPPVpluginNameString:
   case NPPVpluginDescriptionString:
   case NPPVformValue: 
  case NPPVpluginNativeAccessibleAtkPlugId:
 	type = RPC_TYPE_STRING;
 	break;
   case NPPVpluginWindowSize:
  case NPPVpluginTimerInterval:
	type = RPC_TYPE_INT32;
	break;
  case NPPVpluginNeedsXEmbed:
  case NPPVpluginWindowBool:
   case NPPVpluginTransparentBool:
   case NPPVjavascriptPushCallerBool:
   case NPPVpluginKeepLibraryInMemory:
  case NPPVpluginUrlRequestsDisplayedBool:
  case NPPVpluginWantsAllNetworkStreams:
  case NPPVpluginCancelSrcStream:
  case NPPVSupportsAdvancedKeyHandling:
 	type = RPC_TYPE_BOOLEAN;
 	break;
   case NPPVpluginScriptableNPObject:
	type = RPC_TYPE_NP_OBJECT;
	break;
  default:
	type = RPC_ERROR_GENERIC;
	break;
  }
  return type;
}
","1. case NPPVpluginWindowBool:
2. case NPPVpluginKeepLibraryInMemory:
3. break;
4. default:
type = RPC_ERROR_GENERIC;","16
19
25
29-30","CWE-617,CWE-264,CWE-399,CWE-119"
construct_key_and_link,"static struct key *construct_key_and_link(struct keyring_search_context *ctx,
					  const char *callout_info,
					  size_t callout_len,
					  void *aux,
					  struct key *dest_keyring,
					  unsigned long flags)
{
	struct key_user *user;
	struct key *key;
	int ret;

	kenter("""");

 	if (ctx->index_key.type == &key_type_keyring)
 		return ERR_PTR(-EPERM);
 
	ret = construct_get_dest_keyring(&dest_keyring);
	if (ret)
		goto error;
 
	user = key_user_lookup(current_fsuid());
	if (!user) {
		ret = -ENOMEM;
		goto error_put_dest_keyring;
	}
 
 	ret = construct_alloc_key(ctx, dest_keyring, flags, user, &key);
 	key_user_put(user);

	if (ret == 0) {
		ret = construct_key(key, callout_info, callout_len, aux,
				    dest_keyring);
		if (ret < 0) {
			kdebug(""cons failed"");
			goto construction_failed;
		}
 	} else if (ret == -EINPROGRESS) {
 		ret = 0;
 	} else {
		goto error_put_dest_keyring;
 	}
 
 	key_put(dest_keyring);
	kleave("" = key %d"", key_serial(key));
	return key;

 construction_failed:
 	key_negate_and_link(key, key_negative_timeout, NULL, NULL);
 	key_put(key);
error_put_dest_keyring:
 	key_put(dest_keyring);
error:
 	kleave("" = %d"", ret);
 	return ERR_PTR(ret);
 }
","1. const char *callout_info,
size_t callout_len,
2. kenter("""");
3. return ERR_PTR(-EPERM);
4. ret = construct_get_dest_keyring(&dest_keyring);
5. goto error;
6. if (!user) {
7. if (ret == 0) {
ret = construct_key(key, callout_info, callout_len, aux,
8. goto construction_failed;
9. } else if (ret == -EINPROGRESS) {
ret = 0;
10. goto error_put_dest_keyring;
11. kleave("" = key %d"", key_serial(key));
12. construction_failed:
key_negate_and_link(key, key_negative_timeout, NULL, NULL);
key_put(key);
13. error:","2-3
12
15
17
19
22
30-31
35
37-38
40
44
47-49
52","CWE-362,CWE-119,CWE-862,CWE-125,CWE-399"
ih264d_parse_decode_slice_5,"
#define UWORD8

WORD32 ih264d_parse_decode_slice_5(UWORD8 u1_is_idr_slice,
                                 UWORD8 u1_nal_ref_idc,
 dec_struct_t *ps_dec 
 )
{
 dec_bit_stream_t * ps_bitstrm = ps_dec->ps_bitstrm;
 dec_pic_params_t *ps_pps;
 dec_seq_params_t *ps_seq;
 dec_slice_params_t *ps_cur_slice = ps_dec->ps_cur_slice;
 pocstruct_t s_tmp_poc;
    WORD32 i_delta_poc[2];
    WORD32 i4_poc = 0;
    UWORD16 u2_first_mb_in_slice, u2_frame_num;
    UWORD8 u1_field_pic_flag, u1_redundant_pic_cnt = 0, u1_slice_type;
    UWORD32 u4_idr_pic_id = 0;
    UWORD8 u1_bottom_field_flag, u1_pic_order_cnt_type;

    UWORD8 u1_nal_unit_type;
    UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
    UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;
    WORD8 i1_is_end_of_poc;

    WORD32 ret, end_of_frame;
    WORD32 prev_slice_err, num_mb_skipped;
    UWORD8 u1_mbaff;
 pocstruct_t *ps_cur_poc;

    UWORD32 u4_temp;
    WORD32 i_temp;
    UWORD32 u4_call_end_of_pic = 0;

 
    ps_dec->ps_dpb_cmds->u1_dpb_commands_read_slc = 0;
    u2_first_mb_in_slice = ih264d_uev(pu4_bitstrm_ofst,
                                     pu4_bitstrm_buf);
 if(u2_first_mb_in_slice
 > (ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs))
 {

 return ERROR_CORRUPTED_SLICE;
 }

 
 if(((u2_first_mb_in_slice << ps_cur_slice->u1_mbaff_frame_flag)
 <= ps_dec->u2_cur_mb_addr) && (ps_dec->u4_first_slice_in_pic == 0))
 {
 return ERROR_CORRUPTED_SLICE;
 }

    COPYTHECONTEXT(""SH: first_mb_in_slice"",u2_first_mb_in_slice);

    u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);

 if(u4_temp > 9)
 return ERROR_INV_SLC_TYPE_T;

    u1_slice_type = u4_temp;
    COPYTHECONTEXT(""SH: slice_type"",(u1_slice_type));
    ps_dec->u1_sl_typ_5_9 = 0;
 
 
 
 if(u1_slice_type > 4)
 {
        u1_slice_type -= 5;
        ps_dec->u1_sl_typ_5_9 = 1;
 }

 {
        UWORD32 skip;

 if((ps_dec->i4_app_skip_mode == IVD_SKIP_PB)
 || (ps_dec->i4_dec_skip_mode == IVD_SKIP_PB))
 {
            UWORD32 u4_bit_stream_offset = 0;

 if(ps_dec->u1_nal_unit_type == IDR_SLICE_NAL)
 {
                skip = 0;

                ps_dec->i4_dec_skip_mode = IVD_SKIP_NONE;
 }
 else if((I_SLICE == u1_slice_type)
 && (1 >= ps_dec->ps_cur_sps->u1_num_ref_frames))
 {
                skip = 0;

                ps_dec->i4_dec_skip_mode = IVD_SKIP_NONE;
 }
 else
 {
                skip = 1;
 }

 
 if((0 == u2_first_mb_in_slice) && (1 == ps_dec->u4_prev_nal_skipped))
 {
                skip = 0;
 }

 if(skip)
 {
                ps_dec->u4_prev_nal_skipped = 1;
                ps_dec->i4_dec_skip_mode = IVD_SKIP_PB;
 return 0;
 }
 else
 {
 
 if(1 == ps_dec->u4_prev_nal_skipped)
 {
                    ps_dec->u4_return_to_app = 1;
 return 0;
 }
 }
 }

 }

    u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 if(u4_temp & MASK_ERR_PIC_SET_ID)
 return ERROR_INV_SLICE_HDR_T;
 
    COPYTHECONTEXT(""SH: pic_parameter_set_id"", u4_temp);
    ps_pps = &ps_dec->ps_pps[u4_temp];
 if(FALSE == ps_pps->u1_is_valid)
 {
 return ERROR_INV_SLICE_HDR_T;
 }
    ps_seq = ps_pps->ps_sps;
 if(!ps_seq)
 return ERROR_INV_SLICE_HDR_T;
 if(FALSE == ps_seq->u1_is_valid)
 return ERROR_INV_SLICE_HDR_T;

 
    u2_frame_num = ih264d_get_bits_h264(ps_bitstrm,
                                         ps_seq->u1_bits_in_frm_num);

 
     COPYTHECONTEXT(""SH: frame_num"", u2_frame_num);
    if(!ps_dec->u1_first_slice_in_stream && ps_dec->u4_first_slice_in_pic)
     {
         pocstruct_t *ps_prev_poc = &ps_dec->s_prev_pic_poc;
         pocstruct_t *ps_cur_poc = &ps_dec->s_cur_pic_poc;

        ps_dec->u2_mbx = 0xffff;
        ps_dec->u2_mby = 0;

 if((0 == u1_is_idr_slice) && ps_cur_slice->u1_nal_ref_idc)
            ps_dec->u2_prev_ref_frame_num = ps_cur_slice->u2_frame_num;

 if(u1_is_idr_slice || ps_cur_slice->u1_mmco_equalto5)
            ps_dec->u2_prev_ref_frame_num = 0;

 if(ps_dec->ps_cur_sps->u1_gaps_in_frame_num_value_allowed_flag)
 {
            ih264d_decode_gaps_in_frame_num(ps_dec, u2_frame_num);
 }

        ps_prev_poc->i4_prev_frame_num_ofst = ps_cur_poc->i4_prev_frame_num_ofst;
        ps_prev_poc->u2_frame_num = ps_cur_poc->u2_frame_num;
        ps_prev_poc->u1_mmco_equalto5 = ps_cur_slice->u1_mmco_equalto5;
 if(ps_cur_slice->u1_nal_ref_idc)
 {
            ps_prev_poc->i4_pic_order_cnt_lsb = ps_cur_poc->i4_pic_order_cnt_lsb;
            ps_prev_poc->i4_pic_order_cnt_msb = ps_cur_poc->i4_pic_order_cnt_msb;
            ps_prev_poc->i4_delta_pic_order_cnt_bottom =
                            ps_cur_poc->i4_delta_pic_order_cnt_bottom;
            ps_prev_poc->i4_delta_pic_order_cnt[0] =
                            ps_cur_poc->i4_delta_pic_order_cnt[0];
            ps_prev_poc->i4_delta_pic_order_cnt[1] =
                            ps_cur_poc->i4_delta_pic_order_cnt[1];
            ps_prev_poc->u1_bot_field = ps_cur_poc->u1_bot_field;
 }

        ps_dec->u2_total_mbs_coded = 0;
 }
 
 if(!ps_seq->u1_frame_mbs_only_flag)
 {

        u1_field_pic_flag = ih264d_get_bit_h264(ps_bitstrm);
        COPYTHECONTEXT(""SH: field_pic_flag"", u1_field_pic_flag);
        u1_bottom_field_flag = 0;

 if(u1_field_pic_flag)
 {
            ps_dec->pu1_inv_scan = (UWORD8 *)gau1_ih264d_inv_scan_fld;
            u1_bottom_field_flag = ih264d_get_bit_h264(ps_bitstrm);
            COPYTHECONTEXT(""SH: bottom_field_flag"", u1_bottom_field_flag);

 }
 else
 {
            ps_dec->pu1_inv_scan = (UWORD8 *)gau1_ih264d_inv_scan;
 }
 }
 else
 {
        u1_field_pic_flag = 0;
        u1_bottom_field_flag = 0;

        ps_dec->pu1_inv_scan = (UWORD8 *)gau1_ih264d_inv_scan;
 }

    u1_nal_unit_type = SLICE_NAL;
 if(u1_is_idr_slice)
 {
 if(0 == u1_field_pic_flag)
 {
            ps_dec->u1_top_bottom_decoded = TOP_FIELD_ONLY | BOT_FIELD_ONLY;
 }
        u1_nal_unit_type = IDR_SLICE_NAL;
        u4_idr_pic_id = ih264d_uev(pu4_bitstrm_ofst,
                                   pu4_bitstrm_buf);
 if(u4_idr_pic_id > 65535)
 return ERROR_INV_SLICE_HDR_T;
        COPYTHECONTEXT(""SH:  "", u4_idr_pic_id);
 }

 
    i_delta_poc[0] = i_delta_poc[1] = 0;
    s_tmp_poc.i4_pic_order_cnt_lsb = 0;
    s_tmp_poc.i4_delta_pic_order_cnt_bottom = 0;
    u1_pic_order_cnt_type = ps_seq->u1_pic_order_cnt_type;
 if(u1_pic_order_cnt_type == 0)
 {
        i_temp = ih264d_get_bits_h264(
                        ps_bitstrm,
                        ps_seq->u1_log2_max_pic_order_cnt_lsb_minus);
 if(i_temp < 0 || i_temp >= ps_seq->i4_max_pic_order_cntLsb)
 return ERROR_INV_SLICE_HDR_T;
        s_tmp_poc.i4_pic_order_cnt_lsb = i_temp;
        COPYTHECONTEXT(""SH: pic_order_cnt_lsb"", s_tmp_poc.i4_pic_order_cnt_lsb);

 if((ps_pps->u1_pic_order_present_flag == 1) && (!u1_field_pic_flag))
 {
            s_tmp_poc.i4_delta_pic_order_cnt_bottom = ih264d_sev(
                            pu4_bitstrm_ofst, pu4_bitstrm_buf);
            COPYTHECONTEXT(""SH: delta_pic_order_cnt_bottom"",
                            s_tmp_poc.i4_delta_pic_order_cnt_bottom);
 }
 }

    s_tmp_poc.i4_delta_pic_order_cnt[0] = 0;
    s_tmp_poc.i4_delta_pic_order_cnt[1] = 0;
 if(u1_pic_order_cnt_type == 1
 && (!ps_seq->u1_delta_pic_order_always_zero_flag))
 {
        s_tmp_poc.i4_delta_pic_order_cnt[0] = ih264d_sev(pu4_bitstrm_ofst,
                                                         pu4_bitstrm_buf);
        COPYTHECONTEXT(""SH: delta_pic_order_cnt[0]"",
                        s_tmp_poc.i4_delta_pic_order_cnt[0]);

 if(ps_pps->u1_pic_order_present_flag && !u1_field_pic_flag)
 {
            s_tmp_poc.i4_delta_pic_order_cnt[1] = ih264d_sev(
                            pu4_bitstrm_ofst, pu4_bitstrm_buf);
            COPYTHECONTEXT(""SH: delta_pic_order_cnt[1]"",
                            s_tmp_poc.i4_delta_pic_order_cnt[1]);
 }
 }

 if(ps_pps->u1_redundant_pic_cnt_present_flag)
 {
        u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
 if(u4_temp > MAX_REDUNDANT_PIC_CNT)
 return ERROR_INV_SLICE_HDR_T;
        u1_redundant_pic_cnt = u4_temp;
        COPYTHECONTEXT(""SH: redundant_pic_cnt"", u1_redundant_pic_cnt);
 }

 
 
 
 

     i1_is_end_of_poc = 1;
     ps_dec->ps_dec_err_status->u1_err_flag &= MASK_REJECT_CUR_PIC;
 
    if(ps_dec->u4_first_slice_in_pic == 0)
     {
         i1_is_end_of_poc = ih264d_is_end_of_pic(u2_frame_num, u1_nal_ref_idc,
                                             &s_tmp_poc, &ps_dec->s_cur_pic_poc,
                                            ps_cur_slice, u1_pic_order_cnt_type,
                                            u1_nal_unit_type, u4_idr_pic_id,
                                            u1_field_pic_flag,
                                            u1_bottom_field_flag);
 if(i1_is_end_of_poc)
 {
            ps_dec->u1_first_slice_in_stream = 0;
 return ERROR_INCOMPLETE_FRAME;
 }

 }

 
 
 
 
    u1_mbaff = ps_seq->u1_mb_aff_flag && (!u1_field_pic_flag);
    prev_slice_err = 0;

 if(i1_is_end_of_poc || ps_dec->u1_first_slice_in_stream)
 {
 if(u2_frame_num != ps_dec->u2_prv_frame_num
 && ps_dec->u1_top_bottom_decoded != 0
 && ps_dec->u1_top_bottom_decoded
 != (TOP_FIELD_ONLY | BOT_FIELD_ONLY))
 {
            ps_dec->u1_dangling_field = 1;
 if(ps_dec->u4_first_slice_in_pic)
 {
                prev_slice_err = 1;
 }
 else
 {
                prev_slice_err = 2;
 }

 if(ps_dec->u1_top_bottom_decoded ==TOP_FIELD_ONLY)
                ps_cur_slice->u1_bottom_field_flag = 1;
 else
                ps_cur_slice->u1_bottom_field_flag = 0;

            num_mb_skipped = (ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)
 - ps_dec->u2_total_mbs_coded;
            ps_cur_poc = &ps_dec->s_cur_pic_poc;

 
             u1_is_idr_slice = ps_cur_slice->u1_nal_unit_type == IDR_SLICE_NAL;
         }
        else if(ps_dec->u4_first_slice_in_pic)
         {
             if(u2_first_mb_in_slice > 0)
             {
                prev_slice_err = 1;
                num_mb_skipped = u2_first_mb_in_slice << u1_mbaff;
                ps_cur_poc = &s_tmp_poc;

                ps_cur_slice->u4_idr_pic_id = u4_idr_pic_id;
                ps_cur_slice->u1_field_pic_flag = u1_field_pic_flag;
                ps_cur_slice->u1_bottom_field_flag = u1_bottom_field_flag;
                ps_cur_slice->i4_pic_order_cnt_lsb =
                        s_tmp_poc.i4_pic_order_cnt_lsb;
                ps_cur_slice->u1_nal_unit_type = u1_nal_unit_type;
                ps_cur_slice->u1_redundant_pic_cnt = u1_redundant_pic_cnt;
                ps_cur_slice->u1_nal_ref_idc = u1_nal_ref_idc;
                ps_cur_slice->u1_pic_order_cnt_type = u1_pic_order_cnt_type;
                ps_cur_slice->u1_mbaff_frame_flag = ps_seq->u1_mb_aff_flag
 && (!u1_field_pic_flag);
 }

         }
         else
         {
            
            prev_slice_err = 2;
            num_mb_skipped = (ps_dec->u2_frm_ht_in_mbs
                            * ps_dec->u2_frm_wd_in_mbs)
                            - ps_dec->u2_total_mbs_coded;
             ps_cur_poc = &s_tmp_poc;
         }
     }
 else
 {
 if((u2_first_mb_in_slice << u1_mbaff) > ps_dec->u2_total_mbs_coded)
 {
            prev_slice_err = 2;
            num_mb_skipped = (u2_first_mb_in_slice << u1_mbaff)
 - ps_dec->u2_total_mbs_coded;
            ps_cur_poc = &s_tmp_poc;
 }
 else if((u2_first_mb_in_slice << u1_mbaff) < ps_dec->u2_total_mbs_coded)
 {
 return ERROR_CORRUPTED_SLICE;
 }
 }

 if(prev_slice_err)
 {
        ret = ih264d_mark_err_slice_skip(ps_dec, num_mb_skipped, u1_is_idr_slice, u2_frame_num, ps_cur_poc, prev_slice_err);

 if(ps_dec->u1_dangling_field == 1)
 {
            ps_dec->u1_second_field = 1 - ps_dec->u1_second_field;
            ps_cur_slice->u1_bottom_field_flag = u1_bottom_field_flag;
            ps_dec->u2_prv_frame_num = u2_frame_num;
            ps_dec->u1_first_slice_in_stream = 0;
 return ERROR_DANGLING_FIELD_IN_PIC;
 }

 if(prev_slice_err == 2)
 {
            ps_dec->u1_first_slice_in_stream = 0;
 return ERROR_INCOMPLETE_FRAME;
 }

 if(ps_dec->u2_total_mbs_coded
 >= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)
 {
 
            ps_dec->u1_first_slice_in_stream = 0;
 return ERROR_IN_LAST_SLICE_OF_PIC;
 }

 if(ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC)
 {
            ih264d_err_pic_dispbuf_mgr(ps_dec);
 return ERROR_NEW_FRAME_EXPECTED;
 }

 if(ret != OK)
 return ret;

        i1_is_end_of_poc = 0;
 }

 if (ps_dec->u4_first_slice_in_pic == 0)
 {
        ps_dec->ps_parse_cur_slice++;
        ps_dec->u2_cur_slice_num++;
 }

 if((ps_dec->u1_separate_parse == 0) && (ps_dec->u4_first_slice_in_pic == 0))
 {
        ps_dec->ps_decode_cur_slice++;
 }
    ps_dec->u1_slice_header_done = 0;


 if(u1_field_pic_flag)
 {
        ps_dec->u2_prv_frame_num = u2_frame_num;
 }

 if(ps_cur_slice->u1_mmco_equalto5)
 {
        WORD32 i4_temp_poc;
        WORD32 i4_top_field_order_poc, i4_bot_field_order_poc;

 if(!ps_cur_slice->u1_field_pic_flag) 
 {
            i4_top_field_order_poc = ps_dec->ps_cur_pic->i4_top_field_order_cnt;
            i4_bot_field_order_poc =
                            ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;
            i4_temp_poc = MIN(i4_top_field_order_poc,
                                     i4_bot_field_order_poc);
 }
 else if(!ps_cur_slice->u1_bottom_field_flag)
            i4_temp_poc = ps_dec->ps_cur_pic->i4_top_field_order_cnt;
 else
            i4_temp_poc = ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;

        ps_dec->ps_cur_pic->i4_top_field_order_cnt = i4_temp_poc
 - ps_dec->ps_cur_pic->i4_top_field_order_cnt;
        ps_dec->ps_cur_pic->i4_bottom_field_order_cnt = i4_temp_poc
 - ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;

         ps_dec->ps_cur_pic->i4_poc = i4_temp_poc;
         ps_dec->ps_cur_pic->i4_avg_poc = i4_temp_poc;
     }
    if(ps_dec->u4_first_slice_in_pic)
     {
         ret = ih264d_decode_pic_order_cnt(u1_is_idr_slice, u2_frame_num,
                                           &ps_dec->s_prev_pic_poc,
 &s_tmp_poc, ps_cur_slice, ps_pps,
                                          u1_nal_ref_idc,
                                          u1_bottom_field_flag,
                                          u1_field_pic_flag, &i4_poc);
 if(ret != OK)
 return ret;
 
 if(i4_poc >= ps_dec->i4_max_poc)
            ps_dec->i4_max_poc = i4_poc;
 
 if(i4_poc == 0)
 {
            ps_dec->i4_prev_max_display_seq = ps_dec->i4_prev_max_display_seq
 + ps_dec->i4_max_poc
 + ps_dec->u1_max_dec_frame_buffering + 1;
            ps_dec->i4_max_poc = 0;
 }
 }

 
 
 
 
 
    ps_cur_slice->i4_delta_pic_order_cnt[0] = i_delta_poc[0];
    ps_cur_slice->i4_delta_pic_order_cnt[1] = i_delta_poc[1];
    ps_cur_slice->u4_idr_pic_id = u4_idr_pic_id;
    ps_cur_slice->u2_first_mb_in_slice = u2_first_mb_in_slice;
    ps_cur_slice->u1_field_pic_flag = u1_field_pic_flag;
    ps_cur_slice->u1_bottom_field_flag = u1_bottom_field_flag;
    ps_cur_slice->u1_slice_type = u1_slice_type;
    ps_cur_slice->i4_pic_order_cnt_lsb = s_tmp_poc.i4_pic_order_cnt_lsb;

    ps_cur_slice->u1_nal_unit_type = u1_nal_unit_type;
    ps_cur_slice->u1_redundant_pic_cnt = u1_redundant_pic_cnt;
    ps_cur_slice->u1_nal_ref_idc = u1_nal_ref_idc;
    ps_cur_slice->u1_pic_order_cnt_type = u1_pic_order_cnt_type;

 if(ps_seq->u1_frame_mbs_only_flag)
        ps_cur_slice->u1_direct_8x8_inference_flag =
                        ps_seq->u1_direct_8x8_inference_flag;
 else
        ps_cur_slice->u1_direct_8x8_inference_flag = 1;

 if(u1_slice_type == B_SLICE)
 {
        ps_cur_slice->u1_direct_spatial_mv_pred_flag = ih264d_get_bit_h264(
                        ps_bitstrm);
        COPYTHECONTEXT(""SH: direct_spatial_mv_pred_flag"",
                        ps_cur_slice->u1_direct_spatial_mv_pred_flag);

 if(ps_cur_slice->u1_direct_spatial_mv_pred_flag)
            ps_cur_slice->pf_decodeDirect = ih264d_decode_spatial_direct;
 else
            ps_cur_slice->pf_decodeDirect = ih264d_decode_temporal_direct;
 if(!((ps_pps->ps_sps->u1_mb_aff_flag) && (!u1_field_pic_flag)))
            ps_dec->pf_mvpred = ih264d_mvpred_nonmbaffB;
 }
 else
 {
 if(!((ps_pps->ps_sps->u1_mb_aff_flag) && (!u1_field_pic_flag)))

             ps_dec->pf_mvpred = ih264d_mvpred_nonmbaff;
     }
 
    if(ps_dec->u4_first_slice_in_pic)
     {
         if(u2_first_mb_in_slice == 0)
         {
            ret = ih264d_start_of_pic(ps_dec, i4_poc, &s_tmp_poc, u2_frame_num, ps_pps);
 if(ret != OK)
 return ret;
 }

        ps_dec->u4_output_present = 0;

 {
            ih264d_get_next_display_field(ps_dec,
                                          ps_dec->ps_out_buffer,
 &(ps_dec->s_disp_op));
 

 if(0 != ps_dec->s_disp_op.u4_error_code)
 {
                ps_dec->u4_fmt_conv_cur_row = ps_dec->s_disp_frame_info.u4_y_ht;
 }
 else
                ps_dec->u4_output_present = 1;
 }
 if(ps_dec->u1_separate_parse == 1)
 {
 if(ps_dec->u4_dec_thread_created == 0)
 {
                ithread_create(ps_dec->pv_dec_thread_handle, NULL,
 (void *)ih264d_decode_picture_thread,
 (void *)ps_dec);

                ps_dec->u4_dec_thread_created = 1;
 }

 if((ps_dec->u4_num_cores == 3) &&
 ((ps_dec->u4_app_disable_deblk_frm == 0) || ps_dec->i1_recon_in_thread3_flag)
 && (ps_dec->u4_bs_deblk_thread_created == 0))
 {
                ps_dec->u4_start_recon_deblk = 0;
                ithread_create(ps_dec->pv_bs_deblk_thread_handle, NULL,
 (void *)ih264d_recon_deblk_thread,
 (void *)ps_dec);
                ps_dec->u4_bs_deblk_thread_created = 1;
 }
 }

 }

 
 {
        UWORD8 uc_nofield_nombaff;



        uc_nofield_nombaff = ((ps_dec->ps_cur_slice->u1_field_pic_flag == 0)
 && (ps_dec->ps_cur_slice->u1_mbaff_frame_flag == 0)
 && (u1_slice_type != B_SLICE)
 && (ps_dec->ps_cur_pps->u1_wted_pred_flag == 0));

 

 if(uc_nofield_nombaff)
 {
            ps_dec->p_form_mb_part_info = ih264d_form_mb_part_info_bp;
            ps_dec->p_motion_compensate = ih264d_motion_compensate_bp;
 }
 else
 {
            ps_dec->p_form_mb_part_info = ih264d_form_mb_part_info_mp;
            ps_dec->p_motion_compensate = ih264d_motion_compensate_mp;
 }


 }

 
 {
 dec_err_status_t * ps_err = ps_dec->ps_dec_err_status;
 if(ps_err->u4_frm_sei_sync == u2_frame_num)
 {
            ps_err->u1_err_flag = ACCEPT_ALL_PICS;
            ps_err->u4_frm_sei_sync = SYNC_FRM_DEFAULT;
 }
        ps_err->u4_cur_frm = u2_frame_num;
 }

 
 {
        WORD32 i4_skip_b_pic, i4_skip_p_pic;

        i4_skip_b_pic = (ps_dec->u4_skip_frm_mask & B_SLC_BIT)
 && (B_SLICE == u1_slice_type) && (0 == u1_nal_ref_idc);

        i4_skip_p_pic = (ps_dec->u4_skip_frm_mask & P_SLC_BIT)
 && (P_SLICE == u1_slice_type) && (0 == u1_nal_ref_idc);

 
 
 
 
 
 if(i4_skip_b_pic)
 {
            ps_dec->ps_cur_pic->u4_pack_slc_typ |= B_SLC_BIT;
 
 
            ps_dec->u1_last_pic_not_decoded = 1;

 return OK;
 }
 
 
 
 
 
 if(i4_skip_p_pic)
 {
            ps_dec->ps_cur_pic->u4_pack_slc_typ |= P_SLC_BIT;
 
 
            ps_dec->u1_last_pic_not_decoded = 1;

 return OK;
 }
 }

 {
        UWORD16 u2_mb_x, u2_mb_y;

        ps_dec->i4_submb_ofst = ((u2_first_mb_in_slice
 << ps_cur_slice->u1_mbaff_frame_flag) * SUB_BLK_SIZE)
 - SUB_BLK_SIZE;
 if(u2_first_mb_in_slice)
 {
            UWORD8 u1_mb_aff;
            UWORD8 u1_field_pic;
            UWORD16 u2_frm_wd_in_mbs;
            u2_frm_wd_in_mbs = ps_seq->u2_frm_wd_in_mbs;
            u1_mb_aff = ps_cur_slice->u1_mbaff_frame_flag;
            u1_field_pic = ps_cur_slice->u1_field_pic_flag;

 {
                UWORD32 x_offset;
                UWORD32 y_offset;
                UWORD32 u4_frame_stride;
 tfr_ctxt_t *ps_trns_addr; 

 if(ps_dec->u1_separate_parse)
 {
                    ps_trns_addr = &ps_dec->s_tran_addrecon_parse;
 }
 else
 {
                    ps_trns_addr = &ps_dec->s_tran_addrecon;
 }
                u2_mb_x = MOD(u2_first_mb_in_slice, u2_frm_wd_in_mbs);
                u2_mb_y = DIV(u2_first_mb_in_slice, u2_frm_wd_in_mbs);

                u2_mb_y <<= u1_mb_aff;

 if((u2_mb_x > u2_frm_wd_in_mbs - 1)
 || (u2_mb_y > ps_dec->u2_frm_ht_in_mbs - 1))
 {
 return ERROR_CORRUPTED_SLICE;
 }

                u4_frame_stride = ps_dec->u2_frm_wd_y << u1_field_pic;
                x_offset = u2_mb_x << 4;
                y_offset = (u2_mb_y * u4_frame_stride) << 4;

                ps_trns_addr->pu1_dest_y = ps_dec->s_cur_pic.pu1_buf1 + x_offset
 + y_offset;

                u4_frame_stride = ps_dec->u2_frm_wd_uv << u1_field_pic;
                x_offset >>= 1;
                y_offset = (u2_mb_y * u4_frame_stride) << 3;

                x_offset *= YUV420SP_FACTOR;

                ps_trns_addr->pu1_dest_u = ps_dec->s_cur_pic.pu1_buf2 + x_offset
 + y_offset;
                ps_trns_addr->pu1_dest_v = ps_dec->s_cur_pic.pu1_buf3 + x_offset
 + y_offset;

                ps_trns_addr->pu1_mb_y = ps_trns_addr->pu1_dest_y;
                ps_trns_addr->pu1_mb_u = ps_trns_addr->pu1_dest_u;
                ps_trns_addr->pu1_mb_v = ps_trns_addr->pu1_dest_v;


 if(ps_dec->u1_separate_parse == 1)
 {
                    ps_dec->ps_deblk_mbn = ps_dec->ps_deblk_pic
 + (u2_first_mb_in_slice << u1_mb_aff);
 }
 else
 {
                        ps_dec->ps_deblk_mbn = ps_dec->ps_deblk_pic
 + (u2_first_mb_in_slice << u1_mb_aff);
 }

                ps_dec->u2_cur_mb_addr = (u2_first_mb_in_slice << u1_mb_aff);

                ps_dec->ps_mv_cur = ps_dec->s_cur_pic.ps_mv
 + ((u2_first_mb_in_slice << u1_mb_aff) << 4);
 }
 }
 else
 {
 tfr_ctxt_t *ps_trns_addr;

 if(ps_dec->u1_separate_parse)
 {
                ps_trns_addr = &ps_dec->s_tran_addrecon_parse;
 }
 else
 {
                ps_trns_addr = &ps_dec->s_tran_addrecon;
 }

            u2_mb_x = 0xffff;
            u2_mb_y = 0;
            ps_dec->u2_cur_mb_addr = 0;
            ps_dec->ps_deblk_mbn = ps_dec->ps_deblk_pic;
            ps_dec->ps_mv_cur = ps_dec->s_cur_pic.ps_mv;
            ps_trns_addr->pu1_dest_y = ps_dec->s_cur_pic.pu1_buf1;
            ps_trns_addr->pu1_dest_u = ps_dec->s_cur_pic.pu1_buf2;
            ps_trns_addr->pu1_dest_v = ps_dec->s_cur_pic.pu1_buf3;

            ps_trns_addr->pu1_mb_y = ps_trns_addr->pu1_dest_y;
            ps_trns_addr->pu1_mb_u = ps_trns_addr->pu1_dest_u;
            ps_trns_addr->pu1_mb_v = ps_trns_addr->pu1_dest_v;

 }

        ps_dec->ps_part = ps_dec->ps_parse_part_params;

        ps_dec->u2_mbx =
 (MOD(u2_first_mb_in_slice - 1, ps_seq->u2_frm_wd_in_mbs));
        ps_dec->u2_mby =
 (DIV(u2_first_mb_in_slice - 1, ps_seq->u2_frm_wd_in_mbs));
        ps_dec->u2_mby <<= ps_cur_slice->u1_mbaff_frame_flag;
        ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;
        ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;
 }

 
    ps_bitstrm->u4_max_ofst += ps_dec->ps_cur_pps->u1_entropy_coding_mode;

    ps_dec->u1_B = (u1_slice_type == B_SLICE);
    ps_dec->u4_next_mb_skip = 0;

    ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice =
                    ps_dec->ps_cur_slice->u2_first_mb_in_slice;
    ps_dec->ps_parse_cur_slice->slice_type =
                    ps_dec->ps_cur_slice->u1_slice_type;


    ps_dec->u4_start_recon_deblk = 1;
 {
        WORD32 num_entries;
        WORD32 size;
        UWORD8 *pu1_buf;

        num_entries = MIN(MAX_FRAMES, ps_dec->u4_num_ref_frames_at_init);
        num_entries = 2 * ((2 * num_entries) + 1);

        size = num_entries * sizeof(void *);
        size += PAD_MAP_IDX_POC * sizeof(void *);

        pu1_buf = (UWORD8 *)ps_dec->pv_map_ref_idx_to_poc_buf;
        pu1_buf += size * ps_dec->u2_cur_slice_num;
        ps_dec->ps_parse_cur_slice->ppv_map_ref_idx_to_poc = ( void *)pu1_buf;
 }

 if(ps_dec->u1_separate_parse)
 {
        ps_dec->ps_parse_cur_slice->pv_tu_coeff_data_start = ps_dec->pv_parse_tu_coeff_data;
 }
 else
 {
        ps_dec->pv_proc_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data;
 }

 if(u1_slice_type == I_SLICE)
 {
        ps_dec->ps_cur_pic->u4_pack_slc_typ |= I_SLC_BIT;

        ret = ih264d_parse_islice(ps_dec, u2_first_mb_in_slice);

 if(ps_dec->i4_pic_type != B_SLICE && ps_dec->i4_pic_type != P_SLICE)
            ps_dec->i4_pic_type = I_SLICE;

 }
 else if(u1_slice_type == P_SLICE)
 {
        ps_dec->ps_cur_pic->u4_pack_slc_typ |= P_SLC_BIT;
        ret = ih264d_parse_pslice(ps_dec, u2_first_mb_in_slice);
        ps_dec->u1_pr_sl_type = u1_slice_type;
 if(ps_dec->i4_pic_type != B_SLICE)
            ps_dec->i4_pic_type = P_SLICE;
 }
 else if(u1_slice_type == B_SLICE)
 {
        ps_dec->ps_cur_pic->u4_pack_slc_typ |= B_SLC_BIT;
        ret = ih264d_parse_bslice(ps_dec, u2_first_mb_in_slice);
        ps_dec->u1_pr_sl_type = u1_slice_type;
        ps_dec->i4_pic_type = B_SLICE;
 }
 else
 return ERROR_INV_SLC_TYPE_T;


     if(ps_dec->u1_slice_header_done)
     {
         
         ps_dec->u1_first_slice_in_stream = 0;
     }
 
 if(ret != OK)
 return ret;

 
    ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;
    ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;

 

 if(ps_dec->u2_total_mbs_coded >= (ps_seq->u2_max_mb_addr + 1))
 {
        ps_dec->u1_pic_decode_done = 1;

 }

 {
 dec_err_status_t * ps_err = ps_dec->ps_dec_err_status;
 if((ps_err->u1_err_flag & REJECT_PB_PICS)
 && (ps_err->u1_cur_pic_type == PIC_TYPE_I))
 {
            ps_err->u1_err_flag = ACCEPT_ALL_PICS;
 }
 }

    PRINT_BIN_BIT_RATIO(ps_dec)

 return ret;
}
","1. dec_seq_params_t *ps_seq;
2. return ERROR_CORRUPTED_SLICE;
3. return ERROR_INV_SLC_TYPE_T;
4. ps_dec->u1_sl_typ_5_9 = 0;
5. ps_dec->i4_dec_skip_mode = IVD_SKIP_NONE;
6. && (1 >= ps_dec->ps_cur_sps->u1_num_ref_frames))
7. if(u1_is_idr_slice || ps_cur_slice->u1_mmco_equalto5)
8. ps_prev_poc->u1_mmco_equalto5 = ps_cur_slice->u1_mmco_equalto5;
9. u1_bottom_field_flag = 0;
10. u1_nal_unit_type, u4_idr_pic_id,
11. u1_is_idr_slice = ps_cur_slice->u1_nal_unit_type == IDR_SLICE_NAL;
12. ps_cur_slice->u1_field_pic_flag = u1_field_pic_flag;
13. ps_cur_slice->u1_pic_order_cnt_type = u1_pic_order_cnt_type;
14. ps_cur_poc = &s_tmp_poc;
15. WORD32 i4_temp_poc;
16. i4_temp_poc = ps_dec->ps_cur_pic->i4_top_field_order_cnt;
17. i4_temp_poc = ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;
18. - ps_dec->ps_cur_pic->i4_top_field_order_cnt;
19. ps_cur_slice->u2_first_mb_in_slice = u2_first_mb_in_slice;
20. ps_dec->u1_last_pic_not_decoded = 1;
21. UWORD8 u1_mb_aff;
22. u2_mb_y = DIV(u2_first_mb_in_slice, u2_frm_wd_in_mbs);
23. if(ps_dec->u1_separate_parse)","11
43
58
62
84
87
161
171
193
295
340
351
358
372
449
461
463
466
504
652
680
702
756","CWE-200,CWE-20,CWE-119"
on_bytes_received-112364480448493,"static void on_bytes_received(void* context, const unsigned char* buffer, size_t size)
{
    unsigned char* new_received_bytes;
    HTTP_HANDLE_DATA* http_instance = (HTTP_HANDLE_DATA*)context;

    if (http_instance != NULL)
    {

        if (buffer == NULL)
        {
            http_instance->is_io_error = 1;
            LogError(""NULL pointer error"");
        }
        else
        {
            
            size_t malloc_size = http_instance->received_bytes_count + size;
            if (malloc_size < size)
            {
                
                new_received_bytes = NULL;
                LogError(""Invalid size parameter"");
            }
            else
            {
                new_received_bytes = (unsigned char*)realloc(http_instance->received_bytes, malloc_size);
            }

            if (new_received_bytes == NULL)
            {
                http_instance->is_io_error = 1;
                LogError(""Error allocating memory for received data"");
            }
            else
            {
                http_instance->received_bytes = new_received_bytes;
                if (memcpy(http_instance->received_bytes + http_instance->received_bytes_count, buffer, size) == NULL)
                {
                    http_instance->is_io_error = 1;
                    LogError(""Error copping received data to the HTTP bufffer"");
                }
                else
                {
                    http_instance->received_bytes_count += size;
                }
            }
        }
    }
}
","1. static void on_bytes_received(void* context, const unsigned char* buffer, size_t size)
2. unsigned char* new_received_bytes;
HTTP_HANDLE_DATA* http_instance = (HTTP_HANDLE_DATA*)context;
3. if (http_instance != NULL)
4. if (buffer == NULL)
5. {
6. new_received_bytes = NULL;
LogError(""Invalid size parameter"");
7. new_received_bytes = (unsigned char*)realloc(http_instance->received_bytes, malloc_size);
8. LogError(""Error allocating memory for received data"");
9. {","1
3-4
6
9
15
21-22
26
32
35","CWE-190,CWE-120,CWE-787,CWE-284"
ReadMATImage,"
#define ExceptionInfo
#define ImageInfo

static Image *ReadMATImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  Image *image, *image2=NULL,
   *rotated_image;
  PixelPacket *q;

  unsigned int status;
  MATHeader MATLAB_HDR;
  size_t size;
  size_t CellType;
  QuantumInfo *quantum_info;
  ImageInfo *clone_info;
  int i;
  ssize_t ldblk;
  unsigned char *BImgBuff = NULL;
  double MinVal, MaxVal;
  size_t Unknown6;
  unsigned z, z2;
  unsigned Frames;
  int logging;
  int sample_size;
  MagickOffsetType filepos=0x80;
  BlobInfo *blob;
  size_t one;

  unsigned int (*ReadBlobXXXLong)(Image *image);
  unsigned short (*ReadBlobXXXShort)(Image *image);
  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);
  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);


  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickSignature);
  logging = LogMagickEvent(CoderEvent,GetMagickModule(),""enter"");

  
  quantum_info=(QuantumInfo *) NULL;
  image = AcquireImage(image_info);

  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  
  clone_info=(ImageInfo *) NULL;
  if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  if (strncmp(MATLAB_HDR.identific,""MATLAB"",6) != 0)
    {
      image2=ReadMATImageV4(image_info,image,exception);
      if (image2  == NULL)
        goto MATLAB_KO;
      image=image2;
      goto END_OF_READING;
    }
  MATLAB_HDR.Version = ReadBlobLSBShort(image);
  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");

  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),""  Endian %c%c"",
        MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);
  if (!strncmp(MATLAB_HDR.EndianIndicator, ""IM"", 2))
  {
    ReadBlobXXXLong = ReadBlobLSBLong;
    ReadBlobXXXShort = ReadBlobLSBShort;
    ReadBlobDoublesXXX = ReadBlobDoublesLSB;
    ReadBlobFloatsXXX = ReadBlobFloatsLSB;
    image->endian = LSBEndian;
  }
  else if (!strncmp(MATLAB_HDR.EndianIndicator, ""MI"", 2))
  {
    ReadBlobXXXLong = ReadBlobMSBLong;
    ReadBlobXXXShort = ReadBlobMSBShort;
    ReadBlobDoublesXXX = ReadBlobDoublesMSB;
    ReadBlobFloatsXXX = ReadBlobFloatsMSB;
    image->endian = MSBEndian;
  }
  else
    goto MATLAB_KO;    

   if (strncmp(MATLAB_HDR.identific, ""MATLAB"", 6))
     {
 MATLAB_KO:
      if (clone_info != (ImageInfo *) NULL)
        clone_info=DestroyImageInfo(clone_info);
       ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
     }
 
  filepos = TellBlob(image);
  while(!EOFBlob(image)) 
  {
    Frames = 1;
    (void) SeekBlob(image,filepos,SEEK_SET);
    

    MATLAB_HDR.DataType = ReadBlobXXXLong(image);
    if(EOFBlob(image)) break;
    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);
    if(EOFBlob(image)) break;
    if((MagickSizeType) (MATLAB_HDR.ObjectSize+filepos) > GetBlobSize(image))
      goto MATLAB_KO;
    filepos += MATLAB_HDR.ObjectSize + 4 + 4;

    clone_info=CloneImageInfo(image_info);
    image2 = image;
#if defined(MAGICKCORE_ZLIB_DELEGATE)
    if(MATLAB_HDR.DataType == miCOMPRESSED)
    {
      image2 = decompress_block(image,&MATLAB_HDR.ObjectSize,clone_info,exception);
      if(image2==NULL) continue;
      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); 
    }
#endif

    if(MATLAB_HDR.DataType!=miMATRIX) continue;  

    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);
    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);

    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);
    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;
    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;

    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);
    if(image!=image2)
      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  
    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);
    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);
    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);
    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);


    switch(MATLAB_HDR.DimFlag)
    {
      case  8: z2=z=1; break;      
      case 12: z2=z = ReadBlobXXXLong(image2);  
           Unknown6 = ReadBlobXXXLong(image2);
           (void) Unknown6;
         if(z!=3) ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
         break;
      case 16: z2=z = ReadBlobXXXLong(image2);  
         if(z!=3 && z!=1)
           ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
         Frames = ReadBlobXXXLong(image2);
         if (Frames == 0)
           ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
         break;
      default: ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
    }

    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);
    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);

    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
          ""MATLAB_HDR.StructureClass %d"",MATLAB_HDR.StructureClass);
    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&
        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    
        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    
        MATLAB_HDR.StructureClass != mxINT8_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    
        MATLAB_HDR.StructureClass != mxINT16_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    
        MATLAB_HDR.StructureClass != mxINT32_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    
        MATLAB_HDR.StructureClass != mxINT64_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    
      ThrowReaderException(CoderError,""UnsupportedCellTypeInTheMatrix"");

    switch (MATLAB_HDR.NameFlag)
    {
      case 0:
        size = ReadBlobXXXLong(image2);  
        size = 4 * (ssize_t) ((size + 3 + 1) / 4);
        (void) SeekBlob(image2, size, SEEK_CUR);
        break;
      case 1:
      case 2:
      case 3:
      case 4:
        (void) ReadBlob(image2, 4, (unsigned char *) &size); 
        break;
      default:
        goto MATLAB_KO;
    }

    CellType = ReadBlobXXXLong(image2);    
    if (logging)
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""MATLAB_HDR.CellType: %.20g"",(double) CellType);

    (void) ReadBlob(image2, 4, (unsigned char *) &size);     

NEXT_FRAME:
    switch (CellType)
    {
      case miINT8:
      case miUINT8:
        sample_size = 8;
        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)
          image->depth = 1;
        else
          image->depth = 8;         
        ldblk = (ssize_t) MATLAB_HDR.SizeX;
        break;
      case miINT16:
      case miUINT16:
        sample_size = 16;
        image->depth = 16;        
        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);
        break;
      case miINT32:
      case miUINT32:
        sample_size = 32;
        image->depth = 32;        
        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
        break;
      case miINT64:
      case miUINT64:
        sample_size = 64;
        image->depth = 64;        
        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
        break;
      case miSINGLE:
        sample_size = 32;
        image->depth = 32;        
        (void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
  {              
  }
        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
        break;
      case miDOUBLE:
        sample_size = 64;
        image->depth = 64;        
        (void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
DisableMSCWarning(4127)
        if (sizeof(double) != 8)
RestoreMSCWarning
          ThrowReaderException(CoderError, ""IncompatibleSizeOfDouble"");
        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
  {                         
  }
        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
        break;
      default:
        if ((image != image2) && (image2 != (Image *) NULL))
          image2=DestroyImage(image2);
        if (clone_info)
          clone_info=DestroyImageInfo(clone_info);
        ThrowReaderException(CoderError, ""UnsupportedCellTypeInTheMatrix"");
    }
    (void) sample_size;
    image->columns = MATLAB_HDR.SizeX;
    image->rows = MATLAB_HDR.SizeY;
    one=1;
    image->colors = one << image->depth;
    if (image->columns == 0 || image->rows == 0)
      goto MATLAB_KO;
    if((unsigned long)ldblk*MATLAB_HDR.SizeY > MATLAB_HDR.ObjectSize)
      goto MATLAB_KO;
      
    if ((MATLAB_HDR.DimFlag == 8) &&
        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
      {
        SetImageColorspace(image,GRAYColorspace);
        image->type=GrayscaleType;
      }


    
    if (image_info->ping)
    {
      size_t temp = image->columns;
      image->columns = image->rows;
      image->rows = temp;
      goto done_reading; 
    }
    status=SetImageExtent(image,image->columns,image->rows);
    if (status == MagickFalse)
      {
        InheritException(exception,&image->exception);
        return(DestroyImageList(image));
      }
    quantum_info=AcquireQuantumInfo(clone_info,image);
    if (quantum_info == (QuantumInfo *) NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");

  
    BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    
    if (BImgBuff == NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));

    MinVal = 0;
    MaxVal = 0;
    if (CellType==miDOUBLE || CellType==miSINGLE)        
    {
      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);
    }

    
    if(z==1) z=0; 
    
    do
    {
      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
      {
        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);
        if (q == (PixelPacket *) NULL)
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  MAT set image pixels returns unexpected NULL on a row %u."", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto done_reading;    
  }
        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
             ""  MAT cannot read scanrow %u from a file."", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto ExitLoop;
  }
        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))
        {
          FixLogical((unsigned char *)BImgBuff,ldblk);
          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
    {
ImportQuantumPixelsFailed:
      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  MAT failed to ImportQuantumPixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
      break;
    }
        }
        else
        {
          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
      goto ImportQuantumPixelsFailed;


          if (z<=1 &&       
          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))
      FixSignedValues(q,MATLAB_HDR.SizeX);
        }

        if (!SyncAuthenticPixels(image,exception))
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
            ""  MAT failed to sync image pixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto ExitLoop;
  }
      }
    } while(z-- >= 2);
ExitLoop:


    
    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
    {        
      CellType = ReadBlobXXXLong(image2);    
      i = ReadBlobXXXLong(image2);           

      if (CellType==miDOUBLE || CellType==miSINGLE)
      {
        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);
      }

      if (CellType==miDOUBLE)
        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
  {
          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);
          InsertComplexDoubleRow((double *)BImgBuff, i, image, MinVal, MaxVal);
  }

      if (CellType==miSINGLE)
        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
  {
          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);
          InsertComplexFloatRow((float *)BImgBuff, i, image, MinVal, MaxVal);
  }
    }

      
    if ((MATLAB_HDR.DimFlag == 8) &&
        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
      image->type=GrayscaleType;
    if (image->depth == 1)
      image->type=BilevelType;

    if(image2==image)
        image2 = NULL;    

      
    rotated_image = RotateImage(image, 90.0, exception);
    if (rotated_image != (Image *) NULL)
    {
        
      rotated_image->page.x=0;
      rotated_image->page.y=0;

      blob = rotated_image->blob;
      rotated_image->blob = image->blob;
      rotated_image->colors = image->colors;
      image->blob = blob;
      AppendImageToList(&image,rotated_image);
      DeleteImageFromList(&image);
    }

done_reading:

    if(image2!=NULL)
      if(image2!=image)
      {
        DeleteImageFromList(&image2);
  if(clone_info)
  {
          if(clone_info->file)
    {
            fclose(clone_info->file);
            clone_info->file = NULL;
            (void) remove_utf8(clone_info->filename);
    }
        }
      }

      
    AcquireNextImage(image_info,image);
    if (image->next == (Image *) NULL) break;
    image=SyncNextImageInList(image);
    image->columns=image->rows=0;
    image->colors=0;

      
    RelinquishMagickMemory(BImgBuff);
    BImgBuff = NULL;

    if(--Frames>0)
    {
      z = z2;
      if(image2==NULL) image2 = image;
      goto NEXT_FRAME;
    }

    if(image2!=NULL)
      if(image2!=image)   
      {

        DeleteImageFromList(&image2);
        if(clone_info)
        {
          if(clone_info->file)
          {
            fclose(clone_info->file);
            clone_info->file = NULL;
            (void) unlink(clone_info->filename);
          }
         }
       }
  }

  RelinquishMagickMemory(BImgBuff);
  if (quantum_info != (QuantumInfo *) NULL)
    quantum_info=DestroyQuantumInfo(quantum_info);
END_OF_READING:
  if (clone_info)
    clone_info=DestroyImageInfo(clone_info);
  CloseBlob(image);


  {
    Image *p;
    ssize_t scene=0;

    
    p=image;
    image=NULL;
    while (p != (Image *) NULL)
      {
        Image *tmp=p;
        if ((p->rows == 0) || (p->columns == 0)) {
          p=p->previous;
          DeleteImageFromList(&tmp);
        } else {
          image=p;
          p=p->previous;
        }
      }

    
    for (p=image; p != (Image *) NULL; p=p->next)
      p->scene=scene++;
  }

  if(clone_info != NULL)  
  {
    if(clone_info->file)
    {
      fclose(clone_info->file);
      clone_info->file = NULL;
      (void) remove_utf8(clone_info->filename);
    }
    DestroyImageInfo(clone_info);
    clone_info = NULL;
  }
  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),""return"");
  if ((image != image2) && (image2 != (Image *) NULL))
    image2=DestroyImage(image2);
  if(image==NULL)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  return (image);
}
","1. unsigned int status;
2. size_t Unknown6;
3. BlobInfo *blob;
4. ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
5. ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
6. if (!strncmp(MATLAB_HDR.EndianIndicator, ""IM"", 2))
7. filepos += MATLAB_HDR.ObjectSize + 4 + 4;
8. image2 = image;
9. Frames = ReadBlobXXXLong(image2);
10. default: ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
11. MATLAB_HDR.StructureClass != mxUINT64_CLASS)
12. switch (MATLAB_HDR.NameFlag)
13. case miDOUBLE:
14. if (quantum_info == (QuantumInfo *) NULL)
15. ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
16. ""  MAT failed to sync image pixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
17. image->type=GrayscaleType;
18. if(image2!=image)
19. clone_info->file = NULL;
20. image->colors=0;
21. fclose(clone_info->file);
22. image=NULL;
while (p != (Image *) NULL)
23. fclose(clone_info->file);
24. (void) remove_utf8(clone_info->filename);","11
21
27
59
70
74
114
117
156
160
178
181
244
300
306
361
398
424
432
443
465
490-491
514
516","CWE-772,CWE-416"
comics_document_finalize-148064057821074,"
#define GObject

static void
comics_document_finalize (GObject *object)
{
	ComicsDocument *comics_document = COMICS_DOCUMENT (object);

	if (comics_document->page_names) {
                g_ptr_array_foreach (comics_document->page_names, (GFunc) g_free, NULL);
                g_ptr_array_free (comics_document->page_names, TRUE);
	}

	g_clear_pointer (&comics_document->page_positions, g_hash_table_destroy);
	g_clear_object (&comics_document->archive);
	g_free (comics_document->archive_path);
	g_free (comics_document->archive_uri);

	G_OBJECT_CLASS (comics_document_parent_class)->finalize (object);
}
","1. static void
comics_document_finalize (GObject *object)
2. ComicsDocument *comics_document = COMICS_DOCUMENT (object);
3. if (comics_document->page_names) {
g_ptr_array_foreach (comics_document->page_names, (GFunc) g_free, NULL);
4. g_clear_pointer (&comics_document->page_positions, g_hash_table_destroy);
g_clear_object (&comics_document->archive);
g_free (comics_document->archive_path);
g_free (comics_document->archive_uri);","4-5
7
9-10
14-17","CWE-200,CWE-125,CWE-78"
ParaNdis_PrepareReceivedPacket-54206531943839,"
#define PARANDIS_ADAPTER
#define PUINT

tPacketIndicationType ParaNdis_PrepareReceivedPacket(
    PARANDIS_ADAPTER *pContext,
    pRxNetDescriptor pBuffersDesc,
    PUINT            pnCoalescedSegmentsCount)
{
    PMDL pMDL = pBuffersDesc->Holder;
    PNET_BUFFER_LIST pNBL = NULL;
    *pnCoalescedSegmentsCount = 1;

    if (pMDL)
    {
        ULONG nBytesStripped = 0;
        PNET_PACKET_INFO pPacketInfo = &pBuffersDesc->PacketInfo;

        if (pContext->ulPriorityVlanSetting && pPacketInfo->hasVlanHeader)
        {
            nBytesStripped = ParaNdis_StripVlanHeaderMoveHead(pPacketInfo);
        }

        ParaNdis_PadPacketToMinimalLength(pPacketInfo);
        ParaNdis_AdjustRxBufferHolderLength(pBuffersDesc, nBytesStripped);
        pNBL = NdisAllocateNetBufferAndNetBufferList(pContext->BufferListsPool, 0, 0, pMDL, nBytesStripped, pPacketInfo->dataLength);

        if (pNBL)
        {
            virtio_net_hdr_basic *pHeader = (virtio_net_hdr_basic *) pBuffersDesc->PhysicalPages[0].Virtual;
            tChecksumCheckResult csRes;
            pNBL->SourceHandle = pContext->MiniportHandle;
            NBLSetRSSInfo(pContext, pNBL, pPacketInfo);
            NBLSet8021QInfo(pContext, pNBL, pPacketInfo);

            pNBL->MiniportReserved[0] = pBuffersDesc;

#if PARANDIS_SUPPORT_RSC
            if(pHeader->gso_type != VIRTIO_NET_HDR_GSO_NONE)
            {
                *pnCoalescedSegmentsCount = PktGetTCPCoalescedSegmentsCount(pPacketInfo, pContext->MaxPacketSize.nMaxDataSize);
                NBLSetRSCInfo(pContext, pNBL, pPacketInfo, *pnCoalescedSegmentsCount);
            }
            else
#endif
            {
                csRes = ParaNdis_CheckRxChecksum(
                    pContext,
                    pHeader->flags,
                    &pBuffersDesc->PhysicalPages[PARANDIS_FIRST_RX_DATA_PAGE],
                    pPacketInfo->dataLength,
                    nBytesStripped, TRUE);
                if (csRes.value)
                {
                    NDIS_TCP_IP_CHECKSUM_NET_BUFFER_LIST_INFO qCSInfo;
                    qCSInfo.Value = NULL;
                    qCSInfo.Receive.IpChecksumFailed = csRes.flags.IpFailed;
                    qCSInfo.Receive.IpChecksumSucceeded = csRes.flags.IpOK;
                    qCSInfo.Receive.TcpChecksumFailed = csRes.flags.TcpFailed;
                    qCSInfo.Receive.TcpChecksumSucceeded = csRes.flags.TcpOK;
                    qCSInfo.Receive.UdpChecksumFailed = csRes.flags.UdpFailed;
                    qCSInfo.Receive.UdpChecksumSucceeded = csRes.flags.UdpOK;
                    NET_BUFFER_LIST_INFO(pNBL, TcpIpChecksumNetBufferListInfo) = qCSInfo.Value;
                    DPrintf(1, (""Reporting CS %X->%X\n"", csRes.value, (ULONG)(ULONG_PTR)qCSInfo.Value));
                }
            }
            pNBL->Status = NDIS_STATUS_SUCCESS;
#if defined(ENABLE_HISTORY_LOG)
            {
                tTcpIpPacketParsingResult packetReview = ParaNdis_CheckSumVerify(
                    RtlOffsetToPointer(pPacketInfo->headersBuffer, ETH_HEADER_SIZE),
                    pPacketInfo->dataLength,
                    pcrIpChecksum | pcrTcpChecksum | pcrUdpChecksum,
                    __FUNCTION__
                    );
                ParaNdis_DebugHistory(pContext, hopPacketReceived, pNBL, pPacketInfo->dataLength, (ULONG)(ULONG_PTR)qInfo.Value, packetReview.value);
            }
#endif
        }
    }
    return pNBL;
}
","1. ParaNdis_AdjustRxBufferHolderLength(pBuffersDesc, nBytesStripped);",25,"CWE-787,CWE-20,CWE-284,CWE-200"
subprocess_fork_exec_impl-54902037908382,"
#define PyObject

static PyObject *
subprocess_fork_exec_impl(PyObject *module, PyObject *process_args,
                          PyObject *executable_list, int close_fds,
                          PyObject *py_fds_to_keep, PyObject *cwd_obj,
                          PyObject *env_list, int p2cread, int p2cwrite,
                          int c2pread, int c2pwrite, int errread,
                          int errwrite, int errpipe_read, int errpipe_write,
                          int restore_signals, int call_setsid,
                          pid_t pgid_to_set, PyObject *gid_object,
                          PyObject *extra_groups_packed,
                          PyObject *uid_object, int child_umask,
                          PyObject *preexec_fn, int allow_vfork)

{
    PyObject *converted_args = NULL, *fast_args = NULL;
    PyObject *preexec_fn_args_tuple = NULL;
    gid_t *extra_groups = NULL;
    PyObject *cwd_obj2 = NULL;
    const char *cwd = NULL;
    pid_t pid = -1;
    int need_to_reenable_gc = 0;
    char *const *argv = NULL, *const *envp = NULL;
    int need_after_fork = 0;
    int saved_errno = 0;
    int *c_fds_to_keep = NULL;
    Py_ssize_t fds_to_keep_len = PyTuple_GET_SIZE(py_fds_to_keep);

    PyInterpreterState *interp = _PyInterpreterState_GET();
    if ((preexec_fn != Py_None) && interp->finalizing) {
        PyErr_SetString(PyExc_RuntimeError,
                        ""preexec_fn not supported at interpreter shutdown"");
        return NULL;
    }
    if ((preexec_fn != Py_None) && (interp != PyInterpreterState_Main())) {
        PyErr_SetString(PyExc_RuntimeError,
                        ""preexec_fn not supported within subinterpreters"");
        return NULL;
    }

    if (close_fds && errpipe_write < 3) {  
        PyErr_SetString(PyExc_ValueError, ""errpipe_write must be >= 3"");
        return NULL;
    }
    if (_sanity_check_python_fd_sequence(py_fds_to_keep)) {
        PyErr_SetString(PyExc_ValueError, ""bad value(s) in fds_to_keep"");
        return NULL;
    }

    
    if (preexec_fn != Py_None) {
        need_to_reenable_gc = PyGC_Disable();
    }

    char *const *exec_array = _PySequence_BytesToCharpArray(executable_list);
    if (!exec_array)
        goto cleanup;

    
    
    if (process_args != Py_None) {
        Py_ssize_t num_args;
        
        
        fast_args = PySequence_Fast(process_args, ""argv must be a tuple"");
        if (fast_args == NULL)
            goto cleanup;
        num_args = PySequence_Fast_GET_SIZE(fast_args);
        converted_args = PyTuple_New(num_args);
        if (converted_args == NULL)
            goto cleanup;
        for (Py_ssize_t arg_num = 0; arg_num < num_args; ++arg_num) {
            PyObject *borrowed_arg, *converted_arg;
            if (PySequence_Fast_GET_SIZE(fast_args) != num_args) {
                PyErr_SetString(PyExc_RuntimeError, ""args changed during iteration"");
                goto cleanup;
            }
            borrowed_arg = PySequence_Fast_GET_ITEM(fast_args, arg_num);
            if (PyUnicode_FSConverter(borrowed_arg, &converted_arg) == 0)
                goto cleanup;
            PyTuple_SET_ITEM(converted_args, arg_num, converted_arg);
        }

        argv = _PySequence_BytesToCharpArray(converted_args);
        Py_CLEAR(converted_args);
        Py_CLEAR(fast_args);
        if (!argv)
            goto cleanup;
    }

    if (env_list != Py_None) {
        envp = _PySequence_BytesToCharpArray(env_list);
        if (!envp)
            goto cleanup;
    }

    if (cwd_obj != Py_None) {
        if (PyUnicode_FSConverter(cwd_obj, &cwd_obj2) == 0)
            goto cleanup;
        cwd = PyBytes_AsString(cwd_obj2);
    }

    
    
    
    
    
    Py_ssize_t extra_group_size = -2;

    if (extra_groups_packed != Py_None) {
#ifdef HAVE_SETGROUPS
        if (!PyList_Check(extra_groups_packed)) {
            PyErr_SetString(PyExc_TypeError,
                    ""setgroups argument must be a list"");
            goto cleanup;
        }
        extra_group_size = PySequence_Size(extra_groups_packed);

        if (extra_group_size < 0)
            goto cleanup;

        if (extra_group_size > MAX_GROUPS) {
            PyErr_SetString(PyExc_ValueError, ""too many extra_groups"");
            goto cleanup;
        }

        
        if (extra_group_size > 0) {
            extra_groups = PyMem_RawMalloc(extra_group_size * sizeof(gid_t));
            if (extra_groups == NULL) {
                PyErr_SetString(PyExc_MemoryError,
                        ""failed to allocate memory for group list"");
                goto cleanup;
            }
        }

        for (Py_ssize_t i = 0; i < extra_group_size; i++) {
            PyObject *elem;
            elem = PySequence_GetItem(extra_groups_packed, i);
            if (!elem)
                goto cleanup;
            if (!PyLong_Check(elem)) {
                PyErr_SetString(PyExc_TypeError,
                                ""extra_groups must be integers"");
                Py_DECREF(elem);
                goto cleanup;
            } else {
                gid_t gid;
                if (!_Py_Gid_Converter(elem, &gid)) {
                    Py_DECREF(elem);
                    PyErr_SetString(PyExc_ValueError, ""invalid group id"");
                    goto cleanup;
                }
                extra_groups[i] = gid;
            }
            Py_DECREF(elem);
        }

#else 
        PyErr_BadInternalCall();
        goto cleanup;
#endif 
    }

    gid_t gid = (gid_t)-1;
    if (gid_object != Py_None) {
#ifdef HAVE_SETREGID
        if (!_Py_Gid_Converter(gid_object, &gid))
            goto cleanup;

#else 
        PyErr_BadInternalCall();
        goto cleanup;
#endif 
    }

    uid_t uid = (uid_t)-1;
    if (uid_object != Py_None) {
#ifdef HAVE_SETREUID
        if (!_Py_Uid_Converter(uid_object, &uid))
            goto cleanup;

#else 
        PyErr_BadInternalCall();
        goto cleanup;
#endif 
    }

    c_fds_to_keep = PyMem_Malloc(fds_to_keep_len * sizeof(int));
    if (c_fds_to_keep == NULL) {
        PyErr_SetString(PyExc_MemoryError, ""failed to malloc c_fds_to_keep"");
        goto cleanup;
    }
    if (convert_fds_to_keep_to_c(py_fds_to_keep, c_fds_to_keep) < 0) {
        goto cleanup;
    }

    
    if (preexec_fn != Py_None) {
        preexec_fn_args_tuple = PyTuple_New(0);
        if (!preexec_fn_args_tuple)
            goto cleanup;
        PyOS_BeforeFork();
        need_after_fork = 1;
    }

    
    const void *old_sigmask = NULL;
#ifdef VFORK_USABLE
    
    sigset_t old_sigs;
    if (preexec_fn == Py_None && allow_vfork &&
        uid == (uid_t)-1 && gid == (gid_t)-1 && extra_group_size < 0) {
        
        sigset_t all_sigs;
        sigfillset(&all_sigs);
        if ((saved_errno = pthread_sigmask(SIG_BLOCK, &all_sigs, &old_sigs))) {
            goto cleanup;
        }
        old_sigmask = &old_sigs;
    }
#endif

    pid = do_fork_exec(exec_array, argv, envp, cwd,
                       p2cread, p2cwrite, c2pread, c2pwrite,
                       errread, errwrite, errpipe_read, errpipe_write,
                       close_fds, restore_signals, call_setsid, pgid_to_set,
                       gid, extra_group_size, extra_groups,
                       uid, child_umask, old_sigmask,
                       c_fds_to_keep, fds_to_keep_len,
                       preexec_fn, preexec_fn_args_tuple);

    
    if (pid == (pid_t)-1) {
        
        saved_errno = errno;
    }

#ifdef VFORK_USABLE
    if (old_sigmask) {
        
        (void) pthread_sigmask(SIG_SETMASK, old_sigmask, NULL);
    }
#endif

    if (need_after_fork)
        PyOS_AfterFork_Parent();

cleanup:
    if (c_fds_to_keep != NULL) {
        PyMem_Free(c_fds_to_keep);
    }

    if (saved_errno != 0) {
        errno = saved_errno;
        
        PyErr_SetFromErrno(PyExc_OSError);
    }

    Py_XDECREF(preexec_fn_args_tuple);
    PyMem_RawFree(extra_groups);
    Py_XDECREF(cwd_obj2);
    if (envp)
        _Py_FreeCharPArray(envp);
    Py_XDECREF(converted_args);
    Py_XDECREF(fast_args);
    if (argv)
        _Py_FreeCharPArray(argv);
    if (exec_array)
        _Py_FreeCharPArray(exec_array);

    if (need_to_reenable_gc) {
        PyGC_Enable();
    }

    return pid == -1 ? NULL : PyLong_FromPid(pid);
}
","1. PyObject *py_fds_to_keep, PyObject *cwd_obj,
PyObject *env_list, int p2cread, int p2cwrite,
2. int restore_signals, int call_setsid,
pid_t pgid_to_set, PyObject *gid_object,
3. gid_t *extra_groups = NULL;
4. int need_to_reenable_gc = 0;
5. int need_after_fork = 0;
6. if (_sanity_check_python_fd_sequence(py_fds_to_keep)) {
PyErr_SetString(PyExc_ValueError, ""bad value(s) in fds_to_keep"");
7. for (Py_ssize_t arg_num = 0; arg_num < num_args; ++arg_num) {
8. goto cleanup;
9. Py_CLEAR(converted_args);
10. goto cleanup;
11. if (env_list != Py_None) {
envp = _PySequence_BytesToCharpArray(env_list);
12. gid_t gid = (gid_t)-1;
13. goto cleanup;
14. if (convert_fds_to_keep_to_c(py_fds_to_keep, c_fds_to_keep) < 0) {
15. goto cleanup;
16. pid = do_fork_exec(exec_array, argv, envp, cwd,
17. errno = saved_errno;
18. _Py_FreeCharPArray(envp);
Py_XDECREF(converted_args);
Py_XDECREF(fast_args);","7-8
11-12
20
24
26
47-48
75
83
88
91
94-95
168
188
197
207
237
279
289-291","CWE-552,CWE-770,CWE-125,CWE-17,CWE-399"
src_parser_trans_stage_1_2_3-165680167803737,"static int src_parser_trans_stage_1_2_3(const int tmp_fd, const char *src, const struct trans_config cfg)
{
    struct parser_buf pbuf = {
        .f_indx = 0,
        .tmp_indx = 0,
        .f_read_size = 0
    };

    int write_count = 0;
    int src_fd;
    int p_state = P_STATE_CODE;

    src_fd = open(src, O_RDONLY);
    if (src_fd == -1) {
        fprintf(stderr, ""**Error: Could not open source file: %s.\n"", src);
        return -1;
    }

    while (p_buf_refill(&pbuf, src_fd) > 0) {

        while (PBUF_F_REMD(pbuf)) {

            switch (p_state) {
            case P_STATE_COMMENT_C:

                switch (PBUF_F_CHAR(pbuf)) {
                case '*':
                    p_buf_push_tmp_char(&pbuf, '*');
                    continue;

                case '/':
                    if (pbuf.tmp_indx && (PBUF_TMP_PREV_CHAR(pbuf) == '*')) {
                        pbuf.tmp_indx--;
                        p_state = P_STATE_CODE;
                    }
                    break;

                default:
                    if (pbuf.tmp_indx && (PBUF_TMP_PREV_CHAR(pbuf) == '*'))
                        pbuf.tmp_indx--;
                    break;
                }

                pbuf.f_indx++;

            case P_STATE_CODE:
            default:

                

                switch (PBUF_F_CHAR(pbuf)) {
                case ' ':
                case '\t':
                    if (pbuf.tmp_indx &&
                            (PBUF_TMP_PREV_CHAR(pbuf) == ' ' || PBUF_TMP_PREV_CHAR(pbuf) == '\t' ||
                             PBUF_TMP_PREV_CHAR(pbuf) == '\n'))
                        pbuf.f_indx++;
                    else
                        p_buf_push_tmp_char(&pbuf, ' ');

                    continue;

                case '\r':
                case '\n':
                    if (pbuf.tmp_indx &&
                            (PBUF_TMP_PREV_CHAR(pbuf) == ' ' || PBUF_TMP_PREV_CHAR(pbuf) == '\t' ||
                             PBUF_TMP_PREV_CHAR(pbuf) == '\n')) {
                        pbuf.f_indx++;
                    } else if (pbuf.tmp_indx &&
                            (PBUF_TMP_PREV_CHAR(pbuf) == '\\')) {
                        pbuf.tmp_indx--;
                        pbuf.f_indx++;
                    } else {
                        p_buf_push_tmp_char(&pbuf, '\n');
                    }

                    continue;

                case '\\':
                    p_buf_write_tmp(&pbuf, tmp_fd);
                    p_buf_push_tmp_char(&pbuf, '\\');
                    continue;

                case '/':
                    p_buf_write_tmp(&pbuf, tmp_fd);
                    p_buf_push_tmp_char(&pbuf, '/');
                    continue;

                case '*':
                    if (pbuf.tmp_indx &&
                            (PBUF_TMP_PREV_CHAR(pbuf) == '/')) {
                        pbuf.tmp_indx--;
                        pbuf.f_indx++;
                        p_state = P_STATE_COMMENT_C;
                        continue;
                    }

                default:
                    break;
                }

                
                p_buf_write_tmp(&pbuf, tmp_fd);
                p_buf_write_f_char(&pbuf, tmp_fd);
            }
        }
    }

    p_buf_write_tmp(&pbuf, tmp_fd);
    return 0;
}
","1. switch (p_state) {
2. case '\r':","23
63","CWE-476,CWE-200,CWE-787,CWE-416"
drm_mode_dirtyfb_ioctl-176509430123077,"int drm_mode_dirtyfb_ioctl(struct drm_device *dev,
			   void *data, struct drm_file *file_priv)
{
	struct drm_clip_rect __user *clips_ptr;
	struct drm_clip_rect *clips = NULL;
	struct drm_mode_fb_dirty_cmd *r = data;
	struct drm_mode_object *obj;
	struct drm_framebuffer *fb;
	unsigned flags;
	int num_clips;
	int ret = 0;

	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		return -EINVAL;

	mutex_lock(&dev->mode_config.mutex);
	obj = drm_mode_object_find(dev, r->fb_id, DRM_MODE_OBJECT_FB);
	if (!obj) {
		DRM_ERROR(""invalid framebuffer id\n"");
		ret = -EINVAL;
		goto out_err1;
	}
	fb = obj_to_fb(obj);

	num_clips = r->num_clips;
	clips_ptr = (struct drm_clip_rect *)(unsigned long)r->clips_ptr;

	if (!num_clips != !clips_ptr) {
		ret = -EINVAL;
		goto out_err1;
	}

	flags = DRM_MODE_FB_DIRTY_FLAGS & r->flags;

	
	if (flags & DRM_MODE_FB_DIRTY_ANNOTATE_COPY && (num_clips % 2)) {
		ret = -EINVAL;
		goto out_err1;
	}

	if (num_clips && clips_ptr) {
		if (num_clips < 0 || num_clips > DRM_MODE_FB_DIRTY_MAX_CLIPS) {
			ret = -EINVAL;
			goto out_err1;
		}
		clips = kzalloc(num_clips * sizeof(*clips), GFP_KERNEL);
		if (!clips) {
			ret = -ENOMEM;
			goto out_err1;
		}

		ret = copy_from_user(clips, clips_ptr,
				     num_clips * sizeof(*clips));
		if (ret) {
			ret = -EFAULT;
			goto out_err2;
		}
	}

	if (fb->funcs->dirty) {
		ret = fb->funcs->dirty(fb, file_priv, flags, r->color,
				       clips, num_clips);
	} else {
		ret = -ENOSYS;
		goto out_err2;
	}

out_err2:
	kfree(clips);
out_err1:
	mutex_unlock(&dev->mode_config.mutex);
	return ret;
}
","1. int drm_mode_dirtyfb_ioctl(struct drm_device *dev,
2. mutex_lock(&dev->mode_config.mutex);
3. ret = -EINVAL;
4. clips = kzalloc(num_clips * sizeof(*clips), GFP_KERNEL);
5. ret = -ENOSYS;
goto out_err2;
6. kfree(clips);
7. mutex_unlock(&dev->mode_config.mutex);","1
16
37
46
64-65
69
71","CWE-119,CWE-17,CWE-125,CWE-189"
my_csr_reader,"
#define REALTYPE

int my_csr_reader( const char*           i_csr_file_in,
                    unsigned int**        o_row_idx,
                    unsigned int**        o_column_idx,
                    REALTYPE**            o_values,
                    unsigned int*         o_row_count,
                    unsigned int*         o_column_count,
                    unsigned int*         o_element_count ) {
  FILE *l_csr_file_handle;
  const unsigned int l_line_length = 512;
  char l_line[512+1];
  unsigned int l_header_read = 0;
  unsigned int* l_row_idx_id = NULL;
  unsigned int l_i = 0;

  l_csr_file_handle = fopen( i_csr_file_in, ""r"" );
  if ( l_csr_file_handle == NULL ) {
    fprintf( stderr, ""cannot open CSR file!\n"" );
    return -1;
  }

  while (fgets(l_line, l_line_length, l_csr_file_handle) != NULL) {
    if ( strlen(l_line) == l_line_length ) {
      fprintf( stderr, ""could not read file length!\n"" );
      return -1;
    }
    
    if ( l_line[0] == '%' ) {
      continue;
     } else {
       
       if ( l_header_read == 0 ) {
        if (3 == sscanf(l_line, ""%u %u %u"", o_row_count, o_column_count, o_element_count) &&
            0 != *o_row_count && 0 != *o_column_count && 0 != *o_element_count)
        {
           
           *o_column_idx = (unsigned int*) malloc(sizeof(unsigned int) * (*o_element_count));
           *o_row_idx = (unsigned int*) malloc(sizeof(unsigned int) * (*o_row_count + 1));
          *o_values = (REALTYPE*) malloc(sizeof(double) * (*o_element_count));
          l_row_idx_id = (unsigned int*) malloc(sizeof(unsigned int) * (*o_row_count));

          
          if ( ( *o_row_idx == NULL )      ||
               ( *o_column_idx == NULL )   ||
               ( *o_values == NULL )       ||
               ( l_row_idx_id == NULL ) ) {
            fprintf( stderr, ""could not allocate sp data!\n"" );
            return -1;
          }

          
          memset(*o_row_idx, 0, sizeof(unsigned int)*(*o_row_count + 1));
          memset(*o_column_idx, 0, sizeof(unsigned int)*(*o_element_count));
          memset(*o_values, 0, sizeof(double)*(*o_element_count));
          memset(l_row_idx_id, 0, sizeof(unsigned int)*(*o_row_count));

          
          for ( l_i = 0; l_i < (*o_row_count + 1); l_i++)
            (*o_row_idx)[l_i] = (*o_element_count);

          
          (*o_row_idx)[0] = 0;
          l_i = 0;
          l_header_read = 1;
        } else {
          fprintf( stderr, ""could not csr description!\n"" );
          return -1;
        }
      
      } else {
        unsigned int l_row, l_column;
        REALTYPE l_value;
        
        if ( sscanf(l_line, ""%u %u %lf"", &l_row, &l_column, &l_value) != 3 ) {
          fprintf( stderr, ""could not read element!\n"" );
          return -1;
        }
        
        l_row--;
        l_column--;
        
        (*o_column_idx)[l_i] = l_column;
        (*o_values)[l_i] = l_value;
        l_i++;
        
        l_row_idx_id[l_row] = 1;
        (*o_row_idx)[l_row+1] = l_i;
      }
    }
  }

  
  fclose( l_csr_file_handle );

  
  if ( l_i != (*o_element_count) ) {
    fprintf( stderr, ""we were not able to read all elements!\n"" );
    return -1;
  }

  
  for ( l_i = 0; l_i < (*o_row_count); l_i++) {
    if ( l_row_idx_id[l_i] == 0 ) {
      (*o_row_idx)[l_i+1] = (*o_row_idx)[l_i];
    }
  }

  
  if ( l_row_idx_id != NULL ) {
    free( l_row_idx_id );
  }
  return 0;
}
","1. unsigned int*         o_element_count ) {
2. const unsigned int l_line_length = 512;
char l_line[512+1];
unsigned int l_header_read = 0;
3. fprintf( stderr, ""could not read file length!\n"" );
4. if ( l_header_read == 0 ) {
5. 0 != *o_row_count && 0 != *o_column_count && 0 != *o_element_count)
6. ( *o_column_idx == NULL )   ||
7. ( l_row_idx_id == NULL ) ) {
8. return -1;
9. fprintf( stderr, ""could not read element!\n"" );
return -1;
10. l_row--;
11. (*o_column_idx)[l_i] = l_column;
12. l_row_idx_id[l_row] = 1;
13. fclose( l_csr_file_handle );
14. (*o_row_idx)[l_i+1] = (*o_row_idx)[l_i];
15. if ( l_row_idx_id != NULL ) {","10
12-14
26
34
36
46
48
50
77-78
81
84
88
95
106
111","CWE-787,CWE-119"
extract_epub_from_container_1-116296291124811,"
#define EpubDocument
#define GError

static gboolean
extract_epub_from_container_1 (const gchar* uri,
                             EpubDocument *epub_document,
                             GError ** error)
{
    GFile *tmp_gfile = NULL;
    GError *err = NULL;
    epub_document->archivename = g_filename_from_uri(uri,NULL,error);

    if ( !epub_document->archivename )
    {
        if (err) {
            g_propagate_error (error, err);
        }
        else {
            g_set_error_literal (error,
                         EV_DOCUMENT_ERROR,
                         EV_DOCUMENT_ERROR_INVALID,
                         _(""could not retrieve filename""));
        }
        return FALSE;
    }

    gchar *epubfilename = g_strrstr(epub_document->archivename,""/"");
    if ( *epubfilename == '/' )
        epubfilename++ ;

    GString *temporary_sub_directory = g_string_new(epubfilename);
    g_string_append(temporary_sub_directory,""XXXXXX"") ;
    epub_document->tmp_archive_dir = ev_mkdtemp(temporary_sub_directory->str, error);
    g_string_free(temporary_sub_directory, TRUE);

    if (!epub_document->tmp_archive_dir) {
        return FALSE;
    }

    epub_document->epubDocument = unzOpen64(epub_document->archivename);
    if ( epub_document->epubDocument == NULL )
    {
        if (err)    {
            g_propagate_error (error, err);
        }
        else    {
            g_set_error_literal (error,
                         EV_DOCUMENT_ERROR,
                         EV_DOCUMENT_ERROR_INVALID,
                         _(""could not open archive""));
        }
        return FALSE;
    }

    gboolean result = FALSE;

    if ( unzGoToFirstFile(epub_document->epubDocument) != UNZ_OK )
    {
        if (err) {
            g_propagate_error (error, err);
        }
        else    {
            g_set_error_literal (error,
                         EV_DOCUMENT_ERROR,
                         EV_DOCUMENT_ERROR_INVALID,
                         _(""could not extract archive""));
        }
        goto out;
    }

    tmp_gfile = g_file_new_for_path (epub_document->tmp_archive_dir);
    while ( TRUE )
    {
        if ( extract_one_file(epub_document, tmp_gfile, &err) == FALSE )
        {
            if (err) {
                g_propagate_error (error, err);
            }
            else    {
                g_set_error_literal (error,
                             EV_DOCUMENT_ERROR,
                             EV_DOCUMENT_ERROR_INVALID,
                             _(""could not extract archive""));
            }
            goto out;
        }

        if ( unzGoToNextFile(epub_document->epubDocument) == UNZ_END_OF_LIST_OF_FILE ) {
            result = TRUE;
            break;
        }
    }

out:
    g_clear_object (&tmp_gfile);
    unzClose(epub_document->epubDocument);
    return result;
}
","1. static gboolean
2. GError *err = NULL;
3. if (err) {
4. else {
5. _(""could not retrieve filename""));
6. return FALSE;
7. gchar *epubfilename = g_strrstr(epub_document->archivename,""/"");
8. epubfilename++ ;
9. GString *temporary_sub_directory = g_string_new(epubfilename);
g_string_append(temporary_sub_directory,""XXXXXX"") ;
epub_document->tmp_archive_dir = ev_mkdtemp(temporary_sub_directory->str, error);
g_string_free(temporary_sub_directory, TRUE);
10. g_propagate_error (error, err);
11. else    {
12. gboolean result = FALSE;
13. tmp_gfile = g_file_new_for_path (epub_document->tmp_archive_dir);
while ( TRUE )
14. else    {
15. if ( unzGoToNextFile(epub_document->epubDocument) == UNZ_END_OF_LIST_OF_FILE ) {
16. g_clear_object (&tmp_gfile);","5
11
16
19
23
25
28
30
32-35
45
47
56
72-73
80
89
96","CWE-337,CWE-120,CWE-476,CWE-674,CWE-125"
handle_exception,"static int handle_exception(struct kvm_vcpu *vcpu)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	struct kvm_run *kvm_run = vcpu->run;
	u32 intr_info, ex_no, error_code;
	unsigned long cr2, rip, dr6;
	u32 vect_info;
	enum emulation_result er;

	vect_info = vmx->idt_vectoring_info;
	intr_info = vmx->exit_intr_info;

	if (is_machine_check(intr_info))
		return handle_machine_check(vcpu);

	if ((intr_info & INTR_INFO_INTR_TYPE_MASK) == INTR_TYPE_NMI_INTR)
		return 1;  

	if (is_no_device(intr_info)) {
		vmx_fpu_activate(vcpu);
		return 1;
	}

	if (is_invalid_opcode(intr_info)) {
		if (is_guest_mode(vcpu)) {
			kvm_queue_exception(vcpu, UD_VECTOR);
			return 1;
		}
		er = emulate_instruction(vcpu, EMULTYPE_TRAP_UD);
		if (er != EMULATE_DONE)
			kvm_queue_exception(vcpu, UD_VECTOR);
		return 1;
	}

	error_code = 0;
	if (intr_info & INTR_INFO_DELIVER_CODE_MASK)
		error_code = vmcs_read32(VM_EXIT_INTR_ERROR_CODE);

	
	if ((vect_info & VECTORING_INFO_VALID_MASK) &&
	    !(is_page_fault(intr_info) && !(error_code & PFERR_RSVD_MASK))) {
		vcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;
		vcpu->run->internal.suberror = KVM_INTERNAL_ERROR_SIMUL_EX;
		vcpu->run->internal.ndata = 3;
		vcpu->run->internal.data[0] = vect_info;
		vcpu->run->internal.data[1] = intr_info;
		vcpu->run->internal.data[2] = error_code;
		return 0;
	}

	if (is_page_fault(intr_info)) {
		
		BUG_ON(enable_ept);
		cr2 = vmcs_readl(EXIT_QUALIFICATION);
		trace_kvm_page_fault(cr2, error_code);

		if (kvm_event_needs_reinjection(vcpu))
			kvm_mmu_unprotect_page_virt(vcpu, cr2);
		return kvm_mmu_page_fault(vcpu, cr2, error_code, NULL, 0);
	}

	ex_no = intr_info & INTR_INFO_VECTOR_MASK;

	if (vmx->rmode.vm86_active && rmode_exception(vcpu, ex_no))
 		return handle_rmode_exception(vcpu, ex_no, error_code);
 
 	switch (ex_no) {
	case AC_VECTOR:
		kvm_queue_exception_e(vcpu, AC_VECTOR, error_code);
		return 1;
 	case DB_VECTOR:
 		dr6 = vmcs_readl(EXIT_QUALIFICATION);
 		if (!(vcpu->guest_debug &
		      (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP))) {
			vcpu->arch.dr6 &= ~15;
			vcpu->arch.dr6 |= dr6 | DR6_RTM;
			if (!(dr6 & ~DR6_RESERVED)) 
				skip_emulated_instruction(vcpu);

			kvm_queue_exception(vcpu, DB_VECTOR);
			return 1;
		}
		kvm_run->debug.arch.dr6 = dr6 | DR6_FIXED_1;
		kvm_run->debug.arch.dr7 = vmcs_readl(GUEST_DR7);
		
	case BP_VECTOR:
		
		vmx->vcpu.arch.event_exit_inst_len =
			vmcs_read32(VM_EXIT_INSTRUCTION_LEN);
		kvm_run->exit_reason = KVM_EXIT_DEBUG;
		rip = kvm_rip_read(vcpu);
		kvm_run->debug.arch.pc = vmcs_readl(GUEST_CS_BASE) + rip;
		kvm_run->debug.arch.exception = ex_no;
		break;
	default:
		kvm_run->exit_reason = KVM_EXIT_EXCEPTION;
		kvm_run->ex.exception = ex_no;
		kvm_run->ex.error_code = error_code;
		break;
	}
	return 0;
}
","1. struct kvm_run *kvm_run = vcpu->run;
2. enum emulation_result er;
3. return 1;
4. if (intr_info & INTR_INFO_DELIVER_CODE_MASK)
5. if ((vect_info & VECTORING_INFO_VALID_MASK) &&
6. vcpu->run->internal.data[1] = intr_info;
7. switch (ex_no) {
8. if (!(dr6 & ~DR6_RESERVED))
9. kvm_queue_exception(vcpu, DB_VECTOR);","4
8
32
36
44
50
71
81
84","CWE-401,CWE-125,CWE-399,CWE-119"
sudo_passwd_verify_1-29900682356787,"int
sudo_passwd_verify_1(const struct sudoers_context *ctx, struct passwd *pw,
    const char *pass, sudo_auth *auth, struct sudo_conv_callback *callback)
{
    char *pw_passwd = auth->data;
    int ret;
    debug_decl(sudo_passwd_verify_1, SUDOERS_DEBUG_AUTH);

    
    if (strcmp(pass, pw_passwd) == 0)
	ret = AUTH_SUCCESS;
    else
	ret = AUTH_FAILURE;

    debug_return_int(ret);
}
","1. const char *pass, sudo_auth *auth, struct sudo_conv_callback *callback)
2. int ret;
3. if (strcmp(pass, pw_passwd) == 0)","3
6
10","CWE-310,CWE-125,CWE-399,CWE-119"
iloc_box_read-121592160117299,"
#define GF_BitStream
#define GF_Box

GF_Err iloc_box_read(GF_Box *s, GF_BitStream *bs)
{
	u32 item_count, extent_count, i, j;
	GF_ItemLocationBox *ptr = (GF_ItemLocationBox *)s;

	ISOM_DECREASE_SIZE(ptr, 2)
	ptr->offset_size = gf_bs_read_int(bs, 4);
	ptr->length_size = gf_bs_read_int(bs, 4);
	ptr->base_offset_size = gf_bs_read_int(bs, 4);
	if (ptr->version == 1 || ptr->version == 2) {
		ptr->index_size = gf_bs_read_int(bs, 4);
	} else {
		gf_bs_read_int(bs, 4);
	}
	if (ptr->version < 2) {
		ISOM_DECREASE_SIZE(ptr, 2)
		item_count = gf_bs_read_u16(bs);
	} else {
		ISOM_DECREASE_SIZE(ptr, 4)
		item_count = gf_bs_read_u32(bs);
	}

	for (i = 0; i < item_count; i++) {
		GF_ItemLocationEntry *location_entry;
		GF_SAFEALLOC(location_entry, GF_ItemLocationEntry);
		if (!location_entry) return GF_OUT_OF_MEM;

		gf_list_add(ptr->location_entries, location_entry);
		if (ptr->version < 2) {
			ISOM_DECREASE_SIZE(ptr, 2)
			location_entry->item_ID = gf_bs_read_u16(bs);
		} else {
			ISOM_DECREASE_SIZE(ptr, 4)
			location_entry->item_ID = gf_bs_read_u32(bs);
		}
		if (ptr->version == 1 || ptr->version == 2) {
			ISOM_DECREASE_SIZE(ptr, 2)
			location_entry->construction_method = gf_bs_read_u16(bs);
		}
		else {
			location_entry->construction_method = 0;
		}
		ISOM_DECREASE_SIZE(ptr, (2 + ptr->base_offset_size) )
		location_entry->data_reference_index = gf_bs_read_u16(bs);
		location_entry->base_offset = gf_bs_read_int(bs, 8*ptr->base_offset_size);
#ifndef GPAC_DISABLE_ISOM_WRITE
		location_entry->original_base_offset = location_entry->base_offset;
#endif

		ISOM_DECREASE_SIZE(ptr, 2)
		extent_count = gf_bs_read_u16(bs);
		location_entry->extent_entries = gf_list_new();
		for (j = 0; j < extent_count; j++) {
			GF_ItemExtentEntry *extent_entry;
			GF_SAFEALLOC(extent_entry, GF_ItemExtentEntry);
			if (!extent_entry) return GF_OUT_OF_MEM;
			
			gf_list_add(location_entry->extent_entries, extent_entry);
			if ((ptr->version == 1 || ptr->version == 2) && ptr->index_size > 0) {
				ISOM_DECREASE_SIZE(ptr, ptr->index_size)
				extent_entry->extent_index = gf_bs_read_int(bs, 8 * ptr->index_size);
			}
			else {
				extent_entry->extent_index = 0;
			}
			ISOM_DECREASE_SIZE(ptr, (ptr->offset_size+ptr->length_size) )

			extent_entry->extent_offset = gf_bs_read_int(bs, 8*ptr->offset_size);
			extent_entry->extent_length = gf_bs_read_int(bs, 8*ptr->length_size);
#ifndef GPAC_DISABLE_ISOM_WRITE
			extent_entry->original_extent_offset = extent_entry->extent_offset;
#endif
		}
	}
	return GF_OK;
}
","1. GF_Err iloc_box_read(GF_Box *s, GF_BitStream *bs)
2. } else {
3. ISOM_DECREASE_SIZE(ptr, 4)
4. for (i = 0; i < item_count; i++) {
5. gf_list_add(ptr->location_entries, location_entry);
6. ISOM_DECREASE_SIZE(ptr, 2)
7. ISOM_DECREASE_SIZE(ptr, 2)
8. else {
location_entry->construction_method = 0;
9. location_entry->base_offset = gf_bs_read_int(bs, 8*ptr->base_offset_size);
10. ISOM_DECREASE_SIZE(ptr, 2)
11. gf_list_add(location_entry->extent_entries, extent_entry);
if ((ptr->version == 1 || ptr->version == 2) && ptr->index_size > 0) {
12. extent_entry->extent_index = gf_bs_read_int(bs, 8 * ptr->index_size);
13. else {
14. extent_entry->extent_offset = gf_bs_read_int(bs, 8*ptr->offset_size);","5
16
23
27
32
34
41
44-45
49
54
62-63
65
67
72","CWE-476,CWE-190,CWE-189,CWE-119"
mk_vhost_fdt_open,"static inline int mk_vhost_fdt_open(int id, unsigned int hash,
                                    struct session_request *sr)
{
    int i;
    int fd;
    struct vhost_fdt_hash_table *ht = NULL;
    struct vhost_fdt_hash_chain *hc;

    if (config->fdt == MK_FALSE) {
        return open(sr->real_path.data, sr->file_info.flags_read_only);
    }

    ht = mk_vhost_fdt_table_lookup(id, sr->host_conf);
    if (mk_unlikely(!ht)) {
        return open(sr->real_path.data, sr->file_info.flags_read_only);
    }

    
    hc = mk_vhost_fdt_chain_lookup(hash, ht);
    if (hc) {
        
        hc->readers++;
        return hc->fd;
    }

    
    fd = open(sr->real_path.data, sr->file_info.flags_read_only);
    if (fd == -1) {
        return -1;
    }

    
    if (ht->av_slots <= 0) {
        return fd;
    }

    
    for (i = 0; i < VHOST_FDT_HASHTABLE_CHAINS; i++) {
        hc = &ht->chain[i];
        if (hc->fd == -1) {
            hc->fd   = fd;
            hc->hash = hash;
            hc->readers++;
            ht->av_slots--;
 
             sr->vhost_fdt_id   = id;
             sr->vhost_fdt_hash = hash;
            sr->fd_is_fdt      = MK_TRUE;
 
             return fd;
         }
    }

    return -1;
}
","1. int i;
2. struct vhost_fdt_hash_table *ht = NULL;
3. return open(sr->real_path.data, sr->file_info.flags_read_only);
4. return fd;
5. sr->vhost_fdt_hash = hash;
6. return -1;","4
6
10
38
51
58","CWE-200,CWE-20,CWE-122,CWE-369"
__find_callno_7-16862460801679,"static int __find_callno_7(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked, int full_frame)
{
	int res = 0;
	int x;
	struct timeval now;
	char host[80];

	if (new <= NEW_ALLOW) {
		for (x=1;(res < 1) && (x<maxnontrunkcall);x++) {
			ast_mutex_lock(&iaxsl[x]);
			if (iaxs[x]) {
				
				if (match(sin, callno, dcallno, iaxs[x], full_frame)) {
					res = x;
				}
			}
			ast_mutex_unlock(&iaxsl[x]);
		}
		for (x=TRUNK_CALL_START;(res < 1) && (x<maxtrunkcall);x++) {
			ast_mutex_lock(&iaxsl[x]);
			if (iaxs[x]) {
				
				if (match(sin, callno, dcallno, iaxs[x], full_frame)) {
					res = x;
				}
			}
			ast_mutex_unlock(&iaxsl[x]);
		}
	}
	if ((res < 1) && (new >= NEW_ALLOW)) {
		int start, found = 0;

		
		if (!iax2_getpeername(*sin, host, sizeof(host)))
			snprintf(host, sizeof(host), ""%s:%d"", ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));

		now = ast_tvnow();
		start = 1 + (ast_random() % (TRUNK_CALL_START - 1));
		for (x = start; 1; x++) {
			if (x == TRUNK_CALL_START) {
				x = 0;
				continue;
			}

			
			ast_mutex_lock(&iaxsl[x]);
			if (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) {
				found = 1;
				break;
			}
			ast_mutex_unlock(&iaxsl[x]);
			
			if (x == start - 1) {
				break;
			}
		}
		
		if (x == start - 1 && !found) {
			ast_log(LOG_WARNING, ""No more space\n"");
			return 0;
		}
		iaxs[x] = new_iax(sin, host);
		update_max_nontrunk();
		if (iaxs[x]) {
			if (iaxdebug)
				ast_debug(1, ""Creating new call structure %d\n"", x);
			iaxs[x]->sockfd = sockfd;
			iaxs[x]->addr.sin_port = sin->sin_port;
			iaxs[x]->addr.sin_family = sin->sin_family;
			iaxs[x]->addr.sin_addr.s_addr = sin->sin_addr.s_addr;
			iaxs[x]->peercallno = callno;
			iaxs[x]->callno = x;
			iaxs[x]->pingtime = DEFAULT_RETRY_TIME;
			iaxs[x]->expiry = min_reg_expire;
			iaxs[x]->pingid = iax2_sched_add(sched, ping_time * 1000, send_ping, (void *)(long)x);
			iaxs[x]->lagid = iax2_sched_add(sched, lagrq_time * 1000, send_lagrq, (void *)(long)x);
			iaxs[x]->amaflags = amaflags;
			ast_copy_flags(iaxs[x], (&globalflags), IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);
			
			ast_string_field_set(iaxs[x], accountcode, accountcode);
			ast_string_field_set(iaxs[x], mohinterpret, mohinterpret);
			ast_string_field_set(iaxs[x], mohsuggest, mohsuggest);
			ast_string_field_set(iaxs[x], parkinglot, default_parkinglot);
		} else {
			ast_log(LOG_WARNING, ""Out of resources\n"");
			ast_mutex_unlock(&iaxsl[x]);
			return 0;
		}
		if (!return_locked)
			ast_mutex_unlock(&iaxsl[x]);
		res = x;
	}
	return res;
}
","1. static int __find_callno_7(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked, int full_frame)
2. int res = 0;
int x;
struct timeval now;
char host[80];
3. for (x=1;(res < 1) && (x<maxnontrunkcall);x++) {
ast_mutex_lock(&iaxsl[x]);
4. if (match(sin, callno, dcallno, iaxs[x], full_frame)) {
res = x;
5. ast_mutex_unlock(&iaxsl[x]);
6. ast_mutex_lock(&iaxsl[x]);
if (iaxs[x]) {
7. if (match(sin, callno, dcallno, iaxs[x], full_frame)) {
res = x;
8. if ((res < 1) && (new >= NEW_ALLOW)) {
9. now = ast_tvnow();
start = 1 + (ast_random() % (TRUNK_CALL_START - 1));
for (x = start; 1; x++) {
if (x == TRUNK_CALL_START) {
x = 0;
continue;
10. if (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) {
11. break;
12. ast_mutex_unlock(&iaxsl[x]);
13. if (x == start - 1) {
break;
14. if (x == start - 1 && !found) {
15. return 0;
16. iaxs[x] = new_iax(sin, host);
update_max_nontrunk();
if (iaxs[x]) {
17. ast_debug(1, ""Creating new call structure %d\n"", x);
iaxs[x]->sockfd = sockfd;
iaxs[x]->addr.sin_port = sin->sin_port;
iaxs[x]->addr.sin_family = sin->sin_family;
iaxs[x]->addr.sin_addr.s_addr = sin->sin_addr.s_addr;
iaxs[x]->peercallno = callno;
iaxs[x]->callno = x;
iaxs[x]->pingtime = DEFAULT_RETRY_TIME;
iaxs[x]->expiry = min_reg_expire;
iaxs[x]->pingid = iax2_sched_add(sched, ping_time * 1000, send_ping, (void *)(long)x);
iaxs[x]->lagid = iax2_sched_add(sched, lagrq_time * 1000, send_lagrq, (void *)(long)x);
18. ast_copy_flags(iaxs[x], (&globalflags), IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);
19. ast_string_field_set(iaxs[x], accountcode, accountcode);
ast_string_field_set(iaxs[x], mohinterpret, mohinterpret);
ast_string_field_set(iaxs[x], mohsuggest, mohsuggest);
20. } else {
21. if (!return_locked)
ast_mutex_unlock(&iaxsl[x]);
res = x;","1
3-6
9-10
13-14
17
20-21
23-24
30
42-47
52
54
56
58-59
63
65
67-69
71-81
83
85-87
89
94-96",CWE-287
kadm5_create_principal_3_1-86662614845073,"kadm5_ret_t
kadm5_create_principal_3_1(void *server_handle,
                         kadm5_principal_ent_t entry, long mask,
                         int n_ks_tuple, krb5_key_salt_tuple *ks_tuple,
                         char *password)
{
    krb5_db_entry               *kdb;
    osa_princ_ent_rec           adb;
    kadm5_policy_ent_rec        polent;
    krb5_boolean                have_polent = FALSE;
    krb5_timestamp              now;
    krb5_tl_data                *tl_data_tail;
    unsigned int                ret;
    kadm5_server_handle_t handle = server_handle;
    krb5_keyblock               *act_mkey;
    krb5_kvno                   act_kvno;
    int                         new_n_ks_tuple = 0;
    krb5_key_salt_tuple         *new_ks_tuple = NULL;

    CHECK_HANDLE(server_handle);

    krb5_clear_error_message(handle->context);

    check_1_6_dummy(entry, mask, n_ks_tuple, ks_tuple, &password);

    
    if (entry == NULL)
        return EINVAL;
    if(!(mask & KADM5_PRINCIPAL) || (mask & KADM5_MOD_NAME) ||
       (mask & KADM5_MOD_TIME) || (mask & KADM5_LAST_PWD_CHANGE) ||
       (mask & KADM5_MKVNO) || (mask & KADM5_AUX_ATTRIBUTES) ||
       (mask & KADM5_LAST_SUCCESS) || (mask & KADM5_LAST_FAILED) ||
       (mask & KADM5_FAIL_AUTH_COUNT))
        return KADM5_BAD_MASK;
    if ((mask & KADM5_KEY_DATA) && entry->n_key_data != 0)
        return KADM5_BAD_MASK;
    if((mask & KADM5_POLICY) && entry->policy == NULL)
        return KADM5_BAD_MASK;
    if((mask & KADM5_POLICY) && (mask & KADM5_POLICY_CLR))
        return KADM5_BAD_MASK;
    if((mask & ~ALL_PRINC_MASK))
        return KADM5_BAD_MASK;
    if (mask & KADM5_TL_DATA) {
        for (tl_data_tail = entry->tl_data; tl_data_tail != NULL;
             tl_data_tail = tl_data_tail->tl_data_next) {
            if (tl_data_tail->tl_data_type < 256)
                return KADM5_BAD_TL_TYPE;
        }
    }

    
    ret = kdb_get_entry(handle, entry->principal, &kdb, &adb);

    switch(ret) {
    case KADM5_UNK_PRINC:
        break;
    case 0:
        kdb_free_entry(handle, kdb, &adb);
        return KADM5_DUP;
    default:
        return ret;
    }

    kdb = calloc(1, sizeof(*kdb));
    if (kdb == NULL)
        return ENOMEM;
    memset(&adb, 0, sizeof(osa_princ_ent_rec));

    
    if ((mask & KADM5_POLICY)) {
        ret = get_policy(handle, entry->policy, &polent, &have_polent);
        if (ret)
            goto cleanup;
    }
    if (password) {
        ret = passwd_check(handle, password, have_polent ? &polent : NULL,
                           entry->principal);
        if (ret)
            goto cleanup;
    }
    
    if ((ret = krb5_timeofday(handle->context, &now)))
        goto cleanup;

    kdb->magic = KRB5_KDB_MAGIC_NUMBER;
    kdb->len = KRB5_KDB_V1_BASE_LENGTH; 

    if ((mask & KADM5_ATTRIBUTES))
        kdb->attributes = entry->attributes;
    else
        kdb->attributes = handle->params.flags;

    if ((mask & KADM5_MAX_LIFE))
        kdb->max_life = entry->max_life;
    else
        kdb->max_life = handle->params.max_life;

    if (mask & KADM5_MAX_RLIFE)
        kdb->max_renewable_life = entry->max_renewable_life;
    else
        kdb->max_renewable_life = handle->params.max_rlife;

    if ((mask & KADM5_PRINC_EXPIRE_TIME))
        kdb->expiration = entry->princ_expire_time;
    else
        kdb->expiration = handle->params.expiration;

    kdb->pw_expiration = 0;
    if (have_polent) {
        if(polent.pw_max_life)
            kdb->pw_expiration = ts_incr(now, polent.pw_max_life);
        else
            kdb->pw_expiration = 0;
    }
    if ((mask & KADM5_PW_EXPIRATION))
        kdb->pw_expiration = entry->pw_expiration;

    kdb->last_success = 0;
    kdb->last_failed = 0;
    kdb->fail_auth_count = 0;

    

    ret = krb5_copy_principal(handle->context, entry->principal, &kdb->princ);
    if (ret)
        goto cleanup;

    if ((ret = krb5_dbe_update_last_pwd_change(handle->context, kdb, now)))
        goto cleanup;

    if (mask & KADM5_TL_DATA) {
        
        for (tl_data_tail = entry->tl_data; tl_data_tail;
             tl_data_tail = tl_data_tail->tl_data_next)
        {
            ret = krb5_dbe_update_tl_data(handle->context, kdb, tl_data_tail);
            if( ret )
                goto cleanup;
        }
    }

    
    ret = apply_keysalt_policy(handle, entry->policy, n_ks_tuple, ks_tuple,
                               &new_n_ks_tuple, &new_ks_tuple);
    if (ret)
        goto cleanup;

    

    ret = kdb_get_active_mkey(handle, &act_kvno, &act_mkey);
    if (ret)
        goto cleanup;

    if (mask & KADM5_KEY_DATA) {
        
        assert(entry->n_key_data == 0);
    } else if (password) {
        ret = krb5_dbe_cpw(handle->context, act_mkey, new_ks_tuple,
                           new_n_ks_tuple, password,
                           (mask & KADM5_KVNO)?entry->kvno:1,
                           FALSE, kdb);
    } else {
        
        ret = krb5_dbe_crk(handle->context, &master_keyblock,
                           new_ks_tuple, new_n_ks_tuple, FALSE, kdb);
    }
    if (ret)
        goto cleanup;

    
    ret = krb5_dbe_update_mkvno(handle->context, kdb, act_kvno);
    if (ret)
        goto cleanup;

    ret = k5_kadm5_hook_create(handle->context, handle->hook_handles,
                               KADM5_HOOK_STAGE_PRECOMMIT, entry, mask,
                               new_n_ks_tuple, new_ks_tuple, password);
    if (ret)
        goto cleanup;

    

    adb.admin_history_kvno = INITIAL_HIST_KVNO;
    if (mask & KADM5_POLICY) {
        adb.aux_attributes = KADM5_POLICY;

        
        

        adb.policy = entry->policy;
    }

    
    kdb->mask = mask | KADM5_KEY_DATA | KADM5_PRINCIPAL ;

    
    ret = kdb_put_entry(handle, kdb, &adb);

    (void) k5_kadm5_hook_create(handle->context, handle->hook_handles,
                                KADM5_HOOK_STAGE_POSTCOMMIT, entry, mask,
                                new_n_ks_tuple, new_ks_tuple, password);

cleanup:
    free(new_ks_tuple);
    krb5_db_free_principal(handle->context, kdb);
    if (have_polent)
        (void) kadm5_free_policy_ent(handle->lhandle, &polent);
    return ret;
}
","1. kadm5_create_principal_3_1(void *server_handle,
2. unsigned int                ret;
kadm5_server_handle_t handle = server_handle;
3. if(!(mask & KADM5_PRINCIPAL) || (mask & KADM5_MOD_NAME) ||
4. (mask & KADM5_LAST_SUCCESS) || (mask & KADM5_LAST_FAILED) ||
5. tl_data_tail = tl_data_tail->tl_data_next) {
6. break;
7. kdb = calloc(1, sizeof(*kdb));
8. memset(&adb, 0, sizeof(osa_princ_ent_rec));
9. ret = get_policy(handle, entry->policy, &polent, &have_polent);
10. entry->principal);
11. goto cleanup;
12. kdb->attributes = handle->params.flags;
13. kdb->last_failed = 0;
14. goto cleanup;
15. ret = kdb_get_active_mkey(handle, &act_kvno, &act_mkey);
16. } else if (password) {
17. } else {
18. KADM5_HOOK_STAGE_PRECOMMIT, entry, mask,
19. if (have_polent)
(void) kadm5_free_policy_ent(handle->lhandle, &polent);","2
13-14
31
34
47
60
68
71
78
84
94
102
130
151
167
174
179
193
227-228","CWE-362,CWE-320,CWE-90,CWE-125"
freerdp_image_copy-91335144853165,"
#define BYTE
#define DWORD
#define DstFormat
#define SrcFormat
#define UINT32

BOOL freerdp_image_copy(BYTE* pDstData, DWORD DstFormat, UINT32 nDstStep, UINT32 nXDst,
                        UINT32 nYDst, UINT32 nWidth, UINT32 nHeight, const BYTE* pSrcData,
                        DWORD SrcFormat, UINT32 nSrcStep, UINT32 nXSrc, UINT32 nYSrc,
                        const gdiPalette* palette, UINT32 flags)
{
	const UINT32 dstByte = FreeRDPGetBytesPerPixel(DstFormat);
	const UINT32 srcByte = FreeRDPGetBytesPerPixel(SrcFormat);

	if ((nHeight > INT32_MAX) || (nWidth > INT32_MAX))
		return FALSE;

	if (!pDstData || !pSrcData)
		return FALSE;

	if ((nWidth == 0) || (nHeight == 0))
		return TRUE;

	if (nDstStep == 0)
		nDstStep = nWidth * FreeRDPGetBytesPerPixel(DstFormat);

	if (nSrcStep == 0)
		nSrcStep = nWidth * FreeRDPGetBytesPerPixel(SrcFormat);

	const BOOL ovl = overlapping(pDstData, nXDst, nYDst, nDstStep, dstByte, pSrcData, nXSrc, nYSrc,
	                             nSrcStep, srcByte, nWidth, nHeight);
	if (ovl)
		return freerdp_image_copy_overlap(pDstData, DstFormat, nDstStep, nXDst, nYDst, nWidth,
		                                  nHeight, pSrcData, SrcFormat, nSrcStep, nXSrc, nYSrc,
		                                  palette, flags);
	return freerdp_image_copy_no_overlap(pDstData, DstFormat, nDstStep, nXDst, nYDst, nWidth,
	                                     nHeight, pSrcData, SrcFormat, nSrcStep, nXSrc, nYSrc,
	                                     palette, flags);
}
","1. UINT32 nYDst, UINT32 nWidth, UINT32 nHeight, const BYTE* pSrcData,
2. const UINT32 srcByte = FreeRDPGetBytesPerPixel(SrcFormat);
3. nSrcStep = nWidth * FreeRDPGetBytesPerPixel(SrcFormat);
4. const BOOL ovl = overlapping(pDstData, nXDst, nYDst, nDstStep, dstByte, pSrcData, nXSrc, nYSrc,
nSrcStep, srcByte, nWidth, nHeight);","9
14
29
31-32","CWE-476,CWE-190,CWE-200,CWE-119"
ffs_user_copy_worker,"static void ffs_user_copy_worker(struct work_struct *work)
{
	struct ffs_io_data *io_data = container_of(work, struct ffs_io_data,
 						   work);
 	int ret = io_data->req->status ? io_data->req->status :
 					 io_data->req->actual;
	bool kiocb_has_eventfd = io_data->kiocb->ki_flags & IOCB_EVENTFD;
 
 	if (io_data->read && ret > 0) {
 		use_mm(io_data->mm);
		ret = copy_to_iter(io_data->buf, ret, &io_data->data);
		if (iov_iter_count(&io_data->data))
			ret = -EFAULT;
		unuse_mm(io_data->mm);
	}
 
 	io_data->kiocb->ki_complete(io_data->kiocb, ret, ret);
 
	if (io_data->ffs->ffs_eventfd && !kiocb_has_eventfd)
 		eventfd_signal(io_data->ffs->ffs_eventfd, 1);
 
 	usb_ep_free_request(io_data->ep, io_data->req);
 
 	if (io_data->read)
 		kfree(io_data->to_free);
 	kfree(io_data->buf);
	kfree(io_data);
}
","1. static void ffs_user_copy_worker(struct work_struct *work)
2. bool kiocb_has_eventfd = io_data->kiocb->ki_flags & IOCB_EVENTFD;
3. if (io_data->read && ret > 0) {
4. ret = -EFAULT;
5. if (io_data->ffs->ffs_eventfd && !kiocb_has_eventfd)
eventfd_signal(io_data->ffs->ffs_eventfd, 1);
6. usb_ep_free_request(io_data->ep, io_data->req);
7. kfree(io_data->to_free);
kfree(io_data->buf);","1
7
9
13
19-20
22
25-26","CWE-20,CWE-59,CWE-399,CWE-416"
dns_add_rr_nested_end-235975211649350,"int dns_add_rr_nested_end(struct dns_rr_nested *rr_nested, dns_type_t rtype)
{
	if (rr_nested == NULL || rr_nested->rr_start == NULL) {
		return -1;
	}

	int len = rr_nested->context.ptr - rr_nested->rr_start;
	unsigned char *ptr = rr_nested->rr_len_ptr;
	if (ptr == NULL || _dns_left_len(&rr_nested->context) < 2) {
		return -1;
	}

	
	if (len <= 14) {
		rr_nested->context.ptr = rr_nested->rr_start;
		return 0;
	}

	_dns_write_short(&ptr, len - rr_nested->rr_head_len);

	return _dns_rr_add_end(rr_nested->context.packet, rr_nested->type, rtype, len);
}
","1. int dns_add_rr_nested_end(struct dns_rr_nested *rr_nested, dns_type_t rtype)
2. if (rr_nested == NULL || rr_nested->rr_start == NULL) {
return -1;
3. if (ptr == NULL || _dns_left_len(&rr_nested->context) < 2) {
return -1;
4. if (len <= 14) {
5. _dns_write_short(&ptr, len - rr_nested->rr_head_len);
6. return _dns_rr_add_end(rr_nested->context.packet, rr_nested->type, rtype, len);","1
3-4
9-10
14
19
21","CWE-20,CWE-284,CWE-120,CWE-787,CWE-125"
snmp_api_set_time_ticks-146175496467400,"void
snmp_api_set_time_ticks(snmp_varbind_t *varbind, snmp_oid_t *oid, uint32_t integer)
{
  memcpy(&varbind->oid, oid, sizeof(snmp_oid_t));
  varbind->value_type = BER_DATA_TYPE_TIMETICKS;
  varbind->value.integer = integer;
}
","1. void
snmp_api_set_time_ticks(snmp_varbind_t *varbind, snmp_oid_t *oid, uint32_t integer)
2. memcpy(&varbind->oid, oid, sizeof(snmp_oid_t));
varbind->value_type = BER_DATA_TYPE_TIMETICKS;
varbind->value.integer = integer;","1-2
4-6",CWE-125
parse_input,"static void parse_input(h2o_http2_conn_t *conn)
static int parse_input(h2o_http2_conn_t *conn)
 {
     size_t http2_max_concurrent_requests_per_connection = conn->super.ctx->globalconf->http2.max_concurrent_requests_per_connection;
     int perform_early_exit = 0;

    if (conn->num_streams.pull.half_closed + conn->num_streams.push.half_closed != http2_max_concurrent_requests_per_connection)
        perform_early_exit = 1;

    
    while (conn->state < H2O_HTTP2_CONN_STATE_IS_CLOSING && conn->sock->input->size != 0) {
        if (perform_early_exit == 1 &&
            conn->num_streams.pull.half_closed + conn->num_streams.push.half_closed == http2_max_concurrent_requests_per_connection)
            goto EarlyExit;
        
        const char *err_desc = NULL;
        ssize_t ret = conn->_read_expect(conn, (uint8_t *)conn->sock->input->bytes, conn->sock->input->size, &err_desc);
        if (ret == H2O_HTTP2_ERROR_INCOMPLETE) {
            break;
        } else if (ret < 0) {
            if (ret != H2O_HTTP2_ERROR_PROTOCOL_CLOSE_IMMEDIATELY) {
                 enqueue_goaway(conn, (int)ret,
                                err_desc != NULL ? (h2o_iovec_t){(char *)err_desc, strlen(err_desc)} : (h2o_iovec_t){});
             }
            return close_connection(conn);
         }
         
         h2o_buffer_consume(&conn->sock->input, ret);
     }
 
     if (!h2o_socket_is_reading(conn->sock))
         h2o_socket_read_start(conn->sock, on_read);
    return 0;
 
 EarlyExit:
     if (h2o_socket_is_reading(conn->sock))
         h2o_socket_read_stop(conn->sock);
    return 0;
 }
","1. conn->num_streams.pull.half_closed + conn->num_streams.push.half_closed == http2_max_concurrent_requests_per_connection)
2. if (ret == H2O_HTTP2_ERROR_INCOMPLETE) {
3. h2o_buffer_consume(&conn->sock->input, ret);
4. if (!h2o_socket_is_reading(conn->sock))
h2o_socket_read_start(conn->sock, on_read);
5. return 0;","13
18
28
31-32
38","CWE-284,CWE-264,CWE-416,CWE-326,CWE-200"
tar_directory_for_file,"
#define GsfInfileTar

tar_directory_for_file (GsfInfileTar *dir, const char *name, gboolean last)
{
	const char *s = name;

	while (1) {
		const char *s0 = s;
		char *dirname;

		
		while (1) {
			if (*s == 0) {
				if (last && s != s0)
					break;
				else
					return dir;
			}
			
			if (*s == '/')
				break;
			s++;
		}

		dirname = g_strndup (s0, s - s0);
		while (*s == '/')
			s++;

		if (strcmp (dirname, ""."") != 0) {
			GsfInput *subdir =
 				gsf_infile_child_by_name (GSF_INFILE (dir),
 							  dirname);
 			if (subdir) {
				dir = GSF_IS_INFILE_TAR (subdir)
					? GSF_INFILE_TAR (subdir)
					: dir;
 				
 				g_object_unref (subdir);
 			} else
 				dir = tar_create_dir (dir, dirname);
 		}

		g_free (dirname);
	}
}
","1. tar_directory_for_file (GsfInfileTar *dir, const char *name, gboolean last)
2. while (1) {
3. if (last && s != s0)
4. return dir;
5. break;
s++;
6. dirname = g_strndup (s0, s - s0);
7. s++;
8. GsfInput *subdir =
9. g_free (dirname);","4
13
15
18
22-23
26
28
31
44","CWE-476,CWE-362,CWE-17,CWE-119"
mrled-222477842854572,"
#define RESTRICT

static int mrled(u8 * RESTRICT in, u8 * RESTRICT out, s32 outlen, s32 maxin) {
    s32 op = 0, ip = 0;

    s32 c, pc = -1;
    s32 t[256] = { 0 };
    s32 run = 0;

    if(maxin < 32)
        return 1;

    for (s32 i = 0; i < 32; ++i) {
        c = in[ip++];
        for (s32 j = 0; j < 8; ++j) t[i * 8 + j] = (c >> j) & 1;
    }

    while (op < outlen && ip < maxin) {
        c = in[ip++];
        if (t[c]) {
            for (run = 0; (pc = in[ip++]) == 255 && ip < maxin; run += 255)
                ;
            run += pc + 1;
            for (; run > 0 && op < outlen; --run) out[op++] = c;
        } else
            out[op++] = c;
    }

    return op != outlen;
}
","1. s32 c, pc = -1;
s32 t[256] = { 0 };
2. if(maxin < 32)
return 1;
3. for (s32 i = 0; i < 32; ++i) {
4. c = in[ip++];
if (t[c]) {
5. for (; run > 0 && op < outlen; --run) out[op++] = c;","7-8
11-12
14
20-21
25","CWE-20,CWE-264,CWE-787,CWE-119"
set_content_type-176506323275201,"
#define HttpResponse

void set_content_type(HttpResponse res, const char *mime) {
        set_header(res, ""Content-Type"", ""%s"", mime);
}
","1. void set_content_type(HttpResponse res, const char *mime) {",4,"CWE-119,CWE-264,CWE-189,CWE-416"
llc_conn_handler-152559195262090,"void llc_conn_handler(struct llc_sap *sap, struct sk_buff *skb)
{
	struct llc_addr saddr, daddr;
	struct sock *sk;

	llc_pdu_decode_sa(skb, saddr.mac);
	llc_pdu_decode_ssap(skb, &saddr.lsap);
	llc_pdu_decode_da(skb, daddr.mac);
	llc_pdu_decode_dsap(skb, &daddr.lsap);

	sk = __llc_lookup(sap, &saddr, &daddr);
	if (!sk)
		goto drop;

	bh_lock_sock(sk);
	
	if (unlikely(sk->sk_state == TCP_LISTEN)) {
		struct sock *newsk = llc_create_incoming_sock(sk, skb->dev,
							      &saddr, &daddr);
		if (!newsk)
			goto drop_unlock;
		skb_set_owner_r(skb, newsk);
	} else {
		
		skb_orphan(skb);
		sock_hold(sk);
		skb->sk = sk;
		skb->destructor = sock_efree;
	}
	if (!sock_owned_by_user(sk))
		llc_conn_rcv(sk, skb);
	else {
		dprintk(""%s: adding to backlog...\n"", __func__);
		llc_set_backlog_type(skb, LLC_PACKET);
		if (sk_add_backlog(sk, skb, sk->sk_rcvbuf))
			goto drop_unlock;
	}
out:
	bh_unlock_sock(sk);
	sock_put(sk);
	return;
drop:
	kfree_skb(skb);
	return;
drop_unlock:
	kfree_skb(skb);
	goto out;
}
","1. llc_pdu_decode_ssap(skb, &saddr.lsap);
2. skb_orphan(skb);
3. else {
4. kfree_skb(skb);","7
38
45
56","CWE-476,CWE-276,CWE-264,CWE-119"
bn_smb_jac-155785168689142,"int bn_smb_jac(const bn_t a, const bn_t b) {
	bn_t t0, t1, r;
	int t, h, res;

	bn_null(t0);
	bn_null(t1);
	bn_null(r);

	
	if (bn_is_even(b) || bn_sign(b) == RLC_NEG) {
		RLC_THROW(ERR_NO_VALID);
		return 0;
	}

	RLC_TRY {
		bn_new(t0);
		bn_new(t1);
		bn_new(r);
		t = 1;

		if (bn_sign(a) == RLC_NEG) {
			bn_add(t0, a, b);
		} else {
			bn_copy(t0, a);
		}
		bn_copy(t1, b);

		while (1) {
			
			bn_mod(t0, t0, t1);
			
			if (bn_is_zero(t0)) {
				if (bn_cmp_dig(t1, 1) == RLC_EQ) {
					res = 1;
					if (t == -1) {
						res = -1;
					}
					break;
				} else {
					res = 0;
					break;
				}
			}
			
			h = 0;
			while (bn_is_even(t0) && !bn_is_zero(t0)) {
				h++;
				bn_rsh(t0, t0, 1);
			}
			
			bn_mod_2b(r, t1, 3);
			if ((h % 2 != 0) && (bn_cmp_dig(r, 1) != RLC_EQ) &&
					(bn_cmp_dig(r, 7) != RLC_EQ)) {
				t = -t;
			}
			
			bn_mod_2b(r, t0, 2);
			if (bn_cmp_dig(r, 1) != RLC_EQ) {
				bn_mod_2b(r, t1, 2);
				if (bn_cmp_dig(r, 1) != RLC_EQ) {
					t = -t;
				}
			}
			bn_copy(r, t0);
			bn_copy(t0, t1);
			bn_copy(t1, r);
		}
	}
	RLC_CATCH_ANY {
		RLC_THROW(ERR_CAUGHT);
	}
	RLC_FINALLY {
		bn_free(t0);
		bn_free(t1);
		bn_free(r);
	}

	return res;
}
","1. int bn_smb_jac(const bn_t a, const bn_t b) {
bn_t t0, t1, r;
2. bn_null(t0);
3. bn_new(t1);
4. t = 1;
5. while (1) {
6. bn_mod(t0, t0, t1);
7. break;
8. res = 0;
break;
9. bn_mod_2b(r, t1, 3);
10. t = -t;
11. bn_mod_2b(r, t0, 2);
12. bn_mod_2b(r, t1, 2);
13. RLC_CATCH_ANY {
RLC_THROW(ERR_CAUGHT);
14. bn_free(t0);","1-2
5
17
19
28
30
38
40-41
51
54
57
59
69-70
73",CWE-190
change_indent-7751036571726,"    void
change_indent(
    int		type,
    int		amount,
    int		round,
    int		replaced,	
    int		call_changed_bytes)	
{
    int		vcol;
    int		last_vcol;
    int		insstart_less;		
    int		new_cursor_col;
    int		i;
    char_u	*ptr;
    int		save_p_list;
    int		start_col;
    colnr_T	vc;
    colnr_T	orig_col = 0;		
    char_u	*new_line, *orig_line = NULL;	

    
    if (State & VREPLACE_FLAG)
    {
	orig_line = vim_strsave(ml_get_curline());  
	orig_col = curwin->w_cursor.col;
    }

    
    save_p_list = curwin->w_p_list;
    curwin->w_p_list = FALSE;
    vc = getvcol_nolist(&curwin->w_cursor);
    vcol = vc;

    
    
    
    start_col = curwin->w_cursor.col;

    
    new_cursor_col = curwin->w_cursor.col;
    beginline(BL_WHITE);
    new_cursor_col -= curwin->w_cursor.col;

    insstart_less = curwin->w_cursor.col;

    
    
    if (new_cursor_col < 0)
	vcol = get_indent() - vcol;

    if (new_cursor_col > 0)	    
	start_col = -1;

    
    if (type == INDENT_SET)
	(void)set_indent(amount, call_changed_bytes ? SIN_CHANGED : 0);
    else
    {
	int	save_State = State;

	
	if (State & VREPLACE_FLAG)
	    State = INSERT;
	shift_line(type == INDENT_DEC, round, 1, call_changed_bytes);
	State = save_State;
    }
    insstart_less -= curwin->w_cursor.col;

    
    
    
    
    
    
    
    if (new_cursor_col >= 0)
    {
	
	
	if (new_cursor_col == 0)
	    insstart_less = MAXCOL;
	new_cursor_col += curwin->w_cursor.col;
    }
    else if (!(State & INSERT))
	new_cursor_col = curwin->w_cursor.col;
    else
    {
	
	vcol = get_indent() - vcol;
	curwin->w_virtcol = (colnr_T)((vcol < 0) ? 0 : vcol);

	
	vcol = last_vcol = 0;
	new_cursor_col = -1;
	ptr = ml_get_curline();
	while (vcol <= (int)curwin->w_virtcol)
	{
	    last_vcol = vcol;
	    if (has_mbyte && new_cursor_col >= 0)
		new_cursor_col += (*mb_ptr2len)(ptr + new_cursor_col);
	    else
		++new_cursor_col;
	    if (ptr[new_cursor_col] == NUL)
		break;
	    vcol += lbr_chartabsize(ptr, ptr + new_cursor_col, (colnr_T)vcol);
	}
	vcol = last_vcol;

	
	
	if (vcol != (int)curwin->w_virtcol)
	{
	    curwin->w_cursor.col = (colnr_T)new_cursor_col;
	    i = (int)curwin->w_virtcol - vcol;
	    ptr = alloc(i + 1);
	    if (ptr != NULL)
	    {
		new_cursor_col += i;
		ptr[i] = NUL;
		while (--i >= 0)
		    ptr[i] = ' ';
		ins_str(ptr);
		vim_free(ptr);
	    }
	}

	
	
	insstart_less = MAXCOL;
    }

    curwin->w_p_list = save_p_list;

    if (new_cursor_col <= 0)
	curwin->w_cursor.col = 0;
    else
	curwin->w_cursor.col = (colnr_T)new_cursor_col;
    curwin->w_set_curswant = TRUE;
    changed_cline_bef_curs();

    
    if (State & INSERT)
    {
	if (curwin->w_cursor.lnum == Insstart.lnum && Insstart.col != 0)
	{
	    if ((int)Insstart.col <= insstart_less)
		Insstart.col = 0;
	    else
		Insstart.col -= insstart_less;
	}
	if ((int)ai_col <= insstart_less)
	    ai_col = 0;
	else
	    ai_col -= insstart_less;
    }

    
    
    
    
    
    if (REPLACE_NORMAL(State) && start_col >= 0)
    {
	while (start_col > (int)curwin->w_cursor.col)
	{
	    replace_join(0);	    
	    --start_col;
	}
	while (start_col < (int)curwin->w_cursor.col || replaced)
	{
	    replace_push(NUL);
	    if (replaced)
	    {
		replace_push(replaced);
		replaced = NUL;
	    }
	    ++start_col;
	}
    }

    
    
    
    if (State & VREPLACE_FLAG)
    {
	
	
	if (orig_line == NULL)
	    return;

	
	new_line = vim_strsave(ml_get_curline());
	if (new_line == NULL)
	    return;

	
	new_line[curwin->w_cursor.col] = NUL;

	
	ml_replace(curwin->w_cursor.lnum, orig_line, FALSE);
	curwin->w_cursor.col = orig_col;

	
	backspace_until_column(0);

	
	ins_bytes(new_line);

	vim_free(new_line);
    }
}
","1. void
2. if ((int)ai_col <= insstart_less)
3. if (State & VREPLACE_FLAG)","1
151
184","CWE-1284,CWE-17,CWE-787,CWE-119"
jbd2_journal_wait_updates-223624603225714,"void jbd2_journal_wait_updates(journal_t *journal)
{
	DEFINE_WAIT(wait);

	while (1) {
		
		transaction_t *transaction = journal->j_running_transaction;

		if (!transaction)
			break;

		spin_lock(&transaction->t_handle_lock);
		prepare_to_wait(&journal->j_wait_updates, &wait,
				TASK_UNINTERRUPTIBLE);
		if (!atomic_read(&transaction->t_updates)) {
			spin_unlock(&transaction->t_handle_lock);
			finish_wait(&journal->j_wait_updates, &wait);
			break;
		}
		spin_unlock(&transaction->t_handle_lock);
		write_unlock(&journal->j_state_lock);
		schedule();
		finish_wait(&journal->j_wait_updates, &wait);
		write_lock(&journal->j_state_lock);
	}
}
","1. if (!transaction)
break;
2. TASK_UNINTERRUPTIBLE);
3. finish_wait(&journal->j_wait_updates, &wait);
break;
4. finish_wait(&journal->j_wait_updates, &wait);
write_lock(&journal->j_state_lock);","18-19
23
26-27
32-33","CWE-362,CWE-200,CWE-287"
record_recent_object-62075068869299,"static void record_recent_object(struct object *obj,
				 const char *name,
				 void *data)
{
	sha1_array_append(&recent_objects, obj->oid.hash);
}
","1. static void record_recent_object(struct object *obj,
const char *name,",1-2,"CWE-310,CWE-284,CWE-200,CWE-119,CWE-18"
kill_something_info,"static int kill_something_info(int sig, struct siginfo *info, pid_t pid)
{
	int ret;

	if (pid > 0) {
		rcu_read_lock();
		ret = kill_pid_info(sig, info, find_vpid(pid));
		rcu_read_unlock();
 		return ret;
 	}
 
	
	if (pid == INT_MIN)
		return -ESRCH;

 	read_lock(&tasklist_lock);
 	if (pid != -1) {
 		ret = __kill_pgrp_info(sig, info,
				pid ? find_vpid(-pid) : task_pgrp(current));
	} else {
		int retval = 0, count = 0;
		struct task_struct * p;

		for_each_process(p) {
			if (task_pid_vnr(p) > 1 &&
					!same_thread_group(p, current)) {
				int err = group_send_sig_info(sig, info, p);
				++count;
				if (err != -EPERM)
					retval = err;
			}
		}
		ret = count ? retval : -ESRCH;
	}
	read_unlock(&tasklist_lock);

	return ret;
}
","1. static int kill_something_info(int sig, struct siginfo *info, pid_t pid)
2. int ret;
3. ret = kill_pid_info(sig, info, find_vpid(pid));
4. return ret;
5. read_lock(&tasklist_lock);
6. ret = __kill_pgrp_info(sig, info,
pid ? find_vpid(-pid) : task_pgrp(current));
7. if (task_pid_vnr(p) > 1 &&
!same_thread_group(p, current)) {","1
3
7
9
16
18-19
25-26","CWE-119,CWE-369,CWE-189"
__mongo_set_error-3653417856818,"MONGO_EXPORT void __mongo_set_error( mongo *conn, mongo_error_t err, const char *str,
                                     int errcode ) {
    size_t errstr_size, str_size;

    conn->err = err;
    conn->errcode = errcode;

    if( str ) {
        str_size = strlen( str ) + 1;
        errstr_size = str_size > MONGO_ERR_LEN ? MONGO_ERR_LEN : str_size;
        memcpy( conn->errstr, str, errstr_size );
        conn->errstr[errstr_size-1] = '\0';
    }
}
","1. size_t errstr_size, str_size;
2. conn->errcode = errcode;
3. str_size = strlen( str ) + 1;
4. memcpy( conn->errstr, str, errstr_size );
conn->errstr[errstr_size-1] = '\0';","3
6
9
11-12",CWE-125
runSetUp,"
#define PreloadState
#define ReferrerPolicy
#define ViewportState

    void runSetUp(ViewportState viewportState, PreloadState preloadState = PreloadEnabled)
    void runSetUp(ViewportState viewportState, PreloadState preloadState = PreloadEnabled, ReferrerPolicy documentReferrerPolicy = ReferrerPolicyDefault)
     {
         HTMLParserOptions options(&m_dummyPageHolder->document());
         KURL documentURL(ParsedURLString, ""http:
         m_dummyPageHolder->document().settings()->setViewportEnabled(viewportState == ViewportEnabled);
         m_dummyPageHolder->document().settings()->setViewportMetaEnabled(viewportState == ViewportEnabled);
         m_dummyPageHolder->document().settings()->setDoHtmlPreloadScanning(preloadState == PreloadEnabled);
        m_dummyPageHolder->document().setReferrerPolicy(documentReferrerPolicy);
         m_scanner = HTMLPreloadScanner::create(options, documentURL, CachedDocumentParameters::create(&m_dummyPageHolder->document()), createMediaValuesData());
     }
","1. void runSetUp(ViewportState viewportState, PreloadState preloadState = PreloadEnabled, ReferrerPolicy documentReferrerPolicy = ReferrerPolicyDefault)
2. m_dummyPageHolder->document().settings()->setViewportMetaEnabled(viewportState == ViewportEnabled);
m_dummyPageHolder->document().settings()->setDoHtmlPreloadScanning(preloadState == PreloadEnabled);
3. m_scanner = HTMLPreloadScanner::create(options, documentURL, CachedDocumentParameters::create(&m_dummyPageHolder->document()), createMediaValuesData());","7
12-13
15","CWE-310,CWE-120,CWE-326,CWE-190,CWE-59"
kadm5_randkey_principal_3-180264027872769,"kadm5_ret_t
kadm5_randkey_principal_3(void *server_handle,
                          krb5_principal principal,
                          krb5_boolean keepold,
                          int n_ks_tuple, krb5_key_salt_tuple *ks_tuple,
                          krb5_keyblock **keyblocks,
                          int *n_keys)
{
    krb5_db_entry               *kdb;
    osa_princ_ent_rec           adb;
    krb5_int32                  now;
    kadm5_policy_ent_rec        pol;
    int                         ret, last_pwd, n_new_keys;
    krb5_boolean                have_pol = FALSE;
    kadm5_server_handle_t       handle = server_handle;
    krb5_keyblock               *act_mkey;
    krb5_kvno                   act_kvno;
    int                         new_n_ks_tuple = 0;
    krb5_key_salt_tuple         *new_ks_tuple = NULL;

    if (keyblocks)
        *keyblocks = NULL;

    CHECK_HANDLE(server_handle);

    krb5_clear_error_message(handle->context);

    if (principal == NULL)
        return EINVAL;

    if ((ret = kdb_get_entry(handle, principal, &kdb, &adb)))
        return(ret);

    ret = apply_keysalt_policy(handle, adb.policy, n_ks_tuple, ks_tuple,
                               &new_n_ks_tuple, &new_ks_tuple);
    if (ret)
        goto done;

    if (krb5_principal_compare(handle->context, principal, hist_princ)) {
        
        if (keepold)
            return KADM5_PROTECT_PRINCIPAL;
        new_n_ks_tuple = 1;
    }

    ret = kdb_get_active_mkey(handle, &act_kvno, &act_mkey);
    if (ret)
        goto done;

    ret = krb5_dbe_crk(handle->context, act_mkey, new_ks_tuple, new_n_ks_tuple,
                       keepold, kdb);
    if (ret)
        goto done;

    ret = krb5_dbe_update_mkvno(handle->context, kdb, act_kvno);
    if (ret)
        goto done;

    kdb->attributes &= ~KRB5_KDB_REQUIRES_PWCHANGE;

    ret = krb5_timeofday(handle->context, &now);
    if (ret)
        goto done;

    if ((adb.aux_attributes & KADM5_POLICY)) {
        ret = get_policy(handle, adb.policy, &pol, &have_pol);
        if (ret)
            goto done;
    }
    if (have_pol) {
        ret = krb5_dbe_lookup_last_pwd_change(handle->context, kdb, &last_pwd);
        if (ret)
            goto done;

#if 0
        
        if((now - last_pwd) < pol.pw_min_life &&
           !(kdb->attributes & KRB5_KDB_REQUIRES_PWCHANGE)) {
            ret = KADM5_PASS_TOOSOON;
            goto done;
        }
#endif

        if (pol.pw_max_life)
            kdb->pw_expiration = now + pol.pw_max_life;
        else
            kdb->pw_expiration = 0;
    } else {
        kdb->pw_expiration = 0;
    }

    ret = krb5_dbe_update_last_pwd_change(handle->context, kdb, now);
    if (ret)
        goto done;

    
    kdb->fail_auth_count = 0;

    if (keyblocks) {
        
        n_new_keys = count_new_keys(kdb->n_key_data, kdb->key_data);
        ret = decrypt_key_data(handle->context, n_new_keys, kdb->key_data,
                               keyblocks, n_keys);
        if (ret)
            goto done;
    }

    
    kdb->mask = KADM5_KEY_DATA | KADM5_FAIL_AUTH_COUNT;
    ;

    ret = k5_kadm5_hook_chpass(handle->context, handle->hook_handles,
                               KADM5_HOOK_STAGE_PRECOMMIT, principal, keepold,
                               new_n_ks_tuple, new_ks_tuple, NULL);
    if (ret)
        goto done;
    if ((ret = kdb_put_entry(handle, kdb, &adb)))
        goto done;

    (void) k5_kadm5_hook_chpass(handle->context, handle->hook_handles,
                                KADM5_HOOK_STAGE_POSTCOMMIT, principal,
                                keepold, new_n_ks_tuple, new_ks_tuple, NULL);
    ret = KADM5_OK;
done:
    free(new_ks_tuple);
    kdb_free_entry(handle, kdb, &adb);
    if (have_pol)
        kadm5_free_policy_ent(handle->lhandle, &pol);

    return ret;
}
","1. krb5_keyblock **keyblocks,
2. kadm5_policy_ent_rec        pol;
3. CHECK_HANDLE(server_handle);
4. if (principal == NULL)
return EINVAL;
5. goto done;
6. if (ret)
7. ret = get_policy(handle, adb.policy, &pol, &have_pol);
8. ret = krb5_dbe_lookup_last_pwd_change(handle->context, kdb, &last_pwd);
if (ret)
9. if (pol.pw_max_life)
kdb->pw_expiration = now + pol.pw_max_life;
10. goto done;
11. keyblocks, n_keys);
12. (void) k5_kadm5_hook_chpass(handle->context, handle->hook_handles,
13. keepold, new_n_ks_tuple, new_ks_tuple, NULL);","6
12
24
28-29
37
63
67
72-73
90-91
100
109
126
128","CWE-255,CWE-476,CWE-119"
do_adjtimex-104326421306973,"int do_adjtimex(struct timex *txc)
{
	long mtemp, save_adjust;
	s64 freq_adj;
	int result;

	
	if (txc->modes && !capable(CAP_SYS_TIME))
		return -EPERM;

	

	if ((txc->modes & ADJ_OFFSET_SINGLESHOT) == ADJ_OFFSET_SINGLESHOT) {
	  
		if (txc->modes != ADJ_OFFSET_SINGLESHOT &&
					txc->modes != ADJ_OFFSET_SS_READ)
			return -EINVAL;
	}

	if (txc->modes != ADJ_OFFSET_SINGLESHOT && (txc->modes & ADJ_OFFSET))
	  
		if (txc->offset <= - MAXPHASE || txc->offset >= MAXPHASE )
			return -EINVAL;

	
	if (txc->modes & ADJ_TICK)
		if (txc->tick <  900000/USER_HZ ||
		    txc->tick > 1100000/USER_HZ)
			return -EINVAL;

	write_seqlock_irq(&xtime_lock);
	result = time_state;	

	
	save_adjust = time_adjust;

#if 0	
	time_status &= ~STA_CLOCKERR;		
#endif
	
	if (txc->modes)
	{
	    if (txc->modes & ADJ_STATUS)	
		time_status =  (txc->status & ~STA_RONLY) |
			      (time_status & STA_RONLY);

	    if (txc->modes & ADJ_FREQUENCY) {	
		if (txc->freq > MAXFREQ || txc->freq < -MAXFREQ) {
		    result = -EINVAL;
		    goto leave;
		}
		time_freq = ((s64)txc->freq * NSEC_PER_USEC)
				>> (SHIFT_USEC - SHIFT_NSEC);
	    }

	    if (txc->modes & ADJ_MAXERROR) {
		if (txc->maxerror < 0 || txc->maxerror >= NTP_PHASE_LIMIT) {
		    result = -EINVAL;
		    goto leave;
		}
		time_maxerror = txc->maxerror;
	    }

	    if (txc->modes & ADJ_ESTERROR) {
		if (txc->esterror < 0 || txc->esterror >= NTP_PHASE_LIMIT) {
		    result = -EINVAL;
		    goto leave;
		}
		time_esterror = txc->esterror;
	    }

	    if (txc->modes & ADJ_TIMECONST) {	
		if (txc->constant < 0) {	
		    result = -EINVAL;
		    goto leave;
		}
		time_constant = min(txc->constant + 4, (long)MAXTC);
	    }

	    if (txc->modes & ADJ_OFFSET) {	
		if (txc->modes == ADJ_OFFSET_SINGLESHOT) {
		    
		    time_adjust = txc->offset;
		}
		else if (time_status & STA_PLL) {
		    time_offset = txc->offset * NSEC_PER_USEC;

		    
		    time_offset = min(time_offset, (s64)MAXPHASE * NSEC_PER_USEC);
		    time_offset = max(time_offset, (s64)-MAXPHASE * NSEC_PER_USEC);

		    

		    if (time_status & STA_FREQHOLD || time_reftime == 0)
		        time_reftime = xtime.tv_sec;
		    mtemp = xtime.tv_sec - time_reftime;
		    time_reftime = xtime.tv_sec;

		    freq_adj = time_offset * mtemp;
		    freq_adj = shift_right(freq_adj, time_constant * 2 +
					   (SHIFT_PLL + 2) * 2 - SHIFT_NSEC);
		    if (mtemp >= MINSEC && (time_status & STA_FLL || mtemp > MAXSEC))
			freq_adj += div_s64(time_offset << (SHIFT_NSEC - SHIFT_FLL), mtemp);
		    freq_adj += time_freq;
		    freq_adj = min(freq_adj, (s64)MAXFREQ_NSEC);
		    time_freq = max(freq_adj, (s64)-MAXFREQ_NSEC);
		    time_offset = div_s64(time_offset, NTP_INTERVAL_FREQ);
		    time_offset <<= SHIFT_UPDATE;
		} 
	    } 
	    if (txc->modes & ADJ_TICK)
		tick_usec = txc->tick;

	    if (txc->modes & (ADJ_TICK|ADJ_FREQUENCY|ADJ_OFFSET))
		    ntp_update_frequency();
	} 
leave:	if ((time_status & (STA_UNSYNC|STA_CLOCKERR)) != 0)
		result = TIME_ERROR;

	if ((txc->modes == ADJ_OFFSET_SINGLESHOT) ||
			(txc->modes == ADJ_OFFSET_SS_READ))
		txc->offset = save_adjust;
	else
		txc->offset = ((long)shift_right(time_offset, SHIFT_UPDATE)) *
	    			NTP_INTERVAL_FREQ / 1000;
	txc->freq	   = (time_freq / NSEC_PER_USEC) <<
				(SHIFT_USEC - SHIFT_NSEC);
	txc->maxerror	   = time_maxerror;
	txc->esterror	   = time_esterror;
	txc->status	   = time_status;
	txc->constant	   = time_constant;
	txc->precision	   = 1;
	txc->tolerance	   = MAXFREQ;
	txc->tick	   = tick_usec;

	
	txc->ppsfreq	   = 0;
	txc->jitter	   = 0;
	txc->shift	   = 0;
	txc->stabil	   = 0;
	txc->jitcnt	   = 0;
	txc->calcnt	   = 0;
	txc->errcnt	   = 0;
	txc->stbcnt	   = 0;
	write_sequnlock_irq(&xtime_lock);
	do_gettimeofday(&txc->time);
	notify_cmos_timer();
	return(result);
}
","1. if (txc->modes != ADJ_OFFSET_SINGLESHOT &&
2. if (txc->tick <  900000/USER_HZ ||
3. write_seqlock_irq(&xtime_lock);
result = time_state;
4. save_adjust = time_adjust;
5. if (txc->freq > MAXFREQ || txc->freq < -MAXFREQ) {
6. >> (SHIFT_USEC - SHIFT_NSEC);
7. result = -EINVAL;
8. time_constant = min(txc->constant + 4, (long)MAXTC);
9. if (txc->modes == ADJ_OFFSET_SINGLESHOT) {
10. time_adjust = txc->offset;
11. freq_adj = time_offset * mtemp;
12. if (mtemp >= MINSEC && (time_status & STA_FLL || mtemp > MAXSEC))
freq_adj += div_s64(time_offset << (SHIFT_NSEC - SHIFT_FLL), mtemp);
13. time_offset = div_s64(time_offset, NTP_INTERVAL_FREQ);
14. leave:	if ((time_status & (STA_UNSYNC|STA_CLOCKERR)) != 0)
15. txc->tick	   = tick_usec;
16. txc->jitter	   = 0;
txc->shift	   = 0;
17. txc->errcnt	   = 0;
txc->stbcnt	   = 0;","15
27
31-32
35
48
53
58
77
81
83
106
109-110
114
124
141
145-146
150-151","CWE-119,CWE-20,CWE-125,CWE-189"
ast_for_arguments_3-158645931096085,"static arguments_ty
ast_for_arguments_3(struct compiling *c, const node *n)
{
    
    int i, j, k, nposargs = 0, nkwonlyargs = 0;
    int nposdefaults = 0, found_default = 0;
    asdl_seq *posargs, *posdefaults, *kwonlyargs, *kwdefaults;
    arg_ty vararg = NULL, kwarg = NULL;
    arg_ty arg = NULL;
    node *ch;

    if (TYPE(n) == parameters) {
        if (NCH(n) == 2) 
            return arguments(NULL, NULL, NULL, NULL, NULL, NULL, c->c_arena);
        n = CHILD(n, 1);
    }
    assert(TYPE(n) == typedargslist || TYPE(n) == varargslist);

    
    for (i = 0; i < NCH(n); i++) {
        ch = CHILD(n, i);
        if (TYPE(ch) == STAR) {
            
            i++;
            if (i < NCH(n) && 
                (TYPE(CHILD(n, i)) == tfpdef ||
                 TYPE(CHILD(n, i)) == vfpdef)) {
                i++;
            }
            break;
        }
        if (TYPE(ch) == DOUBLESTAR) break;
        if (TYPE(ch) == vfpdef || TYPE(ch) == tfpdef) nposargs++;
        if (TYPE(ch) == EQUAL) nposdefaults++;
    }
    
    for ( ; i < NCH(n); ++i) {
        ch = CHILD(n, i);
        if (TYPE(ch) == DOUBLESTAR) break;
        if (TYPE(ch) == tfpdef || TYPE(ch) == vfpdef) nkwonlyargs++;
    }
    posargs = (nposargs ? _Ta3_asdl_seq_new(nposargs, c->c_arena) : NULL);
    if (!posargs && nposargs)
        return NULL;
    kwonlyargs = (nkwonlyargs ?
                   _Ta3_asdl_seq_new(nkwonlyargs, c->c_arena) : NULL);
    if (!kwonlyargs && nkwonlyargs)
        return NULL;
    posdefaults = (nposdefaults ?
                    _Ta3_asdl_seq_new(nposdefaults, c->c_arena) : NULL);
    if (!posdefaults && nposdefaults)
        return NULL;
    
    kwdefaults = (nkwonlyargs ?
                   _Ta3_asdl_seq_new(nkwonlyargs, c->c_arena) : NULL);
    if (!kwdefaults && nkwonlyargs)
        return NULL;

    
    i = 0;
    j = 0;  
    k = 0;  
    while (i < NCH(n)) {
        ch = CHILD(n, i);
        switch (TYPE(ch)) {
            case tfpdef:
            case vfpdef:
                
                
                if (i + 1 < NCH(n) && TYPE(CHILD(n, i + 1)) == EQUAL) {
                    expr_ty expression = ast_for_expr(c, CHILD(n, i + 2));
                    if (!expression)
                        return NULL;
                    assert(posdefaults != NULL);
                    asdl_seq_SET(posdefaults, j++, expression);
                    i += 2;
                    found_default = 1;
                }
                else if (found_default) {
                    ast_error(c, n,
                             ""non-default argument follows default argument"");
                    return NULL;
                }
                arg = ast_for_arg(c, ch);
                if (!arg)
                    return NULL;
                asdl_seq_SET(posargs, k++, arg);
                i += 1; 
                if (i < NCH(n) && TYPE(CHILD(n, i)) == COMMA)
                    i += 1; 
                break;
            case STAR:
                if (i+1 >= NCH(n) ||
                    (i+2 == NCH(n) && (TYPE(CHILD(n, i+1)) == COMMA
                                       || TYPE(CHILD(n, i+1)) == TYPE_COMMENT))) {
                    ast_error(c, CHILD(n, i),
                        ""named arguments must follow bare *"");
                    return NULL;
                }
                ch = CHILD(n, i+1);  
                if (TYPE(ch) == COMMA) {
                    int res = 0;
                    i += 2; 

                    if (i < NCH(n) && TYPE(CHILD(n, i)) == TYPE_COMMENT) {
                        ast_error(c, CHILD(n, i),
                                ""bare * has associated type comment"");
                        return NULL;
                    }

                    res = handle_keywordonly_args(c, n, i,
                                                  kwonlyargs, kwdefaults);
                    if (res == -1) return NULL;
                    i = res; 
                }
                else {
                    vararg = ast_for_arg(c, ch);
                    if (!vararg)
                        return NULL;

                    i += 2; 
                    if (i < NCH(n) && TYPE(CHILD(n, i)) == COMMA)
                        i += 1; 

                    if (i < NCH(n) && TYPE(CHILD(n, i)) == TYPE_COMMENT) {
                        vararg->type_comment = NEW_TYPE_COMMENT(CHILD(n, i));
                        if (!vararg->type_comment)
                            return NULL;
                        i += 1;
                    }

                    if (i < NCH(n) && (TYPE(CHILD(n, i)) == tfpdef
                                    || TYPE(CHILD(n, i)) == vfpdef)) {
                        int res = 0;
                        res = handle_keywordonly_args(c, n, i,
                                                      kwonlyargs, kwdefaults);
                        if (res == -1) return NULL;
                        i = res; 
                    }
                }
                break;
            case DOUBLESTAR:
                ch = CHILD(n, i+1);  
                assert(TYPE(ch) == tfpdef || TYPE(ch) == vfpdef);
                kwarg = ast_for_arg(c, ch);
                if (!kwarg)
                    return NULL;
                i += 2; 
                if (i < NCH(n) && TYPE(CHILD(n, i)) == COMMA)
                    i += 1; 
                break;
            case TYPE_COMMENT:
                assert(i);

                if (kwarg)
                    arg = kwarg;

                
                arg->type_comment = NEW_TYPE_COMMENT(ch);
                if (!arg->type_comment)
                    return NULL;
                i += 1;
                break;
            default:
                PyErr_Format(PyExc_SystemError,
                             ""unexpected node in varargslist: %d @ %d"",
                             TYPE(ch), i);
                return NULL;
        }
    }
    return arguments(posargs, vararg, kwonlyargs, kwdefaults, kwarg, posdefaults, c->c_arena);
}
","1. asdl_seq *posargs, *posdefaults, *kwonlyargs, *kwdefaults;
2. if (NCH(n) == 2)
3. posargs = (nposargs ? _Ta3_asdl_seq_new(nposargs, c->c_arena) : NULL);
if (!posargs && nposargs)
4. if (!kwonlyargs && nkwonlyargs)
5. case vfpdef:
6. found_default = 1;
7. asdl_seq_SET(posargs, k++, arg);
8. if (i < NCH(n) && TYPE(CHILD(n, i)) == COMMA)
9. ""bare * has associated type comment"");
return NULL;
10. else {
11. if (i < NCH(n) && TYPE(CHILD(n, i)) == TYPE_COMMENT) {
12. break;
13. i += 2;
14. arg = kwarg;
15. i += 1;
16. PyErr_Format(PyExc_SystemError,","25
31
64-65
69
93
104
114
116
134-135
143
152
168
175
183
189
192","CWE-125,CWE-835"
XdmcpGenerateKey,"
#define XdmAuthKeyPtr

XdmcpGenerateKey (XdmAuthKeyPtr key)
 #ifndef HAVE_ARC4RANDOM_BUF

static void
emulate_getrandom_buf (char *auth, int len)
{
     long    lowbits, highbits;
 
     srandom ((int)getpid() ^ time((Time_t *)0));
    highbits = random ();
     highbits = random ();
     getbits (lowbits, key->data);
     getbits (highbits, key->data + 4);
}

static void
arc4random_buf (void *auth, int len)
{
    int	    ret;

#if HAVE_GETENTROPY
    
    ret = getentropy (auth, len);
    if (ret == 0)
	return;
#endif 

    emulate_getrandom_buf (auth, len);
}

#endif 

void
XdmcpGenerateKey (XdmAuthKeyPtr key)
{
     arc4random_buf(key->data, 8);
 }
","1. void
2. arc4random_buf(key->data, 8);","36
39","CWE-264,CWE-416,CWE-19,CWE-119,CWE-125"
rpmsg_probe-78343870953677,"static int rpmsg_probe(struct virtio_device *vdev)
{
	vq_callback_t *vq_cbs[] = { rpmsg_recv_done, rpmsg_xmit_done };
	static const char * const names[] = { ""input"", ""output"" };
	struct virtqueue *vqs[2];
	struct virtproc_info *vrp;
	struct virtio_rpmsg_channel *vch = NULL;
	struct rpmsg_device *rpdev_ns, *rpdev_ctrl;
	void *bufs_va;
	int err = 0, i;
	size_t total_buf_space;
	bool notify;

	vrp = kzalloc(sizeof(*vrp), GFP_KERNEL);
	if (!vrp)
		return -ENOMEM;

	vrp->vdev = vdev;

	idr_init(&vrp->endpoints);
	mutex_init(&vrp->endpoints_lock);
	mutex_init(&vrp->tx_lock);
	init_waitqueue_head(&vrp->sendq);

	
	err = virtio_find_vqs(vdev, 2, vqs, vq_cbs, names, NULL);
	if (err)
		goto free_vrp;

	vrp->rvq = vqs[0];
	vrp->svq = vqs[1];

	
	WARN_ON(virtqueue_get_vring_size(vrp->rvq) !=
		virtqueue_get_vring_size(vrp->svq));

	
	if (virtqueue_get_vring_size(vrp->rvq) < MAX_RPMSG_NUM_BUFS / 2)
		vrp->num_bufs = virtqueue_get_vring_size(vrp->rvq) * 2;
	else
		vrp->num_bufs = MAX_RPMSG_NUM_BUFS;

	vrp->buf_size = MAX_RPMSG_BUF_SIZE;

	total_buf_space = vrp->num_bufs * vrp->buf_size;

	
	bufs_va = dma_alloc_coherent(vdev->dev.parent,
				     total_buf_space, &vrp->bufs_dma,
				     GFP_KERNEL);
	if (!bufs_va) {
		err = -ENOMEM;
		goto vqs_del;
	}

	dev_dbg(&vdev->dev, ""buffers: va %pK, dma %pad\n"",
		bufs_va, &vrp->bufs_dma);

	
	vrp->rbufs = bufs_va;

	
	vrp->sbufs = bufs_va + total_buf_space / 2;

	
	for (i = 0; i < vrp->num_bufs / 2; i++) {
		struct scatterlist sg;
		void *cpu_addr = vrp->rbufs + i * vrp->buf_size;

		rpmsg_sg_init(&sg, cpu_addr, vrp->buf_size);

		err = virtqueue_add_inbuf(vrp->rvq, &sg, 1, cpu_addr,
					  GFP_KERNEL);
		WARN_ON(err); 
	}

	
	virtqueue_disable_cb(vrp->svq);

	vdev->priv = vrp;

	rpdev_ctrl = rpmsg_virtio_add_ctrl_dev(vdev);
	if (IS_ERR(rpdev_ctrl)) {
		err = PTR_ERR(rpdev_ctrl);
		goto free_coherent;
	}

	
	if (virtio_has_feature(vdev, VIRTIO_RPMSG_F_NS)) {
		vch = kzalloc(sizeof(*vch), GFP_KERNEL);
		if (!vch) {
			err = -ENOMEM;
			goto free_ctrldev;
		}

		
		vch->vrp = vrp;

		
		rpdev_ns = &vch->rpdev;
		rpdev_ns->ops = &virtio_rpmsg_ops;
		rpdev_ns->little_endian = virtio_is_little_endian(vrp->vdev);

		rpdev_ns->dev.parent = &vrp->vdev->dev;
		rpdev_ns->dev.release = virtio_rpmsg_release_device;

		err = rpmsg_ns_register_device(rpdev_ns);
		if (err)
			
			goto free_ctrldev;
	}

	
	notify = virtqueue_kick_prepare(vrp->rvq);

	
	virtio_device_ready(vdev);

	
	
	if (notify)
		virtqueue_notify(vrp->rvq);

	dev_info(&vdev->dev, ""rpmsg host is online\n"");

	return 0;

free_ctrldev:
	rpmsg_virtio_del_ctrl_dev(rpdev_ctrl);
free_coherent:
	dma_free_coherent(vdev->dev.parent, total_buf_space,
			  bufs_va, vrp->bufs_dma);
vqs_del:
	vdev->config->del_vqs(vrp->vdev);
free_vrp:
	kfree(vrp);
	return err;
}
","1. int err = 0, i;
size_t total_buf_space;
2. goto free_vrp;
3. GFP_KERNEL);
4. vrp->rbufs = bufs_va;
5. err = PTR_ERR(rpdev_ctrl);
6. rpdev_ns->little_endian = virtio_is_little_endian(vrp->vdev);
7. goto free_ctrldev;
8. virtqueue_notify(vrp->rvq);
9. rpmsg_virtio_del_ctrl_dev(rpdev_ctrl);
10. vqs_del:
11. kfree(vrp);","10-11
28
50
60
84
102
110
128
135
139
142","CWE-362,CWE-200,CWE-125"
install_permanent_handler-192349376063784,"static int install_permanent_handler(int num_cpus, uintptr_t smbase,
					size_t smsize, size_t save_state_size)
{
	
	struct smm_loader_params smm_params = {
		.per_cpu_stack_size = CONFIG_SMM_MODULE_STACK_SIZE,
		.num_concurrent_stacks = num_cpus,
		.per_cpu_save_state_size = save_state_size,
		.num_concurrent_save_states = num_cpus,
	};

	
	if (mp_state.ops.adjust_smm_params != NULL)
		mp_state.ops.adjust_smm_params(&smm_params, 1);

	printk(BIOS_DEBUG, ""Installing permanent SMM handler to 0x%08lx\n"", smbase);

	if (smm_load_module((void *)smbase, smsize, &smm_params))
		return -1;

	adjust_smm_apic_id_map(&smm_params);

	return 0;
}
","1. static int install_permanent_handler(int num_cpus, uintptr_t smbase,
2. mp_state.ops.adjust_smm_params(&smm_params, 1);
3. printk(BIOS_DEBUG, ""Installing permanent SMM handler to 0x%08lx\n"", smbase);","1
20
22","CWE-476,CWE-190,CWE-119"
TestPlaybackRate_1,"   void TestPlaybackRate_1(double playback_rate) {
    const int kDefaultBufferSize = algorithm_.samples_per_second() / 10;
    const int kDefaultFramesRequested = 2 * algorithm_.samples_per_second();
 
     TestPlaybackRate_1(playback_rate, kDefaultBufferSize,
                      kDefaultFramesRequested);
  }
","1. void TestPlaybackRate_1(double playback_rate) {
const int kDefaultBufferSize = algorithm_.samples_per_second() / 10;
2. TestPlaybackRate_1(playback_rate, kDefaultBufferSize,
kDefaultFramesRequested);","1-2
5-6","CWE-190,CWE-200"
Jsi_ObjArraySizer-174434349805675,"
#define Jsi_Interp
#define Jsi_Obj

int Jsi_ObjArraySizer(Jsi_Interp *interp, Jsi_Obj *obj, uint len)
{
    uint nsiz = len + 1, mod = ALLOC_MOD_SIZE;
    assert(obj->isarrlist);
    if (mod>1)
        nsiz = nsiz + ((mod-1) - (nsiz + mod - 1)%mod);
    if (len >= interp->maxArrayList || nsiz > interp->maxArrayList) {
        Jsi_LogError(""array size too big: %u >= %u"", len, interp->maxArrayList);
        return 0;
    }
    if (len >= obj->arrMaxSize) {
        int oldsz = (nsiz-obj->arrMaxSize);
        obj->arr = (Jsi_Value**)Jsi_Realloc(obj->arr, nsiz*sizeof(Jsi_Value*));
        memset(obj->arr+obj->arrMaxSize, 0, oldsz*sizeof(Jsi_Value*));
        obj->arrMaxSize = nsiz;
    }
    if (len>obj->arrCnt)
        obj->arrCnt = len;
    return nsiz;
}
","1. int Jsi_ObjArraySizer(Jsi_Interp *interp, Jsi_Obj *obj, uint len)
2. uint nsiz = len + 1, mod = ALLOC_MOD_SIZE;
assert(obj->isarrlist);
if (mod>1)
nsiz = nsiz + ((mod-1) - (nsiz + mod - 1)%mod);
3. Jsi_LogError(""array size too big: %u >= %u"", len, interp->maxArrayList);
return 0;
4. obj->arr = (Jsi_Value**)Jsi_Realloc(obj->arr, nsiz*sizeof(Jsi_Value*));
memset(obj->arr+obj->arrMaxSize, 0, oldsz*sizeof(Jsi_Value*));
obj->arrMaxSize = nsiz;
5. if (len>obj->arrCnt)
obj->arrCnt = len;
return nsiz;","5
7-10
12-13
17-19
21-23","CWE-119,CWE-125,CWE-189"
cp_cmlhs_onv-8918569835563,"int cp_cmlhs_onv(const g1_t r, const g2_t s, const g1_t sig[], const g2_t z[],
		const g1_t a[], const g1_t c[], const bn_t msg, const char *data,
		const g1_t h, const gt_t vk, const g2_t y[], const g2_t pk[],
		size_t slen, int bls) {
	g1_t g1;
	g2_t g2;
	gt_t e, u, v;
	bn_t k, n;
	size_t len, dlen = strlen(data);
	uint8_t *buf = RLC_ALLOCA(uint8_t, 1 + 8 * RLC_FP_BYTES + dlen);
	int result = 1;

	g1_null(g1);
	g2_null(g2);
	gt_null(e);
	gt_null(u);
	gt_null(v);
	bn_null(k);
	bn_null(n);

	RLC_TRY {
		g1_new(g1);
		g2_new(g2);
		gt_new(e);
		gt_new(u);
		gt_new(v);
		bn_new(k);
		bn_new(n);
		if (buf == NULL) {
			RLC_THROW(ERR_NO_MEMORY);
		}

		for (int i = 0; i < slen; i++) {
			len = g2_size_bin(z[i], 0);
			g2_write_bin(buf, len, z[i], 0);
			memcpy(buf + len, data, dlen);
			if (bls) {
				result &= cp_bls_ver(sig[i], buf, len + dlen, pk[i]);
			} else {
				fp_prime_back(k, sig[i]->x);
				fp_prime_back(n, sig[i]->y);
				fp_copy(g1->x, pk[i]->x[0]);
				fp_copy(g1->y, pk[i]->y[0]);
				fp_set_dig(g1->z, 1);
				result &= cp_ecdsa_ver(k, n, buf, len + dlen, 0, g1);
			}
		}

		pc_get_ord(n);
		g1_get_gen(g1);
		g2_get_gen(g2);

		pc_map_sim(e, a, z, slen);
		pc_map_sim(u, c, y, slen);
		pc_map(v, r, g2);
		gt_mul(u, u, v);
		gt_mul(u, u, vk);

		if (gt_cmp(e, u) != RLC_EQ) {
			result = 0;
		}

		pc_map(e, g1, s);
		g1_set_infty(g1);
		for (int i = 0; i < slen; i++) {
			g1_add(g1, g1, c[i]);
		}
		g1_norm(g1, g1);
		pc_map(u, g1, g2);
		gt_mul(e, e, u);

		g1_mul(g1, h, msg);
		pc_map(v, g1, g2);
		if (gt_cmp(e, v) != RLC_EQ) {
			result = 0;
		}
	} RLC_CATCH_ANY {
		RLC_THROW(ERR_CAUGHT);
	} RLC_FINALLY {
		g1_free(g1);
		g2_free(g2);
		gt_free(e);
		gt_free(u);
		gt_free(v);
		bn_free(k);
		bn_free(n);
		RLC_FREE(buf);
	}
	return result;
}
","1. size_t slen, int bls) {
g1_t g1;
2. bn_new(k);
3. } else {
4. fp_prime_back(n, sig[i]->y);
fp_copy(g1->x, pk[i]->x[0]);
5. result &= cp_ecdsa_ver(k, n, buf, len + dlen, 0, g1);
6. pc_get_ord(n);
7. g2_get_gen(g2);
8. g1_set_infty(g1);
9. g1_norm(g1, g1);
10. gt_mul(e, e, u);
11. if (gt_cmp(e, v) != RLC_EQ) {
12. gt_free(e);","4-5
27
39
41-42
45
49
51
64
68
70
74
82","CWE-476,CWE-190,CWE-362,CWE-119"
RegisterSwReporterComponent,"
#define ComponentUpdateService

 void RegisterSwReporterComponent(ComponentUpdateService* cus) {
  if (!safe_browsing::IsSwReporterEnabled())
     return;
 
   base::string16 cleaner_key_name(kSoftwareRemovalToolRegistryKey);
  cleaner_key_name.append(1, L'\\').append(kCleanerSuffixRegistryKey);
  base::win::RegKey cleaner_key(
      HKEY_CURRENT_USER, cleaner_key_name.c_str(), KEY_ALL_ACCESS);
  if (cleaner_key.Valid()) {
    if (cleaner_key.HasValue(kStartTimeValueName)) {
      if (cleaner_key.HasValue(kVersionValueName)) {
        DWORD version;
        cleaner_key.ReadValueDW(kVersionValueName, &version);
        UMA_HISTOGRAM_SPARSE_SLOWLY(""SoftwareReporter.Cleaner.Version"",
                                    version);
        cleaner_key.DeleteValue(kVersionValueName);
      }
      int64 start_time_value;
      cleaner_key.ReadInt64(kStartTimeValueName, &start_time_value);

      bool completed = cleaner_key.HasValue(kEndTimeValueName);
      SRTHasCompleted(completed ? SRT_COMPLETED_YES : SRT_COMPLETED_NOT_YET);
      if (completed) {
        int64 end_time_value;
        cleaner_key.ReadInt64(kEndTimeValueName, &end_time_value);
        cleaner_key.DeleteValue(kEndTimeValueName);
        base::TimeDelta run_time(
            base::Time::FromInternalValue(end_time_value) -
            base::Time::FromInternalValue(start_time_value));
        UMA_HISTOGRAM_LONG_TIMES(""SoftwareReporter.Cleaner.RunningTime"",
                                 run_time);
      }
      DWORD exit_code = safe_browsing::kSwReporterNothingFound;
      if (cleaner_key.HasValue(kExitCodeValueName)) {
        cleaner_key.ReadValueDW(kExitCodeValueName, &exit_code);
        UMA_HISTOGRAM_SPARSE_SLOWLY(""SoftwareReporter.Cleaner.ExitCode"",
                                    exit_code);
        cleaner_key.DeleteValue(kExitCodeValueName);
      }
      cleaner_key.DeleteValue(kStartTimeValueName);

      if (exit_code == safe_browsing::kSwReporterPostRebootCleanupNeeded ||
          exit_code ==
              safe_browsing::kSwReporterDelayedPostRebootCleanupNeeded) {
        base::TimeDelta elapsed(
            base::Time::Now() -
            base::Time::FromInternalValue(start_time_value));
        DCHECK_GT(elapsed.InMilliseconds(), 0);
        UMA_HISTOGRAM_BOOLEAN(
            ""SoftwareReporter.Cleaner.HasRebooted"",
            static_cast<uint64>(elapsed.InMilliseconds()) > ::GetTickCount());
      }

      if (cleaner_key.HasValue(kUploadResultsValueName)) {
        base::string16 upload_results;
        cleaner_key.ReadValue(kUploadResultsValueName, &upload_results);
        ReportUploadsWithUma(upload_results);
      }
    } else {
      if (cleaner_key.HasValue(kEndTimeValueName)) {
        SRTHasCompleted(SRT_COMPLETED_LATER);
        cleaner_key.DeleteValue(kEndTimeValueName);
      }
    }
  }
  ReportFoundUwS();

  scoped_ptr<ComponentInstallerTraits> traits(new SwReporterInstallerTraits());
  DefaultComponentInstaller* installer =
      new DefaultComponentInstaller(traits.Pass());
  installer->Register(cus, base::Closure());
}
","1. if (cleaner_key.HasValue(kVersionValueName)) {
2. version);
3. int64 start_time_value;
4. int64 end_time_value;
5. exit_code);
6. SRTHasCompleted(SRT_COMPLETED_LATER);","14
18
21
27
40
64","CWE-200,CWE-20,CWE-787,CWE-284"
r_cons_hud_line_string-145996415541468,"R_API char *r_cons_hud_line_string(const char *s) {
	if (!r_cons_is_interactive ()) {
		R_LOG_ERROR (""Hud mode requires scr.interactive=true"");
		return NULL;
	}
	char *os, *track, *ret, *o = strdup (s);
	if (!o) {
		return NULL;
	}
	r_str_replace_ch (o, '\r', 0, true);
	r_str_replace_ch (o, '\t', 0, true);
	r_str_ansi_strip (o);
	RList *fl = r_list_new ();
	int i;
	if (!fl) {
		free (o);
		return NULL;
	}
	fl->free = free;
	for (os = o, i = 0; o[i]; i++) {
		if (o[i] == '\n') {
			o[i] = 0;
			if (*os && *os != '#') {
				track = strdup (os);
				if (!r_list_append (fl, track)) {
					free (track);
					break;
				}
			}
			os = o + i + 1;
		}
	}
	ret = r_cons_hud_line (fl, NULL);
	free (o);
	r_list_free (fl);
	return ret;
}
","1. R_LOG_ERROR (""Hud mode requires scr.interactive=true"");
2. RList *fl = r_list_new ();
3. free (track);
break;
4. free (o);","3
13
26-27
34","CWE-119,CWE-190,CWE-22,CWE-400"
LiSendMouseMoveEvent-165447584819782,"int LiSendMouseMoveEvent(short deltaX, short deltaY) {
    PPACKET_HOLDER holder;
    int err;

    if (!initialized) {
        return -2;
    }

    holder = malloc(sizeof(*holder));
    if (holder == NULL) {
        return -1;
    }

    holder->packetLength = sizeof(NV_MOUSE_MOVE_PACKET);
    holder->packet.mouseMove.header.packetType = htonl(PACKET_TYPE_MOUSE_MOVE);
    holder->packet.mouseMove.magic = MOUSE_MOVE_MAGIC;
    
    if (AppVersionQuad[0] >= 5) {
        holder->packet.mouseMove.magic++;
    }
    holder->packet.mouseMove.deltaX = htons(deltaX);
    holder->packet.mouseMove.deltaY = htons(deltaY);

    err = LbqOfferQueueItem(&packetQueue, holder, &holder->entry);
    if (err != LBQ_SUCCESS) {
        free(holder);
    }

    return err;
}
","1. int err;
2. if (holder == NULL) {
3. holder->packet.mouseMove.deltaX = htons(deltaX);
holder->packet.mouseMove.deltaY = htons(deltaY);
4. return err;","3
10
21-22
29","CWE-120,CWE-399,CWE-400"
econn_message_encode-206400808260752,"int econn_message_encode(char **strp, const struct econn_message *msg)
{
	struct json_object *jobj = NULL;
	char *str = NULL;
	int err;

	if (!strp || !msg)
		return EINVAL;

	err = jzon_creatf(&jobj, ""sss"",
			  ""version"", econn_proto_version,
			  ""type"",   econn_msg_name(msg->msg_type),
			  ""sessid"", msg->sessid_sender);
	if (err)
		return err;

	if (str_isset(msg->src_userid)) {
		err = jzon_add_str(jobj, ""src_userid"", ""%s"", msg->src_userid);
		if (err)
			goto out;
	}

	if (str_isset(msg->src_clientid)) {
		err = jzon_add_str(jobj, ""src_clientid"",
				   ""%s"", msg->src_clientid);
		if (err)
			goto out;
	}

	if (str_isset(msg->dest_userid)) {
		err = jzon_add_str(jobj, ""dest_userid"",
				   ""%s"", msg->dest_userid);
		if (err)
			goto out;
	}

	if (str_isset(msg->dest_clientid)) {
		err = jzon_add_str(jobj, ""dest_clientid"",
				   ""%s"", msg->dest_clientid);
		if (err)
			goto out;
	}

	err = jzon_add_bool(jobj, ""resp"", msg->resp);
	if (err)
		goto out;

	switch (msg->msg_type) {

	case ECONN_SETUP:
	case ECONN_GROUP_SETUP:
	case ECONN_UPDATE:
		err = jzon_add_str(jobj, ""sdp"", ""%s"", msg->u.setup.sdp_msg);
		if (err)
			goto out;

		
		if (msg->u.setup.props) {
			err = econn_props_encode(jobj, msg->u.setup.props);
			if (err)
				goto out;
		}
		if (msg->u.setup.url) {
			err = jzon_add_str(jobj, ""url"", ""%s"", msg->u.setup.url);
			if (err)
				goto out;
		}
		break;

	case ECONN_CANCEL:
		break;

	case ECONN_HANGUP:
		break;

	case ECONN_REJECT:
		break;

	case ECONN_PROPSYNC:

		
		if (!msg->u.propsync.props) {
			warning(""propsync: missing props\n"");
			err = EINVAL;
			goto out;
		}

		err = econn_props_encode(jobj, msg->u.propsync.props);
		if (err)
			goto out;
		break;

	case ECONN_GROUP_START:
		
		if (msg->u.groupstart.props) {
			err = econn_props_encode(jobj, msg->u.groupstart.props);
			if (err)
				goto out;
		}
		break;

	case ECONN_GROUP_LEAVE:
	case ECONN_GROUP_CHECK:
		break;

	case ECONN_CONF_CONN:
		if (msg->u.confconn.turnc > 0) {
			err = zapi_iceservers_encode(jobj,
						     msg->u.confconn.turnv,
						     msg->u.confconn.turnc);
			if (err)
				goto out;
		}

		jzon_add_bool(jobj, ""update"",
			      msg->u.confconn.update);
		jzon_add_str(jobj, ""tool"", 
			     ""%s"", msg->u.confconn.tool);
		jzon_add_str(jobj, ""toolver"",
			     ""%s"", msg->u.confconn.toolver);
		jzon_add_int(jobj, ""status"",
			      msg->u.confconn.status);
		jzon_add_bool(jobj, ""selective_audio"",
			      msg->u.confconn.selective_audio);
		jzon_add_bool(jobj, ""selective_video"",
			      msg->u.confconn.selective_video);
		jzon_add_int(jobj, ""vstreams"",
			      msg->u.confconn.vstreams);
		break;

	case ECONN_CONF_START:
		jzon_add_str(jobj, ""sft_url"", ""%s"", msg->u.confstart.sft_url);
		jzon_add_base64(jobj, ""secret"",
				msg->u.confstart.secret, msg->u.confstart.secretlen);
		jzon_add_str(jobj, ""timestamp"", ""%llu"", msg->u.confstart.timestamp);
		jzon_add_str(jobj, ""seqno"", ""%u"", msg->u.confstart.seqno);
		
		if (msg->u.confstart.props) {
			err = econn_props_encode(jobj, msg->u.confstart.props);
			if (err)
				goto out;
		}
		break;

	case ECONN_CONF_CHECK:
		jzon_add_str(jobj, ""sft_url"", ""%s"", msg->u.confcheck.sft_url);
		jzon_add_base64(jobj, ""secret"",
				msg->u.confcheck.secret, msg->u.confcheck.secretlen);
		jzon_add_str(jobj, ""timestamp"", ""%llu"", msg->u.confcheck.timestamp);
		jzon_add_str(jobj, ""seqno"", ""%u"", msg->u.confcheck.seqno);
		break;

	case ECONN_CONF_END:
		break;

	case ECONN_CONF_PART:
		jzon_add_bool(jobj, ""should_start"",
			      msg->u.confpart.should_start);
		jzon_add_str(jobj, ""timestamp"", ""%llu"", msg->u.confpart.timestamp);
		jzon_add_str(jobj, ""seqno"", ""%u"", msg->u.confpart.seqno);
		jzon_add_base64(jobj, ""entropy"",
				msg->u.confpart.entropy, msg->u.confpart.entropylen);
		econn_parts_encode(jobj, &msg->u.confpart.partl);
		break;

	case ECONN_CONF_KEY:
		econn_keys_encode(jobj, &msg->u.confkey.keyl);
		break;

	case ECONN_DEVPAIR_PUBLISH:
		err = zapi_iceservers_encode(jobj,
					     msg->u.devpair_publish.turnv,
					     msg->u.devpair_publish.turnc);
		if (err)
			goto out;

		err = jzon_add_str(jobj, ""sdp"",
				   ""%s"", msg->u.devpair_publish.sdp);
		err |= jzon_add_str(jobj, ""username"",
				    ""%s"", msg->u.devpair_publish.username);
		if (err)
			goto out;
		break;

	case ECONN_DEVPAIR_ACCEPT:
		err = jzon_add_str(jobj, ""sdp"",
				   ""%s"", msg->u.devpair_accept.sdp);
		if (err)
			goto out;
		break;

	case ECONN_ALERT:
		err  = jzon_add_int(jobj, ""level"", msg->u.alert.level);
		err |= jzon_add_str(jobj, ""descr"", ""%s"", msg->u.alert.descr);
		if (err)
			goto out;
		break;

	case ECONN_PING:
		break;

	default:
		warning(""econn: dont know how to encode %d\n"", msg->msg_type);
		err = EBADMSG;
		break;
	}
	if (err)
		goto out;

	err = jzon_encode(&str, jobj);
	if (err)
		goto out;

 out:
	mem_deref(jobj);
	if (err)
		mem_deref(str);
	else
		*strp = str;

	return err;
}
","1. int econn_message_encode(char **strp, const struct econn_message *msg)
2. char *str = NULL;
3. err = jzon_creatf(&jobj, ""sss"",
4. if (str_isset(msg->src_userid)) {
err = jzon_add_str(jobj, ""src_userid"", ""%s"", msg->src_userid);
5. err = jzon_add_str(jobj, ""src_clientid"",
6. if (str_isset(msg->dest_userid)) {
7. err = jzon_add_str(jobj, ""dest_clientid"",
8. goto out;
9. case ECONN_PROPSYNC:
10. if (err)
11. if (msg->u.groupstart.props) {
12. case ECONN_GROUP_LEAVE:
13. msg->u.confconn.turnc);
14. jzon_add_str(jobj, ""tool"",
15. jzon_add_int(jobj, ""vstreams"",
16. jzon_add_str(jobj, ""sft_url"", ""%s"", msg->u.confcheck.sft_url);
17. jzon_add_str(jobj, ""seqno"", ""%u"", msg->u.confcheck.seqno);
break;
18. case ECONN_CONF_PART:
19. ""%s"", msg->u.devpair_publish.username);
20. err  = jzon_add_int(jobj, ""level"", msg->u.alert.level);
21. case ECONN_PING:
22. *strp = str;
23. return err;","1
4
10
17-18
24
30
38
46
79
89
95
102
110
117
127
146
150-151
156
180
193
199
219
221","CWE-476,CWE-20"
mem_log_init,"mem_log_init(const char* prog_name, const char *banner)
{
	size_t log_name_len;
	char *log_name;

	if (__test_bit(LOG_CONSOLE_BIT, &debug)) {
		log_op = stderr;
		return;
	}

	if (log_op)
		fclose(log_op);

	log_name_len = 5 + strlen(prog_name) + 5 + 7 + 4 + 1;	
	log_name = malloc(log_name_len);
	if (!log_name) {
		log_message(LOG_INFO, ""Unable to malloc log file name"");
		log_op = stderr;
		return;
 	}
 
 	snprintf(log_name, log_name_len, ""/tmp/%s_mem.%d.log"", prog_name, getpid());
	log_op = fopen_safe(log_name, ""a"");
 	if (log_op == NULL) {
 		log_message(LOG_INFO, ""Unable to open %s for appending"", log_name);
 		log_op = stderr;
	}
	else {
		int fd = fileno(log_op);

		
		fcntl(fd, F_SETFD, fcntl(fd, F_GETFD) | FD_CLOEXEC);

		
		setlinebuf(log_op);

		fprintf(log_op, ""\n"");
	}

	free(log_name);

	terminate_banner = banner;
}
","1. mem_log_init(const char* prog_name, const char *banner)
2. size_t log_name_len;
3. if (__test_bit(LOG_CONSOLE_BIT, &debug)) {
4. if (!log_name) {
log_message(LOG_INFO, ""Unable to malloc log file name"");
log_op = stderr;
return;
5. free(log_name);","1
3
6
16-19
42","CWE-120,CWE-129,CWE-125,CWE-78"
X509_to_X509_REQ,"
#define EVP_MD
#define EVP_PKEY
#define X509

X509_REQ *X509_to_X509_REQ(X509 *x, EVP_PKEY *pkey, const EVP_MD *md)
{
    X509_REQ *ret;
    X509_REQ_INFO *ri;
    int i;
    EVP_PKEY *pktmp;

    ret = X509_REQ_new();
    if (ret == NULL) {
        X509err(X509_F_X509_TO_X509_REQ, ERR_R_MALLOC_FAILURE);
        goto err;
    }

    ri = ret->req_info;

    ri->version->length = 1;
    ri->version->data = (unsigned char *)OPENSSL_malloc(1);
    if (ri->version->data == NULL)
        goto err;
    ri->version->data[0] = 0;   

    if (!X509_REQ_set_subject_name(ret, X509_get_subject_name(x)))
         goto err;
 
     pktmp = X509_get_pubkey(x);
    if (pktmp == NULL)
        goto err;
     i = X509_REQ_set_pubkey(ret, pktmp);
     EVP_PKEY_free(pktmp);
     if (!i)
    if (pkey != NULL) {
        if (!X509_REQ_sign(ret, pkey, md))
            goto err;
    }
    return (ret);
 err:
    X509_REQ_free(ret);
    return (NULL);
}
","1. goto err;
2. goto err;
3. i = X509_REQ_set_pubkey(ret, pktmp);
EVP_PKEY_free(pktmp);
if (!i)
4. goto err;
5. X509_REQ_free(ret);","24
28
33-35
38
42","CWE-17,CWE-200,CWE-400,CWE-119"
http1_on_ready-157054965166437,"static void http1_on_ready(intptr_t uuid, fio_protocol_s *protocol) {
  
  http1pr_s *p = (http1pr_s *)protocol;
  if (p->stop & 4) {
    p->stop ^= 4; 
    fio_force_event(uuid, FIO_EVENT_ON_DATA);
  }
  (void)protocol;
}
","1. static void http1_on_ready(intptr_t uuid, fio_protocol_s *protocol) {
2. (void)protocol;","1
8","CWE-476,CWE-416"
r_bin_wasm_get_global_entries,"
#define RBinWasmObj
#define RBinWasmSection

 static RList *r_bin_wasm_get_global_entries (RBinWasmObj *bin, RBinWasmSection *sec) {
 	RList *ret = NULL;
 	RBinWasmGlobalEntry *ptr = NULL;
 
 	if (!(ret = r_list_newf ((RListFree)free))) {
 		return NULL;
 	}
 
 	ut8* buf = bin->buf->buf + (ut32)sec->payload_data;
	int buflen = bin->buf->length - (ut32)sec->payload_data;
 	ut32 len =  sec->payload_len;
 	ut32 count = sec->count;
 	ut32 i = 0, r = 0;

	while (i < len && len < buflen && r < count) {
		if (!(ptr = R_NEW0 (RBinWasmGlobalEntry))) {
			return ret;
		}

		if (len + 8 > buflen || !(consume_u8 (buf + i, buf + len, (ut8*)&ptr->content_type, &i))) {
			goto beach;
		}
		if (len + 8 > buflen || !(consume_u8 (buf + i, buf + len, &ptr->mutability, &i))) {
			goto beach;
		}
		if (len + 8 > buflen || !(consume_init_expr (buf + i, buf + len, R_BIN_WASM_END_OF_CODE, NULL, &i))) {
			goto beach;
		}
		r_list_append (ret, ptr);
		r++;
	}
	return ret;
beach:
	free (ptr);
	return ret;
 }
","1. if (!(ret = r_list_newf ((RListFree)free))) {
2. ut8* buf = bin->buf->buf + (ut32)sec->payload_data;
3. while (i < len && len < buflen && r < count) {
if (!(ptr = R_NEW0 (RBinWasmGlobalEntry))) {
4. goto beach;
5. goto beach;
6. return ret;
7. free (ptr);","9
13
19-20
25
31
36
38","CWE-617,CWE-362,CWE-125,CWE-189"
mount_entry_on_systemfs," static inline int mount_entry_on_systemfs(struct mntent *mntent)
 {
  return mount_entry_on_generic(mntent, mntent->mnt_dir, NULL);
 }
","1. static inline int mount_entry_on_systemfs(struct mntent *mntent)
2. return mount_entry_on_generic(mntent, mntent->mnt_dir, NULL);","1
3","CWE-667,CWE-476,CWE-200,CWE-59"
jpc_pi_nextrpcl,"static int jpc_pi_nextrpcl(register jpc_pi_t *pi)
{
	int rlvlno;
	jpc_pirlvl_t *pirlvl;
	jpc_pchg_t *pchg;
	int prchind;
	int prcvind;
	int *prclyrno;
	int compno;
	jpc_picomp_t *picomp;
	int xstep;
	int ystep;
	uint_fast32_t r;
	uint_fast32_t rpx;
	uint_fast32_t rpy;
	uint_fast32_t trx0;
	uint_fast32_t try0;

	pchg = pi->pchg;
	if (!pi->prgvolfirst) {
		goto skip;
	} else {
		pi->xstep = 0;
		pi->ystep = 0;
		for (compno = 0, picomp = pi->picomps; compno < pi->numcomps;
 		  ++compno, ++picomp) {
 			for (rlvlno = 0, pirlvl = picomp->pirlvls; rlvlno <
 			  picomp->numrlvls; ++rlvlno, ++pirlvl) {
				
				if (pirlvl->prcwidthexpn + pi->picomp->numrlvls >
				  JAS_UINTFAST32_NUMBITS - 2 ||
				  pirlvl->prcheightexpn + pi->picomp->numrlvls >
				  JAS_UINTFAST32_NUMBITS - 2) {
					return -1;
				}
				xstep = picomp->hsamp * (JAS_CAST(uint_fast32_t, 1) <<
				  (pirlvl->prcwidthexpn + picomp->numrlvls - rlvlno - 1));
				ystep = picomp->vsamp * (JAS_CAST(uint_fast32_t, 1) <<
				  (pirlvl->prcheightexpn + picomp->numrlvls - rlvlno - 1));
 				pi->xstep = (!pi->xstep) ? xstep : JAS_MIN(pi->xstep, xstep);
 				pi->ystep = (!pi->ystep) ? ystep : JAS_MIN(pi->ystep, ystep);
 			}
		}
		pi->prgvolfirst = 0;
	}

	for (pi->rlvlno = pchg->rlvlnostart; pi->rlvlno < pchg->rlvlnoend &&
	  pi->rlvlno < pi->maxrlvls; ++pi->rlvlno) {
		for (pi->y = pi->ystart; pi->y < pi->yend; pi->y +=
		  pi->ystep - (pi->y % pi->ystep)) {
			for (pi->x = pi->xstart; pi->x < pi->xend; pi->x +=
			  pi->xstep - (pi->x % pi->xstep)) {
				for (pi->compno = pchg->compnostart,
				  pi->picomp = &pi->picomps[pi->compno];
				  pi->compno < JAS_CAST(int, pchg->compnoend) && pi->compno <
				  pi->numcomps; ++pi->compno, ++pi->picomp) {
					if (pi->rlvlno >= pi->picomp->numrlvls) {
						continue;
					}
					pi->pirlvl = &pi->picomp->pirlvls[pi->rlvlno];
					if (pi->pirlvl->numprcs == 0) {
						continue;
					}
					r = pi->picomp->numrlvls - 1 - pi->rlvlno;
					rpx = r + pi->pirlvl->prcwidthexpn;
 					rpy = r + pi->pirlvl->prcheightexpn;
 					trx0 = JPC_CEILDIV(pi->xstart, pi->picomp->hsamp << r);
 					try0 = JPC_CEILDIV(pi->ystart, pi->picomp->vsamp << r);
					if (((pi->x == pi->xstart &&
					  ((trx0 << r) % (JAS_CAST(uint_fast32_t, 1) << rpx)))
					  || !(pi->x % (JAS_CAST(uint_fast32_t, 1) << rpx))) &&
					  ((pi->y == pi->ystart &&
					  ((try0 << r) % (JAS_CAST(uint_fast32_t, 1) << rpy)))
					  || !(pi->y % (JAS_CAST(uint_fast32_t, 1) << rpy)))) {
						prchind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->x,
						  pi->picomp->hsamp << r), pi->pirlvl->prcwidthexpn) -
						  JPC_FLOORDIVPOW2(trx0, pi->pirlvl->prcwidthexpn);
						prcvind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->y,
						  pi->picomp->vsamp << r), pi->pirlvl->prcheightexpn) -
						  JPC_FLOORDIVPOW2(try0, pi->pirlvl->prcheightexpn);
 						pi->prcno = prcvind * pi->pirlvl->numhprcs + prchind;
 
 						assert(pi->prcno < pi->pirlvl->numprcs);
 						for (pi->lyrno = 0; pi->lyrno <
						  pi->numlyrs && pi->lyrno < JAS_CAST(int,
						  pchg->lyrnoend); ++pi->lyrno) {
 							prclyrno = &pi->pirlvl->prclyrnos[pi->prcno];
 							if (pi->lyrno >= *prclyrno) {
 								++(*prclyrno);
								return 0;
							}
skip:
							;
						}
					}
				}
			}
		}
	}
	return 1;
}
","1. static int jpc_pi_nextrpcl(register jpc_pi_t *pi)
2. int compno;
3. int xstep;
4. goto skip;
5. pi->ystep = 0;
6. for (rlvlno = 0, pirlvl = picomp->pirlvls; rlvlno <
7. if (pirlvl->prcwidthexpn + pi->picomp->numrlvls >
8. pirlvl->prcheightexpn + pi->picomp->numrlvls >
9. xstep = picomp->hsamp * (JAS_CAST(uint_fast32_t, 1) <<
10. ystep = picomp->vsamp * (JAS_CAST(uint_fast32_t, 1) <<
11. pi->xstep = (!pi->xstep) ? xstep : JAS_MIN(pi->xstep, xstep);
pi->ystep = (!pi->ystep) ? ystep : JAS_MIN(pi->ystep, ystep);
12. for (pi->rlvlno = pchg->rlvlnostart; pi->rlvlno < pchg->rlvlnoend &&
pi->rlvlno < pi->maxrlvls; ++pi->rlvlno) {
13. pi->xstep - (pi->x % pi->xstep)) {","1
9
11
21
24
27
30
32
36
38
40-41
47-48
52","CWE-362,CWE-20,CWE-125"
pi_next_pcrl,"static opj_bool pi_next_pcrl(opj_pi_iterator_t * pi)
{
    opj_pi_comp_t *comp = NULL;
    opj_pi_resolution_t *res = NULL;
    long index = 0;

    if (!pi->first) {
        comp = &pi->comps[pi->compno];
        goto LABEL_SKIP;
    } else {
        int compno, resno;
        pi->first = 0;
        pi->dx = 0;
        pi->dy = 0;
        for (compno = 0; compno < pi->numcomps; compno++) {
            comp = &pi->comps[compno];
            for (resno = 0; resno < comp->numresolutions; resno++) {
                int dx, dy;
                res = &comp->resolutions[resno];
                dx = comp->dx * (1 << (res->pdx + comp->numresolutions - 1 - resno));
                dy = comp->dy * (1 << (res->pdy + comp->numresolutions - 1 - resno));
                pi->dx = !pi->dx ? dx : int_min(pi->dx, dx);
                pi->dy = !pi->dy ? dy : int_min(pi->dy, dy);
            }
        }
    }
    if (!pi->tp_on) {
        pi->poc.ty0 = pi->ty0;
        pi->poc.tx0 = pi->tx0;
        pi->poc.ty1 = pi->ty1;
        pi->poc.tx1 = pi->tx1;
    }
    for (pi->y = pi->poc.ty0; pi->y < pi->poc.ty1;
            pi->y += pi->dy - (pi->y % pi->dy)) {
        for (pi->x = pi->poc.tx0; pi->x < pi->poc.tx1;
                pi->x += pi->dx - (pi->x % pi->dx)) {
            for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {
                comp = &pi->comps[pi->compno];
                for (pi->resno = pi->poc.resno0;
                        pi->resno < int_min(pi->poc.resno1, comp->numresolutions); pi->resno++) {
                    int levelno;
                    int trx0, try0;
                    int trx1, try1;
                    int rpx, rpy;
                    int prci, prcj;
                    res = &comp->resolutions[pi->resno];
                    levelno = comp->numresolutions - 1 - pi->resno;
                    trx0 = int_ceildiv(pi->tx0, comp->dx << levelno);
                    try0 = int_ceildiv(pi->ty0, comp->dy << levelno);
                    trx1 = int_ceildiv(pi->tx1, comp->dx << levelno);
                    try1 = int_ceildiv(pi->ty1, comp->dy << levelno);
                    rpx = res->pdx + levelno;
                    rpy = res->pdy + levelno;

                    
                    if (rpx >= 31 || ((comp->dx << rpx) >> rpx) != comp->dx ||
                            rpy >= 31 || ((comp->dy << rpy) >> rpy) != comp->dy) {
                        continue;
                    }

                    if (!((pi->y % (comp->dy << rpy) == 0) || ((pi->y == pi->ty0) &&
                            ((try0 << levelno) % (1 << rpy))))) {
                        continue;
                    }
                    if (!((pi->x % (comp->dx << rpx) == 0) || ((pi->x == pi->tx0) &&
                            ((trx0 << levelno) % (1 << rpx))))) {
                        continue;
                    }

                    if ((res->pw == 0) || (res->ph == 0)) {
                        continue;
                    }

                    if ((trx0 == trx1) || (try0 == try1)) {
                        continue;
                    }

                    prci = int_floordivpow2(int_ceildiv(pi->x, comp->dx << levelno), res->pdx)
                           - int_floordivpow2(trx0, res->pdx);
                    prcj = int_floordivpow2(int_ceildiv(pi->y, comp->dy << levelno), res->pdy)
                           - int_floordivpow2(try0, res->pdy);
                    pi->precno = prci + prcj * res->pw;
                     for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {
                         index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno *
                                 pi->step_c + pi->precno * pi->step_p;
                        
                        if (index >= pi->include_size) {
                            opj_pi_emit_error(pi, ""Invalid access to pi->include"");
                            return OPJ_FALSE;
                        }
                         if (!pi->include[index]) {
                             pi->include[index] = 1;
                             return OPJ_TRUE;
                        }
LABEL_SKIP:
                        ;
                    }
                }
            }
        }
    }

    return OPJ_FALSE;
}
","1. pi->dy = 0;
2. dy = comp->dy * (1 << (res->pdy + comp->numresolutions - 1 - resno));
pi->dx = !pi->dx ? dx : int_min(pi->dx, dx);
3. pi->poc.ty0 = pi->ty0;
4. for (pi->x = pi->poc.tx0; pi->x < pi->poc.tx1;
5. int levelno;
6. try1 = int_ceildiv(pi->ty1, comp->dy << levelno);
rpx = res->pdx + levelno;
7. for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {
8. return OPJ_TRUE;","14
21-22
28
35
41
51-52
83
93","CWE-674,CWE-20,CWE-125,CWE-369"
host_name_lookup-149428144199119,"int
host_name_lookup(void)
{
int old_pool, rc;
int sep = 0;
uschar *save_hostname;
uschar **aliases;
uschar *ordername;
const uschar *list = host_lookup_order;
dns_answer * dnsa = store_get_dns_answer();
dns_scan dnss;

sender_host_dnssec = host_lookup_deferred = host_lookup_failed = FALSE;

HDEBUG(D_host_lookup)
  debug_printf(""looking up host name for %s\n"", sender_host_address);



if (f.running_in_test_harness &&
    Ustrcmp(sender_host_address, ""99.99.99.99"") == 0)
  {
  HDEBUG(D_host_lookup)
    debug_printf(""Test harness: host name lookup returns DEFER\n"");
  host_lookup_deferred = TRUE;
  return DEFER;
  }



while ((ordername = string_nextinlist(&list, &sep, NULL, 0)))
  {
  if (strcmpic(ordername, US""bydns"") == 0)
    {
    uschar * name = dns_build_reverse(sender_host_address);

    dns_init(FALSE, FALSE, FALSE);    
    rc = dns_lookup_timerwrap(dnsa, name, T_PTR, NULL);

    

    if (rc == DNS_SUCCEED)
      {
      uschar **aptr = NULL;
      int ssize = 264;
      int count = 1;  
      int old_pool = store_pool;

      sender_host_dnssec = dns_is_secure(dnsa);
      DEBUG(D_dns)
        debug_printf(""Reverse DNS security status: %s\n"",
            sender_host_dnssec ? ""DNSSEC verified (AD)"" : ""unverified"");

      store_pool = POOL_PERM;        

      for (dns_record * rr = dns_next_rr(dnsa, &dnss, RESET_ANSWERS);
           rr;
           rr = dns_next_rr(dnsa, &dnss, RESET_NEXT)) if (rr->type == T_PTR)
	count++;

      

      aptr = sender_host_aliases = store_get(count * sizeof(uschar *), FALSE);

      

      for (dns_record * rr = dns_next_rr(dnsa, &dnss, RESET_ANSWERS);
           rr;
           rr = dns_next_rr(dnsa, &dnss, RESET_NEXT)) if (rr->type == T_PTR)
        {
        uschar * s = store_get(ssize, TRUE);	

        

        if (dn_expand(dnsa->answer, dnsa->answer + dnsa->answerlen,
             US (rr->data), (DN_EXPAND_ARG4_TYPE)(s), ssize) < 0)
          {
          log_write(0, LOG_MAIN, ""host name alias list truncated for %s"",
            sender_host_address);
          break;
          }

        store_release_above(s + Ustrlen(s) + 1);
        if (!s[0])
          {
          HDEBUG(D_host_lookup) debug_printf(""IP address lookup yielded an ""
            ""empty name: treated as non-existent host name\n"");
          continue;
          }
        if (!sender_host_name) sender_host_name = s;
	else *aptr++ = s;
        while (*s) { *s = tolower(*s); s++; }
        }

      *aptr = NULL;            
      store_pool = old_pool;   

      

      if (sender_host_name) break;
      }

    

    if (rc == DNS_AGAIN)
      {
      HDEBUG(D_host_lookup)
        debug_printf(""IP address PTR lookup gave temporary error\n"");
      host_lookup_deferred = TRUE;
      return DEFER;
      }
    }

  

  else if (strcmpic(ordername, US""byaddr"") == 0)
    {
    HDEBUG(D_host_lookup)
      debug_printf(""IP address lookup using gethostbyaddr()\n"");
    rc = host_name_lookup_byaddr();
    if (rc == DEFER)
      {
      host_lookup_deferred = TRUE;
      return rc;                       
      }
    if (rc == OK) break;               
    }
  }      



if (!sender_host_name)
  {
  if (host_checking || !f.log_testing_mode)
    log_write(L_host_lookup_failed, LOG_MAIN, ""no host name found for IP ""
      ""address %s"", sender_host_address);
  host_lookup_msg = US"" (failed to find host name from IP address)"";
  host_lookup_failed = TRUE;
  return FAIL;
  }

HDEBUG(D_host_lookup)
  {
  uschar **aliases = sender_host_aliases;
  debug_printf(""IP address lookup yielded \""%s\""\n"", sender_host_name);
  while (*aliases != NULL) debug_printf(""  alias \""%s\""\n"", *aliases++);
  }



save_hostname = sender_host_name;   
aliases = sender_host_aliases;
for (uschar * hname = sender_host_name; hname; hname = *aliases++)
  {
  int rc;
  BOOL ok = FALSE;
  host_item h = { .next = NULL, .name = hname, .mx = MX_NONE, .address = NULL };
  dnssec_domains d =
    { .request = sender_host_dnssec ? US""*"" : NULL, .require = NULL };

  if (  (rc = host_find_bydns(&h, NULL, HOST_FIND_BY_A | HOST_FIND_BY_AAAA,
	  NULL, NULL, NULL, &d, NULL, NULL)) == HOST_FOUND
     || rc == HOST_FOUND_LOCAL
     )
    {
    HDEBUG(D_host_lookup) debug_printf(""checking addresses for %s\n"", hname);

    

    DEBUG(D_dns) debug_printf(""Forward DNS security status: %s\n"",
	  h.dnssec == DS_YES ? ""DNSSEC verified (AD)"" : ""unverified"");
    if (h.dnssec != DS_YES) sender_host_dnssec = FALSE;

    for (host_item * hh = &h; hh; hh = hh->next)
      if (host_is_in_net(hh->address, sender_host_address, 0))
        {
        HDEBUG(D_host_lookup) debug_printf(""  %s OK\n"", hh->address);
        ok = TRUE;
        break;
        }
      else
        HDEBUG(D_host_lookup) debug_printf(""  %s\n"", hh->address);

    if (!ok) HDEBUG(D_host_lookup)
      debug_printf(""no IP address for %s matched %s\n"", hname,
        sender_host_address);
    }
  else if (rc == HOST_FIND_AGAIN)
    {
    HDEBUG(D_host_lookup) debug_printf(""temporary error for host name lookup\n"");
    host_lookup_deferred = TRUE;
    sender_host_name = NULL;
    return DEFER;
    }
  else
    HDEBUG(D_host_lookup) debug_printf(""no IP addresses found for %s\n"", hname);

  

  if (!ok)
    {
    if (hname == sender_host_name) sender_host_name = NULL; else
      {
      uschar **a;                              
      a = --aliases;                           
      while (*a != NULL) { *a = a[1]; a++; }
      }
    }
  }



if (sender_host_name == NULL && *sender_host_aliases != NULL)
  sender_host_name = *sender_host_aliases++;



if (sender_host_name != NULL) return OK;



HDEBUG(D_host_lookup)
  debug_printf(""%s does not match any IP address for %s\n"",
    sender_host_address, save_hostname);



old_pool = store_pool;
store_pool = POOL_PERM;
host_lookup_msg = string_sprintf("" (%s does not match any IP address for %s)"",
  sender_host_address, save_hostname);
store_pool = old_pool;
host_lookup_failed = TRUE;
return FAIL;
}
","1. uschar **aliases;
2. const uschar *list = host_lookup_order;
3. uschar * name = dns_build_reverse(sender_host_address);
4. for (dns_record * rr = dns_next_rr(dnsa, &dnss, RESET_ANSWERS);
5. return DEFER;
6. int rc;
7. HDEBUG(D_host_lookup) debug_printf(""no IP addresses found for %s\n"", hname);
8. if (sender_host_name == NULL && *sender_host_aliases != NULL)","7
9
37
62
118
175
216
235","CWE-476,CWE-200,CWE-22,CWE-399"
SQLSetDescField-26942963021413,"
#define SQLHDESC
#define SQLINTEGER
#define SQLPOINTER
#define SQLSMALLINT

SQLRETURN SQLSetDescField( SQLHDESC descriptor_handle,
           SQLSMALLINT rec_number, 
           SQLSMALLINT field_identifier,
           SQLPOINTER value, 
           SQLINTEGER buffer_length )
{
    
    DMHDESC descriptor = (DMHDESC) descriptor_handle;
    SQLRETURN ret;
    SQLCHAR s1[ 100 + LOG_MESSAGE_LEN ];
    int isStrField = 0;

    

    if ( !__validate_desc( descriptor ))
    {
        dm_log_write( __FILE__, 
                    __LINE__, 
                    LOG_INFO, 
                    LOG_INFO, 
                    ""Error: SQL_INVALID_HANDLE"" );

        return SQL_INVALID_HANDLE;
    }

    function_entry( descriptor );

    if ( log_info.log_flag )
    {
        sprintf( descriptor -> msg, ""\n\t\tEntry:\
\n\t\t\tDescriptor = %p\
\n\t\t\tRec Number = %d\
\n\t\t\tField Ident = %s\
\n\t\t\tValue = %p\
\n\t\t\tBuffer Length = %d"",
                descriptor,
                rec_number,
                __desc_attr_as_string( s1, field_identifier ),
                value, 
                (int)buffer_length );

        dm_log_write( __FILE__, 
                __LINE__, 
                LOG_INFO, 
                LOG_INFO, 
                descriptor -> msg );
    }

    thread_protect( SQL_HANDLE_DESC, descriptor );

    if ( descriptor -> connection -> state < STATE_C4 )
    {
        dm_log_write( __FILE__, 
                __LINE__, 
                LOG_INFO, 
                LOG_INFO, 
                ""Error: HY010"" );

        __post_internal_error( &descriptor -> error,
                ERROR_HY010, NULL,
                descriptor -> connection -> environment -> requested_version );

        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );
    }

    

    if( __check_stmt_from_desc( descriptor, STATE_S8 ) ||
        __check_stmt_from_desc( descriptor, STATE_S9 ) ||
        __check_stmt_from_desc( descriptor, STATE_S10 ) ||
        __check_stmt_from_desc( descriptor, STATE_S11 ) ||
        __check_stmt_from_desc( descriptor, STATE_S12 ) ||
        __check_stmt_from_desc( descriptor, STATE_S13 ) ||
        __check_stmt_from_desc( descriptor, STATE_S14 ) ||
        __check_stmt_from_desc( descriptor, STATE_S15 )) {

        dm_log_write( __FILE__, 
                __LINE__, 
                LOG_INFO, 
                LOG_INFO, 
                ""Error: HY010"" );

        __post_internal_error( &descriptor -> error,
                ERROR_HY010, NULL,
                descriptor -> connection -> environment -> requested_version );

        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );
    }


    if ( rec_number < 0 )
    {
        __post_internal_error( &descriptor -> error,
                ERROR_07009, NULL,
                descriptor -> connection -> environment -> requested_version );

        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );
    }

    switch ( field_identifier )
    {
    
    case SQL_DESC_ALLOC_TYPE:
    case SQL_DESC_ARRAY_SIZE:
    case SQL_DESC_ARRAY_STATUS_PTR:
    case SQL_DESC_BIND_OFFSET_PTR:
    case SQL_DESC_BIND_TYPE:
    case SQL_DESC_COUNT:
    case SQL_DESC_ROWS_PROCESSED_PTR:
    case SQL_DESC_AUTO_UNIQUE_VALUE:
    case SQL_DESC_CASE_SENSITIVE:
    case SQL_DESC_CONCISE_TYPE:
    case SQL_DESC_DATA_PTR:
    case SQL_DESC_DATETIME_INTERVAL_CODE:
    case SQL_DESC_DATETIME_INTERVAL_PRECISION:
    case SQL_DESC_DISPLAY_SIZE:
    case SQL_DESC_FIXED_PREC_SCALE:
    case SQL_DESC_INDICATOR_PTR:
    case SQL_DESC_LENGTH:
    case SQL_DESC_NULLABLE:
    case SQL_DESC_NUM_PREC_RADIX:
    case SQL_DESC_OCTET_LENGTH:
    case SQL_DESC_OCTET_LENGTH_PTR:
    case SQL_DESC_PARAMETER_TYPE:
    case SQL_DESC_PRECISION:
    case SQL_DESC_ROWVER:
    case SQL_DESC_SCALE:
    case SQL_DESC_SEARCHABLE:
    case SQL_DESC_TYPE:
    case SQL_DESC_UNNAMED:
    case SQL_DESC_UNSIGNED:
    case SQL_DESC_UPDATABLE:
        isStrField = 0;
        break;
    
    case SQL_DESC_BASE_COLUMN_NAME:
    case SQL_DESC_BASE_TABLE_NAME:
    case SQL_DESC_CATALOG_NAME:
    case SQL_DESC_LABEL:
    case SQL_DESC_LITERAL_PREFIX:
    case SQL_DESC_LITERAL_SUFFIX:
    case SQL_DESC_LOCAL_TYPE_NAME:
    case SQL_DESC_NAME:
    case SQL_DESC_SCHEMA_NAME:
    case SQL_DESC_TABLE_NAME:
    case SQL_DESC_TYPE_NAME:
        isStrField = 1;
        break;
    default:
        isStrField = buffer_length != SQL_IS_POINTER && buffer_length != SQL_IS_INTEGER
            && buffer_length != SQL_IS_UINTEGER && buffer_length != SQL_IS_SMALLINT &&
            buffer_length != SQL_IS_USMALLINT;
    }
    
    if ( isStrField && buffer_length < 0 && buffer_length != SQL_NTS)
    {
        __post_internal_error( &descriptor -> error,
            ERROR_HY090, NULL,
            descriptor -> connection -> environment -> requested_version );

        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );
    }

    if ( field_identifier == SQL_DESC_COUNT && (intptr_t)value < 0 )
    {
        __post_internal_error( &descriptor -> error,
                ERROR_07009, NULL,
                descriptor -> connection -> environment -> requested_version );

        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );
    }
    
    if ( field_identifier == SQL_DESC_PARAMETER_TYPE && (intptr_t)value != SQL_PARAM_INPUT
        && (intptr_t)value != SQL_PARAM_OUTPUT && (intptr_t)value != SQL_PARAM_INPUT_OUTPUT &&
        (intptr_t)value != SQL_PARAM_INPUT_OUTPUT_STREAM && (intptr_t)value != SQL_PARAM_OUTPUT_STREAM )
    {
        __post_internal_error( &descriptor -> error,
                ERROR_HY105, NULL,
                descriptor -> connection -> environment -> requested_version );

        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );
    }

    if ( CHECK_SQLSETDESCFIELD( descriptor -> connection ))
    {
      ret = SQLSETDESCFIELD( descriptor -> connection,
              descriptor -> driver_desc,
              rec_number, 
              field_identifier,
              value, 
              buffer_length );
    }
    else if ( CHECK_SQLSETDESCFIELDW( descriptor -> connection ))
    {
      SQLWCHAR *s1 = NULL;

        if (isStrField)
      {
        s1 = ansi_to_unicode_alloc( value, buffer_length, descriptor -> connection, NULL );
            if (SQL_NTS != buffer_length)
            {
                buffer_length *= sizeof(SQLWCHAR);
            }
      }
      else
      {
              s1 = value;
      }
      ret = SQLSETDESCFIELDW( descriptor -> connection,
                descriptor -> driver_desc,
                rec_number, 
                field_identifier,
                s1, 
                buffer_length );
       
        if (isStrField)
       {
        if (s1)
          free(s1); 
       }
    }
    else 
	{
        dm_log_write( __FILE__, 
                __LINE__, 
                LOG_INFO, 
                LOG_INFO, 
                ""Error: IM001"" );

        __post_internal_error( &descriptor -> error,
                ERROR_IM001, NULL,
                descriptor -> connection -> environment -> requested_version );

        return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );
    }

    if ( log_info.log_flag )
    {
        sprintf( descriptor -> msg, 
                ""\n\t\tExit:[%s]"",
                    __get_return_status( ret, s1 ));

        dm_log_write( __FILE__, 
                __LINE__, 
                LOG_INFO, 
                LOG_INFO, 
                descriptor -> msg );
    }

    return function_return( SQL_HANDLE_DESC, descriptor, ret );
}
","1. SQLSMALLINT field_identifier,
2. if ( !__validate_desc( descriptor ))
3. LOG_INFO,
LOG_INFO,
4. __check_stmt_from_desc( descriptor, STATE_S11 ) ||
5. LOG_INFO,
""Error: HY010"" );
6. ERROR_HY010, NULL,
7. case SQL_DESC_BIND_OFFSET_PTR:
8. case SQL_DESC_DATETIME_INTERVAL_CODE:
9. case SQL_DESC_PRECISION:
10. case SQL_DESC_BASE_COLUMN_NAME:
case SQL_DESC_BASE_TABLE_NAME:
11. break;
12. return function_return_nodrv( SQL_HANDLE_DESC, descriptor, SQL_ERROR );
13. && (intptr_t)value != SQL_PARAM_OUTPUT && (intptr_t)value != SQL_PARAM_INPUT_OUTPUT &&
(intptr_t)value != SQL_PARAM_INPUT_OUTPUT_STREAM && (intptr_t)value != SQL_PARAM_OUTPUT_STREAM )
14. __post_internal_error( &descriptor -> error,
15. buffer_length );
16. LOG_INFO,
descriptor -> msg );","9
29
69-70
87
96-97
100
122
130
141
152-153
164
186
190-191
193
207
262-263","CWE-125,CWE-119"
pam_sm_authenticate-269595794351433,"int pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc,
                        const char **argv) {

  struct passwd *pw = NULL, pw_s;
  const char *user = NULL;

  cfg_t cfg_st;
  cfg_t *cfg = &cfg_st;
  char buffer[BUFSIZE];
  char *buf = NULL;
  char *authfile_dir;
  size_t authfile_dir_len;
  int pgu_ret, gpn_ret;
  int retval = PAM_IGNORE;
  device_t *devices = NULL;
  unsigned n_devices = 0;
  int openasuser;
  int should_free_origin = 0;
  int should_free_appid = 0;
  int should_free_auth_file = 0;
  int should_free_authpending_file = 0;

  parse_cfg(flags, argc, argv, cfg);

  if (!cfg->origin) {
    strcpy(buffer, DEFAULT_ORIGIN_PREFIX);

    if (gethostname(buffer + strlen(DEFAULT_ORIGIN_PREFIX),
                    BUFSIZE - strlen(DEFAULT_ORIGIN_PREFIX)) == -1) {
      DBG(""Unable to get host name"");
      goto done;
    }
    DBG(""Origin not specified, using \""%s\"""", buffer);
    cfg->origin = strdup(buffer);
    if (!cfg->origin) {
      DBG(""Unable to allocate memory"");
      goto done;
    } else {
      should_free_origin = 1;
    }
  }

  if (!cfg->appid) {
    DBG(""Appid not specified, using the same value of origin (%s)"",
         cfg->origin);
    cfg->appid = strdup(cfg->origin);
    if (!cfg->appid) {
      DBG(""Unable to allocate memory"")
      goto done;
    } else {
      should_free_appid = 1;
    }
  }

  if (cfg->max_devs == 0) {
    DBG(""Maximum devices number not set. Using default (%d)"", MAX_DEVS);
    cfg->max_devs = MAX_DEVS;
  }

  devices = malloc(sizeof(device_t) * cfg->max_devs);
  if (!devices) {
    DBG(""Unable to allocate memory"");
    retval = PAM_IGNORE;
    goto done;
  }

  pgu_ret = pam_get_user(pamh, &user, NULL);
  if (pgu_ret != PAM_SUCCESS || user == NULL) {
    DBG(""Unable to access user %s"", user);
    retval = PAM_CONV_ERR;
    goto done;
  }

  DBG(""Requesting authentication for user %s"", user);

  gpn_ret = getpwnam_r(user, &pw_s, buffer, sizeof(buffer), &pw);
  if (gpn_ret != 0 || pw == NULL || pw->pw_dir == NULL ||
      pw->pw_dir[0] != '/') {
    DBG(""Unable to retrieve credentials for user %s, (%s)"", user,
         strerror(errno));
    retval = PAM_USER_UNKNOWN;
    goto done;
  }

  DBG(""Found user %s"", user);
  DBG(""Home directory for %s is %s"", user, pw->pw_dir);

  if (!cfg->auth_file) {
    buf = NULL;
    authfile_dir = secure_getenv(DEFAULT_AUTHFILE_DIR_VAR);
    if (!authfile_dir) {
      DBG(""Variable %s is not set. Using default value ($HOME/.config/)"",
           DEFAULT_AUTHFILE_DIR_VAR);
      authfile_dir_len =
        strlen(pw->pw_dir) + strlen(""/.config"") + strlen(DEFAULT_AUTHFILE) + 1;
      buf = malloc(sizeof(char) * (authfile_dir_len));

      if (!buf) {
        DBG(""Unable to allocate memory"");
        retval = PAM_IGNORE;
        goto done;
      }

      snprintf(buf, authfile_dir_len,
               ""%s/.config%s"", pw->pw_dir, DEFAULT_AUTHFILE);
    } else {
      DBG(""Variable %s set to %s"", DEFAULT_AUTHFILE_DIR_VAR, authfile_dir);
      authfile_dir_len = strlen(authfile_dir) + strlen(DEFAULT_AUTHFILE) + 1;
      buf = malloc(sizeof(char) * (authfile_dir_len));

      if (!buf) {
        DBG(""Unable to allocate memory"");
        retval = PAM_IGNORE;
        goto done;
      }

      snprintf(buf, authfile_dir_len,
               ""%s%s"", authfile_dir, DEFAULT_AUTHFILE);
    }

    DBG(""Using default authentication file %s"", buf);

    cfg->auth_file = buf; 
    should_free_auth_file = 1;
    buf = NULL;
  } else {
    DBG(""Using authentication file %s"", cfg->auth_file);
  }

  openasuser = geteuid() == 0 && cfg->openasuser;
  if (openasuser) {
    if (seteuid(pw_s.pw_uid)) {
      DBG(""Unable to switch user to uid %i"", pw_s.pw_uid);
      retval = PAM_IGNORE;
      goto done;
    }
    DBG(""Switched to uid %i"", pw_s.pw_uid);
  }
  retval = get_devices_from_authfile(cfg->auth_file, user, cfg->max_devs,
                                     cfg->debug, cfg->debug_file,
                                     devices, &n_devices);
  if (openasuser) {
    if (seteuid(0)) {
      DBG(""Unable to switch back to uid 0"");
      retval = PAM_IGNORE;
      goto done;
    }
    DBG(""Switched back to uid 0"");
  }

  if (retval != 1) {
    
    
    n_devices = 0;
  }

  if (n_devices == 0) {
    if (cfg->nouserok) {
      DBG(""Found no devices but nouserok specified. Skipping authentication"");
      retval = PAM_SUCCESS;
      goto done;
    } else if (retval != 1) {
      DBG(""Unable to get devices from file %s"", cfg->auth_file);
      retval = PAM_AUTHINFO_UNAVAIL;
      goto done;
    } else {
      DBG(""Found no devices. Aborting."");
      retval = PAM_AUTHINFO_UNAVAIL;
      goto done;
    }
  }

  
  if (!cfg->authpending_file) {
    int actual_size = snprintf(buffer, BUFSIZE, DEFAULT_AUTHPENDING_FILE_PATH, getuid());
    if (actual_size >= 0 && actual_size < BUFSIZE) {
      cfg->authpending_file = strdup(buffer);
    }
    if (!cfg->authpending_file) {
      DBG(""Unable to allocate memory for the authpending_file, touch request notifications will not be emitted"");
    } else {
      should_free_authpending_file = 1;
    }
  } else {
    if (strlen(cfg->authpending_file) == 0) {
      DBG(""authpending_file is set to an empty value, touch request notifications will be disabled"");
      cfg->authpending_file = NULL;
    }
  }

  int authpending_file_descriptor = -1;
  if (cfg->authpending_file) {
    DBG(""Using file '%s' for emitting touch request notifications"", cfg->authpending_file);

    
    authpending_file_descriptor =
      open(cfg->authpending_file, O_RDONLY | O_CREAT | O_CLOEXEC | O_NOFOLLOW | O_NOCTTY, 0664);
    if (authpending_file_descriptor < 0) {
      DBG(""Unable to emit 'authentication started' notification by opening the file '%s', (%s)"",
          cfg->authpending_file, strerror(errno));
    }
  }

  if (cfg->manual == 0) {
    if (cfg->interactive) {
      converse(pamh, PAM_PROMPT_ECHO_ON,
               cfg->prompt != NULL ? cfg->prompt : DEFAULT_PROMPT);
    }

    retval = do_authentication(cfg, devices, n_devices, pamh);
  } else {
    retval = do_manual_authentication(cfg, devices, n_devices, pamh);
  }

  
  if (authpending_file_descriptor >= 0) {
    if (close(authpending_file_descriptor) < 0) {
      DBG(""Unable to emit 'authentication stopped' notification by closing the file '%s', (%s)"",
          cfg->authpending_file, strerror(errno));
    }
  }

  if (retval != 1) {
    DBG(""do_authentication returned %d"", retval);
    retval = PAM_AUTH_ERR;
    goto done;
  }

  retval = PAM_SUCCESS;

done:
  free_devices(devices, n_devices);

  if (buf) {
    free(buf);
    buf = NULL;
  }

  if (should_free_origin) {
    free((char *) cfg->origin);
    cfg->origin = NULL;
  }

  if (should_free_appid) {
    free((char *) cfg->appid);
    cfg->appid = NULL;
  }

  if (should_free_auth_file) {
    free((char *) cfg->auth_file);
    cfg->auth_file = NULL;
  }

  if (should_free_authpending_file) {
    free((char *) cfg->authpending_file);
    cfg->authpending_file = NULL;
  }

  if (cfg->alwaysok && retval != PAM_SUCCESS) {
    DBG(""alwaysok needed (otherwise return with %d)"", retval);
    retval = PAM_SUCCESS;
  }
  DBG(""done. [%s]"", pam_strerror(pamh, retval));

  if (cfg->is_custom_debug_file) {
    fclose(cfg->debug_file);
  }

  return retval;
}
","1. int openasuser;
int should_free_origin = 0;
int should_free_appid = 0;
2. parse_cfg(flags, argc, argv, cfg);
3. BUFSIZE - strlen(DEFAULT_ORIGIN_PREFIX)) == -1) {
DBG(""Unable to get host name"");
4. if (!cfg->origin) {
5. cfg->origin);
6. if (!cfg->appid) {
7. goto done;
8. retval = PAM_USER_UNKNOWN;
9. DBG(""Found user %s"", user);
10. authfile_dir = secure_getenv(DEFAULT_AUTHFILE_DIR_VAR);
11. authfile_dir_len =
12. } else {
13. authfile_dir_len = strlen(authfile_dir) + strlen(DEFAULT_AUTHFILE) + 1;
14. goto done;
15. DBG(""Using authentication file %s"", cfg->auth_file);
16. goto done;
17. devices, &n_devices);
18. goto done;
19. retval = PAM_AUTHINFO_UNAVAIL;
20. if (!cfg->authpending_file) {
DBG(""Unable to allocate memory for the authpending_file, touch request notifications will not be emitted"");
21. DBG(""authpending_file is set to an empty value, touch request notifications will be disabled"");
22. if (buf) {","17-19
23
29-30
35
45
47
64
81
85
90
94
106
108
114
127
135
141
161
168
179-180
186
234","CWE-120,CWE-200,CWE-862,CWE-125,CWE-59"
ioctl_file_dedupe_range,"
#define __user

static long ioctl_file_dedupe_range(struct file *file, void __user *arg)
{
	struct file_dedupe_range __user *argp = arg;
	struct file_dedupe_range *same = NULL;
	int ret;
	unsigned long size;
	u16 count;

	if (get_user(count, &argp->dest_count)) {
		ret = -EFAULT;
		goto out;
	}

	size = offsetof(struct file_dedupe_range __user, info[count]);

	same = memdup_user(argp, size);
	if (IS_ERR(same)) {
		ret = PTR_ERR(same);
		same = NULL;
 		goto out;
 	}
 
	same->dest_count = count;
 	ret = vfs_dedupe_file_range(file, same);
 	if (ret)
 		goto out;

	ret = copy_to_user(argp, same, size);
	if (ret)
		ret = -EFAULT;

out:
	kfree(same);
	return ret;
}
","1. if (IS_ERR(same)) {
ret = PTR_ERR(same);
2. goto out;
3. same->dest_count = count;
ret = vfs_dedupe_file_range(file, same);
4. ret = copy_to_user(argp, same, size);
if (ret)","20-21
23
26-27
31-32","CWE-264,CWE-323,CWE-787,CWE-119,CWE-77"
commit_tree-171465431723532,"static void commit_tree(struct mount *mnt, struct mount *shadows)
{
	struct mount *parent = mnt->mnt_parent;
	struct mount *m;
	LIST_HEAD(head);
	struct mnt_namespace *n = parent->mnt_ns;

	BUG_ON(parent == mnt);

	list_add_tail(&head, &mnt->mnt_list);
	list_for_each_entry(m, &head, mnt_list)
		m->mnt_ns = n;

	list_splice(&head, n->list.prev);

	n->mounts += n->pending_mounts;
	n->pending_mounts = 0;

	attach_shadowed(mnt, parent, shadows);
	touch_mnt_namespace(n);
}
","1. struct mount *parent = mnt->mnt_parent;
2. struct mnt_namespace *n = parent->mnt_ns;
3. list_add_tail(&head, &mnt->mnt_list);
4. m->mnt_ns = n;
5. n->mounts += n->pending_mounts;
n->pending_mounts = 0;
6. touch_mnt_namespace(n);","3
6
10
12
16-17
20","CWE-20,CWE-476,CWE-190,CWE-787,CWE-400"
keepalived_main-524648104270,"int
keepalived_main(int argc, char **argv)
{
	bool report_stopped = true;
	struct utsname uname_buf;
	char *end;

	
	set_time_now();

	
	save_cmd_line_options(argc, argv);

	
	debug = 0;

	
#ifndef _DEBUG_
	prog_type = PROG_TYPE_PARENT;
#endif

	
#ifdef _WITH_VRRP_
	__set_bit(DAEMON_VRRP, &daemon_mode);
#endif
#ifdef _WITH_LVS_
	__set_bit(DAEMON_CHECKERS, &daemon_mode);
#endif
#ifdef _WITH_BFD_
	__set_bit(DAEMON_BFD, &daemon_mode);
#endif

	
	umask(022);

	
	openlog(PACKAGE_NAME, LOG_PID, log_facility);

#ifdef _MEM_CHECK_
	mem_log_init(PACKAGE_NAME, ""Parent process"");
#endif

	
	if (uname(&uname_buf))
		log_message(LOG_INFO, ""Unable to get uname() information - error %d"", errno);
	else {
		os_major = (unsigned)strtoul(uname_buf.release, &end, 10);
		if (*end != '.')
			os_major = 0;
		else {
			os_minor = (unsigned)strtoul(end + 1, &end, 10);
			if (*end != '.')
				os_major = 0;
			else {
				if (!isdigit(end[1]))
					os_major = 0;
				else
					os_release = (unsigned)strtoul(end + 1, &end, 10);
			}
		}
		if (!os_major)
			log_message(LOG_INFO, ""Unable to parse kernel version %s"", uname_buf.release);

		
		if (!config_id) {
			end = strchrnul(uname_buf.nodename, '.');
			config_id = MALLOC((size_t)(end - uname_buf.nodename) + 1);
			strncpy(config_id, uname_buf.nodename, (size_t)(end - uname_buf.nodename));
			config_id[end - uname_buf.nodename] = '\0';
		}
	}

	
	if (parse_cmdline(argc, argv)) {
		closelog();
		if (!__test_bit(NO_SYSLOG_BIT, &debug))
			openlog(PACKAGE_NAME, LOG_PID | ((__test_bit(LOG_CONSOLE_BIT, &debug)) ? LOG_CONS : 0) , log_facility);
	}

	if (__test_bit(LOG_CONSOLE_BIT, &debug))
		enable_console_log();

#ifdef GIT_COMMIT
	log_message(LOG_INFO, ""Starting %s, git commit %s"", version_string, GIT_COMMIT);
#else
	log_message(LOG_INFO, ""Starting %s"", version_string);
#endif

	
	core_dump_init();

	if (os_major) {
		if (KERNEL_VERSION(os_major, os_minor, os_release) < LINUX_VERSION_CODE) {
			
			log_message(LOG_INFO, ""WARNING - keepalived was build for newer Linux %d.%d.%d, running on %s %s %s"",
					(LINUX_VERSION_CODE >> 16) & 0xff,
					(LINUX_VERSION_CODE >>  8) & 0xff,
					(LINUX_VERSION_CODE      ) & 0xff,
					uname_buf.sysname, uname_buf.release, uname_buf.version);
		} else {
			
			log_message(LOG_INFO, ""Running on %s %s %s (built for Linux %d.%d.%d)"",
					uname_buf.sysname, uname_buf.release, uname_buf.version,
					(LINUX_VERSION_CODE >> 16) & 0xff,
					(LINUX_VERSION_CODE >>  8) & 0xff,
					(LINUX_VERSION_CODE      ) & 0xff);
		}
	}

#ifndef _DEBUG_
	log_command_line(0);
#endif

	
	if (!check_conf_file(conf_file)) {
		if (__test_bit(CONFIG_TEST_BIT, &debug))
			config_test_exit();

		goto end;
	}

	global_data = alloc_global_data();
	global_data->umask = umask_val;

	read_config_file();

	init_global_data(global_data, NULL);

#if HAVE_DECL_CLONE_NEWNET
	if (override_namespace) {
		if (global_data->network_namespace) {
			log_message(LOG_INFO, ""Overriding config net_namespace '%s' with command line namespace '%s'"", global_data->network_namespace, override_namespace);
			FREE(global_data->network_namespace);
		}
		global_data->network_namespace = override_namespace;
		override_namespace = NULL;
	}
#endif

	if (!__test_bit(CONFIG_TEST_BIT, &debug) &&
	    (global_data->instance_name
#if HAVE_DECL_CLONE_NEWNET
	     || global_data->network_namespace
#endif
					      )) {
		if ((syslog_ident = make_syslog_ident(PACKAGE_NAME))) {
			log_message(LOG_INFO, ""Changing syslog ident to %s"", syslog_ident);
			closelog();
			openlog(syslog_ident, LOG_PID | ((__test_bit(LOG_CONSOLE_BIT, &debug)) ? LOG_CONS : 0), log_facility);
		}
		else
			log_message(LOG_INFO, ""Unable to change syslog ident"");

		use_pid_dir = true;

		open_log_file(log_file_name,
				NULL,
#if HAVE_DECL_CLONE_NEWNET
				global_data->network_namespace,
#else
				NULL,
#endif
				global_data->instance_name);
	}

	
	set_child_finder_name(find_keepalived_child_name);

	if (!__test_bit(CONFIG_TEST_BIT, &debug)) {
		if (use_pid_dir) {
			
			create_pid_dir();
		}
	}

#if HAVE_DECL_CLONE_NEWNET
	if (global_data->network_namespace) {
		if (global_data->network_namespace && !set_namespaces(global_data->network_namespace)) {
			log_message(LOG_ERR, ""Unable to set network namespace %s - exiting"", global_data->network_namespace);
			goto end;
		}
	}
#endif

	if (!__test_bit(CONFIG_TEST_BIT, &debug)) {
		if (global_data->instance_name) {
			if (!main_pidfile && (main_pidfile = make_pidfile_name(KEEPALIVED_PID_DIR KEEPALIVED_PID_FILE, global_data->instance_name, PID_EXTENSION)))
				free_main_pidfile = true;
#ifdef _WITH_LVS_
			if (!checkers_pidfile && (checkers_pidfile = make_pidfile_name(KEEPALIVED_PID_DIR CHECKERS_PID_FILE, global_data->instance_name, PID_EXTENSION)))
				free_checkers_pidfile = true;
#endif
#ifdef _WITH_VRRP_
			if (!vrrp_pidfile && (vrrp_pidfile = make_pidfile_name(KEEPALIVED_PID_DIR VRRP_PID_FILE, global_data->instance_name, PID_EXTENSION)))
				free_vrrp_pidfile = true;
#endif
#ifdef _WITH_BFD_
			if (!bfd_pidfile && (bfd_pidfile = make_pidfile_name(KEEPALIVED_PID_DIR VRRP_PID_FILE, global_data->instance_name, PID_EXTENSION)))
				free_bfd_pidfile = true;
#endif
		}

		if (use_pid_dir) {
			if (!main_pidfile)
				main_pidfile = KEEPALIVED_PID_DIR KEEPALIVED_PID_FILE PID_EXTENSION;
#ifdef _WITH_LVS_
			if (!checkers_pidfile)
				checkers_pidfile = KEEPALIVED_PID_DIR CHECKERS_PID_FILE PID_EXTENSION;
#endif
#ifdef _WITH_VRRP_
			if (!vrrp_pidfile)
				vrrp_pidfile = KEEPALIVED_PID_DIR VRRP_PID_FILE PID_EXTENSION;
#endif
#ifdef _WITH_BFD_
			if (!bfd_pidfile)
				bfd_pidfile = KEEPALIVED_PID_DIR BFD_PID_FILE PID_EXTENSION;
#endif
		}
		else
		{
			if (!main_pidfile)
				main_pidfile = PID_DIR KEEPALIVED_PID_FILE PID_EXTENSION;
#ifdef _WITH_LVS_
			if (!checkers_pidfile)
				checkers_pidfile = PID_DIR CHECKERS_PID_FILE PID_EXTENSION;
#endif
#ifdef _WITH_VRRP_
			if (!vrrp_pidfile)
				vrrp_pidfile = PID_DIR VRRP_PID_FILE PID_EXTENSION;
#endif
#ifdef _WITH_BFD_
			if (!bfd_pidfile)
				bfd_pidfile = PID_DIR BFD_PID_FILE PID_EXTENSION;
#endif
		}

		
		if (keepalived_running(daemon_mode)) {
			log_message(LOG_INFO, ""daemon is already running"");
			report_stopped = false;
			goto end;
		}
	}

	
	if (!__test_bit(DONT_FORK_BIT, &debug) &&
	    xdaemon(false, false, true) > 0) {
		closelog();
		FREE_PTR(config_id);
		FREE_PTR(orig_core_dump_pattern);
		close_std_fd();
		exit(0);
	}

#ifdef _MEM_CHECK_
	enable_mem_log_termination();
#endif

	if (__test_bit(CONFIG_TEST_BIT, &debug)) {
		validate_config();

		config_test_exit();
	}

	
	if (!pidfile_write(main_pidfile, getpid()))
		goto end;

	
	master = thread_make_master();

	
	signal_init();

	
	if (!start_keepalived())
		log_message(LOG_INFO, ""Warning - keepalived has no configuration to run"");

	initialise_debug_options();

#ifdef THREAD_DUMP
	register_parent_thread_addresses();
#endif

	
	launch_thread_scheduler(master);

	
	stop_keepalived();

#ifdef THREAD_DUMP
	deregister_thread_addresses();
#endif

	
end:
	if (report_stopped) {
#ifdef GIT_COMMIT
		log_message(LOG_INFO, ""Stopped %s, git commit %s"", version_string, GIT_COMMIT);
#else
		log_message(LOG_INFO, ""Stopped %s"", version_string);
#endif
	}

#if HAVE_DECL_CLONE_NEWNET
	if (global_data && global_data->network_namespace)
		clear_namespaces();
#endif

	if (use_pid_dir)
		remove_pid_dir();

	
	if (orig_core_dump_pattern)
		update_core_dump_pattern(orig_core_dump_pattern);

	free_parent_mallocs_startup(false);
	free_parent_mallocs_exit();
	free_global_data(global_data);

	closelog();

#ifndef _MEM_CHECK_LOG_
	FREE_PTR(syslog_ident);
#else
	if (syslog_ident)
		free(syslog_ident);
#endif
	close_std_fd();

	exit(KEEPALIVED_EXIT_OK);
}
","1. char *end;
2. openlog(PACKAGE_NAME, LOG_PID, log_facility);
3. os_minor = (unsigned)strtoul(end + 1, &end, 10);
4. os_major = 0;
5. if (!os_major)
6. openlog(PACKAGE_NAME, LOG_PID | ((__test_bit(LOG_CONSOLE_BIT, &debug)) ? LOG_CONS : 0) , log_facility);
7. (LINUX_VERSION_CODE >> 16) & 0xff,
(LINUX_VERSION_CODE >>  8) & 0xff,
8. main_pidfile = PID_DIR KEEPALIVED_PID_FILE PID_EXTENSION;
9. initialise_debug_options();
10. free_global_data(global_data);","6
38
52
57
62
81
100-101
232
289
332","CWE-190,CWE-20,CWE-399"
ceph_x_verify_authorizer_reply,"static int ceph_x_verify_authorizer_reply(struct ceph_auth_client *ac,
					  struct ceph_authorizer *a, size_t len)
{
	struct ceph_x_authorizer *au = (void *)a;
 	struct ceph_x_ticket_handler *th;
 	int ret = 0;
 	struct ceph_x_authorize_reply reply;
	void *preply = &reply;
 	void *p = au->reply_buf;
 	void *end = p + sizeof(au->reply_buf);
 
 	th = get_ticket_handler(ac, au->service);
 	if (IS_ERR(th))
 		return PTR_ERR(th);
	ret = ceph_x_decrypt(&th->session_key, &p, end, &preply, sizeof(reply));
 	if (ret < 0)
 		return ret;
 	if (ret != sizeof(reply))
		return -EPERM;

	if (au->nonce + 1 != le64_to_cpu(reply.nonce_plus_one))
		ret = -EPERM;
	else
		ret = 0;
	dout(""verify_authorizer_reply nonce %llx got %llx ret %d\n"",
	     au->nonce, le64_to_cpu(reply.nonce_plus_one), ret);
	return ret;
}
","1. struct ceph_authorizer *a, size_t len)
2. void *preply = &reply;
void *p = au->reply_buf;
3. th = get_ticket_handler(ac, au->service);
4. if (ret < 0)
5. if (ret != sizeof(reply))","2
8-9
12
16
18","CWE-119,CWE-264,CWE-79,CWE-416"
__filterShell-34409988526709,"static char *__filterShell(const char *arg) {
	r_return_val_if_fail (arg, NULL);
	char *a = malloc (strlen (arg) + 1);
	if (!a) {
		return NULL;
	}
	char *b = a;
	while (*arg) {
		char ch = *arg;
		switch (ch) {
		case '@':
		case '`':
		case '|':
		case ';':
		case '=':
		case '\n':
			break;
		default:
			*b++ = ch;
			break;
		}
		arg++;
	}
	*b = 0;
	return a;
}
","1. if (!a) {
2. char *b = a;
3. char ch = *arg;
switch (ch) {
4. default:
5. return a;","4
7
9-10
18
25","CWE-772,CWE-78,CWE-787,CWE-119,CWE-125"
ihevcd_parse_slice_header_1,"IHEVCD_ERROR_T ihevcd_parse_slice_header_1(codec_t *ps_codec,
 nal_header_t *ps_nal)
{
    IHEVCD_ERROR_T ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS;
    WORD32 value;
    WORD32 i, j;
    WORD32 sps_id;

 pps_t *ps_pps;
 sps_t *ps_sps;
 slice_header_t *ps_slice_hdr;
    WORD32 disable_deblocking_filter_flag;
 bitstrm_t *ps_bitstrm = &ps_codec->s_parse.s_bitstrm;
    WORD32 idr_pic_flag;
    WORD32 pps_id;
    WORD32 first_slice_in_pic_flag;
    WORD32 no_output_of_prior_pics_flag = 0;

     WORD8 i1_nal_unit_type = ps_nal->i1_nal_unit_type;
     WORD32 num_poc_total_curr = 0;
     WORD32 slice_address;
    WORD32 prev_slice_incomplete_flag = 0;
 
     if(ps_codec->i4_slice_error == 1)
         return ret;

    idr_pic_flag = (NAL_IDR_W_LP == i1_nal_unit_type) ||
 (NAL_IDR_N_LP == i1_nal_unit_type);


    BITS_PARSE(""first_slice_in_pic_flag"", first_slice_in_pic_flag, ps_bitstrm, 1);
 if((NAL_BLA_W_LP <= i1_nal_unit_type) &&
 (NAL_RSV_RAP_VCL23          >= i1_nal_unit_type))
 {
        BITS_PARSE(""no_output_of_prior_pics_flag"", no_output_of_prior_pics_flag, ps_bitstrm, 1);
 }
    UEV_PARSE(""pic_parameter_set_id"", pps_id, ps_bitstrm);
    pps_id = CLIP3(pps_id, 0, MAX_PPS_CNT - 2);

 
    ps_pps = ps_codec->s_parse.ps_pps_base + pps_id;
 if(0 == ps_pps->i1_pps_valid)
 {
 pps_t *ps_pps_ref = ps_codec->ps_pps_base;
 while(0 == ps_pps_ref->i1_pps_valid)
 {
            ps_pps_ref++;
 if((ps_pps_ref - ps_codec->ps_pps_base >= MAX_PPS_CNT - 1))
 return IHEVCD_INVALID_HEADER;
 }

        ihevcd_copy_pps(ps_codec, pps_id, ps_pps_ref->i1_pps_id);
 }

 
    sps_id = ps_pps->i1_sps_id;

 
    ps_sps = ps_codec->s_parse.ps_sps_base + sps_id;

 
 if((0 != ps_codec->u4_pic_cnt || ps_codec->i4_pic_present) &&
                    first_slice_in_pic_flag)
 {
 if(ps_codec->i4_pic_present)
 {
 slice_header_t *ps_slice_hdr_next;
            ps_codec->i4_slice_error = 1;
            ps_codec->s_parse.i4_cur_slice_idx--;
 if(ps_codec->s_parse.i4_cur_slice_idx < 0)
                ps_codec->s_parse.i4_cur_slice_idx = 0;

            ps_slice_hdr_next = ps_codec->s_parse.ps_slice_hdr_base + ((ps_codec->s_parse.i4_cur_slice_idx + 1) & (MAX_SLICE_HDR_CNT - 1));
            ps_slice_hdr_next->i2_ctb_x = 0;
            ps_slice_hdr_next->i2_ctb_y = ps_codec->s_parse.ps_sps->i2_pic_ht_in_ctb;
 return ret;
 }
 else
 {
            ps_codec->i4_slice_error = 0;
 }
 }

 if(first_slice_in_pic_flag)
 {
        ps_codec->s_parse.i4_cur_slice_idx = 0;
 }
 else
 {
 
 if(0 == ps_codec->i4_pic_present)
            ps_codec->s_parse.i4_cur_slice_idx = 1;
 }

    ps_slice_hdr = ps_codec->s_parse.ps_slice_hdr_base + (ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1));


 if((ps_pps->i1_dependent_slice_enabled_flag) &&
 (!first_slice_in_pic_flag))
 {
        BITS_PARSE(""dependent_slice_flag"", value, ps_bitstrm, 1);

 
 if(value && (ps_codec->s_parse.i4_cur_slice_idx > 0))
 {
            ihevcd_copy_slice_hdr(ps_codec,
 (ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1)),
 ((ps_codec->s_parse.i4_cur_slice_idx - 1) & (MAX_SLICE_HDR_CNT - 1)));
 }
        ps_slice_hdr->i1_dependent_slice_flag = value;
 }
 else
 {
        ps_slice_hdr->i1_dependent_slice_flag = 0;
 }
    ps_slice_hdr->i1_nal_unit_type = i1_nal_unit_type;
    ps_slice_hdr->i1_pps_id = pps_id;
    ps_slice_hdr->i1_first_slice_in_pic_flag = first_slice_in_pic_flag;

    ps_slice_hdr->i1_no_output_of_prior_pics_flag = 1;
 if((NAL_BLA_W_LP <= i1_nal_unit_type) &&
 (NAL_RSV_RAP_VCL23          >= i1_nal_unit_type))
 {
        ps_slice_hdr->i1_no_output_of_prior_pics_flag = no_output_of_prior_pics_flag;
 }
    ps_slice_hdr->i1_pps_id = pps_id;

 if(!ps_slice_hdr->i1_first_slice_in_pic_flag)
 {
        WORD32 num_bits;

 
        num_bits = 32 - CLZ(ps_sps->i4_pic_size_in_ctb - 1);
        BITS_PARSE(""slice_address"", value, ps_bitstrm, num_bits);

        slice_address = value;
 
 if(value >= ps_sps->i4_pic_size_in_ctb)
 return IHEVCD_IGNORE_SLICE;
 }
 else
 {
        slice_address = 0;
 }

 if(!ps_slice_hdr->i1_dependent_slice_flag)
 {
        ps_slice_hdr->i1_pic_output_flag = 1;
        ps_slice_hdr->i4_pic_order_cnt_lsb = 0;
        ps_slice_hdr->i1_num_long_term_sps = 0;
        ps_slice_hdr->i1_num_long_term_pics = 0;

 for(i = 0; i < ps_pps->i1_num_extra_slice_header_bits; i++)
 {
            BITS_PARSE(""slice_reserved_undetermined_flag[ i ]"", value, ps_bitstrm, 1);
 }
        UEV_PARSE(""slice_type"", value, ps_bitstrm);
        ps_slice_hdr->i1_slice_type = value;

 
 if((ps_slice_hdr->i1_nal_unit_type >= NAL_BLA_W_LP) &&
 (ps_slice_hdr->i1_nal_unit_type <= NAL_RSV_RAP_VCL23))
            ps_slice_hdr->i1_slice_type = ISLICE;

 if((ps_slice_hdr->i1_slice_type < 0) ||
 (ps_slice_hdr->i1_slice_type > 2))
 return IHEVCD_IGNORE_SLICE;

 if(ps_pps->i1_output_flag_present_flag)
 {
            BITS_PARSE(""pic_output_flag"", value, ps_bitstrm, 1);
            ps_slice_hdr->i1_pic_output_flag = value;
 }
        ps_slice_hdr->i1_colour_plane_id = 0;
 if(1 == ps_sps->i1_separate_colour_plane_flag)
 {
            BITS_PARSE(""colour_plane_id"", value, ps_bitstrm, 2);
            ps_slice_hdr->i1_colour_plane_id = value;
 }
        ps_slice_hdr->i1_slice_temporal_mvp_enable_flag = 0;

 if(!idr_pic_flag)
 {

            WORD32 st_rps_idx;
            WORD32 num_neg_pics;
            WORD32 num_pos_pics;
            WORD8 *pi1_used;

            BITS_PARSE(""pic_order_cnt_lsb"", value, ps_bitstrm, ps_sps->i1_log2_max_pic_order_cnt_lsb);
            ps_slice_hdr->i4_pic_order_cnt_lsb = value;

            BITS_PARSE(""short_term_ref_pic_set_sps_flag"", value, ps_bitstrm, 1);
            ps_slice_hdr->i1_short_term_ref_pic_set_sps_flag = value;

 if(1 == ps_slice_hdr->i1_short_term_ref_pic_set_sps_flag)
 {
                WORD32 numbits;

                ps_slice_hdr->i1_short_term_ref_pic_set_idx = 0;
 if(ps_sps->i1_num_short_term_ref_pic_sets > 1)
 {
                    numbits = 32 - CLZ(ps_sps->i1_num_short_term_ref_pic_sets - 1);
                    BITS_PARSE(""short_term_ref_pic_set_idx"", value, ps_bitstrm, numbits);
                    ps_slice_hdr->i1_short_term_ref_pic_set_idx = value;
 }

                st_rps_idx = ps_slice_hdr->i1_short_term_ref_pic_set_idx;
                num_neg_pics = ps_sps->as_stref_picset[st_rps_idx].i1_num_neg_pics;
                num_pos_pics = ps_sps->as_stref_picset[st_rps_idx].i1_num_pos_pics;
                pi1_used = ps_sps->as_stref_picset[st_rps_idx].ai1_used;
 }
 else
 {
                ihevcd_short_term_ref_pic_set(ps_bitstrm,
 &ps_sps->as_stref_picset[0],
                                              ps_sps->i1_num_short_term_ref_pic_sets,
                                              ps_sps->i1_num_short_term_ref_pic_sets,
 &ps_slice_hdr->s_stref_picset);

                st_rps_idx = ps_sps->i1_num_short_term_ref_pic_sets;
                num_neg_pics = ps_slice_hdr->s_stref_picset.i1_num_neg_pics;
                num_pos_pics = ps_slice_hdr->s_stref_picset.i1_num_pos_pics;
                pi1_used = ps_slice_hdr->s_stref_picset.ai1_used;
 }

 if(ps_sps->i1_long_term_ref_pics_present_flag)
 {
 if(ps_sps->i1_num_long_term_ref_pics_sps > 0)
 {
                    UEV_PARSE(""num_long_term_sps"", value, ps_bitstrm);
                    ps_slice_hdr->i1_num_long_term_sps = value;

                    ps_slice_hdr->i1_num_long_term_sps = CLIP3(ps_slice_hdr->i1_num_long_term_sps,
 0, MAX_DPB_SIZE - num_neg_pics - num_pos_pics);
 }
                UEV_PARSE(""num_long_term_pics"", value, ps_bitstrm);
                ps_slice_hdr->i1_num_long_term_pics = value;
                ps_slice_hdr->i1_num_long_term_pics = CLIP3(ps_slice_hdr->i1_num_long_term_pics,
 0, MAX_DPB_SIZE - num_neg_pics - num_pos_pics -
                                                            ps_slice_hdr->i1_num_long_term_sps);

 for(i = 0; i < (ps_slice_hdr->i1_num_long_term_sps +
                                ps_slice_hdr->i1_num_long_term_pics); i++)
 {
 if(i < ps_slice_hdr->i1_num_long_term_sps)
 {
 
 if (ps_sps->i1_num_long_term_ref_pics_sps > 1)
 {
                            WORD32 num_bits = 32 - CLZ(ps_sps->i1_num_long_term_ref_pics_sps - 1);
                            BITS_PARSE(""lt_idx_sps[ i ]"", value, ps_bitstrm, num_bits);
 }
 else
 {
                            value = 0;
 }
                        ps_slice_hdr->ai4_poc_lsb_lt[i] = ps_sps->au2_lt_ref_pic_poc_lsb_sps[value];
                        ps_slice_hdr->ai1_used_by_curr_pic_lt_flag[i] = ps_sps->ai1_used_by_curr_pic_lt_sps_flag[value];

 }
 else
 {
                        BITS_PARSE(""poc_lsb_lt[ i ]"", value, ps_bitstrm, ps_sps->i1_log2_max_pic_order_cnt_lsb);
                        ps_slice_hdr->ai4_poc_lsb_lt[i] = value;

                        BITS_PARSE(""used_by_curr_pic_lt_flag[ i ]"", value, ps_bitstrm, 1);
                        ps_slice_hdr->ai1_used_by_curr_pic_lt_flag[i] = value;

 }
                    BITS_PARSE(""delta_poc_msb_present_flag[ i ]"", value, ps_bitstrm, 1);
                    ps_slice_hdr->ai1_delta_poc_msb_present_flag[i] = value;


                    ps_slice_hdr->ai1_delta_poc_msb_cycle_lt[i] = 0;
 if(ps_slice_hdr->ai1_delta_poc_msb_present_flag[i])
 {

                        UEV_PARSE(""delata_poc_msb_cycle_lt[ i ]"", value, ps_bitstrm);
                        ps_slice_hdr->ai1_delta_poc_msb_cycle_lt[i] = value;
 }

 if((i != 0) && (i != ps_slice_hdr->i1_num_long_term_sps))
 {
                        ps_slice_hdr->ai1_delta_poc_msb_cycle_lt[i] += ps_slice_hdr->ai1_delta_poc_msb_cycle_lt[i - 1];
 }

 }
 }

 for(i = 0; i < num_neg_pics + num_pos_pics; i++)
 {
 if(pi1_used[i])
 {
                    num_poc_total_curr++;
 }
 }
 for(i = 0; i < ps_slice_hdr->i1_num_long_term_sps + ps_slice_hdr->i1_num_long_term_pics; i++)
 {
 if(ps_slice_hdr->ai1_used_by_curr_pic_lt_flag[i])
 {
                    num_poc_total_curr++;
 }
 }


 if(ps_sps->i1_sps_temporal_mvp_enable_flag)
 {
                BITS_PARSE(""enable_temporal_mvp_flag"", value, ps_bitstrm, 1);
                ps_slice_hdr->i1_slice_temporal_mvp_enable_flag = value;
 }

 }
        ps_slice_hdr->i1_slice_sao_luma_flag = 0;
        ps_slice_hdr->i1_slice_sao_chroma_flag = 0;
 if(ps_sps->i1_sample_adaptive_offset_enabled_flag)
 {
            BITS_PARSE(""slice_sao_luma_flag"", value, ps_bitstrm, 1);
            ps_slice_hdr->i1_slice_sao_luma_flag = value;

            BITS_PARSE(""slice_sao_chroma_flag"", value, ps_bitstrm, 1);
            ps_slice_hdr->i1_slice_sao_chroma_flag = value;

 }

        ps_slice_hdr->i1_max_num_merge_cand = 1;
        ps_slice_hdr->i1_cabac_init_flag = 0;

        ps_slice_hdr->i1_num_ref_idx_l0_active = 0;
        ps_slice_hdr->i1_num_ref_idx_l1_active = 0;
        ps_slice_hdr->i1_slice_cb_qp_offset = 0;
        ps_slice_hdr->i1_slice_cr_qp_offset = 0;
 if((PSLICE == ps_slice_hdr->i1_slice_type) ||
 (BSLICE == ps_slice_hdr->i1_slice_type))
 {
            BITS_PARSE(""num_ref_idx_active_override_flag"", value, ps_bitstrm, 1);
            ps_slice_hdr->i1_num_ref_idx_active_override_flag = value;

 if(ps_slice_hdr->i1_num_ref_idx_active_override_flag)
 {
                UEV_PARSE(""num_ref_idx_l0_active_minus1"", value, ps_bitstrm);
                ps_slice_hdr->i1_num_ref_idx_l0_active = value + 1;

 if(BSLICE == ps_slice_hdr->i1_slice_type)
 {
                    UEV_PARSE(""num_ref_idx_l1_active_minus1"", value, ps_bitstrm);
                    ps_slice_hdr->i1_num_ref_idx_l1_active = value + 1;
 }

 }
 else
 {
                ps_slice_hdr->i1_num_ref_idx_l0_active = ps_pps->i1_num_ref_idx_l0_default_active;

 if(BSLICE == ps_slice_hdr->i1_slice_type)
 {
                    ps_slice_hdr->i1_num_ref_idx_l1_active = ps_pps->i1_num_ref_idx_l1_default_active;
 }
 }

            ps_slice_hdr->i1_num_ref_idx_l0_active = CLIP3(ps_slice_hdr->i1_num_ref_idx_l0_active, 0, MAX_DPB_SIZE - 1);
            ps_slice_hdr->i1_num_ref_idx_l1_active = CLIP3(ps_slice_hdr->i1_num_ref_idx_l1_active, 0, MAX_DPB_SIZE - 1);

 if(0 == num_poc_total_curr)
 return IHEVCD_IGNORE_SLICE;
 if((ps_pps->i1_lists_modification_present_flag) && (num_poc_total_curr > 1))
 {
                ihevcd_ref_pic_list_modification(ps_bitstrm,
                                                 ps_slice_hdr, num_poc_total_curr);
 }
 else
 {
                ps_slice_hdr->s_rplm.i1_ref_pic_list_modification_flag_l0 = 0;
                ps_slice_hdr->s_rplm.i1_ref_pic_list_modification_flag_l1 = 0;
 }

 if(BSLICE == ps_slice_hdr->i1_slice_type)
 {
                BITS_PARSE(""mvd_l1_zero_flag"", value, ps_bitstrm, 1);
                ps_slice_hdr->i1_mvd_l1_zero_flag = value;
 }

            ps_slice_hdr->i1_cabac_init_flag = 0;
 if(ps_pps->i1_cabac_init_present_flag)
 {
                BITS_PARSE(""cabac_init_flag"", value, ps_bitstrm, 1);
                ps_slice_hdr->i1_cabac_init_flag = value;

 }
            ps_slice_hdr->i1_collocated_from_l0_flag = 1;
            ps_slice_hdr->i1_collocated_ref_idx = 0;
 if(ps_slice_hdr->i1_slice_temporal_mvp_enable_flag)
 {
 if(BSLICE == ps_slice_hdr->i1_slice_type)
 {
                    BITS_PARSE(""collocated_from_l0_flag"", value, ps_bitstrm, 1);
                    ps_slice_hdr->i1_collocated_from_l0_flag = value;
 }

 if((ps_slice_hdr->i1_collocated_from_l0_flag  && (ps_slice_hdr->i1_num_ref_idx_l0_active > 1)) ||
 (!ps_slice_hdr->i1_collocated_from_l0_flag  && (ps_slice_hdr->i1_num_ref_idx_l1_active > 1)))
 {
                    UEV_PARSE(""collocated_ref_idx"", value, ps_bitstrm);
                    ps_slice_hdr->i1_collocated_ref_idx = value;
 }

 }
            ps_slice_hdr->i1_collocated_ref_idx = CLIP3(ps_slice_hdr->i1_collocated_ref_idx, 0, MAX_DPB_SIZE - 1);

 if((ps_pps->i1_weighted_pred_flag  && (PSLICE == ps_slice_hdr->i1_slice_type)) ||
 (ps_pps->i1_weighted_bipred_flag  && (BSLICE == ps_slice_hdr->i1_slice_type)))
 {
                ihevcd_parse_pred_wt_ofst(ps_bitstrm, ps_sps, ps_pps, ps_slice_hdr);
 }
            UEV_PARSE(""five_minus_max_num_merge_cand"", value, ps_bitstrm);
            ps_slice_hdr->i1_max_num_merge_cand = 5 - value;

 }
        ps_slice_hdr->i1_max_num_merge_cand = CLIP3(ps_slice_hdr->i1_max_num_merge_cand, 1, 5);
        SEV_PARSE(""slice_qp_delta"", value, ps_bitstrm);
        ps_slice_hdr->i1_slice_qp_delta = value;

 if(ps_pps->i1_pic_slice_level_chroma_qp_offsets_present_flag)
 {
            SEV_PARSE(""slice_cb_qp_offset"", value, ps_bitstrm);
            ps_slice_hdr->i1_slice_cb_qp_offset = value;

            SEV_PARSE(""slice_cr_qp_offset"", value, ps_bitstrm);
            ps_slice_hdr->i1_slice_cr_qp_offset = value;

 }
        ps_slice_hdr->i1_deblocking_filter_override_flag = 0;
        ps_slice_hdr->i1_slice_disable_deblocking_filter_flag  = ps_pps->i1_pic_disable_deblocking_filter_flag;
        ps_slice_hdr->i1_beta_offset_div2 = ps_pps->i1_beta_offset_div2;
        ps_slice_hdr->i1_tc_offset_div2 = ps_pps->i1_tc_offset_div2;

        disable_deblocking_filter_flag = ps_pps->i1_pic_disable_deblocking_filter_flag;

 if(ps_pps->i1_deblocking_filter_control_present_flag)
 {

 if(ps_pps->i1_deblocking_filter_override_enabled_flag)
 {
                BITS_PARSE(""deblocking_filter_override_flag"", value, ps_bitstrm, 1);
                ps_slice_hdr->i1_deblocking_filter_override_flag = value;
 }

 if(ps_slice_hdr->i1_deblocking_filter_override_flag)
 {
                BITS_PARSE(""slice_disable_deblocking_filter_flag"", value, ps_bitstrm, 1);
                ps_slice_hdr->i1_slice_disable_deblocking_filter_flag = value;
                disable_deblocking_filter_flag = ps_slice_hdr->i1_slice_disable_deblocking_filter_flag;

 if(!ps_slice_hdr->i1_slice_disable_deblocking_filter_flag)
 {
                    SEV_PARSE(""beta_offset_div2"", value, ps_bitstrm);
                    ps_slice_hdr->i1_beta_offset_div2 = value;

                    SEV_PARSE(""tc_offset_div2"", value, ps_bitstrm);
                    ps_slice_hdr->i1_tc_offset_div2 = value;

 }
 }
 }

        ps_slice_hdr->i1_slice_loop_filter_across_slices_enabled_flag = ps_pps->i1_loop_filter_across_slices_enabled_flag;
 if(ps_pps->i1_loop_filter_across_slices_enabled_flag  &&
 (ps_slice_hdr->i1_slice_sao_luma_flag  ||  ps_slice_hdr->i1_slice_sao_chroma_flag  || !disable_deblocking_filter_flag))
 {
            BITS_PARSE(""slice_loop_filter_across_slices_enabled_flag"", value, ps_bitstrm, 1);
            ps_slice_hdr->i1_slice_loop_filter_across_slices_enabled_flag = value;
 }

 }

 
 if((!first_slice_in_pic_flag) &&
 (ps_codec->i4_pic_present))
 {
 slice_header_t *ps_slice_hdr_base = ps_codec->ps_slice_hdr_base;


 
 if((ps_slice_hdr_base->i1_pps_id != ps_slice_hdr->i1_pps_id) ||
 (ps_slice_hdr_base->i4_pic_order_cnt_lsb != ps_slice_hdr->i4_pic_order_cnt_lsb))
 {
 return IHEVCD_IGNORE_SLICE;
 }

 }


 if(0 == ps_codec->i4_pic_present)
 {
        ps_slice_hdr->i4_abs_pic_order_cnt = ihevcd_calc_poc(ps_codec, ps_nal, ps_sps->i1_log2_max_pic_order_cnt_lsb, ps_slice_hdr->i4_pic_order_cnt_lsb);
 }
 else
 {
        ps_slice_hdr->i4_abs_pic_order_cnt = ps_codec->s_parse.i4_abs_pic_order_cnt;
 }


 if(!first_slice_in_pic_flag)
 {
 
 if(ps_codec->s_parse.i4_abs_pic_order_cnt == ps_slice_hdr->i4_abs_pic_order_cnt)
 {

 
 if(slice_address > ps_codec->s_parse.i4_next_ctb_indx)

             {
                 if(ps_codec->i4_pic_present)
                 {
                    prev_slice_incomplete_flag = 1;
                 }
                 else
                 {
 return IHEVCD_IGNORE_SLICE;
 }
 }
 
 else if(slice_address < ps_codec->s_parse.i4_next_ctb_indx)
 {
 return IHEVCD_IGNORE_SLICE;
 }
 else
 {
                ps_codec->i4_slice_error = 0;
 }
 }

 
 else
 {
 
 if(ps_codec->i4_pic_present)
 {
 slice_header_t *ps_slice_hdr_next;
                ps_codec->i4_slice_error = 1;
                ps_codec->s_parse.i4_cur_slice_idx--;
 if(ps_codec->s_parse.i4_cur_slice_idx < 0)
                    ps_codec->s_parse.i4_cur_slice_idx = 0;

                ps_slice_hdr_next = ps_codec->s_parse.ps_slice_hdr_base + ((ps_codec->s_parse.i4_cur_slice_idx + 1) & (MAX_SLICE_HDR_CNT - 1));
                ps_slice_hdr_next->i2_ctb_x = 0;
                ps_slice_hdr_next->i2_ctb_y = ps_codec->s_parse.ps_sps->i2_pic_ht_in_ctb;
 return ret;
 }

 
 else
 {
 if(ps_slice_hdr->i1_dependent_slice_flag)
 return IHEVCD_IGNORE_SLICE;

                ps_codec->s_parse.i4_abs_pic_order_cnt = ps_slice_hdr->i4_abs_pic_order_cnt;
 }
 }
 }

 
 else
 {
 
 if(ps_codec->s_parse.i4_abs_pic_order_cnt == ps_slice_hdr->i4_abs_pic_order_cnt)
 return IHEVCD_IGNORE_SLICE;

        ps_codec->s_parse.i4_abs_pic_order_cnt = ps_slice_hdr->i4_abs_pic_order_cnt;
 }

    ps_slice_hdr->i4_num_entry_point_offsets = 0;
 if((ps_pps->i1_tiles_enabled_flag) ||
 (ps_pps->i1_entropy_coding_sync_enabled_flag))
 {
        UEV_PARSE(""num_entry_point_offsets"", value, ps_bitstrm);
        ps_slice_hdr->i4_num_entry_point_offsets = value;

 {
            WORD32 max_num_entry_point_offsets;
 if((ps_pps->i1_tiles_enabled_flag) &&
 (ps_pps->i1_entropy_coding_sync_enabled_flag))
 {
                max_num_entry_point_offsets = ps_pps->i1_num_tile_columns * (ps_sps->i2_pic_ht_in_ctb - 1);
 }
 else if(ps_pps->i1_tiles_enabled_flag)
 {
                max_num_entry_point_offsets = ps_pps->i1_num_tile_columns * ps_pps->i1_num_tile_rows;
 }
 else
 {
                max_num_entry_point_offsets = (ps_sps->i2_pic_ht_in_ctb - 1);
 }

            ps_slice_hdr->i4_num_entry_point_offsets = CLIP3(ps_slice_hdr->i4_num_entry_point_offsets,
 0, max_num_entry_point_offsets);
 }

 if(ps_slice_hdr->i4_num_entry_point_offsets > 0)
 {
            UEV_PARSE(""offset_len_minus1"", value, ps_bitstrm);
            ps_slice_hdr->i1_offset_len = value + 1;

 for(i = 0; i < ps_slice_hdr->i4_num_entry_point_offsets; i++)
 {
                BITS_PARSE(""entry_point_offset"", value, ps_bitstrm, ps_slice_hdr->i1_offset_len);

 
 }

 }
 }

 if(ps_pps->i1_slice_header_extension_present_flag)
 {
        UEV_PARSE(""slice_header_extension_length"", value, ps_bitstrm);
        ps_slice_hdr->i2_slice_header_extension_length = value;


 for(i = 0; i < ps_slice_hdr->i2_slice_header_extension_length; i++)
 {
            BITS_PARSE(""slice_header_extension_data_byte"", value, ps_bitstrm, 8);
 }

 }

    ihevcd_bits_flush_to_byte_boundary(ps_bitstrm);

 if((UWORD8 *)ps_bitstrm->pu4_buf > ps_bitstrm->pu1_buf_max)
 return IHEVCD_INVALID_PARAMETER;

 {
 dpb_mgr_t *ps_dpb_mgr = (dpb_mgr_t *)ps_codec->pv_dpb_mgr;
        WORD32 r_idx;

 if((NAL_IDR_W_LP == ps_slice_hdr->i1_nal_unit_type) ||
 (NAL_IDR_N_LP == ps_slice_hdr->i1_nal_unit_type) ||
 (NAL_BLA_N_LP == ps_slice_hdr->i1_nal_unit_type) ||
 (NAL_BLA_W_DLP == ps_slice_hdr->i1_nal_unit_type) ||
 (NAL_BLA_W_LP == ps_slice_hdr->i1_nal_unit_type) ||
 (0 == ps_codec->u4_pic_cnt))
 {
 for(i = 0; i < MAX_DPB_BUFS; i++)
 {
 if(ps_dpb_mgr->as_dpb_info[i].ps_pic_buf)
 {
 pic_buf_t *ps_pic_buf = ps_dpb_mgr->as_dpb_info[i].ps_pic_buf;
 mv_buf_t *ps_mv_buf;

 
                    ihevc_dpb_mgr_del_ref((dpb_mgr_t *)ps_codec->pv_dpb_mgr, (buf_mgr_t *)ps_codec->pv_pic_buf_mgr, ps_pic_buf->i4_abs_poc);
 
                    ps_mv_buf = (mv_buf_t *)ps_codec->ps_mv_buf;
 for(j = 0; j < ps_codec->i4_max_dpb_size; j++)
 {
 if(ps_mv_buf && ps_mv_buf->i4_abs_poc == ps_pic_buf->i4_abs_poc)
 {
                            ihevc_buf_mgr_release((buf_mgr_t *)ps_codec->pv_mv_buf_mgr, j, BUF_MGR_REF);
 break;
 }
                        ps_mv_buf++;
 }

 }

 }

 
 for(r_idx = 0; r_idx < MAX_DPB_SIZE; r_idx++)
 {
                ps_slice_hdr->as_ref_pic_list0[r_idx].pv_pic_buf = NULL;
                ps_slice_hdr->as_ref_pic_list0[r_idx].pv_mv_buf = NULL;

                ps_slice_hdr->as_ref_pic_list1[r_idx].pv_pic_buf = NULL;
                ps_slice_hdr->as_ref_pic_list1[r_idx].pv_mv_buf = NULL;
 }

 }
 else
 {
            ret = ihevcd_ref_list(ps_codec, ps_pps, ps_sps, ps_slice_hdr);
 if ((WORD32)IHEVCD_SUCCESS != ret)
 {
 return ret;
 }

 }

 }

 
 if(ps_codec->i4_pic_present)
 {
 pic_buf_t *ps_pic_buf_ref;
 mv_buf_t *ps_mv_buf_ref;
        WORD32 r_idx;
 dpb_mgr_t *ps_dpb_mgr = (dpb_mgr_t *)ps_codec->pv_dpb_mgr;
 buf_mgr_t *ps_mv_buf_mgr = (buf_mgr_t *)ps_codec->pv_mv_buf_mgr;

        ps_pic_buf_ref = ihevc_dpb_mgr_get_ref_by_nearest_poc(ps_dpb_mgr, ps_slice_hdr->i4_abs_pic_order_cnt);
 if(NULL == ps_pic_buf_ref)
 {
            ps_pic_buf_ref = ps_codec->as_process[0].ps_cur_pic;
            ps_mv_buf_ref = ps_codec->s_parse.ps_cur_mv_buf;
 }
 else
 {
            ps_mv_buf_ref = ihevcd_mv_mgr_get_poc(ps_mv_buf_mgr, ps_pic_buf_ref->i4_abs_poc);
 }

 for(r_idx = 0; r_idx < ps_slice_hdr->i1_num_ref_idx_l0_active; r_idx++)
 {
 if(NULL == ps_slice_hdr->as_ref_pic_list0[r_idx].pv_pic_buf)
 {
                ps_slice_hdr->as_ref_pic_list0[r_idx].pv_pic_buf = (void *)ps_pic_buf_ref;
                ps_slice_hdr->as_ref_pic_list0[r_idx].pv_mv_buf = (void *)ps_mv_buf_ref;
 }
 }

 for(r_idx = ps_slice_hdr->i1_num_ref_idx_l0_active; r_idx < MAX_DPB_SIZE; r_idx++)
 {
            ps_slice_hdr->as_ref_pic_list0[r_idx].pv_pic_buf = (void *)ps_pic_buf_ref;
            ps_slice_hdr->as_ref_pic_list0[r_idx].pv_mv_buf = (void *)ps_mv_buf_ref;
 }

 for(r_idx = 0; r_idx < ps_slice_hdr->i1_num_ref_idx_l1_active; r_idx++)
 {
 if(NULL == ps_slice_hdr->as_ref_pic_list1[r_idx].pv_pic_buf)
 {
                ps_slice_hdr->as_ref_pic_list1[r_idx].pv_pic_buf = (void *)ps_pic_buf_ref;
                ps_slice_hdr->as_ref_pic_list1[r_idx].pv_mv_buf = (void *)ps_mv_buf_ref;
 }
 }

 for(r_idx = ps_slice_hdr->i1_num_ref_idx_l1_active; r_idx < MAX_DPB_SIZE; r_idx++)
 {
            ps_slice_hdr->as_ref_pic_list1[r_idx].pv_pic_buf = (void *)ps_pic_buf_ref;
            ps_slice_hdr->as_ref_pic_list1[r_idx].pv_mv_buf = (void *)ps_mv_buf_ref;
 }
 }

 
 if(!ps_slice_hdr->i1_first_slice_in_pic_flag)
 {
        ps_slice_hdr->i2_ctb_x = slice_address % ps_sps->i2_pic_wd_in_ctb;
        ps_slice_hdr->i2_ctb_y = slice_address / ps_sps->i2_pic_wd_in_ctb;

 if(!ps_slice_hdr->i1_dependent_slice_flag)
 {
            ps_slice_hdr->i2_independent_ctb_x = ps_slice_hdr->i2_ctb_x;
            ps_slice_hdr->i2_independent_ctb_y = ps_slice_hdr->i2_ctb_y;
 }
 }
 else
 {
        ps_slice_hdr->i2_ctb_x = 0;
        ps_slice_hdr->i2_ctb_y = 0;

        ps_slice_hdr->i2_independent_ctb_x = 0;
        ps_slice_hdr->i2_independent_ctb_y = 0;
 }

 
 if((!first_slice_in_pic_flag) &&
 (0 == ps_codec->i4_pic_present))
 {

         slice_header_t *ps_slice_hdr_prev = ps_codec->s_parse.ps_slice_hdr_base;
         ihevcd_copy_slice_hdr(ps_codec, 0, (ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1)));
 
        prev_slice_incomplete_flag = 1;
        ASSERT(ps_codec->s_parse.i4_cur_slice_idx == 1);
 
         ps_slice_hdr_prev->i2_ctb_x = 0;
         ps_slice_hdr_prev->i2_ctb_y = 0;

        ps_codec->s_parse.i4_ctb_x = 0;
        ps_codec->s_parse.i4_ctb_y = 0;

        ps_codec->s_parse.i4_cur_slice_idx = 0;

 if((ps_slice_hdr->i2_ctb_x == 0) &&
 (ps_slice_hdr->i2_ctb_y == 0))
 {
            ps_slice_hdr->i2_ctb_x++;
 }
 }

 {
 

 if((i1_nal_unit_type < NAL_BLA_W_LP) &&
 (i1_nal_unit_type % 2 == 0))
 {
 if(IVD_SKIP_B == ps_codec->e_pic_skip_mode)
 return IHEVCD_IGNORE_SLICE;
 }

 
 if((IVD_SKIP_PB == ps_codec->e_pic_skip_mode) &&
 (ISLICE != ps_slice_hdr->i1_slice_type))
 {
 return IHEVCD_IGNORE_SLICE;

         }
     }
 
    if(prev_slice_incomplete_flag)
    {
        ps_codec->i4_slice_error = 1;
        ps_codec->s_parse.i4_cur_slice_idx--;
        if(ps_codec->s_parse.i4_cur_slice_idx < 0)
            ps_codec->s_parse.i4_cur_slice_idx = 0;
    }

     return ret;
 }
","1. sps_id = ps_pps->i1_sps_id;
2. WORD32 num_bits;
3. WORD32 num_neg_pics;
4. num_pos_pics = ps_slice_hdr->s_stref_picset.i1_num_pos_pics;
5. if(i < ps_slice_hdr->i1_num_long_term_sps)
6. BITS_PARSE(""collocated_from_l0_flag"", value, ps_bitstrm, 1);
7. if((ps_slice_hdr_base->i1_pps_id != ps_slice_hdr->i1_pps_id) ||
8. if(ps_codec->i4_pic_present)
9. ps_slice_hdr_next = ps_codec->s_parse.ps_slice_hdr_base + ((ps_codec->s_parse.i4_cur_slice_idx + 1) & (MAX_SLICE_HDR_CNT - 1));
10. ps_codec->s_parse.i4_abs_pic_order_cnt = ps_slice_hdr->i4_abs_pic_order_cnt;
11. 0, max_num_entry_point_offsets);
12. WORD32 r_idx;
13. if((NAL_IDR_W_LP == ps_slice_hdr->i1_nal_unit_type) ||
14. if(ps_codec->i4_pic_present)
15. ps_slice_hdr->as_ref_pic_list1[r_idx].pv_mv_buf = (void *)ps_mv_buf_ref;
16. ps_codec->s_parse.i4_ctb_x = 0;","56
136
193
230
253
403
492
523
558
572
613
651
653
713
759
799","CWE-362,CWE-120,CWE-416,CWE-119,CWE-125"
perf_event_overflow-189045741577961,"int perf_event_overflow(struct perf_event *event,
			  struct perf_sample_data *data,
			  struct pt_regs *regs)
{
	return __perf_event_overflow(event, 1, data, regs);
}
","1. int perf_event_overflow(struct perf_event *event,
struct perf_sample_data *data,
struct pt_regs *regs)
2. return __perf_event_overflow(event, 1, data, regs);","1-3
5","CWE-190,CWE-400,CWE-119"
ed_mul_sim_joint-277776817466233,"void ed_mul_sim_joint(ed_t r, const ed_t p, const bn_t k, const ed_t q,
		const bn_t m) {
	ed_t t[5];
	int i, u_i, offset;
	int8_t jsf[2 * (RLC_FP_BITS + 1)];
	size_t l;

	if (bn_is_zero(k) || ed_is_infty(p)) {
		ed_mul(r, q, m);
		return;
	}
	if (bn_is_zero(m) || ed_is_infty(q)) {
		ed_mul(r, p, k);
		return;
	}

	RLC_TRY {
		for (i = 0; i < 5; i++) {
			ed_null(t[i]);
			ed_new(t[i]);
		}

		ed_set_infty(t[0]);
		ed_copy(t[1], q);
		if (bn_sign(m) == RLC_NEG) {
			ed_neg(t[1], t[1]);
		}
		ed_copy(t[2], p);
		if (bn_sign(k) == RLC_NEG) {
			ed_neg(t[2], t[2]);
		}
		ed_add(t[3], t[2], t[1]);
		ed_sub(t[4], t[2], t[1]);
#if defined(ED_MIXED)
		ed_norm_sim(t + 3, (const ed_t *)t + 3, 2);
#endif

		l = 2 * (RLC_FP_BITS + 1);
		bn_rec_jsf(jsf, &l, k, m);

		ed_set_infty(r);

		offset = RLC_MAX(bn_bits(k), bn_bits(m)) + 1;
		for (i = l - 1; i >= 0; i--) {
			ed_dbl(r, r);
			if (jsf[i] != 0 && jsf[i] == -jsf[i + offset]) {
				u_i = jsf[i] * 2 + jsf[i + offset];
				if (u_i < 0) {
					ed_sub(r, r, t[4]);
				} else {
					ed_add(r, r, t[4]);
				}
			} else {
				u_i = jsf[i] * 2 + jsf[i + offset];
				if (u_i < 0) {
					ed_sub(r, r, t[-u_i]);
				} else {
					ed_add(r, r, t[u_i]);
				}
			}
		}
		ed_norm(r, r);
	}
	RLC_CATCH_ANY {
		RLC_THROW(ERR_CAUGHT);
	}
	RLC_FINALLY {
		for (i = 0; i < 5; i++) {
			ed_free(t[i]);
		}
	}
}
","1. ed_null(t[i]);
2. u_i = jsf[i] * 2 + jsf[i + offset];","19
54","CWE-190,CWE-200"
snd_ctl_add-134051200544097,"int snd_ctl_add(struct snd_card *card, struct snd_kcontrol *kcontrol)
{
	struct snd_ctl_elem_id id;
	unsigned int idx;
	unsigned int count;
	int err = -EINVAL;

	if (! kcontrol)
		return err;
	if (snd_BUG_ON(!card || !kcontrol->info))
		goto error;
	id = kcontrol->id;
	down_write(&card->controls_rwsem);
	if (snd_ctl_find_id(card, &id)) {
		up_write(&card->controls_rwsem);
		dev_err(card->dev, ""control %i:%i:%i:%s:%i is already present\n"",
					id.iface,
					id.device,
					id.subdevice,
					id.name,
					id.index);
		err = -EBUSY;
		goto error;
	}
	if (snd_ctl_find_hole(card, kcontrol->count) < 0) {
		up_write(&card->controls_rwsem);
		err = -ENOMEM;
		goto error;
	}
	list_add_tail(&kcontrol->list, &card->controls);
	card->controls_count += kcontrol->count;
	kcontrol->id.numid = card->last_numid + 1;
	card->last_numid += kcontrol->count;
	count = kcontrol->count;
	up_write(&card->controls_rwsem);
	for (idx = 0; idx < count; idx++, id.index++, id.numid++)
		snd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_ADD, &id);
	return 0;

 error:
	snd_ctl_free_one(kcontrol);
	return err;
}
","1. int err = -EINVAL;
2. goto error;
3. if (snd_ctl_find_id(card, &id)) {
4. id.iface,
5. id.name,
id.index);
6. up_write(&card->controls_rwsem);
7. card->last_numid += kcontrol->count;
8. snd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_ADD, &id);","6
11
14
17
20-21
26
33
37","CWE-189,CWE-476,CWE-119,CWE-125,CWE-415"
rpl_dao_print,"rpl_dao_print(netdissect_options *ndo,
              const u_char *bp, u_int length)
{
        const struct nd_rpl_dao *dao = (const struct nd_rpl_dao *)bp;
        const char *dagid_str = ""<elided>"";

        ND_TCHECK(*dao);
        if (length < ND_RPL_DAO_MIN_LEN)
        	goto tooshort;

        bp += ND_RPL_DAO_MIN_LEN;
        length -= ND_RPL_DAO_MIN_LEN;
        if(RPL_DAO_D(dao->rpl_flags)) {
                ND_TCHECK2(dao->rpl_dagid, DAGID_LEN);
                if (length < DAGID_LEN)
                	goto tooshort;
                dagid_str = ip6addr_string (ndo, dao->rpl_dagid);
                bp += DAGID_LEN;
                length -= DAGID_LEN;
        }

        ND_PRINT((ndo, "" [dagid:%s,seq:%u,instance:%u%s%s,%02x]"",
                  dagid_str,
                  dao->rpl_daoseq,
                  dao->rpl_instanceid,
                  RPL_DAO_K(dao->rpl_flags) ? "",acK"":"""",
                  RPL_DAO_D(dao->rpl_flags) ? "",Dagid"":"""",
                  dao->rpl_flags));

        if(ndo->ndo_vflag > 1) {
                const struct rpl_dio_genoption *opt = (const struct rpl_dio_genoption *)bp;
                rpl_dio_printopt(ndo, opt, length);
        }
 	return;
 
 trunc:
	ND_PRINT((ndo, ""%s"", rpl_tstr));
 	return;
 
 tooshort:
	ND_PRINT((ndo,"" [|length too short]""));
	return;
}
","1. ND_TCHECK2(dao->rpl_dagid, DAGID_LEN);
2. rpl_dio_printopt(ndo, opt, length);
3. return;
4. return;","14
32
34
38",CWE-125
asn1_write_DATA_BLOB_LDAPString,"
#define DATA_BLOB

 bool asn1_write_DATA_BLOB_LDAPString(struct asn1_data *data, const DATA_BLOB *s)
 {
       return asn1_write(data, s->data, s->length);
 }
","1. bool asn1_write_DATA_BLOB_LDAPString(struct asn1_data *data, const DATA_BLOB *s)
2. return asn1_write(data, s->data, s->length);","4
6","CWE-200,CWE-125,CWE-399"
OpenURL-123361315136946,"void OpenURL(const char *url)
{
    
    if (strchr(url, '\'') != NULL) TRACELOG(LOG_WARNING, ""SYSTEM: Provided URL could be potentially malicious, avoid [\'] character"");
    else
    {
#if defined(PLATFORM_DESKTOP)
        char *cmd = (char *)RL_CALLOC(strlen(url) + 32, sizeof(char));
    #if defined(_WIN32)
        sprintf(cmd, ""explorer \""%s\"""", url);
    #endif
    #if defined(__linux__) || defined(__FreeBSD__) || defined(__OpenBSD__)
        sprintf(cmd, ""xdg-open '%s'"", url); 
    #endif
    #if defined(__APPLE__)
        sprintf(cmd, ""open '%s'"", url);
    #endif
        int result = system(cmd);
        if (result == -1) TRACELOG(LOG_WARNING, ""OpenURL() child process could not be created"");
        RL_FREE(cmd);
#endif
#if defined(PLATFORM_WEB)
        emscripten_run_script(TextFormat(""window.open('%s', '_blank')"", url));
#endif
#if defined(PLATFORM_ANDROID)
        JNIEnv *env = NULL;
        JavaVM *vm = CORE.Android.app->activity->vm;
        (*vm)->AttachCurrentThread(vm, &env, NULL);

        jstring urlString = (*env)->NewStringUTF(env, url);
        jclass uriClass = (*env)->FindClass(env, ""android/net/Uri"");
        jmethodID uriParse = (*env)->GetStaticMethodID(env, uriClass, ""parse"", ""(Ljava/lang/String;)Landroid/net/Uri;"");
        jobject uri = (*env)->CallStaticObjectMethod(env, uriClass, uriParse, urlString);

        jclass intentClass = (*env)->FindClass(env, ""android/content/Intent"");
        jfieldID actionViewId = (*env)->GetStaticFieldID(env, intentClass, ""ACTION_VIEW"", ""Ljava/lang/String;"");
        jobject actionView = (*env)->GetStaticObjectField(env, intentClass, actionViewId);
        jmethodID newIntent = (*env)->GetMethodID(env, intentClass, ""<init>"", ""(Ljava/lang/String;Landroid/net/Uri;)V"");
        jobject intent = (*env)->AllocObject(env, intentClass);

        (*env)->CallVoidMethod(env, intent, newIntent, actionView, uri);
        jclass activityClass = (*env)->FindClass(env, ""android/app/Activity"");
        jmethodID startActivity = (*env)->GetMethodID(env, activityClass, ""startActivity"", ""(Landroid/content/Intent;)V"");
        (*env)->CallVoidMethod(env, CORE.Android.app->activity->clazz, startActivity, intent);

        (*vm)->DetachCurrentThread(vm);
#endif
    }
}
","1. void OpenURL(const char *url)
2. if (strchr(url, '\'') != NULL) TRACELOG(LOG_WARNING, ""SYSTEM: Provided URL could be potentially malicious, avoid [\'] character"");
3. {","1
4
6","CWE-20,CWE-476,CWE-326,CWE-200,CWE-59"
btsock_rfc_signaled,"
#define UNUSED_ATTR

void btsock_rfc_signaled(UNUSED_ATTR int fd, int flags, uint32_t user_id) {
  pthread_mutex_lock(&slot_lock);

 rfc_slot_t *slot = find_rfc_slot_by_id(user_id);
 if (!slot)
 goto out;

 bool need_close = false;

 if (flags & SOCK_THREAD_FD_RD && !slot->f.server) {

     if (slot->f.connected) {
       int size = 0;
      if (!(flags & SOCK_THREAD_FD_EXCEPTION) || (TEMP_FAILURE_RETRY(ioctl(slot->fd, FIONREAD, &size)) == 0 && size)) {
         BTA_JvRfcommWrite(slot->rfc_handle, slot->id);
      }
     } else {
       LOG_ERROR(""%s socket signaled for read while disconnected, slot: %d, channel: %d"", __func__, slot->id, slot->scn);
       need_close = true;
 }
 }

 if (flags & SOCK_THREAD_FD_WR) {
 if (!slot->f.connected || !flush_incoming_que_on_wr_signal(slot)) {
      LOG_ERROR(""%s socket signaled for write while disconnected (or write failure), slot: %d, channel: %d"", __func__, slot->id, slot->scn);
      need_close = true;
 }
 }


   if (need_close || (flags & SOCK_THREAD_FD_EXCEPTION)) {
     int size = 0;
    if (need_close || TEMP_FAILURE_RETRY(ioctl(slot->fd, FIONREAD, &size)) != 0 || !size)
       cleanup_rfc_slot(slot);
   }
 
out:;
  pthread_mutex_unlock(&slot_lock);
}
","1. if (!slot)
2. if (flags & SOCK_THREAD_FD_RD && !slot->f.server) {
3. int size = 0;
if (!(flags & SOCK_THREAD_FD_EXCEPTION) || (TEMP_FAILURE_RETRY(ioctl(slot->fd, FIONREAD, &size)) == 0 && size)) {
4. LOG_ERROR(""%s socket signaled for read while disconnected, slot: %d, channel: %d"", __func__, slot->id, slot->scn);
need_close = true;
5. if (flags & SOCK_THREAD_FD_WR) {
if (!slot->f.connected || !flush_incoming_que_on_wr_signal(slot)) {
LOG_ERROR(""%s socket signaled for write while disconnected (or write failure), slot: %d, channel: %d"", __func__, slot->id, slot->scn);
6. int size = 0;
7. out:;","8
13
16-17
21-22
26-28
35
40","CWE-362,CWE-125,CWE-284"
ReadPropertyMSBLong,"static inline signed int ReadPropertyMSBLong(const unsigned char **p,
  size_t *length)
{
  union
  {
    unsigned int
      unsigned_value;

    signed int
      signed_value;
  } quantum;

  int
    c;

  register ssize_t
    i;

   unsigned char
     buffer[4];
 
  unsigned int
     value;
 
   if (*length < 4)
    return(-1);
  for (i=0; i < 4; i++)
  {
    c=(int) (*(*p)++);
     (*length)--;
     buffer[i]=(unsigned char) c;
   }
  value=(unsigned int) buffer[0] << 24;
  value|=(unsigned int) buffer[1] << 16;
  value|=(unsigned int) buffer[2] << 8;
  value|=(unsigned int) buffer[3];
  quantum.unsigned_value=value & 0xffffffff;
   return(quantum.signed_value);
 }
","1. c;
2. value;
3. c=(int) (*(*p)++);
(*length)--;
4. value=(unsigned int) buffer[0] << 24;
value|=(unsigned int) buffer[1] << 16;
value|=(unsigned int) buffer[2] << 8;
5. return(quantum.signed_value);","14
23
29-30
33-35
38","CWE-120,CWE-125,CWE-863"
fpDiff_1,"
#define TIFF

fpDiff_1(TIFF* tif, uint8* cp0, tmsize_t cc)
{
	tmsize_t stride = PredictorState(tif)->stride;
	uint32 bps = tif->tif_dir.td_bitspersample / 8;
 	tmsize_t wc = cc / bps;
 	tmsize_t count;
 	uint8 *cp = (uint8 *) cp0;
	uint8 *tmp;
 
     if((cc%(bps*stride))!=0)
     {
         TIFFErrorExt(tif->tif_clientdata, ""fpDiff_1"",
                      ""%s"", ""(cc%(bps*stride))!=0"");
         return 0;
     }

    tmp = (uint8 *)_TIFFmalloc(cc);
 	if (!tmp)
 		return 0;
 
	_TIFFmemcpy(tmp, cp0, cc);
	for (count = 0; count < wc; count++) {
		uint32 byte;
		for (byte = 0; byte < bps; byte++) {
			#if WORDS_BIGENDIAN
			cp[byte * wc + count] = tmp[bps * count + byte];
			#else
			cp[(bps - byte - 1) * wc + count] =
				tmp[bps * count + byte];
			#endif
		}
	}
	_TIFFfree(tmp);

	cp = (uint8 *) cp0;
	cp += cc - stride - 1;
	for (count = cc; count > stride; count -= stride)
		REPEAT4(stride, cp[stride] = (unsigned char)((cp[stride] - cp[0])&0xff); cp--)
    return 1;
}
","1. tmsize_t stride = PredictorState(tif)->stride;
uint32 bps = tif->tif_dir.td_bitspersample / 8;
tmsize_t wc = cc / bps;
2. uint8 *cp = (uint8 *) cp0;
3. TIFFErrorExt(tif->tif_clientdata, ""fpDiff_1"",
4. return 0;
5. if (!tmp)
6. _TIFFmemcpy(tmp, cp0, cc);
7. uint32 byte;
for (byte = 0; byte < bps; byte++) {
8. _TIFFfree(tmp);","6-8
10
15
17
21
24
26-27
36","CWE-190,CWE-119"
usage_exit_1,"void usage_exit_1() {
void usage_exit_1(void) {
   fprintf(stderr, ""Usage: %s <infile> <outfile>\n"", exec_name);
   exit(EXIT_FAILURE);
 }
","1. fprintf(stderr, ""Usage: %s <infile> <outfile>\n"", exec_name);",3,"CWE-399,CWE-119"
check_sticky,"static inline int check_sticky(struct inode *dir, struct inode *inode)
{
	kuid_t fsuid = current_fsuid();

	if (!(dir->i_mode & S_ISVTX))
		return 0;
	if (uid_eq(inode->i_uid, fsuid))
 		return 0;
 	if (uid_eq(dir->i_uid, fsuid))
 		return 0;
	return !capable_wrt_inode_uidgid(inode, CAP_FOWNER);
 }
","1. static inline int check_sticky(struct inode *dir, struct inode *inode)
2. kuid_t fsuid = current_fsuid();
3. if (!(dir->i_mode & S_ISVTX))
4. if (uid_eq(inode->i_uid, fsuid))
return 0;
if (uid_eq(dir->i_uid, fsuid))","1
3
5
7-9","CWE-190,CWE-264,CWE-119"
semctl_main,"
#define __user

 static int semctl_main(struct ipc_namespace *ns, int semid, int semnum,
		int cmd, void __user *p)
{
	struct sem_array *sma;
	struct sem* curr;
	int err, nsems;
	ushort fast_sem_io[SEMMSL_FAST];
	ushort* sem_io = fast_sem_io;
	struct list_head tasks;

	INIT_LIST_HEAD(&tasks);

	rcu_read_lock();
	sma = sem_obtain_object_check(ns, semid);
	if (IS_ERR(sma)) {
		rcu_read_unlock();
		return PTR_ERR(sma);
	}

	nsems = sma->sem_nsems;

	err = -EACCES;
	if (ipcperms(ns, &sma->sem_perm,
			cmd == SETALL ? S_IWUGO : S_IRUGO)) {
		rcu_read_unlock();
		goto out_wakeup;
	}

	err = security_sem_semctl(sma, cmd);
	if (err) {
		rcu_read_unlock();
		goto out_wakeup;
	}

	err = -EACCES;
	switch (cmd) {
	case GETALL:
	{
		ushort __user *array = p;
		int i;

		if(nsems > SEMMSL_FAST) {
			sem_getref(sma);

			sem_io = ipc_alloc(sizeof(ushort)*nsems);
			if(sem_io == NULL) {
				sem_putref(sma);
				return -ENOMEM;
			}
 
 			sem_lock_and_putref(sma);
 			if (sma->sem_perm.deleted) {
				sem_unlock(sma, -1);
 				err = -EIDRM;
 				goto out_free;
 			}
		} else
			sem_lock(sma, NULL, -1);
 
 		for (i = 0; i < sma->sem_nsems; i++)
 			sem_io[i] = sma->sem_base[i].semval;
		sem_unlock(sma, -1);
 		err = 0;
 		if(copy_to_user(array, sem_io, nsems*sizeof(ushort)))
 			err = -EFAULT;
		goto out_free;
	}
	case SETALL:
	{
 		int i;
 		struct sem_undo *un;
 
		if (!ipc_rcu_getref(sma)) {
			rcu_read_unlock();
			return -EIDRM;
		}
 		rcu_read_unlock();
 
 		if(nsems > SEMMSL_FAST) {
			sem_io = ipc_alloc(sizeof(ushort)*nsems);
			if(sem_io == NULL) {
				sem_putref(sma);
				return -ENOMEM;
			}
		}

		if (copy_from_user (sem_io, p, nsems*sizeof(ushort))) {
			sem_putref(sma);
			err = -EFAULT;
			goto out_free;
		}

		for (i = 0; i < nsems; i++) {
			if (sem_io[i] > SEMVMX) {
				sem_putref(sma);
				err = -ERANGE;
				goto out_free;
			}
 		}
 		sem_lock_and_putref(sma);
 		if (sma->sem_perm.deleted) {
			sem_unlock(sma, -1);
 			err = -EIDRM;
 			goto out_free;
 		}

		for (i = 0; i < nsems; i++)
			sma->sem_base[i].semval = sem_io[i];

		assert_spin_locked(&sma->sem_perm.lock);
		list_for_each_entry(un, &sma->list_id, list_id) {
			for (i = 0; i < nsems; i++)
				un->semadj[i] = 0;
		}
		sma->sem_ctime = get_seconds();
		
		do_smart_update(sma, NULL, 0, 0, &tasks);
		err = 0;
		goto out_unlock;
	}
	
	}
	err = -EINVAL;
	if (semnum < 0 || semnum >= nsems) {
		rcu_read_unlock();
 		goto out_wakeup;
 	}
 
	sem_lock(sma, NULL, -1);
 	curr = &sma->sem_base[semnum];
 
 	switch (cmd) {
	case GETVAL:
		err = curr->semval;
		goto out_unlock;
	case GETPID:
		err = curr->sempid;
		goto out_unlock;
	case GETNCNT:
		err = count_semncnt(sma,semnum);
		goto out_unlock;
	case GETZCNT:
		err = count_semzcnt(sma,semnum);
		goto out_unlock;
 	}
 
 out_unlock:
	sem_unlock(sma, -1);
 out_wakeup:
 	wake_up_sem_queue_do(&tasks);
 out_free:
	if(sem_io != fast_sem_io)
		ipc_free(sem_io, sizeof(ushort)*nsems);
	return err;
}
","1. static int semctl_main(struct ipc_namespace *ns, int semid, int semnum,
2. int err, nsems;
3. INIT_LIST_HEAD(&tasks);
4. if (IS_ERR(sma)) {
rcu_read_unlock();
5. nsems = sma->sem_nsems;
6. cmd == SETALL ? S_IWUGO : S_IRUGO)) {
7. err = security_sem_semctl(sma, cmd);
if (err) {
8. goto out_wakeup;
9. switch (cmd) {
10. if(nsems > SEMMSL_FAST) {
11. sem_putref(sma);
return -ENOMEM;
12. sem_lock_and_putref(sma);
if (sma->sem_perm.deleted) {
13. sem_io[i] = sma->sem_base[i].semval;
sem_unlock(sma, -1);
err = 0;
14. goto out_free;
15. case SETALL:
16. struct sem_undo *un;
17. rcu_read_unlock();
18. if(sem_io == NULL) {
sem_putref(sma);
19. if (copy_from_user (sem_io, p, nsems*sizeof(ushort))) {
20. sem_putref(sma);
21. goto out_free;
22. sma->sem_base[i].semval = sem_io[i];
23. for (i = 0; i < nsems; i++)
24. sma->sem_ctime = get_seconds();
25. sem_lock(sma, NULL, -1);
26. goto out_unlock;
case GETPID:
27. goto out_unlock;
28. goto out_unlock;
29. out_unlock:
30. if(sem_io != fast_sem_io)
ipc_free(sem_io, sizeof(ushort)*nsems);","4
9
14
18-19
23
27
32-33
35
39
45
50-51
54-55
64-66
69
71
74
80
84-85
90
98
100
111
115
118
132
138-139
144
147
150
155-156","CWE-125,CWE-189"
perf_cpu_time_max_percent_handler,"
#define __user

int perf_cpu_time_max_percent_handler(struct ctl_table *table, int write,
 				void __user *buffer, size_t *lenp,
 				loff_t *ppos)
 {
	int ret = proc_dointvec_minmax(table, write, buffer, lenp, ppos);
 
 	if (ret || !write)
 		return ret;

	if (sysctl_perf_cpu_time_max_percent == 100 ||
	    sysctl_perf_cpu_time_max_percent == 0) {
		printk(KERN_WARNING
		       ""perf: Dynamic interrupt throttling disabled, can hang your system!\n"");
		WRITE_ONCE(perf_sample_allowed_ns, 0);
	} else {
		update_perf_cpu_limits();
	}

	return 0;
}
","1. void __user *buffer, size_t *lenp,
2. if (ret || !write)
3. WRITE_ONCE(perf_sample_allowed_ns, 0);
} else {
4. return 0;","5
10
17-18
22","CWE-319,CWE-190,CWE-264,CWE-119"
parse_ip_address_ex,"static inline char *parse_ip_address_ex(const char *str, size_t str_len, int *portno, int get_err, zend_string **err)
{
	char *colon;
 	char *host = NULL;
 
 #ifdef HAVE_IPV6
 	if (*(str) == '[' && str_len > 1) {
 		
		char *p = memchr(str + 1, ']', str_len - 2), *e = NULL;
 		if (!p || *(p + 1) != ':') {
 			if (get_err) {
 				*err = strpprintf(0, ""Failed to parse IPv6 address \""%s\"""", str);
 			}
 			return NULL;
 		}
		*portno = strtol(p + 2, &e, 10);
		if (e && *e) {
			if (get_err) {
				*err = strpprintf(0, ""Failed to parse address \""%s\"""", str);
			}
			return NULL;
		}
 		return estrndup(str + 1, p - str - 1);
 	}
 #endif

 	if (str_len) {
 		colon = memchr(str, ':', str_len - 1);
 	} else {
 		colon = NULL;
 	}

 	if (colon) {
		char *e = NULL;
		*portno = strtol(colon + 1, &e, 10);
		if (!e || !*e) {
			return estrndup(str, colon - str);
 		}
 	}
 
	if (get_err) {
		*err = strpprintf(0, ""Failed to parse address \""%s\"""", str);
	}
	return NULL;
 }
",1. } else {,29,"CWE-617,CWE-20,CWE-358,CWE-284"
svcauth_gss_accept_sec_context,"svcauth_gss_accept_sec_context(struct svc_req *rqst,
			       struct rpc_gss_init_res *gr)
{
	struct svc_rpc_gss_data	*gd;
	struct rpc_gss_cred	*gc;
	gss_buffer_desc		 recv_tok, seqbuf;
	gss_OID			 mech;
	OM_uint32		 maj_stat = 0, min_stat = 0, ret_flags, seq;

	log_debug(""in svcauth_gss_accept_context()"");

	gd = SVCAUTH_PRIVATE(rqst->rq_xprt->xp_auth);
	gc = (struct rpc_gss_cred *)rqst->rq_clntcred;
	memset(gr, 0, sizeof(*gr));

	
	memset(&recv_tok, 0, sizeof(recv_tok));

	if (!svc_getargs(rqst->rq_xprt, xdr_rpc_gss_init_args,
			 (caddr_t)&recv_tok))
		return (FALSE);

	gr->gr_major = gss_accept_sec_context(&gr->gr_minor,
					      &gd->ctx,
					      svcauth_gss_creds,
					      &recv_tok,
					      GSS_C_NO_CHANNEL_BINDINGS,
					      &gd->client_name,
					      &mech,
					      &gr->gr_token,
					      &ret_flags,
					      NULL,
					      NULL);

	svc_freeargs(rqst->rq_xprt, xdr_rpc_gss_init_args, (caddr_t)&recv_tok);

	log_status(""accept_sec_context"", gr->gr_major, gr->gr_minor);
	if (gr->gr_major != GSS_S_COMPLETE &&
	    gr->gr_major != GSS_S_CONTINUE_NEEDED) {
		badauth(gr->gr_major, gr->gr_minor, rqst->rq_xprt);
 		gd->ctx = GSS_C_NO_CONTEXT;
 		goto errout;
 	}
	gr->gr_ctx.value = ""xxxx"";
	gr->gr_ctx.length = 4;
 
 	
 	gr->gr_win = sizeof(gd->seqmask) * 8;

	
	gd->sec.mech = mech;
	gd->sec.qop = GSS_C_QOP_DEFAULT;
	gd->sec.svc = gc->gc_svc;
	gd->seq = gc->gc_seq;
	gd->win = gr->gr_win;

	if (gr->gr_major == GSS_S_COMPLETE) {
#ifdef SPKM
		
		if(!g_OID_equal(gss_mech_spkm3, mech)) {
#endif
		    maj_stat = gss_display_name(&min_stat, gd->client_name,
					    &gd->cname, &gd->sec.mech);
#ifdef SPKM
		}
#endif
		if (maj_stat != GSS_S_COMPLETE) {
			log_status(""display_name"", maj_stat, min_stat);
			goto errout;
		}
#ifdef DEBUG
#ifdef HAVE_HEIMDAL
		log_debug(""accepted context for %.*s with ""
			  ""<mech {}, qop %d, svc %d>"",
			  gd->cname.length, (char *)gd->cname.value,
			  gd->sec.qop, gd->sec.svc);
#else
		{
			gss_buffer_desc mechname;

			gss_oid_to_str(&min_stat, mech, &mechname);

			log_debug(""accepted context for %.*s with ""
				  ""<mech %.*s, qop %d, svc %d>"",
				  gd->cname.length, (char *)gd->cname.value,
				  mechname.length, (char *)mechname.value,
				  gd->sec.qop, gd->sec.svc);

			gss_release_buffer(&min_stat, &mechname);
		}
#endif
#endif 
		seq = htonl(gr->gr_win);
		seqbuf.value = &seq;
		seqbuf.length = sizeof(seq);

		gss_release_buffer(&min_stat, &gd->checksum);
		maj_stat = gss_sign(&min_stat, gd->ctx, GSS_C_QOP_DEFAULT,
				    &seqbuf, &gd->checksum);

		if (maj_stat != GSS_S_COMPLETE) {
			goto errout;
		}


		rqst->rq_xprt->xp_verf.oa_flavor = RPCSEC_GSS;
		rqst->rq_xprt->xp_verf.oa_base = gd->checksum.value;
		rqst->rq_xprt->xp_verf.oa_length = gd->checksum.length;
	}
	return (TRUE);
errout:
	gss_release_buffer(&min_stat, &gr->gr_token);
	return (FALSE);
}
","1. struct rpc_gss_cred	*gc;
2. gss_OID			 mech;
3. log_debug(""in svcauth_gss_accept_context()"");
4. gc = (struct rpc_gss_cred *)rqst->rq_clntcred;
memset(gr, 0, sizeof(*gr));
5. svcauth_gss_creds,
6. GSS_C_NO_CHANNEL_BINDINGS,
&gd->client_name,
&mech,
7. log_status(""accept_sec_context"", gr->gr_major, gr->gr_minor);
if (gr->gr_major != GSS_S_COMPLETE &&
8. goto errout;
9. gd->sec.svc = gc->gc_svc;
10. if (gr->gr_major == GSS_S_COMPLETE) {
11. gss_release_buffer(&min_stat, &gd->checksum);
12. return (FALSE);","5
7
10
13-14
25
27-29
37-38
42
53
57
97
113","CWE-362,CWE-200,CWE-19"
ext4_ext_handle_uninitialized_extents_1,"ext4_ext_handle_uninitialized_extents_1(handle_t *handle, struct inode *inode,
			struct ext4_map_blocks *map,
			struct ext4_ext_path *path, int flags,
			unsigned int allocated, ext4_fsblk_t newblock)
{
	int ret = 0;
	int err = 0;
	ext4_io_end_t *io = ext4_inode_aio(inode);

	ext_debug(""ext4_ext_handle_uninitialized_extents_1: inode %lu, logical ""
		  ""block %llu, max_blocks %u, flags %x, allocated %u\n"",
		  inode->i_ino, (unsigned long long)map->m_lblk, map->m_len,
		  flags, allocated);
	ext4_ext_show_leaf(inode, path);

	trace_ext4_ext_handle_uninitialized_extents(inode, map, allocated,
						    newblock);

	
	if ((flags & EXT4_GET_BLOCKS_PRE_IO)) {
		ret = ext4_split_unwritten_extents(handle, inode, map,
						   path, flags);
		if (ret <= 0)
			goto out;
		
		if (io)
			ext4_set_io_unwritten_flag(inode, io);
		else
			ext4_set_inode_state(inode, EXT4_STATE_DIO_UNWRITTEN);
		if (ext4_should_dioread_nolock(inode))
			map->m_flags |= EXT4_MAP_UNINIT;
		goto out;
 	}
 	
 	if ((flags & EXT4_GET_BLOCKS_CONVERT)) {
		ret = ext4_convert_unwritten_extents_endio(handle, inode, map,
 							path);
 		if (ret >= 0) {
 			ext4_update_inode_fsync_trans(handle, inode, 1);
			err = check_eofblocks_fl(handle, inode, map->m_lblk,
						 path, map->m_len);
		} else
			err = ret;
		goto out2;
	}
	
	
	if (flags & EXT4_GET_BLOCKS_UNINIT_EXT)
		goto map_out;

	
	if ((flags & EXT4_GET_BLOCKS_CREATE) == 0) {
		
		map->m_flags |= EXT4_MAP_UNWRITTEN;
		goto out1;
	}

	
	ret = ext4_ext_convert_to_initialized(handle, inode, map, path);
	if (ret >= 0)
		ext4_update_inode_fsync_trans(handle, inode, 1);
out:
	if (ret <= 0) {
		err = ret;
		goto out2;
	} else
		allocated = ret;
	map->m_flags |= EXT4_MAP_NEW;
	
	if (allocated > map->m_len) {
		unmap_underlying_metadata_blocks(inode->i_sb->s_bdev,
					newblock + map->m_len,
					allocated - map->m_len);
		allocated = map->m_len;
	}

	
	if (flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) {
		unsigned int reserved_clusters;
		reserved_clusters = get_reserved_cluster_alloc(inode,
				map->m_lblk, map->m_len);
		if (reserved_clusters)
			ext4_da_update_reserve_space(inode,
						     reserved_clusters,
						     0);
	}

map_out:
	map->m_flags |= EXT4_MAP_MAPPED;
	if ((flags & EXT4_GET_BLOCKS_KEEP_SIZE) == 0) {
		err = check_eofblocks_fl(handle, inode, map->m_lblk, path,
					 map->m_len);
		if (err < 0)
			goto out2;
	}
out1:
	if (allocated > map->m_len)
		allocated = map->m_len;
	ext4_ext_show_leaf(inode, path);
	map->m_pblk = newblock;
	map->m_len = allocated;
out2:
	if (path) {
		ext4_ext_drop_refs(path);
		kfree(path);
	}
	return err ? err : allocated;
}
","1. unsigned int allocated, ext4_fsblk_t newblock)
2. ext4_io_end_t *io = ext4_inode_aio(inode);
3. ext4_ext_show_leaf(inode, path);
4. if ((flags & EXT4_GET_BLOCKS_PRE_IO)) {
5. if ((flags & EXT4_GET_BLOCKS_CONVERT)) {
6. out:
7. allocated = ret;
8. map_out:
9. if (err < 0)
10. out1:
11. out2:","4
8
14
20
39
75
80
113
118
121
127","CWE-362,CWE-200,CWE-19"
clone_private_mount-115144079487189,"struct vfsmount *clone_private_mount(const struct path *path)
{
	struct mount *old_mnt = real_mount(path->mnt);
	struct mount *new_mnt;

	down_read(&namespace_sem);
	if (IS_MNT_UNBINDABLE(old_mnt))
		goto invalid;

	if (!check_mnt(old_mnt))
		goto invalid;

	if (has_locked_children(old_mnt, path->dentry))
		goto invalid;

	new_mnt = clone_mnt(old_mnt, path->dentry, CL_PRIVATE);
	up_read(&namespace_sem);

	if (IS_ERR(new_mnt))
		return ERR_CAST(new_mnt);

	
	new_mnt->mnt_ns = MNT_NS_INTERNAL;

	return &new_mnt->mnt;

invalid:
	up_read(&namespace_sem);
	return ERR_PTR(-EINVAL);
}
","1. struct vfsmount *clone_private_mount(const struct path *path)
2. struct mount *new_mnt;
3. goto invalid;
4. goto invalid;
5. goto invalid;
6. return ERR_CAST(new_mnt);","1
4
8
11
14
20","CWE-362,CWE-416,CWE-476,CWE-190,CWE-200"
jas_image_cmpt_create,"static jas_image_cmpt_t *jas_image_cmpt_create(int_fast32_t tlx,
  int_fast32_t tly, int_fast32_t hstep, int_fast32_t vstep,
  int_fast32_t width, int_fast32_t height, uint_fast16_t depth, bool sgnd,
  uint_fast32_t inmem)
{
	jas_image_cmpt_t *cmpt;
	size_t size;

	cmpt = 0;
	if (width < 0 || height < 0 || hstep <= 0 || vstep <= 0) {
		goto error;
	}
	if (!jas_safe_intfast32_add(tlx, width, 0) ||
	  !jas_safe_intfast32_add(tly, height, 0)) {
		goto error;
	}

	if (!(cmpt = jas_malloc(sizeof(jas_image_cmpt_t)))) {
		goto error;
	}

	cmpt->type_ = JAS_IMAGE_CT_UNKNOWN;
	cmpt->tlx_ = tlx;
	cmpt->tly_ = tly;
	cmpt->hstep_ = hstep;
	cmpt->vstep_ = vstep;
	cmpt->width_ = width;
	cmpt->height_ = height;
	cmpt->prec_ = depth;
	cmpt->sgnd_ = sgnd;
	cmpt->stream_ = 0;
	cmpt->cps_ = (depth + 7) / 8;

	if (!jas_safe_size_mul(cmpt->width_, cmpt->height_, &size) ||
 	  !jas_safe_size_mul(size, cmpt->cps_, &size)) {
 		goto error;
 	}
	cmpt->stream_ = (inmem) ? jas_stream_memopen2(0, size) :
 	  jas_stream_tmpfile();
 	if (!cmpt->stream_) {
 		goto error;
	}

	
	
	if (jas_stream_seek(cmpt->stream_, size - 1, SEEK_SET) < 0 ||
	  jas_stream_putc(cmpt->stream_, 0) == EOF ||
	  jas_stream_seek(cmpt->stream_, 0, SEEK_SET) < 0) {
		goto error;
	}

	return cmpt;

error:
	if (cmpt) {
		jas_image_cmpt_destroy(cmpt);
	}
	return 0;
}
","1. static jas_image_cmpt_t *jas_image_cmpt_create(int_fast32_t tlx,
2. uint_fast32_t inmem)
3. goto error;
4. goto error;
5. cmpt->hstep_ = hstep;
6. cmpt->prec_ = depth;
7. cmpt->stream_ = 0;
8. goto error;
9. if (!cmpt->stream_) {
10. jas_stream_putc(cmpt->stream_, 0) == EOF ||
11. return 0;","1
4
11
15
25
29
31
36
40
48
59","CWE-119,CWE-908,CWE-200,CWE-400,CWE-193"
handle_vmon,"static int handle_vmon(struct kvm_vcpu *vcpu)
{
	int ret;
	gpa_t vmptr;
	struct page *page;
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	const u64 VMXON_NEEDED_FEATURES = FEATURE_CONTROL_LOCKED
		| FEATURE_CONTROL_VMXON_ENABLED_OUTSIDE_SMX;

	
	if (!kvm_read_cr4_bits(vcpu, X86_CR4_VMXE)) {
		kvm_queue_exception(vcpu, UD_VECTOR);
 		return 1;
 	}
 
	
	if (vmx_get_cpl(vcpu)) {
		kvm_queue_exception(vcpu, UD_VECTOR);
		return 1;
	}

 	if (vmx->nested.vmxon) {
 		nested_vmx_failValid(vcpu, VMXERR_VMXON_IN_VMX_ROOT_OPERATION);
 		return kvm_skip_emulated_instruction(vcpu);
	}

	if ((vmx->msr_ia32_feature_control & VMXON_NEEDED_FEATURES)
			!= VMXON_NEEDED_FEATURES) {
		kvm_inject_gp(vcpu, 0);
		return 1;
	}

	if (nested_vmx_get_vmptr(vcpu, &vmptr))
		return 1;

	
	if (!PAGE_ALIGNED(vmptr) || (vmptr >> cpuid_maxphyaddr(vcpu))) {
		nested_vmx_failInvalid(vcpu);
		return kvm_skip_emulated_instruction(vcpu);
	}

	page = kvm_vcpu_gpa_to_page(vcpu, vmptr);
	if (is_error_page(page)) {
		nested_vmx_failInvalid(vcpu);
		return kvm_skip_emulated_instruction(vcpu);
	}
	if (*(u32 *)kmap(page) != VMCS12_REVISION) {
		kunmap(page);
		kvm_release_page_clean(page);
		nested_vmx_failInvalid(vcpu);
		return kvm_skip_emulated_instruction(vcpu);
	}
	kunmap(page);
	kvm_release_page_clean(page);

	vmx->nested.vmxon_ptr = vmptr;
	ret = enter_vmx_operation(vcpu);
	if (ret)
		return ret;

	nested_vmx_succeed(vcpu);
	return kvm_skip_emulated_instruction(vcpu);
}
","1. const u64 VMXON_NEEDED_FEATURES = FEATURE_CONTROL_LOCKED
| FEATURE_CONTROL_VMXON_ENABLED_OUTSIDE_SMX;
2. kvm_queue_exception(vcpu, UD_VECTOR);
3. != VMXON_NEEDED_FEATURES) {
4. return 1;
5. page = kvm_vcpu_gpa_to_page(vcpu, vmptr);
6. nested_vmx_failInvalid(vcpu);
7. kunmap(page);
8. return kvm_skip_emulated_instruction(vcpu);
9. return ret;","7-8
26
36
42
57
59
63
66
74","CWE-264,CWE-189,CWE-119"
bn_size_str-250742957016678,"size_t bn_size_str(const bn_t a, unsigned int radix) {
	int digits = 0;
	bn_t t;

	bn_null(t);

	
	if (radix < 2 || radix > 64) {
		RLC_THROW(ERR_NO_VALID);
		return 0;
	}

	if (bn_is_zero(a)) {
		return 2;
	}

	
	if (radix == 2) {
		return bn_bits(a) + (a->sign == RLC_NEG ? 1 : 0) + 1;
	}

	if (a->sign == RLC_NEG) {
		digits++;
	}

	RLC_TRY {
		bn_new(t);
		bn_copy(t, a);

		t->sign = RLC_POS;

		while (!bn_is_zero(t)) {
			bn_div_dig(t, t, (dig_t)radix);
			digits++;
		}
	} RLC_CATCH_ANY {
		RLC_THROW(ERR_CAUGHT);
	} RLC_FINALLY {
		bn_free(t);
	}

	return digits + 1;
}
","1. bn_t t;
2. bn_null(t);
3. RLC_THROW(ERR_NO_VALID);
4. if (bn_is_zero(a)) {
return 2;
5. return bn_bits(a) + (a->sign == RLC_NEG ? 1 : 0) + 1;
6. if (a->sign == RLC_NEG) {
digits++;
7. RLC_TRY {
bn_new(t);
8. t->sign = RLC_POS;
9. while (!bn_is_zero(t)) {
bn_div_dig(t, t, (dig_t)radix);
digits++;
10. RLC_THROW(ERR_CAUGHT);
} RLC_FINALLY {
bn_free(t);
11. return digits + 1;","3
5
9
13-14
19
22-23
26-27
30
32-34
37-39
42","CWE-476,CWE-120,CWE-119,CWE-189"
lxclock_name,"static char *lxclock_name(const char *p, const char *n)
{
	int ret;
	int len;
	char *dest;
 	char *rundir;
 
 	
 
	
	len = strlen(""/lxc/lock/"") + strlen(n) + strlen(p) + 3;
 	rundir = get_rundir();
 	if (!rundir)
 		return NULL;
	len += strlen(rundir);

	if ((dest = malloc(len)) == NULL) {
		free(rundir);
 		return NULL;
 	}
 
	ret = snprintf(dest, len, ""%s/lxc/lock/%s"", rundir, p);
 	if (ret < 0 || ret >= len) {
 		free(dest);
 		free(rundir);
 		return NULL;
 	}
 	ret = mkdir_p(dest, 0755);
 	if (ret < 0) {
		free(dest);
		free(rundir);
		return NULL;
	}
 
	ret = snprintf(dest, len, ""%s/lxc/lock/%s/.%s"", rundir, p, n);
 	free(rundir);
 	if (ret < 0 || ret >= len) {
 		free(dest);
 		return NULL;
	}
	return dest;
}
","1. int ret;
int len;
char *dest;
char *rundir;
2. return NULL;
len += strlen(rundir);
3. if ((dest = malloc(len)) == NULL) {
free(rundir);
return NULL;
4. if (ret < 0 || ret >= len) {
free(dest);
5. return NULL;
6. ret = mkdir_p(dest, 0755);
7. free(dest);
free(rundir);
return NULL;
8. ret = snprintf(dest, len, ""%s/lxc/lock/%s/.%s"", rundir, p, n);
9. if (ret < 0 || ret >= len) {","3-6
18-19
21-23
27-28
30
32
34-36
39
41","CWE-787,CWE-125,CWE-59"
qeth_snmp_command-133328543374355,"
#define __user

int qeth_snmp_command(struct qeth_card *card, char __user *udata)
{
	struct qeth_cmd_buffer *iob;
	struct qeth_ipa_cmd *cmd;
	struct qeth_snmp_ureq *ureq;
	unsigned int req_len;
	struct qeth_arp_query_info qinfo = {0, };
	int rc = 0;

	QETH_CARD_TEXT(card, 3, ""snmpcmd"");

	if (card->info.guestlan)
		return -EOPNOTSUPP;

	if ((!qeth_adp_supported(card, IPA_SETADP_SET_SNMP_CONTROL)) &&
	    (!card->options.layer2)) {
		return -EOPNOTSUPP;
	}
	
	if (copy_from_user(&req_len, udata + sizeof(int), sizeof(int)))
		return -EFAULT;
	if (req_len > (QETH_BUFSIZE - IPA_PDU_HEADER_SIZE -
		       sizeof(struct qeth_ipacmd_hdr) -
		       sizeof(struct qeth_ipacmd_setadpparms_hdr)))
		return -EINVAL;
	ureq = memdup_user(udata, req_len + sizeof(struct qeth_snmp_ureq_hdr));
	if (IS_ERR(ureq)) {
		QETH_CARD_TEXT(card, 2, ""snmpnome"");
		return PTR_ERR(ureq);
	}
	qinfo.udata_len = ureq->hdr.data_len;
	qinfo.udata = kzalloc(qinfo.udata_len, GFP_KERNEL);
	if (!qinfo.udata) {
		kfree(ureq);
		return -ENOMEM;
	}
	qinfo.udata_offset = sizeof(struct qeth_snmp_ureq_hdr);

	iob = qeth_get_adapter_cmd(card, IPA_SETADP_SET_SNMP_CONTROL,
				   QETH_SNMP_SETADP_CMDLENGTH + req_len);
	cmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);
	memcpy(&cmd->data.setadapterparms.data.snmp, &ureq->cmd, req_len);
	rc = qeth_send_ipa_snmp_cmd(card, iob, QETH_SETADP_BASE_LEN + req_len,
				    qeth_snmp_command_cb, (void *)&qinfo);
	if (rc)
		QETH_DBF_MESSAGE(2, ""SNMP command failed on %s: (0x%x)\n"",
			   QETH_CARD_IFNAME(card), rc);
	else {
		if (copy_to_user(udata, qinfo.udata, qinfo.udata_len))
			rc = -EFAULT;
	}

	kfree(ureq);
	kfree(qinfo.udata);
	return rc;
}
","1. int qeth_snmp_command(struct qeth_card *card, char __user *udata)
2. struct qeth_cmd_buffer *iob;
3. unsigned int req_len;
struct qeth_arp_query_info qinfo = {0, };
4. if (card->info.guestlan)
5. sizeof(struct qeth_ipacmd_setadpparms_hdr)))
6. ureq = memdup_user(udata, req_len + sizeof(struct qeth_snmp_ureq_hdr));
7. return PTR_ERR(ureq);
8. qinfo.udata = kzalloc(qinfo.udata_len, GFP_KERNEL);
9. if (rc)
10. else {
if (copy_to_user(udata, qinfo.udata, qinfo.udata_len))
11. kfree(ureq);","4
6
9-10
15
27
29
32
35
48
51-52
56","CWE-362,CWE-119"
btrfs_finish_sprout-226624370130469,"static int btrfs_finish_sprout(struct btrfs_trans_handle *trans,
			       struct btrfs_fs_info *fs_info)
{
	struct btrfs_root *root = fs_info->chunk_root;
	struct btrfs_path *path;
	struct extent_buffer *leaf;
	struct btrfs_dev_item *dev_item;
	struct btrfs_device *device;
	struct btrfs_key key;
	u8 fs_uuid[BTRFS_FSID_SIZE];
	u8 dev_uuid[BTRFS_UUID_SIZE];
	u64 devid;
	int ret;

	path = btrfs_alloc_path();
	if (!path)
		return -ENOMEM;

	key.objectid = BTRFS_DEV_ITEMS_OBJECTID;
	key.offset = 0;
	key.type = BTRFS_DEV_ITEM_KEY;

	while (1) {
		ret = btrfs_search_slot(trans, root, &key, path, 0, 1);
		if (ret < 0)
			goto error;

		leaf = path->nodes[0];
next_slot:
		if (path->slots[0] >= btrfs_header_nritems(leaf)) {
			ret = btrfs_next_leaf(root, path);
			if (ret > 0)
				break;
			if (ret < 0)
				goto error;
			leaf = path->nodes[0];
			btrfs_item_key_to_cpu(leaf, &key, path->slots[0]);
			btrfs_release_path(path);
			continue;
		}

		btrfs_item_key_to_cpu(leaf, &key, path->slots[0]);
		if (key.objectid != BTRFS_DEV_ITEMS_OBJECTID ||
		    key.type != BTRFS_DEV_ITEM_KEY)
			break;

		dev_item = btrfs_item_ptr(leaf, path->slots[0],
					  struct btrfs_dev_item);
		devid = btrfs_device_id(leaf, dev_item);
		read_extent_buffer(leaf, dev_uuid, btrfs_device_uuid(dev_item),
				   BTRFS_UUID_SIZE);
		read_extent_buffer(leaf, fs_uuid, btrfs_device_fsid(dev_item),
				   BTRFS_FSID_SIZE);
		device = btrfs_find_device(fs_info->fs_devices, devid, dev_uuid,
					   fs_uuid, true);
		BUG_ON(!device); 

		if (device->fs_devices->seeding) {
			btrfs_set_device_generation(leaf, dev_item,
						    device->generation);
			btrfs_mark_buffer_dirty(leaf);
		}

		path->slots[0]++;
		goto next_slot;
	}
	ret = 0;
error:
	btrfs_free_path(path);
	return ret;
}
","1. struct btrfs_path *path;
2. struct btrfs_device *device;
3. if (!path)
return -ENOMEM;
4. break;
5. devid = btrfs_device_id(leaf, dev_item);
read_extent_buffer(leaf, dev_uuid, btrfs_device_uuid(dev_item),
6. if (device->fs_devices->seeding) {","5
8
16-17
45
49-50
58","CWE-22,CWE-681,CWE-125,CWE-787"
rawv6_sendmsg-232911019235291,"static int rawv6_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)
{
	struct ipv6_txoptions *opt_to_free = NULL;
	struct ipv6_txoptions opt_space;
	DECLARE_SOCKADDR(struct sockaddr_in6 *, sin6, msg->msg_name);
	struct in6_addr *daddr, *final_p, final;
	struct inet_sock *inet = inet_sk(sk);
	struct ipv6_pinfo *np = inet6_sk(sk);
	struct raw6_sock *rp = raw6_sk(sk);
	struct ipv6_txoptions *opt = NULL;
	struct ip6_flowlabel *flowlabel = NULL;
	struct dst_entry *dst = NULL;
	struct raw6_frag_vec rfv;
	struct flowi6 fl6;
	int addr_len = msg->msg_namelen;
	int hlimit = -1;
	int tclass = -1;
	int dontfrag = -1;
	u16 proto;
	int err;

	
	if (len > INT_MAX)
		return -EMSGSIZE;

	
	if (msg->msg_flags & MSG_OOB)
		return -EOPNOTSUPP;

	
	memset(&fl6, 0, sizeof(fl6));

	fl6.flowi6_mark = sk->sk_mark;

	if (sin6) {
		if (addr_len < SIN6_LEN_RFC2133)
			return -EINVAL;

		if (sin6->sin6_family && sin6->sin6_family != AF_INET6)
			return -EAFNOSUPPORT;

		
		proto = ntohs(sin6->sin6_port);

		if (!proto)
			proto = inet->inet_num;
		else if (proto != inet->inet_num)
			return -EINVAL;

		if (proto > 255)
			return -EINVAL;

		daddr = &sin6->sin6_addr;
		if (np->sndflow) {
			fl6.flowlabel = sin6->sin6_flowinfo&IPV6_FLOWINFO_MASK;
			if (fl6.flowlabel&IPV6_FLOWLABEL_MASK) {
				flowlabel = fl6_sock_lookup(sk, fl6.flowlabel);
				if (!flowlabel)
					return -EINVAL;
			}
		}

		
		if (sk->sk_state == TCP_ESTABLISHED &&
		    ipv6_addr_equal(daddr, &sk->sk_v6_daddr))
			daddr = &sk->sk_v6_daddr;

		if (addr_len >= sizeof(struct sockaddr_in6) &&
		    sin6->sin6_scope_id &&
		    __ipv6_addr_needs_scope_id(__ipv6_addr_type(daddr)))
			fl6.flowi6_oif = sin6->sin6_scope_id;
	} else {
		if (sk->sk_state != TCP_ESTABLISHED)
			return -EDESTADDRREQ;

		proto = inet->inet_num;
		daddr = &sk->sk_v6_daddr;
		fl6.flowlabel = np->flow_label;
	}

	if (fl6.flowi6_oif == 0)
		fl6.flowi6_oif = sk->sk_bound_dev_if;

	if (msg->msg_controllen) {
		opt = &opt_space;
		memset(opt, 0, sizeof(struct ipv6_txoptions));
		opt->tot_len = sizeof(struct ipv6_txoptions);

		err = ip6_datagram_send_ctl(sock_net(sk), sk, msg, &fl6, opt,
					    &hlimit, &tclass, &dontfrag);
		if (err < 0) {
			fl6_sock_release(flowlabel);
			return err;
		}
		if ((fl6.flowlabel&IPV6_FLOWLABEL_MASK) && !flowlabel) {
			flowlabel = fl6_sock_lookup(sk, fl6.flowlabel);
			if (!flowlabel)
				return -EINVAL;
		}
		if (!(opt->opt_nflen|opt->opt_flen))
			opt = NULL;
	}
	if (!opt) {
		opt = txopt_get(np);
		opt_to_free = opt;
		}
	if (flowlabel)
		opt = fl6_merge_options(&opt_space, flowlabel, opt);
	opt = ipv6_fixup_options(&opt_space, opt);

	fl6.flowi6_proto = proto;
	rfv.msg = msg;
	rfv.hlen = 0;
	err = rawv6_probe_proto_opt(&rfv, &fl6);
	if (err)
		goto out;

	if (!ipv6_addr_any(daddr))
		fl6.daddr = *daddr;
	else
		fl6.daddr.s6_addr[15] = 0x1; 
	if (ipv6_addr_any(&fl6.saddr) && !ipv6_addr_any(&np->saddr))
		fl6.saddr = np->saddr;

	final_p = fl6_update_dst(&fl6, opt, &final);

	if (!fl6.flowi6_oif && ipv6_addr_is_multicast(&fl6.daddr))
		fl6.flowi6_oif = np->mcast_oif;
	else if (!fl6.flowi6_oif)
		fl6.flowi6_oif = np->ucast_oif;
	security_sk_classify_flow(sk, flowi6_to_flowi(&fl6));

	if (inet->hdrincl)
		fl6.flowi6_flags |= FLOWI_FLAG_KNOWN_NH;

	dst = ip6_dst_lookup_flow(sk, &fl6, final_p);
	if (IS_ERR(dst)) {
		err = PTR_ERR(dst);
		goto out;
	}
	if (hlimit < 0)
		hlimit = ip6_sk_dst_hoplimit(np, &fl6, dst);

	if (tclass < 0)
		tclass = np->tclass;

	if (dontfrag < 0)
		dontfrag = np->dontfrag;

	if (msg->msg_flags&MSG_CONFIRM)
		goto do_confirm;

back_from_confirm:
	if (inet->hdrincl)
		err = rawv6_send_hdrinc(sk, msg, len, &fl6, &dst, msg->msg_flags);
	else {
		lock_sock(sk);
		err = ip6_append_data(sk, raw6_getfrag, &rfv,
			len, 0, hlimit, tclass, opt, &fl6, (struct rt6_info *)dst,
			msg->msg_flags, dontfrag);

		if (err)
			ip6_flush_pending_frames(sk);
		else if (!(msg->msg_flags & MSG_MORE))
			err = rawv6_push_pending_frames(sk, &fl6, rp);
		release_sock(sk);
	}
done:
	dst_release(dst);
out:
	fl6_sock_release(flowlabel);
	txopt_put(opt_to_free);
	return err < 0 ? err : len;
do_confirm:
	dst_confirm(dst);
	if (!(msg->msg_flags & MSG_PROBE) || len)
		goto back_from_confirm;
	err = 0;
	goto done;
}
","1. static int rawv6_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)
2. struct ipv6_txoptions *opt = NULL;
3. int addr_len = msg->msg_namelen;
int hlimit = -1;
4. int dontfrag = -1;
5. int err;
6. if (len > INT_MAX)
7. return -EOPNOTSUPP;
8. if (sin6) {
9. if (sin6->sin6_family && sin6->sin6_family != AF_INET6)
10. return -EINVAL;
11. daddr = &sin6->sin6_addr;
12. flowlabel = fl6_sock_lookup(sk, fl6.flowlabel);
13. ipv6_addr_equal(daddr, &sk->sk_v6_daddr))
14. __ipv6_addr_needs_scope_id(__ipv6_addr_type(daddr)))
15. } else {
16. fl6.flowlabel = np->flow_label;
17. if (msg->msg_controllen) {
18. err = ip6_datagram_send_ctl(sock_net(sk), sk, msg, &fl6, opt,
19. if ((fl6.flowlabel&IPV6_FLOWLABEL_MASK) && !flowlabel) {
flowlabel = fl6_sock_lookup(sk, fl6.flowlabel);
20. return -EINVAL;
21. if (!opt) {
opt = txopt_get(np);
22. if (!fl6.flowi6_oif && ipv6_addr_is_multicast(&fl6.daddr))
fl6.flowi6_oif = np->mcast_oif;
else if (!fl6.flowi6_oif)
23. security_sk_classify_flow(sk, flowi6_to_flowi(&fl6));
24. err = PTR_ERR(dst);
25. hlimit = ip6_sk_dst_hoplimit(np, &fl6, dst);
26. if (msg->msg_flags&MSG_CONFIRM)
27. err = rawv6_send_hdrinc(sk, msg, len, &fl6, &dst, msg->msg_flags);
28. lock_sock(sk);
29. if (err)
ip6_flush_pending_frames(sk);
30. fl6_sock_release(flowlabel);
31. goto back_from_confirm;","1
10
15-16
18
20
25
30
39
43
52
57
61
72
77
79
85
91
96
102-103
105
110-111
134-136
138
145
149
157
162
164
169-170
178
184","CWE-362,CWE-264,CWE-416"
process_plane-95477264761607,"static int
process_plane(uint8 * in, int width, int height, uint8 * out, int size)
{
	UNUSED(size);
	int indexw;
	int indexh;
	int code;
	int collen;
	int replen;
	int color;
	int x;
	int revcode;
	uint8 * last_line;
	uint8 * this_line;
	uint8 * org_in;
	uint8 * org_out;

	org_in = in;
	org_out = out;
	last_line = 0;
	indexh = 0;
	while (indexh < height)
	{
		out = (org_out + width * height * 4) - ((indexh + 1) * width * 4);
		color = 0;
		this_line = out;
		indexw = 0;
		if (last_line == 0)
		{
			while (indexw < width)
			{
				code = CVAL(in);
				replen = code & 0xf;
				collen = (code >> 4) & 0xf;
				revcode = (replen << 4) | collen;
				if ((revcode <= 47) && (revcode >= 16))
				{
					replen = revcode;
					collen = 0;
				}
				while (indexw < width && collen > 0)
				{
					color = CVAL(in);
					*out = color;
					out += 4;
					indexw++;
					collen--;
				}
				while (indexw < width && replen > 0)
				{
					*out = color;
					out += 4;
					indexw++;
					replen--;
				}
			}
		}
		else
		{
			while (indexw < width)
			{
				code = CVAL(in);
				replen = code & 0xf;
				collen = (code >> 4) & 0xf;
				revcode = (replen << 4) | collen;
				if ((revcode <= 47) && (revcode >= 16))
				{
					replen = revcode;
					collen = 0;
				}
				while (indexw < width && collen > 0)
				{
					x = CVAL(in);
					if (x & 1)
					{
						x = x >> 1;
						x = x + 1;
						color = -x;
					}
					else
					{
						x = x >> 1;
						color = x;
					}
					x = last_line[indexw * 4] + color;
					*out = x;
					out += 4;
					indexw++;
					collen--;
				}
				while (indexw < width && replen > 0)
				{
					x = last_line[indexw * 4] + color;
					*out = x;
					out += 4;
					indexw++;
					replen--;
				}
			}
		}
		indexh++;
		last_line = this_line;
	}
	return (int) (in - org_in);
}
","1. UNUSED(size);
2. int code;
int collen;
3. if (last_line == 0)
4. x = CVAL(in);
5. color = -x;
6. color = x;
7. out += 4;
8. out += 4;","4
7-8
28
73
78
83
87
95","CWE-125,CWE-787,CWE-119"
arch_ptrace-233532646704622,"long arch_ptrace(struct task_struct *child, long request,
		 unsigned long addr, unsigned long data)
{
	int ret;
	unsigned long __user *datap = (unsigned long __user *) data;

	switch (request) {
		case PTRACE_PEEKUSR:
			ret = ptrace_read_user(child, addr, datap);
			break;

		case PTRACE_POKEUSR:
			ret = ptrace_write_user(child, addr, data);
			break;

		case PTRACE_GETREGS:
			ret = copy_regset_to_user(child,
						  &user_arm_view, REGSET_GPR,
						  0, sizeof(struct pt_regs),
						  datap);
			break;

		case PTRACE_SETREGS:
			ret = copy_regset_from_user(child,
						    &user_arm_view, REGSET_GPR,
						    0, sizeof(struct pt_regs),
						    datap);
			break;

		case PTRACE_GETFPREGS:
			ret = copy_regset_to_user(child,
						  &user_arm_view, REGSET_FPR,
						  0, sizeof(union fp_state),
						  datap);
			break;

		case PTRACE_SETFPREGS:
			ret = copy_regset_from_user(child,
						    &user_arm_view, REGSET_FPR,
						    0, sizeof(union fp_state),
						    datap);
			break;

#ifdef CONFIG_IWMMXT
		case PTRACE_GETWMMXREGS:
			ret = ptrace_getwmmxregs(child, datap);
			break;

		case PTRACE_SETWMMXREGS:
			ret = ptrace_setwmmxregs(child, datap);
			break;
#endif

		case PTRACE_GET_THREAD_AREA:
			ret = put_user(task_thread_info(child)->tp_value[0],
				       datap);
			break;

		case PTRACE_SET_SYSCALL:
			task_thread_info(child)->syscall = data;
			ret = 0;
			break;

#ifdef CONFIG_CRUNCH
		case PTRACE_GETCRUNCHREGS:
			ret = ptrace_getcrunchregs(child, datap);
			break;

		case PTRACE_SETCRUNCHREGS:
			ret = ptrace_setcrunchregs(child, datap);
			break;
#endif

#ifdef CONFIG_VFP
		case PTRACE_GETVFPREGS:
			ret = copy_regset_to_user(child,
						  &user_arm_view, REGSET_VFP,
						  0, ARM_VFPREGS_SIZE,
						  datap);
			break;

		case PTRACE_SETVFPREGS:
			ret = copy_regset_from_user(child,
						    &user_arm_view, REGSET_VFP,
						    0, ARM_VFPREGS_SIZE,
						    datap);
			break;
#endif

#ifdef CONFIG_HAVE_HW_BREAKPOINT
		case PTRACE_GETHBPREGS:
			if (ptrace_get_breakpoints(child) < 0)
				return -ESRCH;

			ret = ptrace_gethbpregs(child, addr,
						(unsigned long __user *)data);
			ptrace_put_breakpoints(child);
			break;
		case PTRACE_SETHBPREGS:
			if (ptrace_get_breakpoints(child) < 0)
				return -ESRCH;

			ret = ptrace_sethbpregs(child, addr,
						(unsigned long __user *)data);
			ptrace_put_breakpoints(child);
			break;
#endif

		default:
			ret = ptrace_request(child, request, addr, data);
			break;
	}

	return ret;
}
","1. unsigned long addr, unsigned long data)
2. datap);
break;
3. case PTRACE_SET_SYSCALL:","2
56-57
59","CWE-190,CWE-264,CWE-119"
stv06xx_start-189720405906751,"static int stv06xx_start(struct gspca_dev *gspca_dev)
{
	struct sd *sd = (struct sd *) gspca_dev;
	struct usb_host_interface *alt;
	struct usb_interface *intf;
	int err, packet_size;

	intf = usb_ifnum_to_if(sd->gspca_dev.dev, sd->gspca_dev.iface);
	alt = usb_altnum_to_altsetting(intf, sd->gspca_dev.alt);
	if (!alt) {
		gspca_err(gspca_dev, ""Couldn't get altsetting\n"");
		return -EIO;
	}

	if (alt->desc.bNumEndpoints < 1)
		return -ENODEV;

	packet_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);
	err = stv06xx_write_bridge(sd, STV_ISO_SIZE_L, packet_size);
	if (err < 0)
		return err;

	
	err = sd->sensor->start(sd);
	if (err < 0)
		goto out;

	
	err = stv06xx_write_bridge(sd, STV_ISO_ENABLE, 1);

out:
	if (err < 0)
		gspca_dbg(gspca_dev, D_STREAM, ""Starting stream failed\n"");
	else
		gspca_dbg(gspca_dev, D_STREAM, ""Started streaming\n"");

	return (err < 0) ? err : 0;
}
","1. intf = usb_ifnum_to_if(sd->gspca_dev.dev, sd->gspca_dev.iface);
2. if (!alt) {
3. return -EIO;
4. err = stv06xx_write_bridge(sd, STV_ISO_SIZE_L, packet_size);
if (err < 0)
return err;
5. goto out;
6. err = stv06xx_write_bridge(sd, STV_ISO_ENABLE, 1);
7. gspca_dbg(gspca_dev, D_STREAM, ""Starting stream failed\n"");","8
10
12
19-21
26
29
33","CWE-120,CWE-125,CWE-119"
nsc_rle_decompress_data-278964544778933,"
#define NSC_CONTEXT

static BOOL nsc_rle_decompress_data(NSC_CONTEXT* context)
{
	UINT16 i;
	BYTE* rle;
	UINT32 planeSize;
	UINT32 originalSize;

	if (!context)
		return FALSE;

	rle = context->Planes;

	for (i = 0; i < 4; i++)
	{
		originalSize = context->OrgByteCount[i];
		planeSize = context->PlaneByteCount[i];

		if (planeSize == 0)
		{
			if (context->priv->PlaneBuffersLength < originalSize)
				return FALSE;

			FillMemory(context->priv->PlaneBuffers[i], originalSize, 0xFF);
		}
		else if (planeSize < originalSize)
		{
			if (!nsc_rle_decode(rle, context->priv->PlaneBuffers[i], context->priv->PlaneBuffersLength,
			                    originalSize))
				return FALSE;
		}
		else
		{
			if (context->priv->PlaneBuffersLength < originalSize)
				return FALSE;

			CopyMemory(context->priv->PlaneBuffers[i], rle, originalSize);
		}

		rle += planeSize;
	}

	return TRUE;
}
","1. static BOOL nsc_rle_decompress_data(NSC_CONTEXT* context)
2. UINT16 i;
3. UINT32 originalSize;
4. return FALSE;
5. rle = context->Planes;
6. for (i = 0; i < 4; i++)
7. originalSize = context->OrgByteCount[i];
planeSize = context->PlaneByteCount[i];
8. if (planeSize == 0)
9. if (context->priv->PlaneBuffersLength < originalSize)
return FALSE;
10. FillMemory(context->priv->PlaneBuffers[i], originalSize, 0xFF);
11. else if (planeSize < originalSize)
12. originalSize))
return FALSE;
13. if (context->priv->PlaneBuffersLength < originalSize)
return FALSE;
14. CopyMemory(context->priv->PlaneBuffers[i], rle, originalSize);
15. rle += planeSize;
16. return TRUE;","4
6
9
12
14
16
18-19
21
23-24
26
28
31-32
36-37
39
42
45","CWE-125,CWE-787"
check_allocations,"
#define ASS_Shaper

static bool check_allocations(ASS_Shaper *shaper, size_t new_size)
{
    if (new_size > shaper->n_glyphs) {
        if (!ASS_REALLOC_ARRAY(shaper->event_text, new_size) ||
            !ASS_REALLOC_ARRAY(shaper->ctypes, new_size) ||
             !ASS_REALLOC_ARRAY(shaper->emblevels, new_size) ||
             !ASS_REALLOC_ARRAY(shaper->cmap, new_size))
             return false;
        shaper->n_glyphs = new_size;
     }
     return true;
 }
","1. !ASS_REALLOC_ARRAY(shaper->ctypes, new_size) ||",8,"CWE-189,CWE-476,CWE-119,CWE-18,CWE-125"
flatpak_context_set_persistent-175474575808867,"
#define FlatpakContext
#define GError

static gboolean
flatpak_context_set_persistent (FlatpakContext *context,
                                const char     *path,
                                GError        **error)
{
  if (!flatpak_validate_path_characters (path, error))
    return FALSE;

  g_hash_table_insert (context->persistent, g_strdup (path), GINT_TO_POINTER (1));
  return TRUE;
}
","1. flatpak_context_set_persistent (FlatpakContext *context,
const char     *path,
GError        **error)
2. if (!flatpak_validate_path_characters (path, error))
return FALSE;","6-8
10-11","CWE-120,CWE-787,CWE-399,CWE-119"
do_fault-168861715198189,"static int do_fault(struct mm_struct *mm, struct vm_area_struct *vma,
		unsigned long address, pte_t *page_table, pmd_t *pmd,
		unsigned int flags, pte_t orig_pte)
{
	pgoff_t pgoff = (((address & PAGE_MASK)
			- vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;

	pte_unmap(page_table);
	
	if (!vma->vm_ops->fault)
		return VM_FAULT_SIGBUS;
	if (!(flags & FAULT_FLAG_WRITE))
		return do_read_fault(mm, vma, address, pmd, pgoff, flags,
				orig_pte);
	if (!(vma->vm_flags & VM_SHARED))
		return do_cow_fault(mm, vma, address, pmd, pgoff, flags,
				orig_pte);
	return do_shared_fault(mm, vma, address, pmd, pgoff, flags, orig_pte);
}
","1. static int do_fault(struct mm_struct *mm, struct vm_area_struct *vma,
2. pgoff_t pgoff = (((address & PAGE_MASK)
- vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;
3. pte_unmap(page_table);
4. orig_pte);","1
5-6
8
17","CWE-476,CWE-20,CWE-787,CWE-400"
unix_attach_fds-164487470968178,"static int unix_attach_fds(struct scm_cookie *scm, struct sk_buff *skb)
{
	int i;
	unsigned char max_level = 0;
	int unix_sock_count = 0;

	if (too_many_unix_fds(current))
		return -ETOOMANYREFS;

	for (i = scm->fp->count - 1; i >= 0; i--) {
		struct sock *sk = unix_get_socket(scm->fp->fp[i]);

		if (sk) {
			unix_sock_count++;
			max_level = max(max_level,
					unix_sk(sk)->recursion_level);
		}
	}
	if (unlikely(max_level > MAX_RECURSION_LEVEL))
		return -ETOOMANYREFS;

	
	UNIXCB(skb).fp = scm_fp_dup(scm->fp);
	if (!UNIXCB(skb).fp)
		return -ENOMEM;

	for (i = scm->fp->count - 1; i >= 0; i--)
		unix_inflight(scm->fp->fp[i]);
	return max_level;
}
","1. static int unix_attach_fds(struct scm_cookie *scm, struct sk_buff *skb)
2. unsigned char max_level = 0;","1
4","CWE-200,CWE-20,CWE-399,CWE-119"
opj_tcd_code_block_enc_allocate_data,"static OPJ_BOOL opj_tcd_code_block_enc_allocate_data(opj_tcd_cblk_enc_t *
        p_code_block)
 {
     OPJ_UINT32 l_data_size;
 
    
    l_data_size = 1 + (OPJ_UINT32)((p_code_block->x1 - p_code_block->x0) *
                                   (p_code_block->y1 - p_code_block->y0) * (OPJ_INT32)sizeof(OPJ_UINT32));
 
     if (l_data_size > p_code_block->data_size) {
         if (p_code_block->data) {
            
            opj_free(p_code_block->data - 1);
        }
        p_code_block->data = (OPJ_BYTE*) opj_malloc(l_data_size + 1);
        if (! p_code_block->data) {
            p_code_block->data_size = 0U;
            return OPJ_FALSE;
        }
        p_code_block->data_size = l_data_size;

        
        
        
        
        p_code_block->data[0] = 0;
        p_code_block->data += 1; 
    }
    return OPJ_TRUE;
}
","1. if (l_data_size > p_code_block->data_size) {
2. opj_free(p_code_block->data - 1);
3. p_code_block->data += 1;
4. return OPJ_TRUE;","10
13
27
29","CWE-20,CWE-284,CWE-476,CWE-787,CWE-119"
sanity_check_ckpt,"int sanity_check_ckpt(struct f2fs_sb_info *sbi)
{
	unsigned int total, fsmeta;
 	struct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);
 	struct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);
 	unsigned int ovp_segments, reserved_segments;
	unsigned int main_segs, blocks_per_seg;
	int i;
 
 	total = le32_to_cpu(raw_super->segment_count);
 	fsmeta = le32_to_cpu(raw_super->segment_count_ckpt);
	fsmeta += le32_to_cpu(raw_super->segment_count_sit);
	fsmeta += le32_to_cpu(raw_super->segment_count_nat);
	fsmeta += le32_to_cpu(ckpt->rsvd_segment_count);
	fsmeta += le32_to_cpu(raw_super->segment_count_ssa);

	if (unlikely(fsmeta >= total))
		return 1;

	ovp_segments = le32_to_cpu(ckpt->overprov_segment_count);
	reserved_segments = le32_to_cpu(ckpt->rsvd_segment_count);

	if (unlikely(fsmeta < F2FS_MIN_SEGMENTS ||
			ovp_segments == 0 || reserved_segments == 0)) {
		f2fs_msg(sbi->sb, KERN_ERR,
			""Wrong layout: check mkfs.f2fs version"");
 		return 1;
 	}
 
	main_segs = le32_to_cpu(raw_super->segment_count_main);
	blocks_per_seg = sbi->blocks_per_seg;

	for (i = 0; i < NR_CURSEG_NODE_TYPE; i++) {
		if (le32_to_cpu(ckpt->cur_node_segno[i]) >= main_segs ||
			le16_to_cpu(ckpt->cur_node_blkoff[i]) >= blocks_per_seg)
			return 1;
	}
	for (i = 0; i < NR_CURSEG_DATA_TYPE; i++) {
		if (le32_to_cpu(ckpt->cur_data_segno[i]) >= main_segs ||
			le16_to_cpu(ckpt->cur_data_blkoff[i]) >= blocks_per_seg)
			return 1;
	}

 	if (unlikely(f2fs_cp_error(sbi))) {
 		f2fs_msg(sbi->sb, KERN_ERR, ""A bug case: need to run fsck"");
 		return 1;
	}
	return 0;
}
","1. int sanity_check_ckpt(struct f2fs_sb_info *sbi)
2. struct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);
3. total = le32_to_cpu(raw_super->segment_count);
fsmeta = le32_to_cpu(raw_super->segment_count_ckpt);
4. if (unlikely(fsmeta >= total))
return 1;
5. ovp_segments = le32_to_cpu(ckpt->overprov_segment_count);
reserved_segments = le32_to_cpu(ckpt->rsvd_segment_count);
6. ovp_segments == 0 || reserved_segments == 0)) {
f2fs_msg(sbi->sb, KERN_ERR,
""Wrong layout: check mkfs.f2fs version"");
return 1;
7. le16_to_cpu(ckpt->cur_node_blkoff[i]) >= blocks_per_seg)
return 1;
8. if (le32_to_cpu(ckpt->cur_data_segno[i]) >= main_segs ||
9. return 1;
10. if (unlikely(f2fs_cp_error(sbi))) {
f2fs_msg(sbi->sb, KERN_ERR, ""A bug case: need to run fsck"");","1
4
10-11
17-18
20-21
24-27
35-36
39
41
44-45","CWE-129,CWE-17,CWE-189"
vc4_get_bcl_1-144054352385188,"static int
vc4_get_bcl_1(struct drm_device *dev, struct vc4_exec_info *exec)
{
	struct drm_vc4_submit_cl *args = exec->args;
	void *temp = NULL;
	void *bin;
	int ret = 0;
	uint32_t bin_offset = 0;
	uint32_t shader_rec_offset = roundup(bin_offset + args->bin_cl_size,
					     16);
	uint32_t uniforms_offset = shader_rec_offset + args->shader_rec_size;
	uint32_t exec_size = uniforms_offset + args->uniforms_size;
	uint32_t temp_size = exec_size + (sizeof(struct vc4_shader_state) *
					  args->shader_rec_count);
	struct vc4_bo *bo;

	if (shader_rec_offset < args->bin_cl_size ||
	    uniforms_offset < shader_rec_offset ||
	    exec_size < uniforms_offset ||
	    args->shader_rec_count >= (UINT_MAX /
					  sizeof(struct vc4_shader_state)) ||
	    temp_size < exec_size) {
		DRM_ERROR(""overflow in exec arguments\n"");
		ret = -EINVAL;
		goto fail;
	}

	
	temp = drm_malloc_ab(temp_size, 1);
	if (!temp) {
		DRM_ERROR(""Failed to allocate storage for copying ""
			  ""in bin/render CLs.\n"");
		ret = -ENOMEM;
		goto fail;
	}
	bin = temp + bin_offset;
	exec->shader_rec_u = temp + shader_rec_offset;
	exec->uniforms_u = temp + uniforms_offset;
	exec->shader_state = temp + exec_size;
	exec->shader_state_size = args->shader_rec_count;

	if (copy_from_user(bin,
			   (void __user *)(uintptr_t)args->bin_cl,
			   args->bin_cl_size)) {
		ret = -EFAULT;
		goto fail;
	}

	if (copy_from_user(exec->shader_rec_u,
			   (void __user *)(uintptr_t)args->shader_rec,
			   args->shader_rec_size)) {
		ret = -EFAULT;
		goto fail;
	}

	if (copy_from_user(exec->uniforms_u,
			   (void __user *)(uintptr_t)args->uniforms,
			   args->uniforms_size)) {
		ret = -EFAULT;
		goto fail;
	}

	bo = vc4_bo_create(dev, exec_size, true);
	if (IS_ERR(bo)) {
		DRM_ERROR(""Couldn't allocate BO for binning\n"");
		ret = PTR_ERR(bo);
		goto fail;
	}
	exec->exec_bo = &bo->base;

	list_add_tail(&to_vc4_bo(&exec->exec_bo->base)->unref_head,
		      &exec->unref_list);

	exec->ct0ca = exec->exec_bo->paddr + bin_offset;

	exec->bin_u = bin;

	exec->shader_rec_v = exec->exec_bo->vaddr + shader_rec_offset;
	exec->shader_rec_p = exec->exec_bo->paddr + shader_rec_offset;
	exec->shader_rec_size = args->shader_rec_size;

	exec->uniforms_v = exec->exec_bo->vaddr + uniforms_offset;
	exec->uniforms_p = exec->exec_bo->paddr + uniforms_offset;
	exec->uniforms_size = args->uniforms_size;

	ret = vc4_validate_bin_cl(dev,
				  exec->exec_bo->vaddr + bin_offset,
				  bin,
				  exec);
	if (ret)
		goto fail;

	ret = vc4_validate_shader_recs(dev, exec);
	if (ret)
		goto fail;

	
	ret = vc4_wait_for_seqno(dev, exec->bin_dep_seqno, ~0ull, true);

fail:
	drm_free_large(temp);
	return ret;
}
","1. 16);
2. args->shader_rec_count);
3. sizeof(struct vc4_shader_state)) ||
temp_size < exec_size) {
DRM_ERROR(""overflow in exec arguments\n"");
ret = -EINVAL;
4. temp = drm_malloc_ab(temp_size, 1);
if (!temp) {
5. ret = -ENOMEM;
6. exec->shader_state_size = args->shader_rec_count;
7. if (copy_from_user(bin,
8. if (copy_from_user(exec->uniforms_u,
9. goto fail;
10. if (IS_ERR(bo)) {
11. list_add_tail(&to_vc4_bo(&exec->exec_bo->base)->unref_head,
12. exec->shader_rec_p = exec->exec_bo->paddr + shader_rec_offset;
13. exec->uniforms_v = exec->exec_bo->vaddr + uniforms_offset;
14. goto fail;
15. fail:
drm_free_large(temp);","10
14
21-24
35-36
39
46
48
62
66
70
77
85
88
101
109-110","CWE-476,CWE-190,CWE-125,CWE-416"
pi_next_cprl,"static opj_bool pi_next_cprl(opj_pi_iterator_t * pi)
{
    opj_pi_comp_t *comp = NULL;
    opj_pi_resolution_t *res = NULL;
    long index = 0;

    if (!pi->first) {
        comp = &pi->comps[pi->compno];
        goto LABEL_SKIP;
    } else {
        pi->first = 0;
    }

    for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {
        int resno;
        comp = &pi->comps[pi->compno];
        pi->dx = 0;
        pi->dy = 0;
        for (resno = 0; resno < comp->numresolutions; resno++) {
            int dx, dy;
            res = &comp->resolutions[resno];
            dx = comp->dx * (1 << (res->pdx + comp->numresolutions - 1 - resno));
            dy = comp->dy * (1 << (res->pdy + comp->numresolutions - 1 - resno));
            pi->dx = !pi->dx ? dx : int_min(pi->dx, dx);
            pi->dy = !pi->dy ? dy : int_min(pi->dy, dy);
        }
        if (!pi->tp_on) {
            pi->poc.ty0 = pi->ty0;
            pi->poc.tx0 = pi->tx0;
            pi->poc.ty1 = pi->ty1;
            pi->poc.tx1 = pi->tx1;
        }
        for (pi->y = pi->poc.ty0; pi->y < pi->poc.ty1;
                pi->y += pi->dy - (pi->y % pi->dy)) {
            for (pi->x = pi->poc.tx0; pi->x < pi->poc.tx1;
                    pi->x += pi->dx - (pi->x % pi->dx)) {
                for (pi->resno = pi->poc.resno0;
                        pi->resno < int_min(pi->poc.resno1, comp->numresolutions); pi->resno++) {
                    int levelno;
                    int trx0, try0;
                    int trx1, try1;
                    int rpx, rpy;
                    int prci, prcj;
                    res = &comp->resolutions[pi->resno];
                    levelno = comp->numresolutions - 1 - pi->resno;
                    trx0 = int_ceildiv(pi->tx0, comp->dx << levelno);
                    try0 = int_ceildiv(pi->ty0, comp->dy << levelno);
                    trx1 = int_ceildiv(pi->tx1, comp->dx << levelno);
                    try1 = int_ceildiv(pi->ty1, comp->dy << levelno);
                    rpx = res->pdx + levelno;
                    rpy = res->pdy + levelno;

                    
                    if (rpx >= 31 || ((comp->dx << rpx) >> rpx) != comp->dx ||
                            rpy >= 31 || ((comp->dy << rpy) >> rpy) != comp->dy) {
                        continue;
                    }

                    if (!((pi->y % (comp->dy << rpy) == 0) || ((pi->y == pi->ty0) &&
                            ((try0 << levelno) % (1 << rpy))))) {
                        continue;
                    }
                    if (!((pi->x % (comp->dx << rpx) == 0) || ((pi->x == pi->tx0) &&
                            ((trx0 << levelno) % (1 << rpx))))) {
                        continue;
                    }

                    if ((res->pw == 0) || (res->ph == 0)) {
                        continue;
                    }

                    if ((trx0 == trx1) || (try0 == try1)) {
                        continue;
                    }

                    prci = int_floordivpow2(int_ceildiv(pi->x, comp->dx << levelno), res->pdx)
                           - int_floordivpow2(trx0, res->pdx);
                    prcj = int_floordivpow2(int_ceildiv(pi->y, comp->dy << levelno), res->pdy)
                           - int_floordivpow2(try0, res->pdy);
                    pi->precno = prci + prcj * res->pw;
                     for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {
                         index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno *
                                 pi->step_c + pi->precno * pi->step_p;
                        
                        if (index >= pi->include_size) {
                            opj_pi_emit_error(pi, ""Invalid access to pi->include"");
                            return OPJ_FALSE;
                        }
                         if (!pi->include[index]) {
                             pi->include[index] = 1;
                             return OPJ_TRUE;
                        }
LABEL_SKIP:
                        ;
                    }
                }
            }
        }
    }

    return OPJ_FALSE;
}
","1. } else {
2. for (resno = 0; resno < comp->numresolutions; resno++) {
3. pi->dx = !pi->dx ? dx : int_min(pi->dx, dx);
4. pi->poc.tx0 = pi->tx0;
5. pi->y += pi->dy - (pi->y % pi->dy)) {
6. int levelno;
7. if (rpx >= 31 || ((comp->dx << rpx) >> rpx) != comp->dx ||
8. ((trx0 << levelno) % (1 << rpx))))) {
continue;
9. return OPJ_FALSE;","10
19
24
29
34
39
54
64-65
101","CWE-17,CWE-125,CWE-369"
njs_function_lambda_call-30253705688117,"njs_int_t
njs_function_lambda_call(njs_vm_t *vm, void *promise_cap, void *async_ctx)
{
    uint32_t               n;
    njs_int_t              ret;
    njs_frame_t            *frame;
    njs_value_t            *args, **local, *value;
    njs_value_t            **cur_local, **cur_closures, **cur_temp;
    njs_function_t         *function;
    njs_declaration_t      *declr;
    njs_function_lambda_t  *lambda;

    frame = (njs_frame_t *) vm->top_frame;
    function = frame->native.function;

    njs_assert(function->context == NULL);

    if (function->global && !function->closure_copied) {
        ret = njs_function_capture_global_closures(vm, function);
        if (njs_slow_path(ret != NJS_OK)) {
            return NJS_ERROR;
        }
    }

    lambda = function->u.lambda;

    args = vm->top_frame->arguments;
    local = vm->top_frame->local + function->args_offset;

    

    for (n = 0; n < function->args_count; n++) {
        if (!njs_is_valid(args)) {
            njs_set_undefined(args);
        }

        *local++ = args++;
    }

    

    cur_local = vm->levels[NJS_LEVEL_LOCAL];
    cur_closures = vm->levels[NJS_LEVEL_CLOSURE];
    cur_temp = vm->levels[NJS_LEVEL_TEMP];

    

    vm->levels[NJS_LEVEL_LOCAL] = vm->top_frame->local;
    vm->levels[NJS_LEVEL_CLOSURE] = njs_function_closures(function);
    vm->levels[NJS_LEVEL_TEMP] = frame->native.temp;

    if (lambda->rest_parameters) {
        ret = njs_function_rest_parameters_init(vm, &frame->native);
        if (njs_slow_path(ret != NJS_OK)) {
            return NJS_ERROR;
        }
    }

    

    if (lambda->self != NJS_INDEX_NONE) {
        value = njs_scope_value(vm, lambda->self);

        if (!njs_is_valid(value)) {
            njs_set_function(value, function);
        }
    }

    vm->active_frame = frame;

    

    n = lambda->ndeclarations;

    while (n != 0) {
        n--;

        declr = &lambda->declarations[n];
        value = njs_scope_value(vm, declr->index);

        *value = *declr->value;

        function = njs_function_value_copy(vm, value);
        if (njs_slow_path(function == NULL)) {
            return NJS_ERROR;
        }

        ret = njs_function_capture_closure(vm, function, function->u.lambda);
        if (njs_slow_path(ret != NJS_OK)) {
            return ret;
        }
    }

    ret = njs_vmcode_interpreter(vm, lambda->start, promise_cap, async_ctx);

    
    vm->levels[NJS_LEVEL_LOCAL] = cur_local;
    vm->levels[NJS_LEVEL_CLOSURE] = cur_closures;
    vm->levels[NJS_LEVEL_TEMP] = cur_temp;

    return ret;
}
","1. njs_int_t              ret;
2. njs_declaration_t      *declr;
njs_function_lambda_t  *lambda;
3. function = frame->native.function;
4. njs_assert(function->context == NULL);
5. if (function->global && !function->closure_copied) {
6. args = vm->top_frame->arguments;
7. njs_set_undefined(args);
8. cur_temp = vm->levels[NJS_LEVEL_TEMP];
9. vm->levels[NJS_LEVEL_LOCAL] = vm->top_frame->local;
10. ret = njs_function_rest_parameters_init(vm, &frame->native);
11. vm->active_frame = frame;
12. while (n != 0) {
13. *value = *declr->value;
14. if (njs_slow_path(function == NULL)) {
15. ret = njs_vmcode_interpreter(vm, lambda->start, promise_cap, async_ctx);
16. vm->levels[NJS_LEVEL_LOCAL] = cur_local;
17. vm->levels[NJS_LEVEL_TEMP] = cur_temp;","5
10-11
14
16
18
27
34
44
48
53
69
75
81
84
94
97
99","CWE-362,CWE-20,CWE-400,CWE-119"
epass2003_sm_unwrap_apdu_1,"epass2003_sm_unwrap_apdu_1(struct sc_card *card, struct sc_apdu *sm, struct sc_apdu *plain)
{
	int r;
	size_t len = 0;
	epass2003_exdata *exdata = NULL;

	if (!card->drv_data) 
		return SC_ERROR_INVALID_ARGUMENTS;

	exdata = (epass2003_exdata *)card->drv_data;

	LOG_FUNC_CALLED(card->ctx);

 	r = sc_check_sw(card, sm->sw1, sm->sw2);
 	if (r == SC_SUCCESS) {
 		if (exdata->sm) {
			len = plain->resplen;
 			if (0 != decrypt_response(card, sm->resp, sm->resplen, plain->resp, &len))
 				return SC_ERROR_CARD_CMD_FAILED;
 		}
		else {
			memcpy(plain->resp, sm->resp, sm->resplen);
			len = sm->resplen;
		}
	}

	plain->resplen = len;
	plain->sw1 = sm->sw1;
	plain->sw2 = sm->sw2;

	sc_log(card->ctx,
	       ""unwrapped APDU: resplen %""SC_FORMAT_LEN_SIZE_T""u, SW %02X%02X"",
	       plain->resplen, plain->sw1, plain->sw2);
	LOG_FUNC_RETURN(card->ctx, SC_SUCCESS);
}
","1. epass2003_sm_unwrap_apdu_1(struct sc_card *card, struct sc_apdu *sm, struct sc_apdu *plain)
2. int r;
3. if (!card->drv_data)
4. r = sc_check_sw(card, sm->sw1, sm->sw2);
5. len = plain->resplen;
6. return SC_ERROR_CARD_CMD_FAILED;
7. memcpy(plain->resp, sm->resp, sm->resplen);
len = sm->resplen;
8. plain->resplen = len;
plain->sw1 = sm->sw1;
9. LOG_FUNC_RETURN(card->ctx, SC_SUCCESS);","1
3
7
14
17
19
22-23
27-28
34","CWE-200,CWE-125,CWE-399,CWE-400"
fuse_notify_inval_entry,"static int fuse_notify_inval_entry(struct fuse_conn *fc, unsigned int size,
				   struct fuse_copy_state *cs)
{
	struct fuse_notify_inval_entry_out outarg;
	int err = -ENOMEM;
	char *buf;
	struct qstr name;

	buf = kzalloc(FUSE_NAME_MAX + 1, GFP_KERNEL);
	if (!buf)
		goto err;

	err = -EINVAL;
	if (size < sizeof(outarg))
		goto err;

	err = fuse_copy_one(cs, &outarg, sizeof(outarg));
	if (err)
		goto err;

	err = -ENAMETOOLONG;
 	if (outarg.namelen > FUSE_NAME_MAX)
 		goto err;
 
	err = -EINVAL;
	if (size != sizeof(outarg) + outarg.namelen + 1)
		goto err;

 	name.name = buf;
 	name.len = outarg.namelen;
 	err = fuse_copy_one(cs, buf, outarg.namelen + 1);
	if (err)
		goto err;
	fuse_copy_finish(cs);
	buf[outarg.namelen] = 0;
	name.hash = full_name_hash(name.name, name.len);

	down_read(&fc->killsb);
	err = -ENOENT;
	if (fc->sb)
		err = fuse_reverse_inval_entry(fc->sb, outarg.parent, &name);
	up_read(&fc->killsb);
	kfree(buf);
	return err;

err:
	kfree(buf);
	fuse_copy_finish(cs);
	return err;
}
","1. struct fuse_copy_state *cs)
2. struct fuse_notify_inval_entry_out outarg;
3. char *buf;
4. err = -EINVAL;
if (size < sizeof(outarg))
goto err;
5. err = fuse_copy_one(cs, &outarg, sizeof(outarg));
if (err)
6. err = -ENAMETOOLONG;
7. name.len = outarg.namelen;
8. buf[outarg.namelen] = 0;
name.hash = full_name_hash(name.name, name.len);
9. fuse_copy_finish(cs);","2
4
6
13-15
17-18
21
30
35-36
48","CWE-17,CWE-120,CWE-19,CWE-119"
Huff_offsetTransmit-241877102890679,"void Huff_offsetTransmit (huff_t *huff, int ch, byte *fout, int *offset, int maxoffset) {
	bloc = *offset;
	send(huff->loc[ch], NULL, fout, maxoffset);
	*offset = bloc;
}
","1. void Huff_offsetTransmit (huff_t *huff, int ch, byte *fout, int *offset, int maxoffset) {
2. send(huff->loc[ch], NULL, fout, maxoffset);
*offset = bloc;","1
3-4","CWE-264,CWE-611"
main_25," int main_25(int argc, char **argv) {
 FILE *infile = NULL;
 vpx_codec_ctx_t codec;
 vpx_codec_enc_cfg_t cfg;
 int frame_count = 0;
 vpx_image_t raw;
 vpx_codec_err_t res;
 VpxVideoInfo info = {0};
 VpxVideoWriter *writer = NULL;
 const VpxInterface *encoder = NULL;
 const int fps = 30; 
 const int bitrate = 200; 
 int keyframe_interval = 0;

 const char *codec_arg = NULL;
 const char *width_arg = NULL;
 const char *height_arg = NULL;
 const char *infile_arg = NULL;
 const char *outfile_arg = NULL;
 const char *keyframe_interval_arg = NULL;

  exec_name = argv[0];

 if (argc < 7)
    die(""Invalid number of arguments"");

  codec_arg = argv[1];
  width_arg = argv[2];
  height_arg = argv[3];
  infile_arg = argv[4];
  outfile_arg = argv[5];
  keyframe_interval_arg = argv[6];

  encoder = get_vpx_encoder_by_name(codec_arg);
 if (!encoder)
     die(""Unsupported codec."");

  info.codec_fourcc = encoder->fourcc;
  info.frame_width = strtol(width_arg, NULL, 0);
  info.frame_height = strtol(height_arg, NULL, 0);
  info.time_base.numerator = 1;
  info.time_base.denominator = fps;

 if (info.frame_width <= 0 ||
      info.frame_height <= 0 ||
 (info.frame_width % 2) != 0 ||
 (info.frame_height % 2) != 0) {
    die(""Invalid frame size: %dx%d"", info.frame_width, info.frame_height);
 }

 if (!vpx_img_alloc(&raw, VPX_IMG_FMT_I420, info.frame_width,
                                             info.frame_height, 1)) {
    die(""Failed to allocate image."");
 }

  keyframe_interval = strtol(keyframe_interval_arg, NULL, 0);

   if (keyframe_interval < 0)
     die(""Invalid keyframe interval value."");
 
  printf(""Using %s\n"", vpx_codec_iface_name(encoder->codec_interface()));
 
  res = vpx_codec_enc_config_default(encoder->codec_interface(), &cfg, 0);
   if (res)
     die_codec(&codec, ""Failed to get default codec config."");
 
  cfg.g_w = info.frame_width;
  cfg.g_h = info.frame_height;
  cfg.g_timebase.num = info.time_base.numerator;
  cfg.g_timebase.den = info.time_base.denominator;
  cfg.rc_target_bitrate = bitrate;
  cfg.g_error_resilient = argc > 7 ? strtol(argv[7], NULL, 0) : 0;

  writer = vpx_video_writer_open(outfile_arg, kContainerIVF, &info);
 if (!writer)
    die(""Failed to open %s for writing."", outfile_arg);


   if (!(infile = fopen(infile_arg, ""rb"")))
     die(""Failed to open %s for reading."", infile_arg);
 
  if (vpx_codec_enc_init(&codec, encoder->codec_interface(), &cfg, 0))
     die_codec(&codec, ""Failed to initialize encoder"");
 
  
   while (vpx_img_read(&raw, infile)) {
     int flags = 0;
     if (keyframe_interval > 0 && frame_count % keyframe_interval == 0)
       flags |= VPX_EFLAG_FORCE_KF;
     encode_frame(&codec, &raw, frame_count++, flags, writer);
   }

  
  while (encode_frame(&codec, NULL, -1, 0, writer)) {};
 
   printf(""\n"");
   fclose(infile);
  printf(""Processed %d frames.\n"", frame_count);

  vpx_img_free(&raw);
 if (vpx_codec_destroy(&codec))
    die_codec(&codec, ""Failed to destroy codec."");

  vpx_video_writer_close(writer);

 return EXIT_SUCCESS;
}
","1. int main_25(int argc, char **argv) {
FILE *infile = NULL;
2. VpxVideoWriter *writer = NULL;
3. const int bitrate = 200;
int keyframe_interval = 0;
4. const char *width_arg = NULL;
5. const char *outfile_arg = NULL;
6. die(""Invalid number of arguments"");
7. encoder = get_vpx_encoder_by_name(codec_arg);
8. info.codec_fourcc = encoder->fourcc;
info.frame_width = strtol(width_arg, NULL, 0);
9. info.time_base.denominator = fps;
10. if (info.frame_width <= 0 ||
info.frame_height <= 0 ||
11. die(""Invalid frame size: %dx%d"", info.frame_width, info.frame_height);
12. if (!vpx_img_alloc(&raw, VPX_IMG_FMT_I420, info.frame_width,
13. if (keyframe_interval < 0)
die(""Invalid keyframe interval value."");
14. printf(""Using %s\n"", vpx_codec_iface_name(encoder->codec_interface()));
15. if (res)
16. cfg.rc_target_bitrate = bitrate;
17. if (!(infile = fopen(infile_arg, ""rb"")))
18. die_codec(&codec, ""Failed to initialize encoder"");
19. while (encode_frame(&codec, NULL, -1, 0, writer)) {};
20. vpx_img_free(&raw);
21. return EXIT_SUCCESS;","1-2
9
12-13
16
19
25
34
38-39
42
44-45
48
51
58-59
61
64
71
79
83
94
100
106","CWE-347,CWE-704,CWE-415,CWE-119"
open_log_file," static FILE *open_log_file(void)
 {
	int fh;
	struct stat st;

 	if(log_fp) 
 		return log_fp;
 
	if ((fh = open(log_file, O_RDWR|O_APPEND|O_CREAT|O_NOFOLLOW, S_IRUSR|S_IWUSR)) == -1) {
		if (daemon_mode == FALSE)
			printf(""Warning: Cannot open log file '%s' for writing\n"", log_file);
		return NULL;
	}
	log_fp = fdopen(fh, ""a+"");
 	if(log_fp == NULL) {
		if (daemon_mode == FALSE)
 			printf(""Warning: Cannot open log file '%s' for writing\n"", log_file);
 		return NULL;
 		}
 
	if ((fstat(fh, &st)) == -1) {
		log_fp = NULL;
		close(fh);
		if (daemon_mode == FALSE)
			printf(""Warning: Cannot fstat log file '%s'\n"", log_file);
		return NULL;
	}
	if (st.st_nlink != 1 || (st.st_mode & S_IFMT) != S_IFREG) {
		log_fp = NULL;
		close(fh);
		if (daemon_mode == FALSE)
			printf(""Warning: log file '%s' has an invalid mode\n"", log_file);
		return NULL;
	}

 	(void)fcntl(fileno(log_fp), F_SETFD, FD_CLOEXEC);
 	return log_fp;
 }
","1. if ((fh = open(log_file, O_RDWR|O_APPEND|O_CREAT|O_NOFOLLOW, S_IRUSR|S_IWUSR)) == -1) {
2. log_fp = fdopen(fh, ""a+"");
if(log_fp == NULL) {
if (daemon_mode == FALSE)
3. if (daemon_mode == FALSE)
4. return NULL;
5. if (daemon_mode == FALSE)","9
14-16
24
26
31","CWE-200,CWE-125,CWE-399,CWE-119"
nfs4_open_prepare-96093297386335,"static void nfs4_open_prepare(struct rpc_task *task, void *calldata)
{
	struct nfs4_opendata *data = calldata;
	struct nfs4_state_owner *sp = data->owner;

	if (nfs_wait_on_sequence(data->o_arg.seqid, task) != 0)
		return;
	
	if (data->state != NULL) {
		struct nfs_delegation *delegation;

		if (can_open_cached(data->state, data->o_arg.fmode, data->o_arg.open_flags))
			goto out_no_action;
		rcu_read_lock();
		delegation = rcu_dereference(NFS_I(data->state->inode)->delegation);
		if (delegation != NULL &&
		    test_bit(NFS_DELEGATION_NEED_RECLAIM, &delegation->flags) == 0) {
			rcu_read_unlock();
			goto out_no_action;
		}
		rcu_read_unlock();
	}
	
	data->o_arg.id = sp->so_owner_id.id;
	data->o_arg.clientid = sp->so_client->cl_clientid;
	if (data->o_arg.claim == NFS4_OPEN_CLAIM_PREVIOUS) {
		task->tk_msg.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_OPEN_NOATTR];
		nfs_copy_fh(&data->o_res.fh, data->o_arg.fh);
	}
	data->timestamp = jiffies;
	rpc_call_start(task);
	return;
out_no_action:
	task->tk_action = NULL;

}
","1. struct nfs4_opendata *data = calldata;
2. struct nfs_delegation *delegation;
3. if (can_open_cached(data->state, data->o_arg.fmode, data->o_arg.open_flags))
4. data->o_arg.clientid = sp->so_client->cl_clientid;
5. nfs_copy_fh(&data->o_res.fh, data->o_arg.fh);
6. data->timestamp = jiffies;
rpc_call_start(task);
return;","3
13
15
28
31
33-35","CWE-20,CWE-59,CWE-416"
cdf_read_property_info_2,"cdf_read_property_info_2(const cdf_stream_t *sst, const cdf_header_t *h,
    uint32_t offs, cdf_property_info_t **info, size_t *count, size_t *maxcount)
{
	const cdf_section_header_t *shp;
	cdf_section_header_t sh;
	const uint8_t *p, *q, *e;
	int16_t s16;
	int32_t s32;
	uint32_t u32;
	int64_t s64;
	uint64_t u64;
	cdf_timestamp_t tp;
	size_t i, o, o4, nelements, j;
	cdf_property_info_t *inp;

	if (offs > UINT32_MAX / 4) {
		errno = EFTYPE;
		goto out;
	}
	shp = CAST(const cdf_section_header_t *, (const void *)
	    ((const char *)sst->sst_tab + offs));
	if (cdf_check_stream_offset(sst, h, shp, sizeof(*shp), __LINE__) == -1)
		goto out;
	sh.sh_len = CDF_TOLE4(shp->sh_len);
#define CDF_SHLEN_LIMIT (UINT32_MAX / 8)
	if (sh.sh_len > CDF_SHLEN_LIMIT) {
		errno = EFTYPE;
		goto out;
	}
	sh.sh_properties = CDF_TOLE4(shp->sh_properties);
#define CDF_PROP_LIMIT (UINT32_MAX / (4 * sizeof(*inp)))
	if (sh.sh_properties > CDF_PROP_LIMIT)
		goto out;
	DPRINTF((""section len: %u properties %u\n"", sh.sh_len,
	    sh.sh_properties));
	if (*maxcount) {
		if (*maxcount > CDF_PROP_LIMIT)
			goto out;
		*maxcount += sh.sh_properties;
		inp = CAST(cdf_property_info_t *,
		    realloc(*info, *maxcount * sizeof(*inp)));
	} else {
		*maxcount = sh.sh_properties;
		inp = CAST(cdf_property_info_t *,
		    malloc(*maxcount * sizeof(*inp)));
	}
	if (inp == NULL)
		goto out;
	*info = inp;
	inp += *count;
	*count += sh.sh_properties;
	p = CAST(const uint8_t *, (const void *)
	    ((const char *)(const void *)sst->sst_tab +
	    offs + sizeof(sh)));
	e = CAST(const uint8_t *, (const void *)
	    (((const char *)(const void *)shp) + sh.sh_len));
 	if (cdf_check_stream_offset(sst, h, e, 0, __LINE__) == -1)
 		goto out;
 	for (i = 0; i < sh.sh_properties; i++) {
		size_t ofs = CDF_GETUINT32(p, (i << 1) + 1);
 		q = (const uint8_t *)(const void *)
		    ((const char *)(const void *)p + ofs
		    - 2 * sizeof(uint32_t));
 		if (q > e) {
 			DPRINTF((""Ran of the end %p > %p\n"", q, e));
 			goto out;
 		}
 		inp[i].pi_id = CDF_GETUINT32(p, i << 1);
 		inp[i].pi_type = CDF_GETUINT32(q, 0);
		DPRINTF((""%"" SIZE_T_FORMAT ""u) id=%x type=%x offs=0x%tx,0x%x\n"",
		    i, inp[i].pi_id, inp[i].pi_type, q - p, offs));
 		if (inp[i].pi_type & CDF_VECTOR) {
 			nelements = CDF_GETUINT32(q, 1);
 			o = 2;
		} else {
			nelements = 1;
			o = 1;
		}
		o4 = o * sizeof(uint32_t);
		if (inp[i].pi_type & (CDF_ARRAY|CDF_BYREF|CDF_RESERVED))
			goto unknown;
		switch (inp[i].pi_type & CDF_TYPEMASK) {
		case CDF_NULL:
		case CDF_EMPTY:
			break;
		case CDF_SIGNED16:
			if (inp[i].pi_type & CDF_VECTOR)
				goto unknown;
			(void)memcpy(&s16, &q[o4], sizeof(s16));
			inp[i].pi_s16 = CDF_TOLE2(s16);
			break;
		case CDF_SIGNED32:
			if (inp[i].pi_type & CDF_VECTOR)
				goto unknown;
			(void)memcpy(&s32, &q[o4], sizeof(s32));
			inp[i].pi_s32 = CDF_TOLE4((uint32_t)s32);
			break;
		case CDF_BOOL:
		case CDF_UNSIGNED32:
			if (inp[i].pi_type & CDF_VECTOR)
				goto unknown;
			(void)memcpy(&u32, &q[o4], sizeof(u32));
			inp[i].pi_u32 = CDF_TOLE4(u32);
			break;
		case CDF_SIGNED64:
			if (inp[i].pi_type & CDF_VECTOR)
				goto unknown;
			(void)memcpy(&s64, &q[o4], sizeof(s64));
			inp[i].pi_s64 = CDF_TOLE8((uint64_t)s64);
			break;
		case CDF_UNSIGNED64:
			if (inp[i].pi_type & CDF_VECTOR)
				goto unknown;
			(void)memcpy(&u64, &q[o4], sizeof(u64));
			inp[i].pi_u64 = CDF_TOLE8((uint64_t)u64);
			break;
		case CDF_FLOAT:
			if (inp[i].pi_type & CDF_VECTOR)
				goto unknown;
			(void)memcpy(&u32, &q[o4], sizeof(u32));
			u32 = CDF_TOLE4(u32);
			memcpy(&inp[i].pi_f, &u32, sizeof(inp[i].pi_f));
			break;
		case CDF_DOUBLE:
			if (inp[i].pi_type & CDF_VECTOR)
				goto unknown;
			(void)memcpy(&u64, &q[o4], sizeof(u64));
			u64 = CDF_TOLE8((uint64_t)u64);
			memcpy(&inp[i].pi_d, &u64, sizeof(inp[i].pi_d));
			break;
		case CDF_LENGTH32_STRING:
		case CDF_LENGTH32_WSTRING:
			if (nelements > 1) {
				size_t nelem = inp - *info;
				if (*maxcount > CDF_PROP_LIMIT
				    || nelements > CDF_PROP_LIMIT)
					goto out;
				*maxcount += nelements;
				inp = CAST(cdf_property_info_t *,
				    realloc(*info, *maxcount * sizeof(*inp)));
				if (inp == NULL)
					goto out;
				*info = inp;
				inp = *info + nelem;
			}
			DPRINTF((""nelements = %"" SIZE_T_FORMAT ""u\n"",
			    nelements));
			for (j = 0; j < nelements; j++, i++) {
				uint32_t l = CDF_GETUINT32(q, o);
				inp[i].pi_str.s_len = l;
				inp[i].pi_str.s_buf = (const char *)
				    (const void *)(&q[o4 + sizeof(l)]);
				DPRINTF((""l = %d, r = %"" SIZE_T_FORMAT
				    ""u, s = %s\n"", l,
				    CDF_ROUND(l, sizeof(l)),
				    inp[i].pi_str.s_buf));
				if (l & 1)
					l++;
				o += l >> 1;
				if (q + o >= e)
					goto out;
				o4 = o * sizeof(uint32_t);
			}
			i--;
			break;
		case CDF_FILETIME:
			if (inp[i].pi_type & CDF_VECTOR)
				goto unknown;
			(void)memcpy(&tp, &q[o4], sizeof(tp));
			inp[i].pi_tp = CDF_TOLE8((uint64_t)tp);
			break;
		case CDF_CLIPBOARD:
			if (inp[i].pi_type & CDF_VECTOR)
				goto unknown;
			break;
		default:
		unknown:
			DPRINTF((""Don't know how to deal with %x\n"",
			    inp[i].pi_type));
			break;
		}
	}
	return 0;
out:
	free(*info);
	return -1;
}
","1. uint32_t u32;
int64_t s64;
2. cdf_timestamp_t tp;
3. sh.sh_properties = CDF_TOLE4(shp->sh_properties);
4. if (inp[i].pi_type & CDF_VECTOR)
5. if (inp == NULL)","9-10
12
30
125
141","CWE-119,CWE-20,CWE-189"
parse_bin_node-70563597974833,"static plist_t parse_bin_node(struct bplist_data *bplist, const char** object)
{
    uint16_t type = 0;
    uint64_t size = 0;

    if (!object)
        return NULL;

    type = (**object) & BPLIST_MASK;
    size = (**object) & BPLIST_FILL;
    (*object)++;

    if (size == BPLIST_FILL) {
        switch (type) {
        case BPLIST_DATA:
        case BPLIST_STRING:
        case BPLIST_UNICODE:
        case BPLIST_ARRAY:
        case BPLIST_SET:
        case BPLIST_DICT:
        {
            uint16_t next_size = **object & BPLIST_FILL;
            if ((**object & BPLIST_MASK) != BPLIST_UINT) {
                PLIST_BIN_ERR(""%s: invalid size node type for node type 0x%02x: found 0x%02x, expected 0x%02x\n"", __func__, type, **object & BPLIST_MASK, BPLIST_UINT);
                return NULL;
            }
            (*object)++;
            next_size = 1 << next_size;
            if (*object + next_size > bplist->offset_table) {
                PLIST_BIN_ERR(""%s: size node data bytes for node type 0x%02x point outside of valid range\n"", __func__, type);
                return NULL;
            }
            size = UINT_TO_HOST(*object, next_size);
            (*object) += next_size;
            break;
        }
        default:
            break;
        }
    }

    switch (type)
    {

    case BPLIST_NULL:
        switch (size)
        {

        case BPLIST_TRUE:
        {
            plist_data_t data = plist_new_plist_data();
            data->type = PLIST_BOOLEAN;
            data->boolval = TRUE;
            data->length = 1;
            return node_create(NULL, data);
        }

        case BPLIST_FALSE:
        {
            plist_data_t data = plist_new_plist_data();
            data->type = PLIST_BOOLEAN;
            data->boolval = FALSE;
            data->length = 1;
            return node_create(NULL, data);
        }

        case BPLIST_NULL:
        default:
            return NULL;
        }

    case BPLIST_UINT:
        if (*object + (uint64_t)(1 << size) > bplist->offset_table) {
            PLIST_BIN_ERR(""%s: BPLIST_UINT data bytes point outside of valid range\n"", __func__);
            return NULL;
        }
        return parse_uint_node(object, size);

    case BPLIST_REAL:
        if (*object + (uint64_t)(1 << size) > bplist->offset_table) {
            PLIST_BIN_ERR(""%s: BPLIST_REAL data bytes point outside of valid range\n"", __func__);
            return NULL;
        }
        return parse_real_node(object, size);

    case BPLIST_DATE:
        if (3 != size) {
            PLIST_BIN_ERR(""%s: invalid data size for BPLIST_DATE node\n"", __func__);
            return NULL;
        }
        if (*object + (uint64_t)(1 << size) > bplist->offset_table) {
            PLIST_BIN_ERR(""%s: BPLIST_DATE data bytes point outside of valid range\n"", __func__);
            return NULL;
        }
        return parse_date_node(object, size);

    case BPLIST_DATA:
        if (*object + size < *object || *object + size > bplist->offset_table) {
            PLIST_BIN_ERR(""%s: BPLIST_DATA data bytes point outside of valid range\n"", __func__);
            return NULL;
        }
        return parse_data_node(object, size);

    case BPLIST_STRING:
        if (*object + size < *object || *object + size > bplist->offset_table) {
            PLIST_BIN_ERR(""%s: BPLIST_STRING data bytes point outside of valid range\n"", __func__);
            return NULL;
        }
        return parse_string_node(object, size);

    case BPLIST_UNICODE:
        if (size*2 < size) {
            PLIST_BIN_ERR(""%s: Integer overflow when calculating BPLIST_UNICODE data size.\n"", __func__);
            return NULL;
        }
        if (*object + size*2 < *object || *object + size*2 > bplist->offset_table) {
            PLIST_BIN_ERR(""%s: BPLIST_UNICODE data bytes point outside of valid range\n"", __func__);
            return NULL;
        }
        return parse_unicode_node(object, size);

    case BPLIST_SET:
    case BPLIST_ARRAY:
        if (*object + size < *object || *object + size > bplist->offset_table) {
            PLIST_BIN_ERR(""%s: BPLIST_ARRAY data bytes point outside of valid range\n"", __func__);
            return NULL;
        }
        return parse_array_node(bplist, object, size);

    case BPLIST_UID:
        if (*object + size+1 > bplist->offset_table) {
            PLIST_BIN_ERR(""%s: BPLIST_UID data bytes point outside of valid range\n"", __func__);
            return NULL;
        }
        return parse_uid_node(object, size);

    case BPLIST_DICT:
        if (*object + size < *object || *object + size > bplist->offset_table) {
            PLIST_BIN_ERR(""%s: BPLIST_DICT data bytes point outside of valid range\n"", __func__);
            return NULL;
        }
        return parse_dict_node(bplist, object, size);

    default:
        PLIST_BIN_ERR(""%s: unexpected node type 0x%02x\n"", __func__, type);
        return NULL;
    }
    return NULL;
}
","1. static plist_t parse_bin_node(struct bplist_data *bplist, const char** object)
2. (*object)++;
3. if (size == BPLIST_FILL) {
4. case BPLIST_DATA:
5. case BPLIST_UNICODE:
case BPLIST_ARRAY:
case BPLIST_SET:
case BPLIST_DICT:
6. return NULL;
7. next_size = 1 << next_size;
8. return NULL;
9. size = UINT_TO_HOST(*object, next_size);
10. break;
11. default:
12. case BPLIST_NULL:
switch (size)
13. plist_data_t data = plist_new_plist_data();
data->type = PLIST_BOOLEAN;
data->boolval = TRUE;
data->length = 1;
14. case BPLIST_FALSE:
15. data->boolval = FALSE;
16. return NULL;
17. case BPLIST_UINT:
18. PLIST_BIN_ERR(""%s: BPLIST_UINT data bytes point outside of valid range\n"", __func__);
19. case BPLIST_REAL:
20. PLIST_BIN_ERR(""%s: BPLIST_REAL data bytes point outside of valid range\n"", __func__);
21. return parse_real_node(object, size);
22. PLIST_BIN_ERR(""%s: invalid data size for BPLIST_DATE node\n"", __func__);
23. if (*object + (uint64_t)(1 << size) > bplist->offset_table) {
24. return NULL;
25. case BPLIST_DATA:
if (*object + size < *object || *object + size > bplist->offset_table) {
26. return NULL;
27. return parse_data_node(object, size);
28. return parse_string_node(object, size);
29. if (size*2 < size) {
PLIST_BIN_ERR(""%s: Integer overflow when calculating BPLIST_UNICODE data size.\n"", __func__);
return NULL;
30. if (*object + size*2 < *object || *object + size*2 > bplist->offset_table) {
PLIST_BIN_ERR(""%s: BPLIST_UNICODE data bytes point outside of valid range\n"", __func__);
return NULL;
31. return parse_unicode_node(object, size);
32. case BPLIST_ARRAY:
if (*object + size < *object || *object + size > bplist->offset_table) {
33. return parse_uid_node(object, size);
34. case BPLIST_DICT:
if (*object + size < *object || *object + size > bplist->offset_table) {
35. return NULL;
36. return parse_dict_node(bplist, object, size);
37. default:
PLIST_BIN_ERR(""%s: unexpected node type 0x%02x\n"", __func__, type);
return NULL;
38. return NULL;","1
11
13
15
17-20
25
28
31
33
35
37
45-46
51-54
58
62
69
72
74
79
81
84
88
91
93
97-98
100
102
109
112-114
116-118
120
123-124
135
137-138
140
142
144-146
148","CWE-190,CWE-200,CWE-125,CWE-59"
sraSpanInsertBefore-174772571851227,"static void
sraSpanInsertBefore(sraSpan *newspan, sraSpan *before) {
  if(newspan && before) {
    newspan->_next = before;
    newspan->_prev = before->_prev;
    before->_prev->_next = newspan;
    before->_prev = newspan;
  }
}
","1. static void
sraSpanInsertBefore(sraSpan *newspan, sraSpan *before) {
if(newspan && before) {
newspan->_next = before;
newspan->_prev = before->_prev;
before->_prev->_next = newspan;
before->_prev = newspan;",1-7,"CWE-416,CWE-476,CWE-190,CWE-193,CWE-415"
hns_roce_alloc_ucontext-55465834149441,"static struct ib_ucontext *hns_roce_alloc_ucontext(struct ib_device *ib_dev,
						   struct ib_udata *udata)
{
	int ret = 0;
	struct hns_roce_ucontext *context;
	struct hns_roce_ib_alloc_ucontext_resp resp = {};
	struct hns_roce_dev *hr_dev = to_hr_dev(ib_dev);

	resp.qp_tab_size = hr_dev->caps.num_qps;

	context = kmalloc(sizeof(*context), GFP_KERNEL);
	if (!context)
		return ERR_PTR(-ENOMEM);

	ret = hns_roce_uar_alloc(hr_dev, &context->uar);
	if (ret)
		goto error_fail_uar_alloc;

	if (hr_dev->caps.flags & HNS_ROCE_CAP_FLAG_RECORD_DB) {
		INIT_LIST_HEAD(&context->page_list);
		mutex_init(&context->page_mutex);
	}

	ret = ib_copy_to_udata(udata, &resp, sizeof(resp));
	if (ret)
		goto error_fail_copy_to_udata;

	return &context->ibucontext;

error_fail_copy_to_udata:
	hns_roce_uar_free(hr_dev, &context->uar);

error_fail_uar_alloc:
	kfree(context);

	return ERR_PTR(ret);
}
","1. return ERR_PTR(-ENOMEM);
2. return &context->ibucontext;
3. hns_roce_uar_free(hr_dev, &context->uar);
4. error_fail_uar_alloc:","13
28
31
33","CWE-119,CWE-665,CWE-284,CWE-189"
aac_compat_ioctl,"
#define __user

 static int aac_compat_ioctl(struct scsi_device *sdev, int cmd, void __user *arg)
 {
 	struct aac_dev *dev = (struct aac_dev *)sdev->host->hostdata;
	if (!capable(CAP_SYS_RAWIO))
		return -EPERM;
 	return aac_compat_do_ioctl(dev, cmd, (unsigned long)arg);
 }
","1. struct aac_dev *dev = (struct aac_dev *)sdev->host->hostdata;
2. return -EPERM;
return aac_compat_do_ioctl(dev, cmd, (unsigned long)arg);","6
8-9","CWE-200,CWE-125,CWE-189,CWE-416"
recovery_cipher_init-211771004399947,"
#define _auto_lock_delay_ms
#define _dry_run
#define _enforce_wordlist
#define _u2f_counter

void recovery_cipher_init(bool passphrase_protection, bool pin_protection,
                          const char *language, const char *label, bool _enforce_wordlist,
                          uint32_t _auto_lock_delay_ms, uint32_t _u2f_counter, bool _dry_run)
{
    enforce_wordlist = _enforce_wordlist;
    dry_run = _dry_run;

    if (!dry_run) {
        if (pin_protection) {
            if (!change_pin()) {
                recovery_abort();
                fsm_sendFailure(FailureType_Failure_ActionCancelled, ""PINs do not match"");
                layoutHome();
                return;
            }
        } else {
            storage_setPin("""");
        }

        storage_setPassphraseProtected(passphrase_protection);
        storage_setLanguage(language);
        storage_setLabel(label);
        storage_setAutoLockDelayMs(_auto_lock_delay_ms);
        storage_setU2FCounter(_u2f_counter);
    } else if (!pin_protect(""Enter Your PIN"")) {
        layoutHome();
        return;
    }

    if (!confirm(ButtonRequestType_ButtonRequest_Other,
                 dry_run ? ""Recovery Dry Run"" : ""Recovery"",
                 ""When entering your recovery seed, use the substitution cipher ""
                 ""and check that each word shows up correctly on the screen."")) {
        fsm_sendFailure(FailureType_Failure_ActionCancelled, ""Recovery cancelled"");
        if (!dry_run)
            storage_reset();
        layoutHome();
        return;
    }

    
    memset(mnemonic, 0, sizeof(mnemonic) / sizeof(char));

    
    awaiting_character = true;
    recovery_started = true;
    next_character();
}
","1. enforce_wordlist = _enforce_wordlist;
2. layoutHome();
3. } else if (!pin_protect(""Enter Your PIN"")) {
4. awaiting_character = true;
5. next_character();","11
19
31
51
53","CWE-78,CWE-362,CWE-120,CWE-200,CWE-399"
mov_write_audio_tag-251904002469497,"
#define AVFormatContext
#define AVIOContext
#define MOVMuxContext
#define MOVTrack

static int mov_write_audio_tag(AVFormatContext *s, AVIOContext *pb, MOVMuxContext *mov, MOVTrack *track)
{
    int64_t pos = avio_tell(pb);
    int version = 0;
    uint32_t tag = track->tag;

    if (track->mode == MODE_MOV) {
        if (track->timescale > UINT16_MAX || !track->par->channels) {
            if (mov_get_lpcm_flags(track->par->codec_id))
                tag = AV_RL32(""lpcm"");
            version = 2;
        } else if (track->audio_vbr || mov_pcm_le_gt16(track->par->codec_id) ||
                   mov_pcm_be_gt16(track->par->codec_id) ||
                   track->par->codec_id == AV_CODEC_ID_ADPCM_MS ||
                   track->par->codec_id == AV_CODEC_ID_ADPCM_IMA_WAV ||
                   track->par->codec_id == AV_CODEC_ID_QDM2) {
            version = 1;
        }
    }

    avio_wb32(pb, 0); 
    if (mov->encryption_scheme != MOV_ENC_NONE) {
        ffio_wfourcc(pb, ""enca"");
    } else {
        avio_wl32(pb, tag); 
    }
    avio_wb32(pb, 0); 
    avio_wb16(pb, 0); 
    avio_wb16(pb, 1); 

    
    avio_wb16(pb, version); 
    avio_wb16(pb, 0); 
    avio_wb32(pb, 0); 

    if (version == 2) {
        avio_wb16(pb, 3);
        avio_wb16(pb, 16);
        avio_wb16(pb, 0xfffe);
        avio_wb16(pb, 0);
        avio_wb32(pb, 0x00010000);
        avio_wb32(pb, 72);
        avio_wb64(pb, av_double2int(track->par->sample_rate));
        avio_wb32(pb, track->par->channels);
        avio_wb32(pb, 0x7F000000);
        avio_wb32(pb, av_get_bits_per_sample(track->par->codec_id));
        avio_wb32(pb, mov_get_lpcm_flags(track->par->codec_id));
        avio_wb32(pb, track->sample_size);
        avio_wb32(pb, get_samples_per_packet(track));
    } else {
        if (track->mode == MODE_MOV) {
            avio_wb16(pb, track->par->channels);
            if (track->par->codec_id == AV_CODEC_ID_PCM_U8 ||
                track->par->codec_id == AV_CODEC_ID_PCM_S8)
                avio_wb16(pb, 8); 
            else if (track->par->codec_id == AV_CODEC_ID_ADPCM_G726)
                avio_wb16(pb, track->par->bits_per_coded_sample);
            else
                avio_wb16(pb, 16);
            avio_wb16(pb, track->audio_vbr ? -2 : 0); 
        } else { 
            if (track->par->codec_id == AV_CODEC_ID_FLAC ||
                track->par->codec_id == AV_CODEC_ID_OPUS) {
                avio_wb16(pb, track->par->channels);
            } else {
                avio_wb16(pb, 2);
            }
            if (track->par->codec_id == AV_CODEC_ID_FLAC) {
                avio_wb16(pb, track->par->bits_per_raw_sample);
            } else {
                avio_wb16(pb, 16);
            }
            avio_wb16(pb, 0);
        }

        avio_wb16(pb, 0); 
        if (track->par->codec_id == AV_CODEC_ID_OPUS)
            avio_wb16(pb, 48000);
        else
            avio_wb16(pb, track->par->sample_rate <= UINT16_MAX ?
                          track->par->sample_rate : 0);
        avio_wb16(pb, 0); 
    }

    if (version == 1) { 
        if (mov_pcm_le_gt16(track->par->codec_id) ||
            mov_pcm_be_gt16(track->par->codec_id))
            avio_wb32(pb, 1); 
        else
            avio_wb32(pb, track->par->frame_size); 
        avio_wb32(pb, track->sample_size / track->par->channels); 
        avio_wb32(pb, track->sample_size); 
        avio_wb32(pb, 2); 
    }

    if (track->mode == MODE_MOV &&
        (track->par->codec_id == AV_CODEC_ID_AAC           ||
         track->par->codec_id == AV_CODEC_ID_AC3           ||
         track->par->codec_id == AV_CODEC_ID_EAC3          ||
         track->par->codec_id == AV_CODEC_ID_AMR_NB        ||
         track->par->codec_id == AV_CODEC_ID_ALAC          ||
         track->par->codec_id == AV_CODEC_ID_ADPCM_MS      ||
         track->par->codec_id == AV_CODEC_ID_ADPCM_IMA_WAV ||
         track->par->codec_id == AV_CODEC_ID_QDM2          ||
         (mov_pcm_le_gt16(track->par->codec_id) && version==1) ||
         (mov_pcm_be_gt16(track->par->codec_id) && version==1)))
        mov_write_wave_tag(s, pb, track);
    else if (track->tag == MKTAG('m','p','4','a'))
        mov_write_esds_tag(pb, track);
    else if (track->par->codec_id == AV_CODEC_ID_AMR_NB)
        mov_write_amr_tag(pb, track);
    else if (track->par->codec_id == AV_CODEC_ID_AC3)
        mov_write_ac3_tag(pb, track);
    else if (track->par->codec_id == AV_CODEC_ID_EAC3)
        mov_write_eac3_tag(pb, track);
    else if (track->par->codec_id == AV_CODEC_ID_ALAC)
        mov_write_extradata_tag(pb, track);
    else if (track->par->codec_id == AV_CODEC_ID_WMAPRO)
        mov_write_wfex_tag(s, pb, track);
    else if (track->par->codec_id == AV_CODEC_ID_FLAC)
        mov_write_dfla_tag(pb, track);
    else if (track->par->codec_id == AV_CODEC_ID_OPUS)
        mov_write_dops_tag(pb, track);
    else if (track->vos_len > 0)
        mov_write_glbl_tag(pb, track);

    if (track->mode == MODE_MOV && track->par->codec_type == AVMEDIA_TYPE_AUDIO)
        mov_write_chan_tag(s, pb, track);

    if (mov->encryption_scheme != MOV_ENC_NONE) {
        ff_mov_cenc_write_sinf_tag(track, pb, mov->encryption_kid);
    }

    return update_size(pb, pos);
}
","1. static int mov_write_audio_tag(AVFormatContext *s, AVIOContext *pb, MOVMuxContext *mov, MOVTrack *track)
2. int64_t pos = avio_tell(pb);
3. if (mov_get_lpcm_flags(track->par->codec_id))
tag = AV_RL32(""lpcm"");
4. track->par->codec_id == AV_CODEC_ID_ADPCM_MS ||
5. version = 1;
6. ffio_wfourcc(pb, ""enca"");
7. avio_wl32(pb, tag);
8. avio_wb32(pb, 0);
avio_wb16(pb, 0);
9. if (version == 2) {
10. if (track->mode == MODE_MOV) {
avio_wb16(pb, track->par->channels);
11. avio_wb16(pb, track->audio_vbr ? -2 : 0);
12. mov_pcm_be_gt16(track->par->codec_id))
13. avio_wb32(pb, 2);
14. (track->par->codec_id == AV_CODEC_ID_AAC           ||
15. track->par->codec_id == AV_CODEC_ID_ADPCM_MS      ||
16. else if (track->par->codec_id == AV_CODEC_ID_EAC3)
17. else if (track->par->codec_id == AV_CODEC_ID_WMAPRO)
18. mov_write_dfla_tag(pb, track);
else if (track->par->codec_id == AV_CODEC_ID_OPUS)
19. mov_write_chan_tag(s, pb, track);
20. ff_mov_cenc_write_sinf_tag(track, pb, mov->encryption_kid);","7
9
15-16
20
23
29
31
33-34
42
57-58
66
93
99
103
108
120
124
127-128
134
137","CWE-200,CWE-399,CWE-203,CWE-369"
dns_packet_is_reply_for-107004918653622,"
#define DnsPacket
#define DnsResourceKey

int dns_packet_is_reply_for(DnsPacket *p, const DnsResourceKey *key) {
        int r;

        assert(p);
        assert(key);

        

        if (DNS_PACKET_QR(p) != 1)
                return 0;

        
        r = dns_packet_extract(p);
        if (r < 0)
                return r;

        if (!p->question)
                return 0;

        if (p->question->n_keys != 1)
                return 0;

        return dns_resource_key_equal(p->question->keys[0], key);
}
","1. assert(p);
2. if (DNS_PACKET_QR(p) != 1)
3. r = dns_packet_extract(p);
if (r < 0)
4. if (!p->question)
5. return dns_resource_key_equal(p->question->keys[0], key);","8
15
19-20
23
29","CWE-352,CWE-189,CWE-119"
main_5,"main_5(int argc, char **argv)
{
   int i, valgrind_mode = 0;
   int valgrind_tool = 0;
   int valgrind_gdbserver = 0;
   char buf[16384], **args, *home;
   char valgrind_path[PATH_MAX] = """";
   const char *valgrind_log = NULL;
   Eina_Bool really_know = EINA_FALSE;
   struct sigaction action;
   pid_t child = -1;
#ifdef E_CSERVE
   pid_t cs_child = -1;
   Eina_Bool cs_use = EINA_FALSE;
#endif
#if !defined(__OpenBSD__) && !defined(__NetBSD__) && !defined(__FreeBSD__) && \
   !defined(__FreeBSD_kernel__) && !(defined (__MACH__) && defined (__APPLE__))
   Eina_Bool restart = EINA_TRUE;
#endif

   unsetenv(""NOTIFY_SOCKET"");

   
   action.sa_sigaction = _sigusr1;
   action.sa_flags = SA_RESETHAND;
   sigemptyset(&action.sa_mask);
   sigaction(SIGUSR1, &action, NULL);

   eina_init();

   
   if ((!getenv(""DBUS_SESSION_BUS_ADDRESS"")) &&
       (!getenv(""DBUS_LAUNCHD_SESSION_BUS_SOCKET"")))
     {
        char **dbus_argv;

        dbus_argv = alloca((argc + 3) * sizeof (char *));
        dbus_argv[0] = ""dbus-launch"";
        dbus_argv[1] = ""--exit-with-session"";
        copy_args(dbus_argv + 2, argv, argc);
        dbus_argv[2 + argc] = NULL;
        execvp(""dbus-launch"", dbus_argv);
     }

   prefix_determine(argv[0]);

   env_set(""E_START"", argv[0]);

   for (i = 1; i < argc; i++)
     {
        if (!strcmp(argv[i], ""-valgrind-gdb""))
          valgrind_gdbserver = 1;
        else if (!strncmp(argv[i], ""-valgrind"", sizeof(""-valgrind"") - 1))
          {
             const char *val = argv[i] + sizeof(""-valgrind"") - 1;

             if (*val == '\0') valgrind_mode = 1;
             else if (*val == '-')
               {
                  val++;
                  if (!strncmp(val, ""log-file="", sizeof(""log-file="") - 1))
                    {
                       valgrind_log = val + sizeof(""log-file="") - 1;
                       if (*valgrind_log == '\0') valgrind_log = NULL;
                    }
               }
             else if (*val == '=')
               {
                  val++;
                  if (!strcmp(val, ""all"")) valgrind_mode = VALGRIND_MODE_ALL;
                  else valgrind_mode = atoi(val);
               }
             else
               printf(""Unknown valgrind option: %s\n"", argv[i]);
          }
        else if (!strcmp(argv[i], ""-display""))
          {
             i++;
             env_set(""DISPLAY"", argv[i]);
          }
        else if (!strcmp(argv[i], ""-massif""))
          valgrind_tool = 1;
        else if (!strcmp(argv[i], ""-callgrind""))
          valgrind_tool = 2;
        else if ((!strcmp(argv[i], ""-h"")) ||
                 (!strcmp(argv[i], ""-help"")) ||
                 (!strcmp(argv[i], ""--help"")))
          {
             printf
             (
               ""Options:\n""
               ""\t-valgrind[=MODE]\n""
               ""\t\tRun enlightenment from inside valgrind, mode is OR of:\n""
               ""\t\t   1 = plain valgrind to catch crashes (default)\n""
               ""\t\t   2 = trace children (thumbnailer, efm slaves, ...)\n""
               ""\t\t   4 = check leak\n""
               ""\t\t   8 = show reachable after processes finish.\n""
               ""\t\t all = all of above\n""
               ""\t-massif\n""
               ""\t\tRun enlightenment from inside massif valgrind tool.\n""
               ""\t-callgrind\n""
               ""\t\tRun enlightenment from inside callgrind valgrind tool.\n""
               ""\t-valgrind-log-file=<FILENAME>\n""
               ""\t\tSave valgrind log to file, see valgrind's --log-file for details.\n""
               ""\n""
               ""Please run:\n""
               ""\tenlightenment %s\n""
               ""for more options.\n"",
               argv[i]);
             exit(0);
          }
        else if (!strcmp(argv[i], ""-i-really-know-what-i-am-doing-and-accept-full-responsibility-for-it""))
          really_know = EINA_TRUE;
     }

   if (really_know)
     _env_path_append(""PATH"", eina_prefix_bin_get(pfx));
   else
     _env_path_prepend(""PATH"", eina_prefix_bin_get(pfx));

   if (valgrind_mode || valgrind_tool)
     {
        if (!find_valgrind(valgrind_path, sizeof(valgrind_path)))
          {
             printf(""E - valgrind required but no binary found! Ignoring request.\n"");
             valgrind_mode = 0;
          }
     }

   printf(""E - PID=%i, valgrind=%d"", getpid(), valgrind_mode);
   if (valgrind_mode)
     {
        printf("" valgrind-command='%s'"", valgrind_path);
        if (valgrind_log) printf("" valgrind-log-file='%s'"", valgrind_log);
     }
   putchar('\n');

   
   home = getenv(""HOME"");
   if (home)
     {
        FILE *f;

        
        snprintf(buf, sizeof(buf), ""%s/.e-mtrack"", home);
        f = fopen(buf, ""r"");
        if (f)
          {
             if (fgets(buf, sizeof(buf), f))
               {
                  int len = strlen(buf);
                  if ((len > 1) && (buf[len - 1] == '\n'))
                    {
                       buf[len - 1] = 0;
                       len--;
                    }
                  env_set(""LD_PRELOAD"", buf);
                  env_set(""MTRACK"", ""track"");
                  env_set(""E_START_MTRACK"", ""track"");
                  snprintf(buf, sizeof(buf), ""%s/.e-mtrack.log"", home);
                  env_set(""MTRACK_TRACE_FILE"", buf);
               }
             fclose(f);
          }
     }

   
   snprintf(buf, sizeof(buf), ""%s/enlightenment"", eina_prefix_bin_get(pfx));

   args = alloca((argc + 2 + VALGRIND_MAX_ARGS) * sizeof(char *));
   i = valgrind_append(args, valgrind_gdbserver, valgrind_mode, valgrind_tool, valgrind_path, valgrind_log);
   args[i++] = buf;
   copy_args(args + i, argv + 1, argc - 1);
   args[i + argc - 1] = NULL;

   if (valgrind_tool || valgrind_mode)
     really_know = EINA_TRUE;

#if defined(__OpenBSD__) || defined(__NetBSD__) || defined(__FreeBSD__) || \
   defined(__FreeBSD_kernel__) || (defined (__MACH__) && defined (__APPLE__))
   execv(args[0], args);
#endif

   

#if !defined(__OpenBSD__) && !defined(__NetBSD__) && !defined(__FreeBSD__) && \
   !defined(__FreeBSD_kernel__) && !(defined (__MACH__) && defined (__APPLE__))

#ifdef E_CSERVE
   if (getenv(""E_CSERVE""))
     {
        cs_use = EINA_TRUE;
        cs_child = _cserve2_start();
     }
#endif

   
   while (restart)
     {
        stop_ptrace = EINA_FALSE;

        child = fork();

        if (child < 0) 
          return -1;
        else if (child == 0)
          {
#ifdef HAVE_SYS_PTRACE_H
             if (!really_know)
               
               ptrace(PT_TRACE_ME, 0, NULL, NULL);
#endif
             execv(args[0], args);
             return 0; 
          }
        else
          {
             env_set(""E_RESTART"", ""1"");
             
             pid_t result;
             int status;
             Eina_Bool done = EINA_FALSE;

#ifdef HAVE_SYS_PTRACE_H
             if (!really_know)
               ptrace(PT_ATTACH, child, NULL, NULL);
             result = waitpid(child, &status, 0);
             if ((!really_know) && (!stop_ptrace))
               {
                  if (WIFSTOPPED(status))
                    ptrace(PT_CONTINUE, child, NULL, NULL);
               }
#endif
             while (!done)
               {
                  Eina_Bool remember_sigill = EINA_FALSE;
                  Eina_Bool remember_sigusr1 = EINA_FALSE;

                  result = waitpid(child, &status, WNOHANG);
                  if (!result)
                    {
                       
                       result = waitpid(-1, &status, 0);
                    }

                  if (result == child)
                    {
                       if ((WIFSTOPPED(status)) && (!stop_ptrace))
                         {
                            char buffer[4096];
                            char *backtrace_str = NULL;
                            siginfo_t sig;
                            int r = 0;
                            int back;

#ifdef HAVE_SYS_PTRACE_H
                            if (!really_know)
                              r = ptrace(PT_GETSIGINFO, child, NULL, &sig);
#endif
                            back = r == 0 &&
                              sig.si_signo != SIGTRAP ? sig.si_signo : 0;

                            if (sig.si_signo == SIGUSR1)
                              {
                                 if (remember_sigill)
                                   remember_sigusr1 = EINA_TRUE;
                              }
                            else if (sig.si_signo == SIGILL)
                              {
                                 remember_sigill = EINA_TRUE;
                              }
                            else
                              {
                                 remember_sigill = EINA_FALSE;
                              }

                            if (r != 0 ||
                                (sig.si_signo != SIGSEGV &&
                                 sig.si_signo != SIGFPE &&
                                 sig.si_signo != SIGABRT))
                              {
#ifdef HAVE_SYS_PTRACE_H
                                 if (!really_know)
                                   ptrace(PT_CONTINUE, child, NULL, back);
#endif
                                 continue;
                              }
#ifdef HAVE_SYS_PTRACE_H
                            if (!really_know)
                              
                              ptrace(PT_DETACH, child, NULL, back);
#endif
                            
                            r = 0;
                            if (home)
                               {
                                  
                                  snprintf(buffer, 4096,
                                          ""gdb %i %s/.e-crashdump.txt"",
                                           child,
                                           home);
                                  r = system(buffer);
                                 r = system(buffer);

                                 fprintf(stderr, ""called gdb with '%s' = %i\n"",
                                         buffer, WEXITSTATUS(r));

                                 snprintf(buffer, 4096,
                                          ""%s/.e-crashdump.txt"",
                                          home);

                                 backtrace_str = strdup(buffer);
                                 r = WEXITSTATUS(r);
                              }

                            
                            snprintf(buffer, 4096,
                                     backtrace_str ?
                                     ""%s/enlightenment/utils/enlightenment_alert %i %i '%s' %i"" :
                                     ""%s/enlightenment/utils/enlightenment_alert %i %i '%s' %i"",
                                     eina_prefix_lib_get(pfx),
                                     sig.si_signo == SIGSEGV && remember_sigusr1 ? SIGILL : sig.si_signo,
                                     child,
                                     backtrace_str,
                                     r);
                            r = system(buffer);

                            
                            kill(child, SIGKILL);

                            if (WEXITSTATUS(r) != 1)
                              {
                                 restart = EINA_FALSE;
                              }
                         }
                       else if (!WIFEXITED(status))
                         {
                            done = EINA_TRUE;
                         }
                       else if (stop_ptrace)
                         {
                            done = EINA_TRUE;
                         }
                    }
                  else if (result == -1)
                    {
                       if (errno != EINTR)
                         {
                            done = EINA_TRUE;
                            restart = EINA_FALSE;
                         }
                       else
                         {
                            if (stop_ptrace)
                              {
                                 kill(child, SIGSTOP);
                                 usleep(200000);
#ifdef HAVE_SYS_PTRACE_H
                                 if (!really_know)
                                   ptrace(PT_DETACH, child, NULL, NULL);
#endif
                              }
                         }
                    }
#ifdef E_CSERVE
                  else if (cs_use && (result == cs_child))
                    {
                       if (WIFSIGNALED(status))
                         {
                            printf(""E - cserve2 terminated with signal %d\n"",
                                   WTERMSIG(status));
                            cs_child = _cserve2_start();
                         }
                       else if (WIFEXITED(status))
                         {
                            printf(""E - cserve2 exited with code %d\n"",
                                   WEXITSTATUS(status));
                            cs_child = -1;
                         }
                    }
#endif
               }
          }
     }
#endif

#ifdef E_CSERVE
   if (cs_child > 0)
     {
        pid_t result;
        int status;

        alarm(2);
        kill(cs_child, SIGINT);
        result = waitpid(cs_child, &status, 0);
        if (result != cs_child)
          {
             printf(""E - cserve2 did not shutdown in 2 seconds, killing!\n"");
             kill(cs_child, SIGKILL);
          }
     }
#endif

   return -1;
}
","1. unsetenv(""NOTIFY_SOCKET"");
2. eina_init();
3. const char *val = argv[i] + sizeof(""-valgrind"") - 1;
4. else valgrind_mode = atoi(val);
5. _env_path_append(""PATH"", eina_prefix_bin_get(pfx));
6. args[i + argc - 1] = NULL;
7. if ((WIFSTOPPED(status)) && (!stop_ptrace))
8. child,
9. r = system(buffer);
10. restart = EINA_FALSE;","21
29
55
71
117
176
250
302
304
352","CWE-362,CWE-200,CWE-119"
ReadPSImage-118602108285268,"
#define ExceptionInfo
#define ImageInfo

static Image *ReadPSImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
#define BoundingBox  ""BoundingBox:""
#define BeginDocument  ""BeginDocument:""
#define BeginXMPPacket  ""<?xpacket begin=""
#define EndXMPPacket  ""<?xpacket end=""
#define ICCProfile ""BeginICCProfile:""
#define CMYKCustomColor  ""CMYKCustomColor:""
#define CMYKProcessColor  ""CMYKProcessColor:""
#define DocumentMedia  ""DocumentMedia:""
#define DocumentCustomColors  ""DocumentCustomColors:""
#define DocumentProcessColors  ""DocumentProcessColors:""
#define EndDocument  ""EndDocument:""
#define HiResBoundingBox  ""HiResBoundingBox:""
#define ImageData  ""ImageData:""
#define PageBoundingBox  ""PageBoundingBox:""
#define LanguageLevel  ""LanguageLevel:""
#define PageMedia  ""PageMedia:""
#define Pages  ""Pages:""
#define PhotoshopProfile  ""BeginPhotoshop:""
#define PostscriptLevel  ""!PS-""
#define RenderPostscriptText  ""  Rendering Postscript...  ""
#define SpotColor  ""+ ""

  char
    command[MaxTextExtent],
    *density,
    filename[MaxTextExtent],
    geometry[MaxTextExtent],
    input_filename[MaxTextExtent],
    message[MaxTextExtent],
    *options,
    postscript_filename[MaxTextExtent];

  const char
    *option;

  const DelegateInfo
    *delegate_info;

  GeometryInfo
    geometry_info;

  Image
    *image,
    *next,
    *postscript_image;

  ImageInfo
    *read_info;

  int
    c,
    file;

  MagickBooleanType
    cmyk,
    fitPage,
    skip,
    status;

  MagickStatusType
    flags;

  PointInfo
    delta,
    resolution;

  RectangleInfo
    page;

  register char
    *p;

  register ssize_t
    i;

  SegmentInfo
    bounds,
    hires_bounds;

  short int
    hex_digits[256];

  size_t
    length,
    priority;

  ssize_t
    count;

  StringInfo
    *profile;

  unsigned long
    columns,
    extent,
    language_level,
    pages,
    rows,
    scene,
    spotcolor;

  
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  image=AcquireImage(image_info);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  status=AcquireUniqueSymbolicLink(image_info->filename,input_filename);
  if (status == MagickFalse)
    {
      ThrowFileException(exception,FileOpenError,""UnableToCreateTemporaryFile"",
        image_info->filename);
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  
  (void) memset(hex_digits,0,sizeof(hex_digits));
  hex_digits[(int) '0']=0;
  hex_digits[(int) '1']=1;
  hex_digits[(int) '2']=2;
  hex_digits[(int) '3']=3;
  hex_digits[(int) '4']=4;
  hex_digits[(int) '5']=5;
  hex_digits[(int) '6']=6;
  hex_digits[(int) '7']=7;
  hex_digits[(int) '8']=8;
  hex_digits[(int) '9']=9;
  hex_digits[(int) 'a']=10;
  hex_digits[(int) 'b']=11;
  hex_digits[(int) 'c']=12;
  hex_digits[(int) 'd']=13;
  hex_digits[(int) 'e']=14;
  hex_digits[(int) 'f']=15;
  hex_digits[(int) 'A']=10;
  hex_digits[(int) 'B']=11;
  hex_digits[(int) 'C']=12;
  hex_digits[(int) 'D']=13;
  hex_digits[(int) 'E']=14;
  hex_digits[(int) 'F']=15;
  
  delta.x=DefaultResolution;
  delta.y=DefaultResolution;
  if ((image->x_resolution == 0.0) || (image->y_resolution == 0.0))
    {
      flags=ParseGeometry(PSDensityGeometry,&geometry_info);
      image->x_resolution=geometry_info.rho;
      image->y_resolution=geometry_info.sigma;
      if ((flags & SigmaValue) == 0)
        image->y_resolution=image->x_resolution;
    }
  if (image_info->density != (char *) NULL)
    {
      flags=ParseGeometry(image_info->density,&geometry_info);
      image->x_resolution=geometry_info.rho;
      image->y_resolution=geometry_info.sigma;
      if ((flags & SigmaValue) == 0)
        image->y_resolution=image->x_resolution;
    }
  (void) ParseAbsoluteGeometry(PSPageGeometry,&page);
  if (image_info->page != (char *) NULL)
    (void) ParseAbsoluteGeometry(image_info->page,&page);
  resolution.x=image->x_resolution;
  resolution.y=image->y_resolution;
  page.width=(size_t) ceil((double) (page.width*resolution.x/delta.x)-0.5);
  page.height=(size_t) ceil((double) (page.height*resolution.y/delta.y)-0.5);
  
  (void) memset(&bounds,0,sizeof(bounds));
  (void) memset(command,0,sizeof(command));
  cmyk=image_info->colorspace == CMYKColorspace ? MagickTrue : MagickFalse;
  (void) memset(&hires_bounds,0,sizeof(hires_bounds));
  priority=0;
  columns=0;
  rows=0;
  extent=0;
  spotcolor=0;
  language_level=1;
  skip=MagickFalse;
  pages=(~0UL);
  p=command;
  for (c=ReadBlobByte(image); c != EOF; c=ReadBlobByte(image))
  {
    
    *p++=(char) c;
    if ((strchr(""\n\r%"",c) == (char *) NULL) &&
        ((size_t) (p-command) < (MaxTextExtent-1)))
      continue;
    *p='\0';
    p=command;
    
    if (LocaleNCompare(BeginDocument,command,strlen(BeginDocument)) == 0)
      skip=MagickTrue;
    if (LocaleNCompare(EndDocument,command,strlen(EndDocument)) == 0)
      skip=MagickFalse;
    if (skip != MagickFalse)
      continue;
    if (LocaleNCompare(PostscriptLevel,command,strlen(PostscriptLevel)) == 0)
      {
        (void) SetImageProperty(image,""ps:Level"",command+4);
        if (GlobExpression(command,""*EPSF-*"",MagickTrue) != MagickFalse)
          pages=1;
      }
    if (LocaleNCompare(LanguageLevel,command,strlen(LanguageLevel)) == 0)
      (void) sscanf(command,LanguageLevel "" %lu"",&language_level);
    if (LocaleNCompare(Pages,command,strlen(Pages)) == 0)
      (void) sscanf(command,Pages "" %lu"",&pages);
    if (LocaleNCompare(ImageData,command,strlen(ImageData)) == 0)
      (void) sscanf(command,ImageData "" %lu %lu"",&columns,&rows);
    
    length=strlen(DocumentProcessColors);
    if (LocaleNCompare(DocumentProcessColors,command,length) == 0)
      {
        if ((GlobExpression(command,""*Cyan*"",MagickTrue) != MagickFalse) ||
            (GlobExpression(command,""*Magenta*"",MagickTrue) != MagickFalse) ||
            (GlobExpression(command,""*Yellow*"",MagickTrue) != MagickFalse))
          cmyk=MagickTrue;
      }
    if (LocaleNCompare(CMYKCustomColor,command,strlen(CMYKCustomColor)) == 0)
      cmyk=MagickTrue;
    if (LocaleNCompare(CMYKProcessColor,command,strlen(CMYKProcessColor)) == 0)
      cmyk=MagickTrue;
    length=strlen(DocumentCustomColors);
    if ((LocaleNCompare(DocumentCustomColors,command,length) == 0) ||
        (LocaleNCompare(CMYKCustomColor,command,strlen(CMYKCustomColor)) == 0) ||
        (LocaleNCompare(SpotColor,command,strlen(SpotColor)) == 0))
      {
        char
          property[MaxTextExtent],
          *value;

        register char
          *p;

        
        (void) FormatLocaleString(property,MaxTextExtent,""ps:SpotColor-%.20g"",
          (double) (spotcolor++));
        for (p=command; *p != '\0'; p++)
          if (isspace((int) (unsigned char) *p) != 0)
            break;
        value=ConstantString(p);
        (void) SubstituteString(&value,""("","""");
        (void) SubstituteString(&value,"")"","""");
        (void) StripString(value);
        if (*value != '\0')
          (void) SetImageProperty(image,property,value);
        value=DestroyString(value);
        continue;
      }
    if (image_info->page != (char *) NULL)
      continue;
    
    count=0;
    i=0;
    if (LocaleNCompare(BoundingBox,command,strlen(BoundingBox)) == 0)
      {
        count=(ssize_t) sscanf(command,BoundingBox "" %lf %lf %lf %lf"",
          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);
        i=2;
      }
    if (LocaleNCompare(DocumentMedia,command,strlen(DocumentMedia)) == 0)
      {
        count=(ssize_t) sscanf(command,DocumentMedia "" %lf %lf %lf %lf"",
          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);
        i=1;
      }
    if (LocaleNCompare(HiResBoundingBox,command,strlen(HiResBoundingBox)) == 0)
      {
        count=(ssize_t) sscanf(command,HiResBoundingBox "" %lf %lf %lf %lf"",
          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);
        i=3;
      }
    if (LocaleNCompare(PageBoundingBox,command,strlen(PageBoundingBox)) == 0)
      {
        count=(ssize_t) sscanf(command,PageBoundingBox "" %lf %lf %lf %lf"",
          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);
        i=1;
      }
    if (LocaleNCompare(PageMedia,command,strlen(PageMedia)) == 0)
      {
        count=(ssize_t) sscanf(command,PageMedia "" %lf %lf %lf %lf"",
          &bounds.x1,&bounds.y1,&bounds.x2,&bounds.y2);
        i=1;
      }
    if ((count != 4) || (i < (ssize_t) priority))
      continue;
    if ((fabs(bounds.x2-bounds.x1) <= fabs(hires_bounds.x2-hires_bounds.x1)) ||
        (fabs(bounds.y2-bounds.y1) <= fabs(hires_bounds.y2-hires_bounds.y1)))
      if (i == (ssize_t) priority)
        continue;
    hires_bounds=bounds;
    priority=(size_t) i;
  }
  if ((fabs(hires_bounds.x2-hires_bounds.x1) >= MagickEpsilon) &&
      (fabs(hires_bounds.y2-hires_bounds.y1) >= MagickEpsilon))
    {
      
      (void) FormatLocaleString(geometry,MaxTextExtent,""%gx%g%+.15g%+.15g"",
        hires_bounds.x2-hires_bounds.x1,hires_bounds.y2-hires_bounds.y1,
        hires_bounds.x1,hires_bounds.y1);
      (void) SetImageProperty(image,""ps:HiResBoundingBox"",geometry);
      page.width=(size_t) ceil((double) ((hires_bounds.x2-hires_bounds.x1)*
        resolution.x/delta.x)-0.5);
      page.height=(size_t) ceil((double) ((hires_bounds.y2-hires_bounds.y1)*
        resolution.y/delta.y)-0.5);
    }
  fitPage=MagickFalse;
  option=GetImageOption(image_info,""eps:fit-page"");
  if (option != (char *) NULL)
    {
      char
        *geometry;

      MagickStatusType
        flags;

      geometry=GetPageGeometry(option);
      flags=ParseMetaGeometry(geometry,&page.x,&page.y,&page.width,
        &page.height);
      if (flags == NoValue)
        {
          (void) ThrowMagickException(exception,GetMagickModule(),OptionError,
            ""InvalidGeometry"",""`%s'"",option);
          geometry=DestroyString(geometry);
          image=DestroyImage(image);
          return((Image *) NULL);
        }
      page.width=(size_t) ceil((double) (page.width*image->x_resolution/delta.x)
        -0.5);
      page.height=(size_t) ceil((double) (page.height*image->y_resolution/
        delta.y) -0.5);
      geometry=DestroyString(geometry);
      fitPage=MagickTrue;
    }
  if (IssRGBCompatibleColorspace(image_info->colorspace) != MagickFalse)
    cmyk=MagickFalse;
  
  file=AcquireUniqueFileResource(postscript_filename);
  if (file == -1)
    {
      ThrowFileException(&image->exception,FileOpenError,""UnableToOpenFile"",
        image_info->filename);
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  (void) CopyMagickString(command,""/setpagedevice {pop} bind 1 index where {""
    ""dup wcheck {3 1 roll put} {pop def} ifelse} {def} ifelse\n""
    ""<</UseCIEColor true>>setpagedevice\n"",MaxTextExtent);
  count=write(file,command,(unsigned int) strlen(command));
  if (image_info->page == (char *) NULL)
    {
      char
        translate_geometry[MaxTextExtent];

      (void) FormatLocaleString(translate_geometry,MaxTextExtent,
        ""%g %g translate\n"",-hires_bounds.x1,-hires_bounds.y1);
      count=write(file,translate_geometry,(unsigned int)
        strlen(translate_geometry));
    }
  file=close(file)-1;
  
  if (image_info->monochrome != MagickFalse)
    delegate_info=GetDelegateInfo(""ps:mono"",(char *) NULL,exception);
  else
    if (cmyk != MagickFalse)
      delegate_info=GetDelegateInfo(""ps:cmyk"",(char *) NULL,exception);
    else
      delegate_info=GetDelegateInfo(""ps:alpha"",(char *) NULL,exception);
  if (delegate_info == (const DelegateInfo *) NULL)
    {
      (void) RelinquishUniqueFileResource(postscript_filename);
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  density=AcquireString("""");
  options=AcquireString("""");
  (void) FormatLocaleString(density,MaxTextExtent,""%gx%g"",resolution.x,
    resolution.y);
  (void) FormatLocaleString(options,MaxTextExtent,""-g%.20gx%.20g "",(double)
    page.width,(double) page.height);
  read_info=CloneImageInfo(image_info);
  *read_info->magick='\0';
  if (read_info->number_scenes != 0)
    {
      char
        pages[MaxTextExtent];

      (void) FormatLocaleString(pages,MaxTextExtent,""-dFirstPage=%.20g ""
        ""-dLastPage=%.20g "",(double) read_info->scene+1,(double)
        (read_info->scene+read_info->number_scenes));
      (void) ConcatenateMagickString(options,pages,MaxTextExtent);
      read_info->number_scenes=0;
      if (read_info->scenes != (char *) NULL)
        *read_info->scenes='\0';
    }
  if (*image_info->magick == 'E')
    {
      option=GetImageOption(image_info,""eps:use-cropbox"");
      if ((option == (const char *) NULL) ||
          (IsStringTrue(option) != MagickFalse))
        (void) ConcatenateMagickString(options,""-dEPSCrop "",MaxTextExtent);
      if (fitPage != MagickFalse)
        (void) ConcatenateMagickString(options,""-dEPSFitPage "",MaxTextExtent);
    }
  (void) CopyMagickString(filename,read_info->filename,MaxTextExtent);
  (void) AcquireUniqueFilename(filename);
  (void) RelinquishUniqueFileResource(filename);
  (void) ConcatenateMagickString(filename,""%d"",MaxTextExtent);
  (void) FormatLocaleString(command,MaxTextExtent,
    GetDelegateCommands(delegate_info),
    read_info->antialias != MagickFalse ? 4 : 1,
    read_info->antialias != MagickFalse ? 4 : 1,density,options,filename,
    postscript_filename,input_filename);
  options=DestroyString(options);
  density=DestroyString(density);
  *message='\0';
  status=InvokePostscriptDelegate(read_info->verbose,command,message,exception);
  (void) InterpretImageFilename(image_info,image,filename,1,
    read_info->filename);
  if ((status == MagickFalse) ||
      (IsPostscriptRendered(read_info->filename) == MagickFalse))
    {
      (void) ConcatenateMagickString(command,"" -c showpage"",MaxTextExtent);
      status=InvokePostscriptDelegate(read_info->verbose,command,message,
        exception);
    }
  (void) RelinquishUniqueFileResource(postscript_filename);
  (void) RelinquishUniqueFileResource(input_filename);
  postscript_image=(Image *) NULL;
  if (status == MagickFalse)
    for (i=1; ; i++)
    {
      (void) InterpretImageFilename(image_info,image,filename,(int) i,
        read_info->filename);
      if (IsPostscriptRendered(read_info->filename) == MagickFalse)
        break;
      (void) RelinquishUniqueFileResource(read_info->filename);
    }
  else
    for (i=1; ; i++)
    {
      (void) InterpretImageFilename(image_info,image,filename,(int) i,
        read_info->filename);
      if (IsPostscriptRendered(read_info->filename) == MagickFalse)
        break;
      read_info->blob=NULL;
      read_info->length=0;
      next=ReadImage(read_info,exception);
      (void) RelinquishUniqueFileResource(read_info->filename);
      if (next == (Image *) NULL)
        break;
      AppendImageToList(&postscript_image,next);
    }
  (void) RelinquishUniqueFileResource(read_info->filename);
  read_info=DestroyImageInfo(read_info);
  if (postscript_image == (Image *) NULL)
    {
      if (*message != '\0')
        (void) ThrowMagickException(exception,GetMagickModule(),DelegateError,
          ""PostscriptDelegateFailed"",""`%s'"",message);
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  if (LocaleCompare(postscript_image->magick,""BMP"") == 0)
    {
      Image
        *cmyk_image;

      cmyk_image=ConsolidateCMYKImages(postscript_image,exception);
      if (cmyk_image != (Image *) NULL)
        {
          postscript_image=DestroyImageList(postscript_image);
          postscript_image=cmyk_image;
        }
    }
  (void) SeekBlob(image,0,SEEK_SET);
  for (c=ReadBlobByte(image); c != EOF; c=ReadBlobByte(image))
  {
    
    *p++=(char) c;
    if ((strchr(""\n\r%"",c) == (char *) NULL) &&
        ((size_t) (p-command) < (MaxTextExtent-1)))
      continue;
    *p='\0';
    p=command;
    
    if (LocaleNCompare(BeginDocument,command,strlen(BeginDocument)) == 0)
      skip=MagickTrue;
    if (LocaleNCompare(EndDocument,command,strlen(EndDocument)) == 0)
      skip=MagickFalse;
    if (skip != MagickFalse)
      continue;
    if (LocaleNCompare(PostscriptLevel,command,strlen(PostscriptLevel)) == 0)
      {
        (void) SetImageProperty(image,""ps:Level"",command+4);
        if (GlobExpression(command,""*EPSF-*"",MagickTrue) != MagickFalse)
          pages=1;
      }
    if (LocaleNCompare(LanguageLevel,command,strlen(LanguageLevel)) == 0)
      (void) sscanf(command,LanguageLevel "" %lu"",&language_level);
    if (LocaleNCompare(Pages,command,strlen(Pages)) == 0)
      (void) sscanf(command,Pages "" %lu"",&pages);
    if (LocaleNCompare(ImageData,command,strlen(ImageData)) == 0)
      (void) sscanf(command,ImageData "" %lu %lu"",&columns,&rows);
    if (LocaleNCompare(ICCProfile,command,strlen(ICCProfile)) == 0)
      {
        unsigned char
          *datum;

        
        profile=AcquireStringInfo(MaxTextExtent);
        datum=GetStringInfoDatum(profile);
        for (i=0; (c=ProfileInteger(image,hex_digits)) != EOF; i++)
        {
          if (i >= (ssize_t) GetStringInfoLength(profile))
            {
              SetStringInfoLength(profile,(size_t) i << 1);
              datum=GetStringInfoDatum(profile);
            }
          datum[i]=(unsigned char) c;
        }
        SetStringInfoLength(profile,(size_t) i+1);
        (void) SetImageProfile(image,""icc"",profile);
        profile=DestroyStringInfo(profile);
        continue;
      }
    if (LocaleNCompare(PhotoshopProfile,command,strlen(PhotoshopProfile)) == 0)
      {
        unsigned char
          *p;

        
        count=(ssize_t) sscanf(command,PhotoshopProfile "" %lu"",&extent);
        if (count != 1)
          continue;
        length=extent;
        if ((MagickSizeType) length > GetBlobSize(image))
          ThrowReaderException(CorruptImageError,""InsufficientImageDataInFile"");
        profile=BlobToStringInfo((const void *) NULL,length);
        if (profile != (StringInfo *) NULL)
          {
            p=GetStringInfoDatum(profile);
            for (i=0; i < (ssize_t) length; i++)
              *p++=(unsigned char) ProfileInteger(image,hex_digits);
            (void) SetImageProfile(image,""8bim"",profile);
            profile=DestroyStringInfo(profile);
          }
        continue;
      }
    if (LocaleNCompare(BeginXMPPacket,command,strlen(BeginXMPPacket)) == 0)
      {
        register size_t
          i;

        
        p=command;
        profile=StringToStringInfo(command);
        for (i=GetStringInfoLength(profile)-1; c != EOF; i++)
        {
          SetStringInfoLength(profile,(size_t) (i+1));
          c=ReadBlobByte(image);
          GetStringInfoDatum(profile)[i]=(unsigned char) c;
          *p++=(char) c;
          if ((strchr(""\n\r%"",c) == (char *) NULL) &&
              ((size_t) (p-command) < (MaxTextExtent-1)))
            continue;
          *p='\0';
          p=command;
          if (LocaleNCompare(EndXMPPacket,command,strlen(EndXMPPacket)) == 0)
            break;
        }
        SetStringInfoLength(profile,(size_t) i);
        (void) SetImageProfile(image,""xmp"",profile);
        profile=DestroyStringInfo(profile);
        continue;
      }
  }
  (void) CloseBlob(image);
  if (image_info->number_scenes != 0)
    {
      Image
        *clone_image;

      register ssize_t
        i;

      
      for (i=0; i < (ssize_t) image_info->scene; i++)
      {
        clone_image=CloneImage(postscript_image,1,1,MagickTrue,exception);
        if (clone_image != (Image *) NULL)
          PrependImageToList(&postscript_image,clone_image);
      }
    }
  do
  {
    (void) CopyMagickString(postscript_image->filename,filename,MaxTextExtent);
    (void) CopyMagickString(postscript_image->magick,image->magick,
      MaxTextExtent);
    if (columns != 0)
      postscript_image->magick_columns=columns;
    if (rows != 0)
      postscript_image->magick_rows=rows;
    postscript_image->page=page;
    (void) CloneImageProfiles(postscript_image,image);
    (void) CloneImageProperties(postscript_image,image);
    next=SyncNextImageInList(postscript_image);
    if (next != (Image *) NULL)
      postscript_image=next;
  } while (next != (Image *) NULL);
  image=DestroyImageList(image);
  scene=0;
  for (next=GetFirstImageInList(postscript_image); next != (Image *) NULL; )
  {
    next->scene=scene++;
    next=GetNextImageInList(next);
  }
  return(GetFirstImageInList(postscript_image));
}
","1. *delegate_info;
2. continue;
3. (void) SubstituteString(&value,""("","""");
4. value=DestroyString(value);
5. flags=ParseMetaGeometry(geometry,&page.x,&page.y,&page.width,
6. page.height=(size_t) ceil((double) (page.height*image->y_resolution/
7. page.width,(double) page.height);
8. if (IsPostscriptRendered(read_info->filename) == MagickFalse)
9. (void) InterpretImageFilename(image_info,image,filename,(int) i,
10. if (postscript_image == (Image *) NULL)
11. continue;
12. if (profile != (StringInfo *) NULL)
13. profile=StringToStringInfo(command);
14. c=ReadBlobByte(image);
GetStringInfoDatum(profile)[i]=(unsigned char) c;
15. do
16. postscript_image->magick_rows=rows;","43
211
271
276
351
363
417
472
479
493
580
585
604
608-609
644
652","CWE-119,CWE-834,CWE-399,CWE-415"
fib6_add_rt2node,"static int fib6_add_rt2node(struct fib6_node *fn, struct rt6_info *rt,
			    struct nl_info *info)
{
	struct rt6_info *iter = NULL;
	struct rt6_info **ins;
	int replace = (info->nlh &&
		       (info->nlh->nlmsg_flags & NLM_F_REPLACE));
 	int add = (!info->nlh ||
 		   (info->nlh->nlmsg_flags & NLM_F_CREATE));
 	int found = 0;
	bool rt_can_ecmp = rt6_qualify_for_ecmp(rt);
 
 	ins = &fn->leaf;
 
	for (iter = fn->leaf; iter; iter = iter->dst.rt6_next) {
		

		if (iter->rt6i_metric == rt->rt6i_metric) {
			
			if (info->nlh &&
			    (info->nlh->nlmsg_flags & NLM_F_EXCL))
				return -EEXIST;
			if (replace) {
				found++;
				break;
			}

			if (iter->dst.dev == rt->dst.dev &&
			    iter->rt6i_idev == rt->rt6i_idev &&
			    ipv6_addr_equal(&iter->rt6i_gateway,
					    &rt->rt6i_gateway)) {
				if (rt->rt6i_nsiblings)
					rt->rt6i_nsiblings = 0;
				if (!(iter->rt6i_flags & RTF_EXPIRES))
					return -EEXIST;
				if (!(rt->rt6i_flags & RTF_EXPIRES))
					rt6_clean_expires(iter);
				else
					rt6_set_expires(iter, rt->dst.expires);
				return -EEXIST;
			}
			
			if (rt_can_ecmp &&
			    rt6_qualify_for_ecmp(iter))
 				rt->rt6i_nsiblings++;
 		}
 
		if (iter->rt6i_metric > rt->rt6i_metric)
			break;

		ins = &iter->dst.rt6_next;
	}

	
	if (ins == &fn->leaf)
		fn->rr_ptr = NULL;

	
	if (rt->rt6i_nsiblings) {
		unsigned int rt6i_nsiblings;
		struct rt6_info *sibling, *temp_sibling;

 		
 		sibling = fn->leaf;
 		while (sibling) {
			if (sibling->rt6i_metric == rt->rt6i_metric &&
			    rt6_qualify_for_ecmp(sibling)) {
 				list_add_tail(&rt->rt6i_siblings,
 					      &sibling->rt6i_siblings);
 				break;
			}
			sibling = sibling->dst.rt6_next;
		}
		
		rt6i_nsiblings = 0;
		list_for_each_entry_safe(sibling, temp_sibling,
					 &rt->rt6i_siblings, rt6i_siblings) {
			sibling->rt6i_nsiblings++;
			BUG_ON(sibling->rt6i_nsiblings != rt->rt6i_nsiblings);
			rt6i_nsiblings++;
		}
		BUG_ON(rt6i_nsiblings != rt->rt6i_nsiblings);
	}

	
	if (!replace) {
		if (!add)
			pr_warn(""NLM_F_CREATE should be set when creating new route\n"");

add:
		rt->dst.rt6_next = iter;
		*ins = rt;
		rt->rt6i_node = fn;
		atomic_inc(&rt->rt6i_ref);
		inet6_rt_notify(RTM_NEWROUTE, rt, info);
		info->nl_net->ipv6.rt6_stats->fib_rt_entries++;

		if (!(fn->fn_flags & RTN_RTINFO)) {
			info->nl_net->ipv6.rt6_stats->fib_route_nodes++;
			fn->fn_flags |= RTN_RTINFO;
		}

	} else {
		if (!found) {
			if (add)
				goto add;
			pr_warn(""NLM_F_REPLACE set, but no existing node found!\n"");
			return -ENOENT;
		}
		*ins = rt;
		rt->rt6i_node = fn;
		rt->dst.rt6_next = iter->dst.rt6_next;
		atomic_inc(&rt->rt6i_ref);
		inet6_rt_notify(RTM_NEWROUTE, rt, info);
		rt6_release(iter);
		if (!(fn->fn_flags & RTN_RTINFO)) {
			info->nl_net->ipv6.rt6_stats->fib_route_nodes++;
			fn->fn_flags |= RTN_RTINFO;
		}
	}

	return 0;
}
","1. int replace = (info->nlh &&
2. (info->nlh->nlmsg_flags & NLM_F_CREATE));
int found = 0;
3. if (iter->rt6i_metric == rt->rt6i_metric) {
4. if (replace) {
found++;
5. iter->rt6i_idev == rt->rt6i_idev &&
6. &rt->rt6i_gateway)) {
7. if (!(rt->rt6i_flags & RTF_EXPIRES))
8. fn->rr_ptr = NULL;
9. if (rt->rt6i_nsiblings) {
10. struct rt6_info *sibling, *temp_sibling;
11. sibling = fn->leaf;
12. rt6i_nsiblings = 0;
list_for_each_entry_safe(sibling, temp_sibling,
&rt->rt6i_siblings, rt6i_siblings) {
13. BUG_ON(sibling->rt6i_nsiblings != rt->rt6i_nsiblings);
14. if (!add)
15. rt->rt6i_node = fn;
atomic_inc(&rt->rt6i_ref);
16. info->nl_net->ipv6.rt6_stats->fib_rt_entries++;
17. if (!(fn->fn_flags & RTN_RTINFO)) {
18. rt->dst.rt6_next = iter->dst.rt6_next;
19. return 0;","6
9-10
20
27-28
33
35
40
70
73
75
78
92-94
96
106
112-113
115
117
131
141","CWE-362,CWE-476,CWE-191"
PHP_MINIT_FUNCTION_1-191422927630127,"PHP_MINIT_FUNCTION_1(spl_array)
{
	REGISTER_SPL_STD_CLASS_EX(ArrayObject, spl_array_object_new, spl_funcs_ArrayObject);
	REGISTER_SPL_IMPLEMENTS(ArrayObject, Aggregate);
	REGISTER_SPL_IMPLEMENTS(ArrayObject, ArrayAccess);
	REGISTER_SPL_IMPLEMENTS(ArrayObject, Serializable);
	REGISTER_SPL_IMPLEMENTS(ArrayObject, Countable);
	memcpy(&spl_handler_ArrayObject, zend_get_std_object_handlers(), sizeof(zend_object_handlers));

	spl_handler_ArrayObject.clone_obj = spl_array_object_clone;
	spl_handler_ArrayObject.read_dimension = spl_array_read_dimension;
	spl_handler_ArrayObject.write_dimension = spl_array_write_dimension;
	spl_handler_ArrayObject.unset_dimension = spl_array_unset_dimension;
	spl_handler_ArrayObject.has_dimension = spl_array_has_dimension;
	spl_handler_ArrayObject.count_elements = spl_array_object_count_elements;

	spl_handler_ArrayObject.get_properties = spl_array_get_properties;
	spl_handler_ArrayObject.get_debug_info = spl_array_get_debug_info;
	spl_handler_ArrayObject.get_gc = spl_array_get_gc;
	spl_handler_ArrayObject.read_property = spl_array_read_property;
	spl_handler_ArrayObject.write_property = spl_array_write_property;
	spl_handler_ArrayObject.get_property_ptr_ptr = spl_array_get_property_ptr_ptr;
	spl_handler_ArrayObject.has_property = spl_array_has_property;
	spl_handler_ArrayObject.unset_property = spl_array_unset_property;

	spl_handler_ArrayObject.compare_objects = spl_array_compare_objects;

	REGISTER_SPL_STD_CLASS_EX(ArrayIterator, spl_array_object_new, spl_funcs_ArrayIterator);
	REGISTER_SPL_IMPLEMENTS(ArrayIterator, Iterator);
	REGISTER_SPL_IMPLEMENTS(ArrayIterator, ArrayAccess);
	REGISTER_SPL_IMPLEMENTS(ArrayIterator, SeekableIterator);
	REGISTER_SPL_IMPLEMENTS(ArrayIterator, Serializable);
	REGISTER_SPL_IMPLEMENTS(ArrayIterator, Countable);
	memcpy(&spl_handler_ArrayIterator, &spl_handler_ArrayObject, sizeof(zend_object_handlers));
	spl_ce_ArrayIterator->get_iterator = spl_array_get_iterator;

	REGISTER_SPL_SUB_CLASS_EX(RecursiveArrayIterator, ArrayIterator, spl_array_object_new, spl_funcs_RecursiveArrayIterator);
	REGISTER_SPL_IMPLEMENTS(RecursiveArrayIterator, RecursiveIterator);
	spl_ce_RecursiveArrayIterator->get_iterator = spl_array_get_iterator;

	REGISTER_SPL_CLASS_CONST_LONG(ArrayObject,   ""STD_PROP_LIST"",    SPL_ARRAY_STD_PROP_LIST);
	REGISTER_SPL_CLASS_CONST_LONG(ArrayObject,   ""ARRAY_AS_PROPS"",   SPL_ARRAY_ARRAY_AS_PROPS);

	REGISTER_SPL_CLASS_CONST_LONG(ArrayIterator, ""STD_PROP_LIST"",    SPL_ARRAY_STD_PROP_LIST);
	REGISTER_SPL_CLASS_CONST_LONG(ArrayIterator, ""ARRAY_AS_PROPS"",   SPL_ARRAY_ARRAY_AS_PROPS);

	REGISTER_SPL_CLASS_CONST_LONG(RecursiveArrayIterator, ""CHILD_ARRAYS_ONLY"", SPL_ARRAY_CHILD_ARRAYS_ONLY);

	return SUCCESS;
}
","1. spl_handler_ArrayObject.clone_obj = spl_array_object_clone;
2. spl_handler_ArrayObject.get_gc = spl_array_get_gc;
3. REGISTER_SPL_CLASS_CONST_LONG(ArrayObject,   ""STD_PROP_LIST"",    SPL_ARRAY_STD_PROP_LIST);
4. return SUCCESS;","10
19
41
49","CWE-476,CWE-190,CWE-416"
inet_rtm_getroute-89192016521629,"static int inet_rtm_getroute(struct sk_buff *in_skb, struct nlmsghdr *nlh,
			     struct netlink_ext_ack *extack)
{
	struct net *net = sock_net(in_skb->sk);
	struct rtmsg *rtm;
	struct nlattr *tb[RTA_MAX+1];
	struct fib_result res = {};
	struct rtable *rt = NULL;
	struct flowi4 fl4;
	__be32 dst = 0;
	__be32 src = 0;
	u32 iif;
	int err;
	int mark;
	struct sk_buff *skb;
	u32 table_id = RT_TABLE_MAIN;
	kuid_t uid;

	err = nlmsg_parse(nlh, sizeof(*rtm), tb, RTA_MAX, rtm_ipv4_policy,
			  extack);
	if (err < 0)
		goto errout;

	rtm = nlmsg_data(nlh);

	skb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);
	if (!skb) {
		err = -ENOBUFS;
		goto errout;
	}

	
	skb_reset_mac_header(skb);
	skb_reset_network_header(skb);

	src = tb[RTA_SRC] ? nla_get_in_addr(tb[RTA_SRC]) : 0;
	dst = tb[RTA_DST] ? nla_get_in_addr(tb[RTA_DST]) : 0;
	iif = tb[RTA_IIF] ? nla_get_u32(tb[RTA_IIF]) : 0;
	mark = tb[RTA_MARK] ? nla_get_u32(tb[RTA_MARK]) : 0;
	if (tb[RTA_UID])
		uid = make_kuid(current_user_ns(), nla_get_u32(tb[RTA_UID]));
	else
		uid = (iif ? INVALID_UID : current_uid());

	
	ip_hdr(skb)->protocol = IPPROTO_UDP;
	ip_hdr(skb)->saddr = src;
	ip_hdr(skb)->daddr = dst;

	skb_reserve(skb, MAX_HEADER + sizeof(struct iphdr));

	memset(&fl4, 0, sizeof(fl4));
	fl4.daddr = dst;
	fl4.saddr = src;
	fl4.flowi4_tos = rtm->rtm_tos;
	fl4.flowi4_oif = tb[RTA_OIF] ? nla_get_u32(tb[RTA_OIF]) : 0;
	fl4.flowi4_mark = mark;
	fl4.flowi4_uid = uid;

	rcu_read_lock();

	if (iif) {
		struct net_device *dev;

		dev = dev_get_by_index_rcu(net, iif);
		if (!dev) {
			err = -ENODEV;
			goto errout_free;
		}

		skb->protocol	= htons(ETH_P_IP);
		skb->dev	= dev;
		skb->mark	= mark;
		err = ip_route_input_rcu(skb, dst, src, rtm->rtm_tos,
					 dev, &res);

		rt = skb_rtable(skb);
		if (err == 0 && rt->dst.error)
			err = -rt->dst.error;
	} else {
		rt = ip_route_output_key_hash_rcu(net, &fl4, &res, skb);
		err = 0;
		if (IS_ERR(rt))
			err = PTR_ERR(rt);
		else
			skb_dst_set(skb, &rt->dst);
	}

	if (err)
		goto errout_free;

	if (rtm->rtm_flags & RTM_F_NOTIFY)
		rt->rt_flags |= RTCF_NOTIFY;

	if (rtm->rtm_flags & RTM_F_LOOKUP_TABLE)
		table_id = rt->rt_table_id;

	if (rtm->rtm_flags & RTM_F_FIB_MATCH) {
		if (!res.fi) {
			err = fib_props[res.type].error;
			if (!err)
				err = -EHOSTUNREACH;
			goto errout_free;
		}
		err = fib_dump_info(skb, NETLINK_CB(in_skb).portid,
				    nlh->nlmsg_seq, RTM_NEWROUTE, table_id,
				    rt->rt_type, res.prefix, res.prefixlen,
				    fl4.flowi4_tos, res.fi, 0);
	} else {
		err = rt_fill_info(net, dst, src, table_id, &fl4, skb,
				   NETLINK_CB(in_skb).portid, nlh->nlmsg_seq);
	}
	if (err < 0)
		goto errout_free;

	rcu_read_unlock();

	err = rtnl_unicast(skb, net, NETLINK_CB(in_skb).portid);
errout:
	return err;

errout_free:
	rcu_read_unlock();
	kfree_skb(skb);
	goto errout;
}
","1. struct netlink_ext_ack *extack)
2. struct flowi4 fl4;
3. int mark;
struct sk_buff *skb;
4. extack);
if (err < 0)
5. rtm = nlmsg_data(nlh);
6. if (!skb) {
7. mark = tb[RTA_MARK] ? nla_get_u32(tb[RTA_MARK]) : 0;
8. ip_hdr(skb)->saddr = src;
ip_hdr(skb)->daddr = dst;
9. skb_reserve(skb, MAX_HEADER + sizeof(struct iphdr));
10. rt = ip_route_output_key_hash_rcu(net, &fl4, &res, skb);
err = 0;
11. skb_dst_set(skb, &rt->dst);
12. if (err)
13. if (rtm->rtm_flags & RTM_F_NOTIFY)
rt->rt_flags |= RTCF_NOTIFY;
14. if (rtm->rtm_flags & RTM_F_LOOKUP_TABLE)
15. err = rt_fill_info(net, dst, src, table_id, &fl4, skb,
NETLINK_CB(in_skb).portid, nlh->nlmsg_seq);
16. err = rtnl_unicast(skb, net, NETLINK_CB(in_skb).portid);
17. kfree_skb(skb);","2
9
14-15
20-21
24
27
41
51-52
54
85-86
90
93
96-97
99
114-115
122
128","CWE-476,CWE-399,CWE-119"
horDiff8-101907107918999,"
#define TIFF

static int horDiff8(TIFF* tif, uint8* cp0, tmsize_t cc);
","1. static int horDiff8(TIFF* tif, uint8* cp0, tmsize_t cc);",4,CWE-119
r_bin_mdmp_init_directory_entry_1-60688023838219,"static bool r_bin_mdmp_init_directory_entry_1(struct r_bin_mdmp_obj *obj, struct minidump_directory *entry) {
	r_strf_buffer (128);
	struct minidump_handle_operation_list handle_operation_list;
	struct minidump_memory_list memory_list;
	struct minidump_memory64_list memory64_list;
	struct minidump_memory_info_list memory_info_list;
	struct minidump_module_list module_list;
	struct minidump_thread_list thread_list;
	struct minidump_thread_ex_list thread_ex_list;
	struct minidump_thread_info_list thread_info_list;
	struct minidump_token_info_list token_info_list;
	struct minidump_unloaded_module_list unloaded_module_list;
	ut64 offset;
	int i, r;

	
	if ((ut64)entry->location.rva + entry->location.data_size > r_buf_size (obj->b)) {
		eprintf (""[ERROR] Size Mismatch - Stream data is larger than file size!\n"");
		return false;
	}

	switch (entry->stream_type) {
	case THREAD_LIST_STREAM:
		r = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)&thread_list, sizeof (thread_list));
		if (r != sizeof (thread_list)) {
			break;
		}

		sdb_set (obj->kv, ""mdmp_thread.format"", ""ddddq?? ""
			""ThreadId SuspendCount PriorityClass Priority ""
			""Teb (mdmp_memory_descriptor)Stack ""
			""(mdmp_location_descriptor)ThreadContext"", 0);
		sdb_num_set (obj->kv, ""mdmp_thread_list.offset"",
			entry->location.rva, 0);
		sdb_set (obj->kv, ""mdmp_thread_list.format"",
			r_strf (""d[%d]? ""
				""NumberOfThreads (mdmp_thread)Threads"",
				thread_list.number_of_threads),
			0);

		
		break;
	case MODULE_LIST_STREAM:
		module_list.number_of_modules = r_buf_read_le32_at (obj->b, entry->location.rva);

		sdb_set (obj->kv, ""mdmp_module.format"", ""qddtd???qq ""
			""BaseOfImage SizeOfImage CheckSum ""
			""TimeDateStamp ModuleNameRVA ""
			""(mdmp_vs_fixedfileinfo)VersionInfo ""
			""(mdmp_location_descriptor)CvRecord ""
			""(mdmp_location_descriptor)MiscRecord ""
			""Reserved0 Reserved1"", 0);
		sdb_num_set (obj->kv, ""mdmp_module_list.offset"",
			entry->location.rva, 0);
		sdb_set (obj->kv, ""mdmp_module_list.format"",
			r_strf (""d[%d]? ""
				""NumberOfModule (mdmp_module)Modules"",
				module_list.number_of_modules),
			0);

		offset = entry->location.rva + sizeof (module_list);
		for (i = 0; i < module_list.number_of_modules && offset < obj->size; i++) {
			struct minidump_module *module = read_module (obj->b, offset);
			if (!module) {
				break;	
			}
			r_list_append (obj->streams.modules, module);
			offset += sizeof (*module);
		}
		break;
	case MEMORY_LIST_STREAM:
		r = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)&memory_list, sizeof (memory_list));
		if (r != sizeof (memory_list)) {
			break;
		}

		sdb_num_set (obj->kv, ""mdmp_memory_list.offset"",
			entry->location.rva, 0);
		sdb_set (obj->kv, ""mdmp_memory_list.format"",
			r_strf (""d[%d]? ""
				""NumberOfMemoryRanges ""
				""(mdmp_memory_descriptor)MemoryRanges "",
				memory_list.number_of_memory_ranges),
			0);

		offset = entry->location.rva + sizeof (memory_list);
		for (i = 0; i < memory_list.number_of_memory_ranges && offset < obj->size; i++) {
			struct minidump_memory_descriptor *desc = R_NEW (struct minidump_memory_descriptor);
			if (!desc) {
				break;
			}
			r = r_buf_read_at (obj->b, offset, (ut8 *)desc, sizeof (*desc));
			if (r != sizeof (*desc)) {
				break;
			}
			r_list_append (obj->streams.memories, desc);
			offset += sizeof (*desc);
		}
		break;
	case EXCEPTION_STREAM:
		
		obj->streams.exception = R_NEW (struct minidump_exception_stream);
		if (!obj->streams.exception) {
			break;
		}

		r = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)obj->streams.exception, sizeof (*obj->streams.exception));
		if (r != sizeof (*obj->streams.exception)) {
			break;
		}

		sdb_set (obj->kv, ""mdmp_exception.format"", ""[4]E[4]Eqqdd[15]q ""
							   ""(mdmp_exception_code)ExceptionCode ""
							   ""(mdmp_exception_flags)ExceptionFlags ""
							   ""ExceptionRecord ExceptionAddress ""
							   ""NumberParameters __UnusedAlignment ""
							   ""ExceptionInformation"",
			0);
		sdb_num_set (obj->kv, ""mdmp_exception_stream.offset"",
			entry->location.rva, 0);
		sdb_set (obj->kv, ""mdmp_exception_stream.format"", ""dd?? ""
								  ""ThreadId __Alignment ""
								  ""(mdmp_exception)ExceptionRecord ""
								  ""(mdmp_location_descriptor)ThreadContext"",
			0);

		break;
	case SYSTEM_INFO_STREAM:
		obj->streams.system_info = R_NEW (struct minidump_system_info);
		if (!obj->streams.system_info) {
			break;
		}
		r = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)obj->streams.system_info, sizeof (*obj->streams.system_info));
		if (r != sizeof (*obj->streams.system_info)) {
			break;
		}

		sdb_num_set (obj->kv, ""mdmp_system_info.offset"",
			entry->location.rva, 0);
		
		sdb_set (obj->kv, ""mdmp_system_info.format"", ""[2]EwwbBddd[4]Ed[2]Ew[2]q ""
			""(mdmp_processor_architecture)ProcessorArchitecture ""
			""ProcessorLevel ProcessorRevision NumberOfProcessors ""
			""(mdmp_product_type)ProductType ""
			""MajorVersion MinorVersion BuildNumber (mdmp_platform_id)PlatformId ""
			""CsdVersionRva (mdmp_suite_mask)SuiteMask Reserved2 ProcessorFeatures"", 0);

		break;
	case THREAD_EX_LIST_STREAM:
		
		r = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)&thread_ex_list, sizeof (thread_ex_list));
		if (r != sizeof (thread_ex_list)) {
			break;
		}

		sdb_set (obj->kv, ""mdmp_thread_ex.format"", ""ddddq??? ""
			""ThreadId SuspendCount PriorityClass Priority ""
			""Teb (mdmp_memory_descriptor)Stack ""
			""(mdmp_location_descriptor)ThreadContext ""
			""(mdmp_memory_descriptor)BackingStore"", 0);
		sdb_num_set (obj->kv, ""mdmp_thread_ex_list.offset"",
			entry->location.rva, 0);
		sdb_set (obj->kv, ""mdmp_thread_ex_list.format"",
			r_strf (""d[%d]? NumberOfThreads ""
				""(mdmp_thread_ex)Threads"",
				thread_ex_list.number_of_threads),
			0);

		offset = entry->location.rva + sizeof (thread_ex_list);
		for (i = 0; i < thread_ex_list.number_of_threads && offset < obj->size; i++) {
			struct minidump_thread_ex *thread = R_NEW (struct minidump_thread_ex);
			if (!thread) {
				break;
			}
			r = r_buf_read_at (obj->b, offset, (ut8 *)thread, sizeof (*thread));
			if (r != sizeof (*thread)) {
				break;
			}
			r_list_append (obj->streams.ex_threads, thread);
			offset += sizeof (*thread);
		}
		break;
	case MEMORY_64_LIST_STREAM:
		read_memory64_list (obj->b, entry->location.rva, &memory64_list);

		sdb_num_set (obj->kv, ""mdmp_memory64_list.offset"",
			entry->location.rva, 0);
		sdb_set (obj->kv, ""mdmp_memory64_list.format"",
			r_strf (""qq[%""PFMT64d""]? NumberOfMemoryRanges ""
				""BaseRva ""
				""(mdmp_memory_descriptor64)MemoryRanges"",
				memory64_list.number_of_memory_ranges),
			0);

		obj->streams.memories64.base_rva = memory64_list.base_rva;
		offset = entry->location.rva + sizeof (memory64_list);
		for (i = 0; i < memory64_list.number_of_memory_ranges && offset < obj->size; i++) {
			struct minidump_memory_descriptor64 *desc = R_NEW (struct minidump_memory_descriptor64);
			if (!desc) {
				break;
			}
			read_desc (obj->b, offset, desc);
			r_list_append (obj->streams.memories64.memories, desc);
			offset += sizeof (*desc);
		}
		break;
	case COMMENT_STREAM_A:
		
		obj->streams.comments_a = R_NEWS (ut8, COMMENTS_SIZE);
		if (!obj->streams.comments_a) {
			break;
		}
		r = r_buf_read_at (obj->b, entry->location.rva, obj->streams.comments_a, COMMENTS_SIZE);
		if (r != COMMENTS_SIZE) {
			break;
		}

		sdb_num_set (obj->kv, ""mdmp_comment_stream_a.offset"",
			entry->location.rva, 0);
		sdb_set (obj->kv, ""mdmp_comment_stream_a.format"",
			""s CommentA"", 0);

		break;
	case COMMENT_STREAM_W:
		
		obj->streams.comments_w = R_NEWS (ut8, COMMENTS_SIZE);
		if (!obj->streams.comments_w) {
			break;
		}
		r = r_buf_read_at (obj->b, entry->location.rva, obj->streams.comments_w, COMMENTS_SIZE);
		if (r != COMMENTS_SIZE) {
			break;
		}

		sdb_num_set (obj->kv, ""mdmp_comment_stream_w.offset"",
			entry->location.rva, 0);
		sdb_set (obj->kv, ""mdmp_comment_stream_w.format"",
				""s CommentW"", 0);

		break;
	case HANDLE_DATA_STREAM:
		
		obj->streams.handle_data = R_NEW (struct minidump_handle_data_stream);
		if (!obj->streams.handle_data) {
			break;
		}
		r = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)obj->streams.handle_data, sizeof (*obj->streams.handle_data));
		if (r != sizeof (*obj->streams.handle_data)) {
			break;
		}

		sdb_num_set (obj->kv, ""mdmp_handle_data_stream.offset"",
				entry->location.rva, 0);
		sdb_set (obj->kv, ""mdmp_handle_data_stream.format"", ""dddd ""
				""SizeOfHeader SizeOfDescriptor ""
				""NumberOfDescriptors Reserved"", 0);
		break;
	case FUNCTION_TABLE_STREAM:
		
		obj->streams.function_table = R_NEW (struct minidump_function_table_stream);
		if (!obj->streams.function_table) {
			break;
		}
		r = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)obj->streams.function_table, sizeof (*obj->streams.function_table));
		if (r != sizeof (*obj->streams.function_table)) {
			break;
		}

		sdb_num_set (obj->kv, ""mdmp_function_table_stream.offset"",
			entry->location.rva, 0);
		sdb_set (obj->kv, ""mdmp_function_table_stream.format"", ""dddddd ""
			""SizeOfHeader SizeOfDescriptor SizeOfNativeDescriptor ""
			""SizeOfFunctionEntry NumberOfDescriptors SizeOfAlignPad"",
			0);
		break;
	case UNLOADED_MODULE_LIST_STREAM:
		
		r = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)&unloaded_module_list, sizeof (unloaded_module_list));
		if (r != sizeof (unloaded_module_list)) {
			break;
		}

		sdb_set (obj->kv, ""mdmp_unloaded_module.format"", ""qddtd ""
			""BaseOfImage SizeOfImage CheckSum TimeDateStamp ""
			""ModuleNameRva"", 0);
		sdb_num_set (obj->kv, ""mdmp_unloaded_module_list.offset"",
			entry->location.rva, 0);
		sdb_set (obj->kv, ""mdmp_unloaded_module_list.format"", ""ddd ""
			""SizeOfHeader SizeOfEntry NumberOfEntries"", 0);

		offset = entry->location.rva + sizeof (unloaded_module_list);
		for (i = 0; i < unloaded_module_list.number_of_entries && offset < obj->size; i++) {
			struct minidump_unloaded_module *module = R_NEW (struct minidump_unloaded_module);
			if (!module) {
				break;
			}
			r = r_buf_read_at (obj->b, offset, (ut8 *)module, sizeof (*module));
			if (r != sizeof (*module)) {
				break;
			}
			r_list_append (obj->streams.unloaded_modules, module);
			offset += sizeof (*module);
		}
		break;
	case MISC_INFO_STREAM:
		
		obj->streams.misc_info.misc_info_1 = R_NEW (struct minidump_misc_info);
		if (!obj->streams.misc_info.misc_info_1) {
			break;
		}
		r = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)obj->streams.misc_info.misc_info_1, sizeof (*obj->streams.misc_info.misc_info_1));
		if (r != sizeof (*obj->streams.misc_info.misc_info_1)) {
			break;
		}

		
		sdb_num_set (obj->kv, ""mdmp_misc_info.offset"",
			entry->location.rva, 0);
		sdb_set (obj->kv, ""mdmp_misc_info.format"", ""d[4]Bdtttddddd ""
			""SizeOfInfo (mdmp_misc1_flags)Flags1 ProcessId ""
			""ProcessCreateTime ProcessUserTime ProcessKernelTime ""
			""ProcessorMaxMhz ProcessorCurrentMhz ""
			""ProcessorMhzLimit ProcessorMaxIdleState ""
			""ProcessorCurrentIdleState"", 0);

		break;
	case MEMORY_INFO_LIST_STREAM:
		r = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)&memory_info_list, sizeof (memory_info_list));
		if (r != sizeof (memory_info_list)) {
			break;
		}

		sdb_set (obj->kv, ""mdmp_memory_info.format"",
			""qq[4]Edq[4]E[4]E[4]Ed BaseAddress AllocationBase ""
			""(mdmp_page_protect)AllocationProtect __Alignment1 RegionSize ""
			""(mdmp_mem_state)State (mdmp_page_protect)Protect ""
			""(mdmp_mem_type)Type __Alignment2"", 0);
		sdb_num_set (obj->kv, ""mdmp_memory_info_list.offset"",
			entry->location.rva, 0);
		sdb_set (obj->kv, ""mdmp_memory_info_list.format"",
			r_strf (""ddq[%""PFMT64d""]? SizeOfHeader SizeOfEntry ""
				""NumberOfEntries (mdmp_memory_info)MemoryInfo"",
				memory_info_list.number_of_entries),
			0);

		offset = entry->location.rva + sizeof (memory_info_list);
		for (i = 0; i < memory_info_list.number_of_entries && offset < obj->size; i++) {
			struct minidump_memory_info *info = R_NEW (struct minidump_memory_info);
			if (!info) {
				break;
			}
			r = r_buf_read_at (obj->b, offset, (ut8 *)info, sizeof (*info));
			if (r != sizeof (*info)) {
				break;
			}
			r_list_append (obj->streams.memory_infos, info);
			offset += sizeof (*info);
		}
		break;
	case THREAD_INFO_LIST_STREAM:
		
		r = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)&thread_info_list, sizeof (thread_info_list));
		if (r != sizeof (thread_info_list)) {
			break;
		}

		sdb_set (obj->kv, ""mdmp_thread_info.format"", ""ddddttttqq ""
			""ThreadId DumpFlags DumpError ExitStatus CreateTime ""
			""ExitTime KernelTime UserTime StartAddress Affinity"",
			0);
		sdb_num_set (obj->kv, ""mdmp_thread_info_list.offset"",
				entry->location.rva, 0);
		sdb_set (obj->kv, ""mdmp_thread_info_list.format"", ""ddd ""
			""SizeOfHeader SizeOfEntry NumberOfEntries"", 0);

		offset = entry->location.rva + sizeof (thread_info_list);
		for (i = 0; i < thread_info_list.number_of_entries && offset < obj->size; i++) {
			struct minidump_thread_info *info = R_NEW (struct minidump_thread_info);
			if (!info) {
				break;
			}
			r = r_buf_read_at (obj->b, offset, (ut8 *)info, sizeof (*info));
			if (r != sizeof (*info)) {
				break;
			}
			r_list_append (obj->streams.thread_infos, info);
			offset += sizeof (*info);
		}
		break;
	case HANDLE_OPERATION_LIST_STREAM:
		
		r = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)&handle_operation_list, sizeof (handle_operation_list));
		if (r != sizeof (handle_operation_list)) {
			break;
		}

		sdb_num_set (obj->kv, ""mdmp_handle_operation_list.offset"",
			entry->location.rva, 0);
		sdb_set (obj->kv, ""mdmp_handle_operation_list.format"", ""dddd ""
			""SizeOfHeader SizeOfEntry NumberOfEntries Reserved"", 0);

		offset = entry->location.rva + sizeof (handle_operation_list);
		for (i = 0; i < handle_operation_list.number_of_entries && offset < obj->size; i++) {
			struct avrf_handle_operation *op = R_NEW (struct avrf_handle_operation);
			if (!op) {
				break;
			}
			r = r_buf_read_at (obj->b, offset, (ut8 *)op, sizeof (*op));
			if (r != sizeof (*op)) {
				break;
			}
			r_list_append (obj->streams.operations, op);
			offset += sizeof (*op);
		}

		break;
	case TOKEN_STREAM:
		
		r = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)&token_info_list, sizeof (token_info_list));
		if (r != sizeof (token_info_list)) {
			break;
		}

		sdb_set (obj->kv, ""mdmp_token_info.format"", ""ddq ""
			""TokenSize TokenId TokenHandle"", 0);

		sdb_num_set (obj->kv, ""mdmp_token_info_list.offset"",
			entry->location.rva, 0);
		sdb_set (obj->kv, ""mdmp_token_info_list.format"", ""dddd ""
			""TokenListSize TokenListEntries ListHeaderSize ElementHeaderSize"", 0);

		offset = entry->location.rva + sizeof (token_info_list);
		for (i = 0; i < token_info_list.number_of_entries && offset < obj->size; i++) {
			struct minidump_token_info *info = R_NEW (struct minidump_token_info);
			if (!info) {
				break;
			}
			r = r_buf_read_at (obj->b, offset, (ut8 *)info, sizeof (*info));
			if (r != sizeof (*info)) {
				break;
			}
			r_list_append (obj->streams.token_infos, info);
			offset += sizeof (*info);
		}
		break;

	case LAST_RESERVED_STREAM:
		
		break;
	case UNUSED_STREAM:
	case RESERVED_STREAM_0:
	case RESERVED_STREAM_1:
		
		break;
	default:
		eprintf (""[WARN] Invalid or unsupported enumeration encountered %d\n"", entry->stream_type);
		break;
	}
	return true;
}
","1. case THREAD_LIST_STREAM:
2. if (r != sizeof (thread_list)) {
3. sdb_num_set (obj->kv, ""mdmp_thread_list.offset"",
4. ""Reserved0 Reserved1"", 0);
5. sdb_set (obj->kv, ""mdmp_module_list.format"",
6. if (!module) {
break;
7. r = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)&memory_list, sizeof (memory_list));
8. break;
9. sdb_set (obj->kv, ""mdmp_exception.format"", ""[4]E[4]Eqqdd[15]q ""
10. 0);
11. break;
12. r = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)obj->streams.system_info, sizeof (*obj->streams.system_info));
13. ""CsdVersionRva (mdmp_suite_mask)SuiteMask Reserved2 ProcessorFeatures"", 0);
14. break;
case THREAD_EX_LIST_STREAM:
15. r = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)&thread_ex_list, sizeof (thread_ex_list));
16. break;
17. obj->streams.memories64.base_rva = memory64_list.base_rva;
offset = entry->location.rva + sizeof (memory64_list);
18. read_desc (obj->b, offset, desc);
19. break;
case COMMENT_STREAM_A:
20. entry->location.rva, 0);
21. ""s CommentA"", 0);
22. break;
23. break;
24. 0);
25. r = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)&unloaded_module_list, sizeof (unloaded_module_list));
if (r != sizeof (unloaded_module_list)) {
26. sdb_set (obj->kv, ""mdmp_unloaded_module.format"", ""qddtd ""
27. break;
28. case MISC_INFO_STREAM:
29. break;
30. sdb_set (obj->kv, ""mdmp_memory_info.format"",
31. entry->location.rva, 0);
32. if (r != sizeof (*info)) {
break;
33. 0);
34. for (i = 0; i < thread_info_list.number_of_entries && offset < obj->size; i++) {
35. r = r_buf_read_at (obj->b, offset, (ut8 *)info, sizeof (*info));
36. offset += sizeof (*info);
37. offset = entry->location.rva + sizeof (handle_operation_list);
38. case TOKEN_STREAM:
39. r = r_buf_read_at (obj->b, entry->location.rva, (ut8 *)&token_info_list, sizeof (token_info_list));
40. r = r_buf_read_at (obj->b, offset, (ut8 *)info, sizeof (*info));
41. offset += sizeof (*info);","24
26
34
53
56
65-66
73
95
113
119
132
134
147
149-150
152
178
196-197
203
207-208
220
222
229
250
275
279-280
284
296
306
331
334
340
354-355
371
378
383
388
403
418
420
439
444","CWE-362,CWE-787,CWE-119"
juniper_atm2_print,"juniper_atm2_print(netdissect_options *ndo,
                   const struct pcap_pkthdr *h, register const u_char *p)
{
        int llc_hdrlen;

        struct juniper_l2info_t l2info;

        l2info.pictype = DLT_JUNIPER_ATM2;
        if (juniper_parse_header(ndo, p, h, &l2info) == 0)
            return l2info.header_len;

        p+=l2info.header_len;

        if (l2info.cookie[7] & ATM2_PKT_TYPE_MASK) { 
            oam_print(ndo, p, l2info.length, ATM_OAM_NOHEC);
            return l2info.header_len;
        }

        if (EXTRACT_24BITS(p) == 0xfefe03 || 
            EXTRACT_24BITS(p) == 0xaaaa03) { 

            llc_hdrlen = llc_print(ndo, p, l2info.length, l2info.caplen, NULL, NULL);
            if (llc_hdrlen > 0)
                return l2info.header_len;
        }

        if (l2info.direction != JUNIPER_BPF_PKT_IN && 
            (EXTRACT_32BITS(l2info.cookie) & ATM2_GAP_COUNT_MASK)) {
            ether_print(ndo, p, l2info.length, l2info.caplen, NULL, NULL);
            return l2info.header_len;
         }
 
         if (p[0] == 0x03) { 
            isoclns_print(ndo, p + 1, l2info.length - 1);
             
             return l2info.header_len;
         }

        if(juniper_ppp_heuristic_guess(ndo, p, l2info.length) != 0) 
            return l2info.header_len;

        if (ip_heuristic_guess(ndo, p, l2info.length) != 0) 
            return l2info.header_len;

	return l2info.header_len;
}
","1. const struct pcap_pkthdr *h, register const u_char *p)
2. if (juniper_parse_header(ndo, p, h, &l2info) == 0)
3. llc_hdrlen = llc_print(ndo, p, l2info.length, l2info.caplen, NULL, NULL);
4. return l2info.header_len;
5. if (l2info.direction != JUNIPER_BPF_PKT_IN &&
6. ether_print(ndo, p, l2info.length, l2info.caplen, NULL, NULL);
7. if(juniper_ppp_heuristic_guess(ndo, p, l2info.length) != 0)
8. if (ip_heuristic_guess(ndo, p, l2info.length) != 0)
9. return l2info.header_len;","2
9
22
24
27
29
39
42
45","CWE-200,CWE-125"
main_41-97881127338526,"int
main_41 (int argc, char *argv[])
{
  int res;

  g_test_init (&argc, &argv, NULL);

  g_test_add_func (""/common/has-path-prefix"", test_has_path_prefix);
  g_test_add_func (""/common/path-match-prefix"", test_path_match_prefix);
  g_test_add_func (""/common/fancy-output"", test_fancy_output);
  g_test_add_func (""/common/arches"", test_arches);
  g_test_add_func (""/common/extension-matches"", test_extension_matches);
  g_test_add_func (""/common/valid-name"", test_valid_name);
  g_test_add_func (""/common/string-to-unsigned"", test_string_to_unsigned);
  g_test_add_func (""/common/levenshtein"", test_levenshtein);
  g_test_add_func (""/common/format-choices"", test_format_choices);
  g_test_add_func (""/common/yes-no-prompt"", test_yes_no_prompt);
  g_test_add_func (""/common/number-prompt"", test_number_prompt);
  g_test_add_func (""/common/parse-numbers"", test_parse_numbers);
  g_test_add_func (""/common/subpaths-merge"", test_subpaths_merge);
  g_test_add_func (""/common/lang-from-locale"", test_lang_from_locale);
  g_test_add_func (""/common/appdata"", test_parse_appdata);
  g_test_add_func (""/common/name-matching"", test_name_matching);
  g_test_add_func (""/common/filter_parser"", test_filter_parser);
  g_test_add_func (""/common/filter"", test_filter);
  g_test_add_func (""/common/dconf-app-id"", test_dconf_app_id);
  g_test_add_func (""/common/dconf-paths"", test_dconf_paths);
  g_test_add_func (""/common/decompose-ref"", test_decompose);
  g_test_add_func (""/common/envp-cmp"", test_envp_cmp);
  g_test_add_func (""/common/needs-quoting"", test_needs_quoting);
  g_test_add_func (""/common/quote-argv"", test_quote_argv);
  g_test_add_func (""/common/str-is-integer"", test_str_is_integer);
  g_test_add_func (""/common/parse-x11-display"", test_parse_x11_display);
  g_test_add_func (""/common/string-escape"", test_string_escape);
  g_test_add_func (""/common/validate-path-characters"", test_validate_path_characters);

  g_test_add_func (""/app/looks-like-branch"", test_looks_like_branch);
  g_test_add_func (""/app/columns"", test_columns);
  g_test_add_func (""/app/string-ellipsize"", test_string_ellipsize);
  g_test_add_func (""/app/table"", test_table);
  g_test_add_func (""/app/table-expand"", test_table_expand);
  g_test_add_func (""/app/table-shrink"", test_table_shrink);
  g_test_add_func (""/app/table-shrink-more"", test_table_shrink_more);
  g_test_add_func (""/app/parse-datetime"", test_parse_datetime);

  res = g_test_run ();

  return res;
}
","1. g_test_add_func (""/common/levenshtein"", test_levenshtein);
g_test_add_func (""/common/format-choices"", test_format_choices);
2. g_test_add_func (""/common/appdata"", test_parse_appdata);
3. g_test_add_func (""/common/dconf-paths"", test_dconf_paths);","15-16
22
27","CWE-284,CWE-116,CWE-552"
aio_mount-122583710335962,"static struct dentry *aio_mount(struct file_system_type *fs_type,
				int flags, const char *dev_name, void *data)
{
	static const struct dentry_operations ops = {
		.d_dname	= simple_dname,
	};
	struct dentry *root = mount_pseudo(fs_type, ""aio:"", NULL, &ops,
					   AIO_RING_MAGIC);

	if (!IS_ERR(root))
		root->d_sb->s_iflags |= SB_I_NOEXEC;
	return root;
}
","1. struct dentry *root = mount_pseudo(fs_type, ""aio:"", NULL, &ops,
2. if (!IS_ERR(root))","7
10","CWE-200,CWE-20,CWE-120,CWE-287"
kvm_set_msr_common,"int kvm_set_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)
{
	bool pr = false;
	u32 msr = msr_info->index;
	u64 data = msr_info->data;

	switch (msr) {
	case MSR_AMD64_NB_CFG:
	case MSR_IA32_UCODE_REV:
	case MSR_IA32_UCODE_WRITE:
	case MSR_VM_HSAVE_PA:
	case MSR_AMD64_PATCH_LOADER:
	case MSR_AMD64_BU_CFG2:
		break;

	case MSR_EFER:
		return set_efer(vcpu, data);
	case MSR_K7_HWCR:
		data &= ~(u64)0x40;	
		data &= ~(u64)0x100;	
		data &= ~(u64)0x8;	
		if (data != 0) {
			vcpu_unimpl(vcpu, ""unimplemented HWCR wrmsr: 0x%llx\n"",
				    data);
			return 1;
		}
		break;
	case MSR_FAM10H_MMIO_CONF_BASE:
		if (data != 0) {
			vcpu_unimpl(vcpu, ""unimplemented MMIO_CONF_BASE wrmsr: ""
				    ""0x%llx\n"", data);
			return 1;
		}
		break;
	case MSR_IA32_DEBUGCTLMSR:
		if (!data) {
			
			break;
		} else if (data & ~(DEBUGCTLMSR_LBR | DEBUGCTLMSR_BTF)) {
			
			return 1;
		}
		vcpu_unimpl(vcpu, ""%s: MSR_IA32_DEBUGCTLMSR 0x%llx, nop\n"",
			    __func__, data);
		break;
	case 0x200 ... 0x2ff:
		return set_msr_mtrr(vcpu, msr, data);
	case MSR_IA32_APICBASE:
		kvm_set_apic_base(vcpu, data);
		break;
	case APIC_BASE_MSR ... APIC_BASE_MSR + 0x3ff:
		return kvm_x2apic_msr_write(vcpu, msr, data);
	case MSR_IA32_TSCDEADLINE:
		kvm_set_lapic_tscdeadline_msr(vcpu, data);
		break;
	case MSR_IA32_TSC_ADJUST:
		if (guest_cpuid_has_tsc_adjust(vcpu)) {
			if (!msr_info->host_initiated) {
				u64 adj = data - vcpu->arch.ia32_tsc_adjust_msr;
				kvm_x86_ops->adjust_tsc_offset(vcpu, adj, true);
			}
			vcpu->arch.ia32_tsc_adjust_msr = data;
		}
		break;
	case MSR_IA32_MISC_ENABLE:
		vcpu->arch.ia32_misc_enable_msr = data;
		break;
	case MSR_KVM_WALL_CLOCK_NEW:
	case MSR_KVM_WALL_CLOCK:
		vcpu->kvm->arch.wall_clock = data;
		kvm_write_wall_clock(vcpu->kvm, data);
		break;
	case MSR_KVM_SYSTEM_TIME_NEW:
	case MSR_KVM_SYSTEM_TIME: {
		kvmclock_reset(vcpu);

		vcpu->arch.time = data;
		kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);

		
		if (!(data & 1))
			break;

 		
 		vcpu->arch.time_offset = data & ~(PAGE_MASK | 1);
 
		
		if (vcpu->arch.time_offset &
				(sizeof(struct pvclock_vcpu_time_info) - 1))
			break;

 		vcpu->arch.time_page =
 				gfn_to_page(vcpu->kvm, data >> PAGE_SHIFT);
 
		if (is_error_page(vcpu->arch.time_page))
			vcpu->arch.time_page = NULL;

		break;
	}
	case MSR_KVM_ASYNC_PF_EN:
		if (kvm_pv_enable_async_pf(vcpu, data))
			return 1;
		break;
	case MSR_KVM_STEAL_TIME:

		if (unlikely(!sched_info_on()))
			return 1;

		if (data & KVM_STEAL_RESERVED_MASK)
			return 1;

		if (kvm_gfn_to_hva_cache_init(vcpu->kvm, &vcpu->arch.st.stime,
							data & KVM_STEAL_VALID_BITS))
			return 1;

		vcpu->arch.st.msr_val = data;

		if (!(data & KVM_MSR_ENABLED))
			break;

		vcpu->arch.st.last_steal = current->sched_info.run_delay;

		preempt_disable();
		accumulate_steal_time(vcpu);
		preempt_enable();

		kvm_make_request(KVM_REQ_STEAL_UPDATE, vcpu);

		break;
	case MSR_KVM_PV_EOI_EN:
		if (kvm_lapic_enable_pv_eoi(vcpu, data))
			return 1;
		break;

	case MSR_IA32_MCG_CTL:
	case MSR_IA32_MCG_STATUS:
	case MSR_IA32_MC0_CTL ... MSR_IA32_MC0_CTL + 4 * KVM_MAX_MCE_BANKS - 1:
		return set_msr_mce(vcpu, msr, data);

	
	case MSR_K7_EVNTSEL0:
	case MSR_K7_EVNTSEL1:
	case MSR_K7_EVNTSEL2:
	case MSR_K7_EVNTSEL3:
		if (data != 0)
			vcpu_unimpl(vcpu, ""unimplemented perfctr wrmsr: ""
				    ""0x%x data 0x%llx\n"", msr, data);
		break;
	
	case MSR_K7_PERFCTR0:
	case MSR_K7_PERFCTR1:
	case MSR_K7_PERFCTR2:
	case MSR_K7_PERFCTR3:
		vcpu_unimpl(vcpu, ""unimplemented perfctr wrmsr: ""
			    ""0x%x data 0x%llx\n"", msr, data);
		break;
	case MSR_P6_PERFCTR0:
	case MSR_P6_PERFCTR1:
		pr = true;
	case MSR_P6_EVNTSEL0:
	case MSR_P6_EVNTSEL1:
		if (kvm_pmu_msr(vcpu, msr))
			return kvm_pmu_set_msr(vcpu, msr, data);

		if (pr || data != 0)
			vcpu_unimpl(vcpu, ""disabled perfctr wrmsr: ""
				    ""0x%x data 0x%llx\n"", msr, data);
		break;
	case MSR_K7_CLK_CTL:
		
		break;
	case HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15:
		if (kvm_hv_msr_partition_wide(msr)) {
			int r;
			mutex_lock(&vcpu->kvm->lock);
			r = set_msr_hyperv_pw(vcpu, msr, data);
			mutex_unlock(&vcpu->kvm->lock);
			return r;
		} else
			return set_msr_hyperv(vcpu, msr, data);
		break;
	case MSR_IA32_BBL_CR_CTL3:
		
		vcpu_unimpl(vcpu, ""ignored wrmsr: 0x%x data %llx\n"", msr, data);
		break;
	case MSR_AMD64_OSVW_ID_LENGTH:
		if (!guest_cpuid_has_osvw(vcpu))
			return 1;
		vcpu->arch.osvw.length = data;
		break;
	case MSR_AMD64_OSVW_STATUS:
		if (!guest_cpuid_has_osvw(vcpu))
			return 1;
		vcpu->arch.osvw.status = data;
		break;
	default:
		if (msr && (msr == vcpu->kvm->arch.xen_hvm_config.msr))
			return xen_hvm_config(vcpu, data);
		if (kvm_pmu_msr(vcpu, msr))
			return kvm_pmu_set_msr(vcpu, msr, data);
		if (!ignore_msrs) {
			vcpu_unimpl(vcpu, ""unhandled wrmsr: 0x%x data %llx\n"",
				    msr, data);
			return 1;
		} else {
			vcpu_unimpl(vcpu, ""ignored wrmsr: 0x%x data %llx\n"",
				    msr, data);
			break;
		}
	}
	return 0;
}
","1. case MSR_IA32_UCODE_REV:
2. if (data != 0) {
3. if (!msr_info->host_initiated) {
4. case MSR_KVM_PV_EOI_EN:
5. ""0x%x data 0x%llx\n"", msr, data);
6. vcpu->arch.osvw.length = data;
7. break;
default:
8. if (!ignore_msrs) {","9
29
59
131
154
207
213-214
219","CWE-125,CWE-399,CWE-119"
dev_config_1-268846526868947,"
#define __user

static ssize_t
dev_config_1 (struct file *fd, const char __user *buf, size_t len, loff_t *ptr)
{
	struct dev_data		*dev = fd->private_data;
	ssize_t			value, length = len;
	unsigned		total;
	u32			tag;
	char			*kbuf;

	spin_lock_irq(&dev->lock);
	if (dev->state > STATE_DEV_OPENED) {
		value = ep0_write(fd, buf, len, ptr);
		spin_unlock_irq(&dev->lock);
		return value;
	}
	spin_unlock_irq(&dev->lock);

	if ((len < (USB_DT_CONFIG_SIZE + USB_DT_DEVICE_SIZE + 4)) ||
	    (len > PAGE_SIZE * 4))
		return -EINVAL;

	
	if (copy_from_user (&tag, buf, 4))
		return -EFAULT;
	if (tag != 0)
		return -EINVAL;
	buf += 4;
	length -= 4;

	kbuf = memdup_user(buf, length);
	if (IS_ERR(kbuf))
		return PTR_ERR(kbuf);

	spin_lock_irq (&dev->lock);
	value = -EINVAL;
	if (dev->buf) {
		spin_unlock_irq(&dev->lock);
		kfree(kbuf);
		return value;
	}
	dev->buf = kbuf;

	
	dev->config = (void *) kbuf;
	total = le16_to_cpu(dev->config->wTotalLength);
	if (!is_valid_config(dev->config, total) ||
			total > length - USB_DT_DEVICE_SIZE)
		goto fail;
	kbuf += total;
	length -= total;

	
	if (kbuf [1] == USB_DT_CONFIG) {
		dev->hs_config = (void *) kbuf;
		total = le16_to_cpu(dev->hs_config->wTotalLength);
		if (!is_valid_config(dev->hs_config, total) ||
				total > length - USB_DT_DEVICE_SIZE)
			goto fail;
		kbuf += total;
		length -= total;
	} else {
		dev->hs_config = NULL;
	}

	

	
	if (length != USB_DT_DEVICE_SIZE)
		goto fail;
	dev->dev = (void *)kbuf;
	if (dev->dev->bLength != USB_DT_DEVICE_SIZE
			|| dev->dev->bDescriptorType != USB_DT_DEVICE
			|| dev->dev->bNumConfigurations != 1)
		goto fail;
	dev->dev->bcdUSB = cpu_to_le16 (0x0200);

	
	spin_unlock_irq (&dev->lock);
	if (dev->hs_config)
		gadgetfs_driver.max_speed = USB_SPEED_HIGH;
	else
		gadgetfs_driver.max_speed = USB_SPEED_FULL;

	value = usb_gadget_probe_driver(&gadgetfs_driver);
	if (value != 0) {
		spin_lock_irq(&dev->lock);
		goto fail;
	} else {
		
		value = len;
		dev->gadget_registered = true;
	}
	return value;

fail:
	dev->config = NULL;
	dev->hs_config = NULL;
	dev->dev = NULL;
	spin_unlock_irq (&dev->lock);
	pr_debug (""%s: %s fail %zd, %p\n"", shortname, __func__, value, dev);
	kfree (dev->buf);
	dev->buf = NULL;
	return value;
}
","1. char			*kbuf;
2. spin_unlock_irq(&dev->lock);
3. return -EINVAL;
buf += 4;
4. kbuf = memdup_user(buf, length);
5. return PTR_ERR(kbuf);
6. if (dev->buf) {
7. return value;
8. total = le16_to_cpu(dev->config->wTotalLength);
9. dev->hs_config = (void *) kbuf;
10. dev->hs_config = NULL;
11. value = usb_gadget_probe_driver(&gadgetfs_driver);","11
16
29-30
33
35
39
42
48
57
65
87","CWE-20,CWE-362,CWE-763,CWE-416,CWE-119"
can_unload_buffer-41066564235405,"    static int
can_unload_buffer(buf_T *buf)
{
    int	    can_unload = !buf->b_locked;

    if (can_unload && updating_screen)
    {
	win_T	*wp;

	FOR_ALL_WINDOWS(wp)
	    if (wp->w_buffer == buf)
	    {
		can_unload = FALSE;
		break;
	    }
    }
    if (!can_unload)
    {
	char_u *fname = buf->b_fname != NULL ? buf->b_fname : buf->b_ffname;

	semsg(_(e_attempt_to_delete_buffer_that_is_in_use_str),
				fname != NULL ? fname : (char_u *)""[No Name]"");
    }
    return can_unload;
}
","1. can_unload_buffer(buf_T *buf)
2. FOR_ALL_WINDOWS(wp)
3. can_unload = FALSE;
4. return can_unload;","2
10
13
24","CWE-122,CWE-20,CWE-787,CWE-284"
gup_huge_pgd,"static int gup_huge_pgd(pgd_t orig, pgd_t *pgdp, unsigned long addr,
			unsigned long end, int write,
			struct page **pages, int *nr)
{
	int refs;
	struct page *head, *page;

	if (!pgd_access_permitted(orig, write))
		return 0;

	BUILD_BUG_ON(pgd_devmap(orig));
	refs = 0;
	page = pgd_page(orig) + ((addr & ~PGDIR_MASK) >> PAGE_SHIFT);
	do {
		pages[*nr] = page;
		(*nr)++;
		page++;
 		refs++;
 	} while (addr += PAGE_SIZE, addr != end);
 
	head = try_get_compound_head(pgd_page(orig), refs);
	if (!head) {
 		*nr -= refs;
 		return 0;
 	}

	if (unlikely(pgd_val(orig) != pgd_val(*pgdp))) {
		*nr -= refs;
		while (refs--)
			put_page(head);
		return 0;
	}

	SetPageReferenced(head);
	return 1;
}
","1. static int gup_huge_pgd(pgd_t orig, pgd_t *pgdp, unsigned long addr,
unsigned long end, int write,
2. int refs;
struct page *head, *page;
3. if (!pgd_access_permitted(orig, write))
return 0;
4. BUILD_BUG_ON(pgd_devmap(orig));
5. page = pgd_page(orig) + ((addr & ~PGDIR_MASK) >> PAGE_SHIFT);
6. (*nr)++;
page++;
7. if (!head) {
*nr -= refs;
8. if (unlikely(pgd_val(orig) != pgd_val(*pgdp))) {
*nr -= refs;
while (refs--)
put_page(head);","1-2
5-6
8-9
11
13
16-17
22-23
27-30","CWE-119,CWE-787,CWE-416"
do_ssl3_write,"
#define SSL

int do_ssl3_write(SSL *s, int type, const unsigned char *buf,
                  unsigned int *pipelens, unsigned int numpipes,
                  int create_empty_fragment)
{
    unsigned char *outbuf[SSL_MAX_PIPELINES], *plen[SSL_MAX_PIPELINES];
    SSL3_RECORD wr[SSL_MAX_PIPELINES];
    int i, mac_size, clear = 0;
    int prefix_len = 0;
    int eivlen;
    size_t align = 0;
    SSL3_BUFFER *wb;
    SSL_SESSION *sess;
    unsigned int totlen = 0;
    unsigned int j;

    for (j = 0; j < numpipes; j++)
        totlen += pipelens[j];
    
    if (RECORD_LAYER_write_pending(&s->rlayer))
        return (ssl3_write_pending(s, type, buf, totlen));

    
    if (s->s3->alert_dispatch) {
        i = s->method->ssl_dispatch_alert(s);
        if (i <= 0)
            return (i);
        
    }

    if (s->rlayer.numwpipes < numpipes)
        if (!ssl3_setup_write_buffer(s, numpipes, 0))
            return -1;

    if (totlen == 0 && !create_empty_fragment)
        return 0;

    sess = s->session;

    if ((sess == NULL) ||
        (s->enc_write_ctx == NULL) || (EVP_MD_CTX_md(s->write_hash) == NULL)) {
        clear = s->enc_write_ctx ? 0 : 1; 
        mac_size = 0;
    } else {
        mac_size = EVP_MD_CTX_size(s->write_hash);
        if (mac_size < 0)
            goto err;
    }

    
    if (!clear && !create_empty_fragment && !s->s3->empty_fragment_done) {
        

        if (s->s3->need_empty_fragments && type == SSL3_RT_APPLICATION_DATA) {
            
            unsigned int tmppipelen = 0;

            prefix_len = do_ssl3_write(s, type, buf, &tmppipelen, 1, 1);
            if (prefix_len <= 0)
                goto err;

            if (prefix_len >
                (SSL3_RT_HEADER_LENGTH + SSL3_RT_SEND_MAX_ENCRYPTED_OVERHEAD)) {
                
                SSLerr(SSL_F_DO_SSL3_WRITE, ERR_R_INTERNAL_ERROR);
                goto err;
            }
        }

        s->s3->empty_fragment_done = 1;
    }

    if (create_empty_fragment) {
        wb = &s->rlayer.wbuf[0];
#if defined(SSL3_ALIGN_PAYLOAD) && SSL3_ALIGN_PAYLOAD!=0
        
        align = (size_t)SSL3_BUFFER_get_buf(wb) + 2 * SSL3_RT_HEADER_LENGTH;
        align = SSL3_ALIGN_PAYLOAD - 1 - ((align - 1) % SSL3_ALIGN_PAYLOAD);
#endif
        outbuf[0] = SSL3_BUFFER_get_buf(wb) + align;
        SSL3_BUFFER_set_offset(wb, align);
    } else if (prefix_len) {
        wb = &s->rlayer.wbuf[0];
        outbuf[0] = SSL3_BUFFER_get_buf(wb) + SSL3_BUFFER_get_offset(wb)
            + prefix_len;
    } else {
        for (j = 0; j < numpipes; j++) {
            wb = &s->rlayer.wbuf[j];
#if defined(SSL3_ALIGN_PAYLOAD) && SSL3_ALIGN_PAYLOAD!=0
            align = (size_t)SSL3_BUFFER_get_buf(wb) + SSL3_RT_HEADER_LENGTH;
            align = SSL3_ALIGN_PAYLOAD - 1 - ((align - 1) % SSL3_ALIGN_PAYLOAD);
#endif
            outbuf[j] = SSL3_BUFFER_get_buf(wb) + align;
            SSL3_BUFFER_set_offset(wb, align);
        }
    }

    
    if (s->enc_write_ctx && SSL_USE_EXPLICIT_IV(s)) {
        int mode = EVP_CIPHER_CTX_mode(s->enc_write_ctx);
        if (mode == EVP_CIPH_CBC_MODE) {
            eivlen = EVP_CIPHER_CTX_iv_length(s->enc_write_ctx);
            if (eivlen <= 1)
                eivlen = 0;
        }
        
        else if (mode == EVP_CIPH_GCM_MODE)
            eivlen = EVP_GCM_TLS_EXPLICIT_IV_LEN;
        else if (mode == EVP_CIPH_CCM_MODE)
            eivlen = EVP_CCM_TLS_EXPLICIT_IV_LEN;
        else
            eivlen = 0;
    } else
        eivlen = 0;

    totlen = 0;
    
    memset(wr, 0, sizeof wr);
    for (j = 0; j < numpipes; j++) {
        
        *(outbuf[j]++) = type & 0xff;
        SSL3_RECORD_set_type(&wr[j], type);

        *(outbuf[j]++) = (s->version >> 8);
        
        if (SSL_get_state(s) == TLS_ST_CW_CLNT_HELLO
            && !s->renegotiate && TLS1_get_version(s) > TLS1_VERSION)
            *(outbuf[j]++) = 0x1;
        else
            *(outbuf[j]++) = s->version & 0xff;

        
        plen[j] = outbuf[j];
        outbuf[j] += 2;

        
        SSL3_RECORD_set_data(&wr[j], outbuf[j] + eivlen);
        SSL3_RECORD_set_length(&wr[j], (int)pipelens[j]);
        SSL3_RECORD_set_input(&wr[j], (unsigned char *)&buf[totlen]);
        totlen += pipelens[j];

        

        
        if (s->compress != NULL) {
            if (!ssl3_do_compress(s, &wr[j])) {
                SSLerr(SSL_F_DO_SSL3_WRITE, SSL_R_COMPRESSION_FAILURE);
                goto err;
            }
        } else {
            memcpy(wr[j].data, wr[j].input, wr[j].length);
            SSL3_RECORD_reset_input(&wr[j]);
        }

        
 
        if (!SSL_WRITE_ETM(s) && mac_size != 0) {
             if (s->method->ssl3_enc->mac(s, &wr[j],
                                          &(outbuf[j][wr[j].length + eivlen]),
                                          1) < 0)
                goto err;
            SSL3_RECORD_add_length(&wr[j], mac_size);
        }

        SSL3_RECORD_set_data(&wr[j], outbuf[j]);
        SSL3_RECORD_reset_input(&wr[j]);

        if (eivlen) {
            
            SSL3_RECORD_add_length(&wr[j], eivlen);
        }
    }

    if (s->method->ssl3_enc->enc(s, wr, numpipes, 1) < 1)
         goto err;
 
     for (j = 0; j < numpipes; j++) {
        if (SSL_WRITE_ETM(s) && mac_size != 0) {
             if (s->method->ssl3_enc->mac(s, &wr[j],
                                          outbuf[j] + wr[j].length, 1) < 0)
                 goto err;
            SSL3_RECORD_add_length(&wr[j], mac_size);
        }

        
        s2n(SSL3_RECORD_get_length(&wr[j]), plen[j]);

        if (s->msg_callback)
            s->msg_callback(1, 0, SSL3_RT_HEADER, plen[j] - 5, 5, s,
                            s->msg_callback_arg);

        
        SSL3_RECORD_set_type(&wr[j], type); 
        SSL3_RECORD_add_length(&wr[j], SSL3_RT_HEADER_LENGTH);

        if (create_empty_fragment) {
            
            if (j > 0) {
                
                SSLerr(SSL_F_DO_SSL3_WRITE, ERR_R_INTERNAL_ERROR);
                goto err;
            }
            return SSL3_RECORD_get_length(wr);
        }

        
        SSL3_BUFFER_set_left(&s->rlayer.wbuf[j],
                             prefix_len + SSL3_RECORD_get_length(&wr[j]));
    }

    
    s->rlayer.wpend_tot = totlen;
    s->rlayer.wpend_buf = buf;
    s->rlayer.wpend_type = type;
    s->rlayer.wpend_ret = totlen;

    
    return ssl3_write_pending(s, type, buf, totlen);
 err:
    return -1;
}
","1. int eivlen;
2. unsigned int j;
3. return (i);
4. if (mac_size < 0)
5. eivlen = EVP_CIPHER_CTX_iv_length(s->enc_write_ctx);
6. else if (mode == EVP_CIPH_GCM_MODE)
7. else if (mode == EVP_CIPH_CCM_MODE)
8. *(outbuf[j]++) = type & 0xff;
9. *(outbuf[j]++) = (s->version >> 8);
10. if (SSL_get_state(s) == TLS_ST_CW_CLNT_HELLO
11. plen[j] = outbuf[j];
12. SSL3_RECORD_set_length(&wr[j], (int)pipelens[j]);
13. if (s->compress != NULL) {
14. 1) < 0)
15. SSL3_RECORD_add_length(&wr[j], mac_size);
16. outbuf[j] + wr[j].length, 1) < 0)
17. SSL3_RECORD_add_length(&wr[j], mac_size);
18. s->rlayer.wpend_type = type;
19. err:","12
17
32
51
121
126
128
140
143
148
155
160
169
188
190
210
212
254
259","CWE-362,CWE-1284,CWE-399,CWE-189"
pgx_validate-146008881256456,"int pgx_validate(jas_stream_t *in)
{
	jas_uchar buf[PGX_MAGICLEN];
	uint_fast32_t magic;
	int i;
	int n;

	assert(JAS_STREAM_MAXPUTBACK >= PGX_MAGICLEN);

	
	if ((n = jas_stream_read(in, buf, PGX_MAGICLEN)) < 0) {
		return -1;
	}

	
	for (i = n - 1; i >= 0; --i) {
		if (jas_stream_ungetc(in, buf[i]) == EOF) {
			return -1;
		}
	}

	
	if (n < PGX_MAGICLEN) {
		return -1;
	}

	
	magic = (buf[0] << 8) | buf[1];

	
	if (magic != PGX_MAGIC) {
		return -1;
	}

	return 0;
}
","1. uint_fast32_t magic;
2. assert(JAS_STREAM_MAXPUTBACK >= PGX_MAGICLEN);
3. if (n < PGX_MAGICLEN) {
4. return 0;","4
8
25
37","CWE-190,CWE-20"
safe_fprintf-173808893225754,"
#define FILE

void
safe_fprintf(FILE *f, const char *fmt, ...)
{
	char fmtbuff_stack[256]; 
	char outbuff[256]; 
	char *fmtbuff_heap; 
	char *fmtbuff;  
	int fmtbuff_length;
	int length, n;
	va_list ap;
	const char *p;
	unsigned i;
	wchar_t wc;
	char try_wc;

	
	fmtbuff_heap = NULL;
	fmtbuff_length = sizeof(fmtbuff_stack);
	fmtbuff = fmtbuff_stack;

	
	va_start(ap, fmt);
	length = vsnprintf(fmtbuff, fmtbuff_length, fmt, ap);
	va_end(ap);

	
	while (length < 0 || length >= fmtbuff_length) {
		if (length >= fmtbuff_length)
			fmtbuff_length = length+1;
		else if (fmtbuff_length < 8192)
			fmtbuff_length *= 2;
		else if (fmtbuff_length < 1000000)
			fmtbuff_length += fmtbuff_length / 4;
		else {
			length = fmtbuff_length;
			fmtbuff_heap[length-1] = '\0';
			break;
		}
		free(fmtbuff_heap);
		fmtbuff_heap = malloc(fmtbuff_length);

		
		if (fmtbuff_heap != NULL) {
			fmtbuff = fmtbuff_heap;
			va_start(ap, fmt);
			length = vsnprintf(fmtbuff, fmtbuff_length, fmt, ap);
			va_end(ap);
		} else {
			
			length = sizeof(fmtbuff_stack) - 1;
			break;
		}
	}

	
	if (mbtowc(NULL, NULL, 1) == -1) { 
		
		free(fmtbuff_heap);
		return;
	}

	
	p = fmtbuff;
	i = 0;
	try_wc = 1;
	while (*p != '\0') {

		
		if (try_wc && (n = mbtowc(&wc, p, length)) != -1) {
			length -= n;
			if (iswprint(wc) && wc != L'\\') {
				
				while (n-- > 0)
					outbuff[i++] = *p++;
			} else {
				
				while (n-- > 0)
					i += (unsigned)bsdtar_expand_char(
					    outbuff, i, *p++);
			}
		} else {
			
			i += (unsigned)bsdtar_expand_char(outbuff, i, *p++);
			try_wc = 0;
		}

		
		if (i > (sizeof(outbuff) - 128)) {
			outbuff[i] = '\0';
			fprintf(f, ""%s"", outbuff);
			i = 0;
		}
	}
	outbuff[i] = '\0';
	fprintf(f, ""%s"", outbuff);

	
	free(fmtbuff_heap);
}
","1. char *fmtbuff;
int fmtbuff_length;
2. unsigned i;
3. if (length >= fmtbuff_length)
4. else {
5. break;
6. va_start(ap, fmt);
7. } else {
8. break;
9. while (n-- > 0)
10. fprintf(f, ""%s"", outbuff);
i = 0;","10-11
15
31
37
40
48
51
55
84
98-99","CWE-362,CWE-119"
o2nm_node_num_store-24584271378775,"static ssize_t o2nm_node_num_store(struct config_item *item, const char *page,
				   size_t count)
{
	struct o2nm_node *node = to_o2nm_node(item);
	struct o2nm_cluster *cluster;
	unsigned long tmp;
	char *p = (char *)page;
	int ret = 0;

	tmp = simple_strtoul(p, &p, 0);
	if (!p || (*p && (*p != '\n')))
		return -EINVAL;

	if (tmp >= O2NM_MAX_NODES)
		return -ERANGE;

	
	if (!test_bit(O2NM_NODE_ATTR_ADDRESS, &node->nd_set_attributes) ||
	    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))
		return -EINVAL; 

	o2nm_lock_subsystem();
	cluster = to_o2nm_cluster_from_node(node);
	if (!cluster) {
		o2nm_unlock_subsystem();
		return -EINVAL;
	}

	write_lock(&cluster->cl_nodes_lock);
	if (cluster->cl_nodes[tmp])
		ret = -EEXIST;
	else if (test_and_set_bit(O2NM_NODE_ATTR_NUM,
			&node->nd_set_attributes))
		ret = -EBUSY;
	else  {
		cluster->cl_nodes[tmp] = node;
		node->nd_num = tmp;
		set_bit(tmp, cluster->cl_nodes_bitmap);
	}
	write_unlock(&cluster->cl_nodes_lock);
	o2nm_unlock_subsystem();

	if (ret)
		return ret;

	return count;
}
","1. static ssize_t o2nm_node_num_store(struct config_item *item, const char *page,
2. struct o2nm_cluster *cluster;
3. int ret = 0;
4. tmp = simple_strtoul(p, &p, 0);
5. return -ERANGE;
6. if (!test_bit(O2NM_NODE_ATTR_ADDRESS, &node->nd_set_attributes) ||
!test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))
return -EINVAL;
7. cluster = to_o2nm_cluster_from_node(node);
8. write_lock(&cluster->cl_nodes_lock);
9. ret = -EEXIST;
10. &node->nd_set_attributes))
ret = -EBUSY;
11. set_bit(tmp, cluster->cl_nodes_bitmap);
12. write_unlock(&cluster->cl_nodes_lock);
o2nm_unlock_subsystem();
13. return count;","1
5
8
10
15
21-23
26
32
34
36-37
41
43-44
49","CWE-476,CWE-17,CWE-399,CWE-119"
test_request_connection_reset-229952022138178,"static void test_request_connection_reset(connection *con)
{
    con->request.http_method = HTTP_METHOD_UNSET;
    con->request.http_version = HTTP_VERSION_UNSET;
    con->request.http_host = NULL;
    con->request.http_content_type = NULL;
    con->request.http_if_modified_since = NULL;
    con->request.http_if_none_match = NULL;
    con->request.content_length = 0;
    con->header_len = 0;
    con->http_status = 0;
    buffer_reset(con->proto);
    buffer_reset(con->parse_request);
    buffer_reset(con->request.request);
    buffer_reset(con->request.request_line);
    buffer_reset(con->request.orig_uri);
    buffer_reset(con->request.uri);
    array_reset(con->request.headers);
}
","1. static void test_request_connection_reset(connection *con)
2. con->request.http_version = HTTP_VERSION_UNSET;
con->request.http_host = NULL;
3. buffer_reset(con->parse_request);
buffer_reset(con->request.request);","1
4-5
13-14","CWE-119,CWE-770,CWE-189,CWE-416"
memory2-208201483469002,"static void memory2(void) {
	ep2_t a[BENCH];

	BENCH_FEW(""ep2_null"", ep2_null(a[i]), 1);

	BENCH_FEW(""ep2_new"", ep2_new(a[i]), 1);
	for (int i = 0; i < BENCH; i++) {
		ep2_free(a[i]);
	}

	for (int i = 0; i < BENCH; i++) {
		ep2_new(a[i]);
	}
	BENCH_FEW(""ep2_free"", ep2_free(a[i]), 1);

	(void)a;
}
","1. BENCH_FEW(""ep2_null"", ep2_null(a[i]), 1);
2. ep2_free(a[i]);
3. ep2_new(a[i]);
4. BENCH_FEW(""ep2_free"", ep2_free(a[i]), 1);","4
8
12
14","CWE-476,CWE-190"
build_principal_va,"build_principal_va(krb5_context context, krb5_principal princ,
                   unsigned int rlen, const char *realm, va_list ap)
{
    krb5_error_code retval = 0;
    char *r = NULL;
    krb5_data *data = NULL;
    krb5_int32 count = 0;
    krb5_int32 size = 2;  
    char *component = NULL;

     data = malloc(size * sizeof(krb5_data));
     if (!data) { retval = ENOMEM; }
 
    if (!retval)
        r = k5memdup0(realm, rlen, &retval);
 
     while (!retval && (component = va_arg(ap, char *))) {
         if (count == size) {
            krb5_data *new_data = NULL;

            size *= 2;
            new_data = realloc(data, size * sizeof(krb5_data));
            if (new_data) {
                data = new_data;
            } else {
                retval = ENOMEM;
            }
        }

        if (!retval) {
            data[count].length = strlen(component);
            data[count].data = strdup(component);
            if (!data[count].data) { retval = ENOMEM; }
            count++;
        }
    }

    if (!retval) {
        princ->type = KRB5_NT_UNKNOWN;
        princ->magic = KV5M_PRINCIPAL;
        princ->realm = make_data(r, rlen);
        princ->data = data;
        princ->length = count;
        r = NULL;    
        data = NULL; 
    }

    if (data) {
        while (--count >= 0) {
            free(data[count].data);
        }
        free(data);
    }
    free(r);

    return retval;
}
","1. krb5_error_code retval = 0;
char *r = NULL;
krb5_data *data = NULL;
2. if (!data) { retval = ENOMEM; }
3. r = k5memdup0(realm, rlen, &retval);
4. if (count == size) {
5. size *= 2;
new_data = realloc(data, size * sizeof(krb5_data));
if (new_data) {
6. if (!retval) {
data[count].length = strlen(component);
7. if (!data[count].data) { retval = ENOMEM; }
8. princ->type = KRB5_NT_UNKNOWN;
9. princ->realm = make_data(r, rlen);
princ->data = data;
princ->length = count;
10. data = NULL;
11. free(data[count].data);","4-6
12
15
18
21-23
30-31
33
39
41-43
45
50","CWE-200,CWE-20,CWE-125,CWE-399"
WriteTIFFImage_1,"
#define Image
#define ImageInfo

static MagickBooleanType WriteTIFFImage_1(const ImageInfo *image_info,
  Image *image)
{
#if !defined(TIFFDefaultStripSize)
#define TIFFDefaultStripSize(tiff,request)  (8192UL/TIFFScanlineSize(tiff))
#endif

  const char
    *mode,
    *option;

  CompressionType
    compression;

  EndianType
    endian_type;

  MagickBooleanType
    debug,
    status;

  MagickOffsetType
    scene;

  QuantumInfo
    *quantum_info;

  QuantumType
    quantum_type;

  register ssize_t
    i;

  ssize_t
    y;

  TIFF
    *tiff;

  TIFFInfo
    tiff_info;

  uint16
    bits_per_sample,
    compress_tag,
    endian,
    photometric;

  uint32
    rows_per_strip;

  unsigned char
    *pixels;

  
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  assert(image != (Image *) NULL);
  assert(image->signature == MagickSignature);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);
  if (status == MagickFalse)
    return(status);
  (void) SetMagickThreadValue(tiff_exception,&image->exception);
  endian_type=UndefinedEndian;
  option=GetImageOption(image_info,""tiff:endian"");
  if (option != (const char *) NULL)
    {
      if (LocaleNCompare(option,""msb"",3) == 0)
        endian_type=MSBEndian;
      if (LocaleNCompare(option,""lsb"",3) == 0)
        endian_type=LSBEndian;;
    }
  switch (endian_type)
  {
    case LSBEndian: mode=""wl""; break;
    case MSBEndian: mode=""wb""; break;
    default: mode=""w""; break;
  }
#if defined(TIFF_VERSION_BIG)
  if (LocaleCompare(image_info->magick,""TIFF64"") == 0)
    switch (endian_type)
    {
      case LSBEndian: mode=""wl8""; break;
      case MSBEndian: mode=""wb8""; break;
      default: mode=""w8""; break;
    }
#endif
  tiff=TIFFClientOpen(image->filename,mode,(thandle_t) image,TIFFReadBlob,
    TIFFWriteBlob,TIFFSeekBlob,TIFFCloseBlob,TIFFGetBlobSize,TIFFMapBlob,
    TIFFUnmapBlob);
  if (tiff == (TIFF *) NULL)
    return(MagickFalse);
  scene=0;
  debug=IsEventLogging();
  (void) debug;
  do
  {
    
    if ((image_info->type != UndefinedType) &&
        (image_info->type != OptimizeType))
      (void) SetImageType(image,image_info->type);
    compression=UndefinedCompression;
    if (image->compression != JPEGCompression)
      compression=image->compression;
    if (image_info->compression != UndefinedCompression)
      compression=image_info->compression;
    switch (compression)
    {
      case FaxCompression:
      case Group4Compression:
      {
        (void) SetImageType(image,BilevelType);
        (void) SetImageDepth(image,1);
        break;
      }
      case JPEGCompression:
      {
        (void) SetImageStorageClass(image,DirectClass);
        (void) SetImageDepth(image,8);
        break;
      }
      default:
        break;
    }
    quantum_info=AcquireQuantumInfo(image_info,image);
    if (quantum_info == (QuantumInfo *) NULL)
      ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
    if ((image->storage_class != PseudoClass) && (image->depth >= 32) &&
        (quantum_info->format == UndefinedQuantumFormat) &&
        (IsHighDynamicRangeImage(image,&image->exception) != MagickFalse))
      {
        status=SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);
        if (status == MagickFalse)
          ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
      }
    if ((LocaleCompare(image_info->magick,""PTIF"") == 0) &&
        (GetPreviousImageInList(image) != (Image *) NULL))
      (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_REDUCEDIMAGE);
    if ((image->columns != (uint32) image->columns) ||
        (image->rows != (uint32) image->rows))
      ThrowWriterException(ImageError,""WidthOrHeightExceedsLimit"");
    (void) TIFFSetField(tiff,TIFFTAG_IMAGELENGTH,(uint32) image->rows);
    (void) TIFFSetField(tiff,TIFFTAG_IMAGEWIDTH,(uint32) image->columns);
    switch (compression)
    {
      case FaxCompression:
      {
        compress_tag=COMPRESSION_CCITTFAX3;
        SetQuantumMinIsWhite(quantum_info,MagickTrue);
        break;
      }
      case Group4Compression:
      {
        compress_tag=COMPRESSION_CCITTFAX4;
        SetQuantumMinIsWhite(quantum_info,MagickTrue);
        break;
      }
#if defined(COMPRESSION_JBIG)
      case JBIG1Compression:
      {
        compress_tag=COMPRESSION_JBIG;
        break;
      }
#endif
      case JPEGCompression:
      {
        compress_tag=COMPRESSION_JPEG;
        break;
      }
#if defined(COMPRESSION_LZMA)
      case LZMACompression:
      {
        compress_tag=COMPRESSION_LZMA;
        break;
      }
#endif
      case LZWCompression:
      {
        compress_tag=COMPRESSION_LZW;
        break;
      }
      case RLECompression:
      {
        compress_tag=COMPRESSION_PACKBITS;
        break;
      }
      case ZipCompression:
      {
        compress_tag=COMPRESSION_ADOBE_DEFLATE;
        break;
      }
      case NoCompression:
      default:
      {
        compress_tag=COMPRESSION_NONE;
        break;
      }
    }
#if defined(MAGICKCORE_HAVE_TIFFISCODECCONFIGURED) || (TIFFLIB_VERSION > 20040919)
    if ((compress_tag != COMPRESSION_NONE) &&
        (TIFFIsCODECConfigured(compress_tag) == 0))
      {
        (void) ThrowMagickException(&image->exception,GetMagickModule(),
          CoderError,""CompressionNotSupported"",""`%s'"",CommandOptionToMnemonic(
          MagickCompressOptions,(ssize_t) compression));
        compress_tag=COMPRESSION_NONE;
      }
#else
      switch (compress_tag)
      {
#if defined(CCITT_SUPPORT)
        case COMPRESSION_CCITTFAX3:
        case COMPRESSION_CCITTFAX4:
#endif
#if defined(YCBCR_SUPPORT) && defined(JPEG_SUPPORT)
        case COMPRESSION_JPEG:
#endif
#if defined(LZMA_SUPPORT) && defined(COMPRESSION_LZMA)
        case COMPRESSION_LZMA:
#endif
#if defined(LZW_SUPPORT)
        case COMPRESSION_LZW:
#endif
#if defined(PACKBITS_SUPPORT)
        case COMPRESSION_PACKBITS:
#endif
#if defined(ZIP_SUPPORT)
        case COMPRESSION_ADOBE_DEFLATE:
#endif
        case COMPRESSION_NONE:
          break;
        default:
        {
          (void) ThrowMagickException(&image->exception,GetMagickModule(),
            CoderError,""CompressionNotSupported"",""`%s'"",CommandOptionToMnemonic(
              MagickCompressOptions,(ssize_t) compression));
          compress_tag=COMPRESSION_NONE;
          break;
        }
      }
#endif
    if (image->colorspace == CMYKColorspace)
      {
        photometric=PHOTOMETRIC_SEPARATED;
        (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,4);
        (void) TIFFSetField(tiff,TIFFTAG_INKSET,INKSET_CMYK);
      }
    else
      {
        
        if (image->colorspace == LabColorspace)
          {
            photometric=PHOTOMETRIC_CIELAB;
            EncodeLabImage(image,&image->exception);
          }
        else
          if (image->colorspace == YCbCrColorspace)
            {
              photometric=PHOTOMETRIC_YCBCR;
              (void) TIFFSetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,1,1);
              (void) SetImageStorageClass(image,DirectClass);
              (void) SetImageDepth(image,8);
            }
          else
            photometric=PHOTOMETRIC_RGB;
        (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,3);
        if ((image_info->type != TrueColorType) &&
            (image_info->type != TrueColorMatteType))
          {
            if ((image_info->type != PaletteType) &&
                (SetImageGray(image,&image->exception) != MagickFalse))
              {
                photometric=(uint16) (quantum_info->min_is_white !=
                  MagickFalse ? PHOTOMETRIC_MINISWHITE :
                  PHOTOMETRIC_MINISBLACK);
                (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,1);
                if ((image->depth == 1) && (image->matte == MagickFalse))
                  SetImageMonochrome(image,&image->exception);
              }
            else
              if (image->storage_class == PseudoClass)
                {
                  size_t
                    depth;

                  
                  (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,1);
                  photometric=PHOTOMETRIC_PALETTE;
                  depth=1;
                  while ((GetQuantumRange(depth)+1) < image->colors)
                    depth<<=1;
                  status=SetQuantumDepth(image,quantum_info,depth);
                  if (status == MagickFalse)
                    ThrowWriterException(ResourceLimitError,
                      ""MemoryAllocationFailed"");
                }
          }
      }
    (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_FILLORDER,&endian);
    if ((compress_tag == COMPRESSION_CCITTFAX3) &&
        (photometric != PHOTOMETRIC_MINISWHITE))
      {
        compress_tag=COMPRESSION_NONE;
        endian=FILLORDER_MSB2LSB;
      }
    else
      if ((compress_tag == COMPRESSION_CCITTFAX4) &&
         (photometric != PHOTOMETRIC_MINISWHITE))
       {
         compress_tag=COMPRESSION_NONE;
         endian=FILLORDER_MSB2LSB;
       }
    option=GetImageOption(image_info,""tiff:fill-order"");
    if (option != (const char *) NULL)
      {
        if (LocaleNCompare(option,""msb"",3) == 0)
          endian=FILLORDER_MSB2LSB;
        if (LocaleNCompare(option,""lsb"",3) == 0)
          endian=FILLORDER_LSB2MSB;
      }
    (void) TIFFSetField(tiff,TIFFTAG_COMPRESSION,compress_tag);
    (void) TIFFSetField(tiff,TIFFTAG_FILLORDER,endian);
    (void) TIFFSetField(tiff,TIFFTAG_BITSPERSAMPLE,quantum_info->depth);
    if (image->matte != MagickFalse)
      {
        uint16
          extra_samples,
          sample_info[1],
          samples_per_pixel;

        
        extra_samples=1;
        sample_info[0]=EXTRASAMPLE_UNASSALPHA;
        option=GetImageOption(image_info,""tiff:alpha"");
        if (option != (const char *) NULL)
          {
            if (LocaleCompare(option,""associated"") == 0)
              sample_info[0]=EXTRASAMPLE_ASSOCALPHA;
            else
              if (LocaleCompare(option,""unspecified"") == 0)
                sample_info[0]=EXTRASAMPLE_UNSPECIFIED;
          }
        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLESPERPIXEL,
          &samples_per_pixel);
        (void) TIFFSetField(tiff,TIFFTAG_SAMPLESPERPIXEL,samples_per_pixel+1);
        (void) TIFFSetField(tiff,TIFFTAG_EXTRASAMPLES,extra_samples,
          &sample_info);
        if (sample_info[0] == EXTRASAMPLE_ASSOCALPHA)
          SetQuantumAlphaType(quantum_info,AssociatedQuantumAlpha);
      }
    (void) TIFFSetField(tiff,TIFFTAG_PHOTOMETRIC,photometric);
    switch (quantum_info->format)
    {
      case FloatingPointQuantumFormat:
      {
        (void) TIFFSetField(tiff,TIFFTAG_SAMPLEFORMAT,SAMPLEFORMAT_IEEEFP);
        (void) TIFFSetField(tiff,TIFFTAG_SMINSAMPLEVALUE,quantum_info->minimum);
        (void) TIFFSetField(tiff,TIFFTAG_SMAXSAMPLEVALUE,quantum_info->maximum);
        break;
      }
      case SignedQuantumFormat:
      {
        (void) TIFFSetField(tiff,TIFFTAG_SAMPLEFORMAT,SAMPLEFORMAT_INT);
        break;
      }
      case UnsignedQuantumFormat:
      {
        (void) TIFFSetField(tiff,TIFFTAG_SAMPLEFORMAT,SAMPLEFORMAT_UINT);
        break;
      }
      default:
        break;
    }
    (void) TIFFSetField(tiff,TIFFTAG_ORIENTATION,ORIENTATION_TOPLEFT);
    (void) TIFFSetField(tiff,TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);
    if (photometric == PHOTOMETRIC_RGB)
       if ((image_info->interlace == PlaneInterlace) ||
           (image_info->interlace == PartitionInterlace))
         (void) TIFFSetField(tiff,TIFFTAG_PLANARCONFIG,PLANARCONFIG_SEPARATE);
    rows_per_strip=1;
    if (TIFFScanlineSize(tiff) != 0)
      rows_per_strip=TIFFDefaultStripSize(tiff,0);
     option=GetImageOption(image_info,""tiff:rows-per-strip"");
     if (option != (const char *) NULL)
       rows_per_strip=(size_t) strtol(option,(char **) NULL,10);
    switch (compress_tag)
    {
      case COMPRESSION_JPEG:
      {
#if defined(JPEG_SUPPORT)
        const char
          *sampling_factor;

        GeometryInfo
          geometry_info;

        MagickStatusType
          flags;

        rows_per_strip+=(16-(rows_per_strip % 16));
        if (image_info->quality != UndefinedCompressionQuality)
          (void) TIFFSetField(tiff,TIFFTAG_JPEGQUALITY,image_info->quality);
        (void) TIFFSetField(tiff,TIFFTAG_JPEGCOLORMODE,JPEGCOLORMODE_RAW);
        if (IssRGBCompatibleColorspace(image->colorspace) != MagickFalse)
          {
            const char
              *value;

            (void) TIFFSetField(tiff,TIFFTAG_JPEGCOLORMODE,JPEGCOLORMODE_RGB);
            sampling_factor=(const char *) NULL;
            value=GetImageProperty(image,""jpeg:sampling-factor"");
            if (value != (char *) NULL)
              {
                sampling_factor=value;
                if (image->debug != MagickFalse)
                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                    ""  Input sampling-factors=%s"",sampling_factor);
              }
            if (image_info->sampling_factor != (char *) NULL)
              sampling_factor=image_info->sampling_factor;
            if (sampling_factor != (const char *) NULL)
              {
                flags=ParseGeometry(sampling_factor,&geometry_info);
                if ((flags & SigmaValue) == 0)
                  geometry_info.sigma=geometry_info.rho;
                if (image->colorspace == YCbCrColorspace)
                  (void) TIFFSetField(tiff,TIFFTAG_YCBCRSUBSAMPLING,(uint16)
                    geometry_info.rho,(uint16) geometry_info.sigma);
              }
          }
        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,
          &bits_per_sample);
        if (bits_per_sample == 12)
          (void) TIFFSetField(tiff,TIFFTAG_JPEGTABLESMODE,JPEGTABLESMODE_QUANT);
#endif
        break;
      }
      case COMPRESSION_ADOBE_DEFLATE:
      {
        rows_per_strip=(uint32) image->rows;
        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,
          &bits_per_sample);
        if (((photometric == PHOTOMETRIC_RGB) ||
             (photometric == PHOTOMETRIC_MINISBLACK)) &&
            ((bits_per_sample == 8) || (bits_per_sample == 16)))
          (void) TIFFSetField(tiff,TIFFTAG_PREDICTOR,PREDICTOR_HORIZONTAL);
        (void) TIFFSetField(tiff,TIFFTAG_ZIPQUALITY,(long) (
          image_info->quality == UndefinedCompressionQuality ? 7 :
          MagickMin((ssize_t) image_info->quality/10,9)));
        break;
      }
      case COMPRESSION_CCITTFAX3:
      {
        
        rows_per_strip=(uint32) image->rows;
        (void) TIFFSetField(tiff,TIFFTAG_GROUP3OPTIONS,4);
        break;
      }
      case COMPRESSION_CCITTFAX4:
      {
        rows_per_strip=(uint32) image->rows;
        break;
      }
#if defined(LZMA_SUPPORT) && defined(COMPRESSION_LZMA)
      case COMPRESSION_LZMA:
      {
        if (((photometric == PHOTOMETRIC_RGB) ||
             (photometric == PHOTOMETRIC_MINISBLACK)) &&
            ((bits_per_sample == 8) || (bits_per_sample == 16)))
          (void) TIFFSetField(tiff,TIFFTAG_PREDICTOR,PREDICTOR_HORIZONTAL);
        (void) TIFFSetField(tiff,TIFFTAG_LZMAPRESET,(long) (
          image_info->quality == UndefinedCompressionQuality ? 7 :
          MagickMin((ssize_t) image_info->quality/10,9)));
        break;
      }
#endif
      case COMPRESSION_LZW:
      {
        (void) TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,
          &bits_per_sample);
        if (((photometric == PHOTOMETRIC_RGB) ||
             (photometric == PHOTOMETRIC_MINISBLACK)) &&
            ((bits_per_sample == 8) || (bits_per_sample == 16)))
          (void) TIFFSetField(tiff,TIFFTAG_PREDICTOR,PREDICTOR_HORIZONTAL);
        break;
      }
      default:
        break;
    }
    if (rows_per_strip < 1)
      rows_per_strip=1;
    if ((image->rows/rows_per_strip) >= (1UL << 15))
      rows_per_strip=(uint32) (image->rows >> 15);
    (void) TIFFSetField(tiff,TIFFTAG_ROWSPERSTRIP,rows_per_strip);
    if ((image->x_resolution != 0.0) && (image->y_resolution != 0.0))
      {
        unsigned short
          units;

        
        units=RESUNIT_NONE;
        if (image->units == PixelsPerInchResolution)
          units=RESUNIT_INCH;
        if (image->units == PixelsPerCentimeterResolution)
          units=RESUNIT_CENTIMETER;
        (void) TIFFSetField(tiff,TIFFTAG_RESOLUTIONUNIT,(uint16) units);
        (void) TIFFSetField(tiff,TIFFTAG_XRESOLUTION,image->x_resolution);
        (void) TIFFSetField(tiff,TIFFTAG_YRESOLUTION,image->y_resolution);
        if ((image->page.x < 0) || (image->page.y < 0))
          (void) ThrowMagickException(&image->exception,GetMagickModule(),
            CoderError,""TIFF: negative image positions unsupported"",""%s"",
            image->filename);
        if ((image->page.x > 0) && (image->x_resolution > 0.0))
          {
            
            (void) TIFFSetField(tiff,TIFFTAG_XPOSITION,(float) image->page.x/
              image->x_resolution);
          }
        if ((image->page.y > 0) && (image->y_resolution > 0.0))
          {
            
            (void) TIFFSetField(tiff,TIFFTAG_YPOSITION,(float) image->page.y/
              image->y_resolution);
          }
      }
    if (image->chromaticity.white_point.x != 0.0)
      {
        float
          chromaticity[6];

        
        chromaticity[0]=(float) image->chromaticity.red_primary.x;
        chromaticity[1]=(float) image->chromaticity.red_primary.y;
        chromaticity[2]=(float) image->chromaticity.green_primary.x;
        chromaticity[3]=(float) image->chromaticity.green_primary.y;
        chromaticity[4]=(float) image->chromaticity.blue_primary.x;
        chromaticity[5]=(float) image->chromaticity.blue_primary.y;
        (void) TIFFSetField(tiff,TIFFTAG_PRIMARYCHROMATICITIES,chromaticity);
        chromaticity[0]=(float) image->chromaticity.white_point.x;
        chromaticity[1]=(float) image->chromaticity.white_point.y;
        (void) TIFFSetField(tiff,TIFFTAG_WHITEPOINT,chromaticity);
      }
    if ((LocaleCompare(image_info->magick,""PTIF"") != 0) &&
        (image_info->adjoin != MagickFalse) && (GetImageListLength(image) > 1))
      {
        (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_PAGE);
        if (image->scene != 0)
          (void) TIFFSetField(tiff,TIFFTAG_PAGENUMBER,(uint16) image->scene,
            GetImageListLength(image));
      }
    if (image->orientation != UndefinedOrientation)
      (void) TIFFSetField(tiff,TIFFTAG_ORIENTATION,(uint16) image->orientation);
    (void) TIFFSetProfiles(tiff,image);
    {
      uint16
        page,
        pages;

      page=(uint16) scene;
      pages=(uint16) GetImageListLength(image);
      if ((LocaleCompare(image_info->magick,""PTIF"") != 0) &&
          (image_info->adjoin != MagickFalse) && (pages > 1))
        (void) TIFFSetField(tiff,TIFFTAG_SUBFILETYPE,FILETYPE_PAGE);
      (void) TIFFSetField(tiff,TIFFTAG_PAGENUMBER,page,pages);
    }
    (void) TIFFSetProperties(tiff,image_info,image);
DisableMSCWarning(4127)
    if (0)
RestoreMSCWarning
      (void) TIFFSetEXIFProperties(tiff,image);
    
    if (GetTIFFInfo(image_info,tiff,&tiff_info) == MagickFalse)
      ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
    quantum_info->endian=LSBEndian;
    pixels=GetQuantumPixels(quantum_info);
    tiff_info.scanline=GetQuantumPixels(quantum_info);
    switch (photometric)
    {
      case PHOTOMETRIC_CIELAB:
      case PHOTOMETRIC_YCBCR:
      case PHOTOMETRIC_RGB:
      {
        
        switch (image_info->interlace)
        {
          case NoInterlace:
          default:
          {
            quantum_type=RGBQuantum;
            if (image->matte != MagickFalse)
              quantum_type=RGBAQuantum;
            for (y=0; y < (ssize_t) image->rows; y++)
            {
              register const PixelPacket
                *magick_restrict p;

              p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);
              if (p == (const PixelPacket *) NULL)
                break;
              (void) ExportQuantumPixels(image,(const CacheView *) NULL,
                quantum_info,quantum_type,pixels,&image->exception);
              if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)
                break;
              if (image->previous == (Image *) NULL)
                {
                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)
                    y,image->rows);
                  if (status == MagickFalse)
                    break;
                }
            }
            break;
          }
          case PlaneInterlace:
          case PartitionInterlace:
          {
            
            for (y=0; y < (ssize_t) image->rows; y++)
            {
              register const PixelPacket
                *magick_restrict p;

              p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);
              if (p == (const PixelPacket *) NULL)
                break;
              (void) ExportQuantumPixels(image,(const CacheView *) NULL,
                quantum_info,RedQuantum,pixels,&image->exception);
              if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)
                break;
            }
            if (image->previous == (Image *) NULL)
              {
                status=SetImageProgress(image,SaveImageTag,100,400);
                if (status == MagickFalse)
                  break;
              }
            for (y=0; y < (ssize_t) image->rows; y++)
            {
              register const PixelPacket
                *magick_restrict p;

              p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);
              if (p == (const PixelPacket *) NULL)
                break;
              (void) ExportQuantumPixels(image,(const CacheView *) NULL,
                quantum_info,GreenQuantum,pixels,&image->exception);
              if (TIFFWritePixels(tiff,&tiff_info,y,1,image) == -1)
                break;
            }
            if (image->previous == (Image *) NULL)
              {
                status=SetImageProgress(image,SaveImageTag,200,400);
                if (status == MagickFalse)
                  break;
              }
            for (y=0; y < (ssize_t) image->rows; y++)
            {
              register const PixelPacket
                *magick_restrict p;

              p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);
              if (p == (const PixelPacket *) NULL)
                break;
              (void) ExportQuantumPixels(image,(const CacheView *) NULL,
                quantum_info,BlueQuantum,pixels,&image->exception);
              if (TIFFWritePixels(tiff,&tiff_info,y,2,image) == -1)
                break;
            }
            if (image->previous == (Image *) NULL)
              {
                status=SetImageProgress(image,SaveImageTag,300,400);
                if (status == MagickFalse)
                  break;
              }
            if (image->matte != MagickFalse)
              for (y=0; y < (ssize_t) image->rows; y++)
              {
                register const PixelPacket
                  *magick_restrict p;

                p=GetVirtualPixels(image,0,y,image->columns,1,
                  &image->exception);
                if (p == (const PixelPacket *) NULL)
                  break;
                (void) ExportQuantumPixels(image,(const CacheView *) NULL,
                  quantum_info,AlphaQuantum,pixels,&image->exception);
                if (TIFFWritePixels(tiff,&tiff_info,y,3,image) == -1)
                  break;
              }
            if (image->previous == (Image *) NULL)
              {
                status=SetImageProgress(image,SaveImageTag,400,400);
                if (status == MagickFalse)
                  break;
              }
            break;
          }
        }
        break;
      }
      case PHOTOMETRIC_SEPARATED:
      {
        
        quantum_type=CMYKQuantum;
        if (image->matte != MagickFalse)
          quantum_type=CMYKAQuantum;
        if (image->colorspace != CMYKColorspace)
          (void) TransformImageColorspace(image,CMYKColorspace);
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          register const PixelPacket
            *magick_restrict p;

          p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);
          if (p == (const PixelPacket *) NULL)
            break;
          (void) ExportQuantumPixels(image,(const CacheView *) NULL,
            quantum_info,quantum_type,pixels,&image->exception);
          if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        break;
      }
      case PHOTOMETRIC_PALETTE:
      {
        uint16
          *blue,
          *green,
          *red;

        
        red=(uint16 *) AcquireQuantumMemory(65536,sizeof(*red));
        green=(uint16 *) AcquireQuantumMemory(65536,sizeof(*green));
        blue=(uint16 *) AcquireQuantumMemory(65536,sizeof(*blue));
        if ((red == (uint16 *) NULL) || (green == (uint16 *) NULL) ||
            (blue == (uint16 *) NULL))
          ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
        
        (void) ResetMagickMemory(red,0,65536*sizeof(*red));
        (void) ResetMagickMemory(green,0,65536*sizeof(*green));
        (void) ResetMagickMemory(blue,0,65536*sizeof(*blue));
        for (i=0; i < (ssize_t) image->colors; i++)
        {
          red[i]=ScaleQuantumToShort(image->colormap[i].red);
          green[i]=ScaleQuantumToShort(image->colormap[i].green);
          blue[i]=ScaleQuantumToShort(image->colormap[i].blue);
        }
        (void) TIFFSetField(tiff,TIFFTAG_COLORMAP,red,green,blue);
        red=(uint16 *) RelinquishMagickMemory(red);
        green=(uint16 *) RelinquishMagickMemory(green);
        blue=(uint16 *) RelinquishMagickMemory(blue);
      }
      default:
      {
        
        quantum_type=IndexQuantum;
        if (image->matte != MagickFalse)
          {
            if (photometric != PHOTOMETRIC_PALETTE)
              quantum_type=GrayAlphaQuantum;
            else
              quantum_type=IndexAlphaQuantum;
           }
         else
           if (photometric != PHOTOMETRIC_PALETTE)
             quantum_type=GrayQuantum;
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          register const PixelPacket
            *magick_restrict p;

          p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);
          if (p == (const PixelPacket *) NULL)
            break;
          (void) ExportQuantumPixels(image,(const CacheView *) NULL,
            quantum_info,quantum_type,pixels,&image->exception);
          if (TIFFWritePixels(tiff,&tiff_info,y,0,image) == -1)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
        break;
      }
    }
    quantum_info=DestroyQuantumInfo(quantum_info);
    if (image->colorspace == LabColorspace)
      DecodeLabImage(image,&image->exception);
    DestroyTIFFInfo(&tiff_info);
DisableMSCWarning(4127)
    if (0 && (image_info->verbose != MagickFalse))
RestoreMSCWarning
      TIFFPrintDirectory(tiff,stdout,MagickFalse);
    (void) TIFFWriteDirectory(tiff);
    image=SyncNextImageInList(image);
    if (image == (Image *) NULL)
      break;
    status=SetImageProgress(image,SaveImagesTag,scene++,
      GetImageListLength(image));
    if (status == MagickFalse)
      break;
  } while (image_info->adjoin != MagickFalse);
  TIFFClose(tiff);
  return(MagickTrue);
}
","1. *quantum_info;
2. endian,
3. if ((LocaleCompare(image_info->magick,""PTIF"") == 0) &&
4. (void) TIFFSetField(tiff,TIFFTAG_IMAGEWIDTH,(uint32) image->columns);
5. case RLECompression:
6. break;
7. ThrowWriterException(ResourceLimitError,
8. endian=FILLORDER_MSB2LSB;
9. endian=FILLORDER_LSB2MSB;
10. sample_info[1],
11. (void) TIFFSetField(tiff,TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);
12. (image_info->interlace == PartitionInterlace))
13. rows_per_strip=(size_t) strtol(option,(char **) NULL,10);
14. case COMPRESSION_LZW:
15. &bits_per_sample);
16. quantum_info->endian=LSBEndian;
17. if (image->matte != MagickFalse)
18. if (image->previous == (Image *) NULL)
19. if (TIFFWritePixels(tiff,&tiff_info,y,1,image) == -1)
20. if (TIFFWritePixels(tiff,&tiff_info,y,2,image) == -1)
21. status=SetImageProgress(image,SaveImageTag,400,400);
22. break;
23. for (i=0; i < (ssize_t) image->colors; i++)
24. *magick_restrict p;
25. (void) ExportQuantumPixels(image,(const CacheView *) NULL,
26. } while (image_info->adjoin != MagickFalse);","30
50
146
153
192
206
308
325
333
342
391
394
401
495
498
602
620
663
679
698
724
754
787
817
822
853","CWE-772,CWE-125,CWE-119"
read_png_1,"read_png_1(struct control *control)
 

 {
    png_structp png_ptr;
    png_infop info_ptr = NULL;
    volatile int rc;
 
    png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, control,
      error_handler, warning_handler);

 if (png_ptr == NULL)
 {
 
      log_error(&control->file, LIBPNG_ERROR_CODE, ""OOM allocating png_struct"");
      control->file.status_code |= INTERNAL_ERROR;
 return LIBPNG_ERROR_CODE;
 }


    rc = setjmp(control->file.jmpbuf);
    if (rc == 0)
    {
#     ifdef PNG_SET_USER_LIMITS_SUPPORTED
         
         png_set_user_limits(png_ptr, 0x7fffffff, 0x7fffffff);
         png_set_chunk_cache_max(png_ptr, 0);
         png_set_chunk_malloc_max(png_ptr, 0);
#     endif

       png_set_read_fn(png_ptr, control, read_callback);
 
       info_ptr = png_create_info_struct(png_ptr);
 if (info_ptr == NULL)
         png_error(png_ptr, ""OOM allocating info structure"");

 if (control->file.global->verbose)
         fprintf(stderr, "" INFO\n"");


       png_read_info(png_ptr, info_ptr);
 
       {
        png_uint_32 height = png_get_image_height(png_ptr, info_ptr);
        int passes = png_set_interlace_handling(png_ptr);
        int pass;
 
        png_start_read_image(png_ptr);
 
        for (pass = 0; pass < passes; ++pass)
        {
           png_uint_32 y = height;
 
           
           while (y-- > 0)
              png_read_row(png_ptr, NULL, NULL);
        }
       }
 
       if (control->file.global->verbose)
         fprintf(stderr, "" END\n"");

 
      png_read_end(png_ptr, info_ptr);

    }
 
    png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
    return rc;
 }
","1. png_set_read_fn(png_ptr, control, read_callback);
2. int pass;
3. while (y-- > 0)","36
51
62","CWE-20,CWE-787,CWE-400"
entries-179614999321602,"
#define RBinFile

static RList* entries(RBinFile* bf) {
	RList* ret = NULL;
	RBinAddr* addr = NULL;
	psxexe_header psxheader;

	if (!(ret = r_list_new ())) {
		return NULL;
	}

	if (!(addr = R_NEW0 (RBinAddr))) {
		r_list_free (ret);
		return NULL;
	}

	if (r_buf_fread_at (bf->buf, 0, (ut8*)&psxheader, ""8c17i"", 1) != sizeof (psxexe_header)) {
		eprintf (""PSXEXE Header truncated\n"");
		r_list_free (ret);
		free (addr);
		return NULL;
	}

	addr->paddr = (psxheader.pc0 - psxheader.t_addr) + PSXEXE_TEXTSECTION_OFFSET;
	addr->vaddr = psxheader.pc0;

	r_list_append (ret, addr);
	return ret;
}
","1. static RList* entries(RBinFile* bf) {
RList* ret = NULL;
2. if (!(ret = r_list_new ())) {
return NULL;
3. if (!(addr = R_NEW0 (RBinAddr))) {
r_list_free (ret);
return NULL;
4. eprintf (""PSXEXE Header truncated\n"");
r_list_free (ret);
5. addr->paddr = (psxheader.pc0 - psxheader.t_addr) + PSXEXE_TEXTSECTION_OFFSET;
addr->vaddr = psxheader.pc0;
6. r_list_append (ret, addr);
return ret;","4-5
9-10
13-15
19-20
25-26
28-29","CWE-362,CWE-862,CWE-399,CWE-400"
DetachBlob_1,"
#define BlobInfo

MagickExport void *DetachBlob_1(BlobInfo *blob_info)
{
  void
    *data;

  assert(blob_info != (BlobInfo *) NULL);
  if (blob_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""..."");
   if (blob_info->mapped != MagickFalse)
     {
       (void) UnmapBlob(blob_info->data,blob_info->length);
      blob_info->data=NULL;
       RelinquishMagickResource(MapResource,blob_info->length);
     }
   blob_info->mapped=MagickFalse;
  blob_info->length=0;
  blob_info->offset=0;
  blob_info->eof=MagickFalse;
  blob_info->error=0;
  blob_info->exempt=MagickFalse;
  blob_info->type=UndefinedStream;
  blob_info->file_info.file=(FILE *) NULL;
  data=blob_info->data;
  blob_info->data=(unsigned char *) NULL;
  blob_info->stream=(StreamHandler) NULL;
  blob_info->custom_stream=(CustomStreamInfo *) NULL;
  return(data);
}
","1. (void) UnmapBlob(blob_info->data,blob_info->length);
2. blob_info->error=0;
blob_info->exempt=MagickFalse;
3. blob_info->data=(unsigned char *) NULL;
blob_info->stream=(StreamHandler) NULL;","14
22-23
27-28","CWE-119,CWE-125,CWE-787,CWE-416"
DecodeIPV6ExtHdrs,"
#define DecodeThreadVars
#define Packet
#define PacketQueue
#define ThreadVars

DecodeIPV6ExtHdrs(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p, uint8_t *pkt, uint16_t len, PacketQueue *pq)
{
     SCEnter();
 
     uint8_t *orig_pkt = pkt;
    uint8_t nh = IPV6_GET_NH(p); 
     uint16_t hdrextlen = 0;
    uint16_t plen = len;
     char dstopts = 0;
     char exthdr_fh_done = 0;
     int hh = 0;
     int rh = 0;
     int eh = 0;
     int ah = 0;
 
     while(1)
     {
        if (nh == IPPROTO_NONE) {
            if (plen > 0) {
                
                ENGINE_SET_EVENT(p, IPV6_DATA_AFTER_NONE_HEADER);
            }
             SCReturn;
         }
 
         if (plen < 2) { 
            ENGINE_SET_INVALID_EVENT(p, IPV6_TRUNC_EXTHDR);
             SCReturn;
         }
 
        switch(nh)
        {
            case IPPROTO_TCP:
                IPV6_SET_L4PROTO(p,nh);
                DecodeTCP(tv, dtv, p, pkt, plen, pq);
                SCReturn;

            case IPPROTO_UDP:
                IPV6_SET_L4PROTO(p,nh);
                DecodeUDP(tv, dtv, p, pkt, plen, pq);
                SCReturn;

            case IPPROTO_ICMPV6:
                IPV6_SET_L4PROTO(p,nh);
                DecodeICMPV6(tv, dtv, p, pkt, plen, pq);
                SCReturn;

            case IPPROTO_SCTP:
                IPV6_SET_L4PROTO(p,nh);
                DecodeSCTP(tv, dtv, p, pkt, plen, pq);
                SCReturn;

            case IPPROTO_ROUTING:
                IPV6_SET_L4PROTO(p,nh);
                hdrextlen = 8 + (*(pkt+1) * 8);  

                 SCLogDebug(""hdrextlen %""PRIu8, hdrextlen);
 
                 if (hdrextlen > plen) {
                    ENGINE_SET_INVALID_EVENT(p, IPV6_TRUNC_EXTHDR);
                     SCReturn;
                 }
 
                if (rh) {
                    ENGINE_SET_EVENT(p, IPV6_EXTHDR_DUPL_RH);
                    
                    nh = *pkt;
                    pkt += hdrextlen;
                    plen -= hdrextlen;
                    break;
                }

                rh = 1;
                IPV6_EXTHDR_SET_RH(p);

                uint8_t ip6rh_type = *(pkt + 2);
                if (ip6rh_type == 0) {
                    ENGINE_SET_EVENT(p, IPV6_EXTHDR_RH_TYPE_0);
                }
                p->ip6eh.rh_type = ip6rh_type;

                nh = *pkt;
                pkt += hdrextlen;
                plen -= hdrextlen;
                break;

            case IPPROTO_HOPOPTS:
            case IPPROTO_DSTOPTS:
            {
                IPV6OptHAO hao_s, *hao = &hao_s;
                IPV6OptRA ra_s, *ra = &ra_s;
                IPV6OptJumbo jumbo_s, *jumbo = &jumbo_s;
                uint16_t optslen = 0;

                 IPV6_SET_L4PROTO(p,nh);
                 hdrextlen =  (*(pkt+1) + 1) << 3;
                 if (hdrextlen > plen) {
                    ENGINE_SET_INVALID_EVENT(p, IPV6_TRUNC_EXTHDR);
                     SCReturn;
                 }
 
                uint8_t *ptr = pkt + 2; 

                
                if (nh == IPPROTO_HOPOPTS) {
                    if (hh) {
                        ENGINE_SET_EVENT(p, IPV6_EXTHDR_DUPL_HH);
                        
                        nh = *pkt;
                        pkt += hdrextlen;
                        plen -= hdrextlen;
                        break;
                    }

                    hh = 1;

                    optslen = ((*(pkt + 1) + 1 ) << 3) - 2;
                }
                else if (nh == IPPROTO_DSTOPTS)
                {
                    if (dstopts == 0) {
                        optslen = ((*(pkt + 1) + 1 ) << 3) - 2;
                        dstopts = 1;
                    } else if (dstopts == 1) {
                        optslen = ((*(pkt + 1) + 1 ) << 3) - 2;
                        dstopts = 2;
                    } else {
                        ENGINE_SET_EVENT(p, IPV6_EXTHDR_DUPL_DH);
                        
                        nh = *pkt;
                        pkt += hdrextlen;
                        plen -= hdrextlen;
                        break;
                    }
                }

                 if (optslen > plen) {
                     
                    ENGINE_SET_INVALID_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);
                     
                     nh = *pkt;
                    pkt += hdrextlen;
                    plen -= hdrextlen;
                    break;
                }

                uint16_t padn_cnt = 0;
                uint16_t other_cnt = 0;
                uint16_t offset = 0;
                while(offset < optslen)
                {
                    if (*ptr == IPV6OPT_PAD1)
                    {
                        padn_cnt++;
                        offset++;
                        ptr++;
                        continue;
                     }
 
                     if (offset + 1 >= optslen) {
                        ENGINE_SET_INVALID_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);
                         break;
                     }
 
                    
                    uint8_t ip6_optlen = *(ptr + 1);
 
                     
                     if ((offset + 1 + ip6_optlen) > optslen) {
                        ENGINE_SET_INVALID_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);
                         break;
                     }
 
                    if (*ptr == IPV6OPT_PADN) 
                    {
                        padn_cnt++;

                        
                        if (ip6_optlen == 0)
                            ENGINE_SET_EVENT(p, IPV6_EXTHDR_ZERO_LEN_PADN);
                    }
                    else if (*ptr == IPV6OPT_RA) 
                    {
                        ra->ip6ra_type = *(ptr);
                         ra->ip6ra_len  = ip6_optlen;
 
                         if (ip6_optlen < sizeof(ra->ip6ra_value)) {
                            ENGINE_SET_INVALID_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);
                             break;
                         }
 
                        memcpy(&ra->ip6ra_value, (ptr + 2), sizeof(ra->ip6ra_value));
                        ra->ip6ra_value = SCNtohs(ra->ip6ra_value);
                        other_cnt++;
                    }
                    else if (*ptr == IPV6OPT_JUMBO) 
                    {
                        jumbo->ip6j_type = *(ptr);
                         jumbo->ip6j_len  = ip6_optlen;
 
                         if (ip6_optlen < sizeof(jumbo->ip6j_payload_len)) {
                            ENGINE_SET_INVALID_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);
                             break;
                         }
 
                        memcpy(&jumbo->ip6j_payload_len, (ptr+2), sizeof(jumbo->ip6j_payload_len));
                        jumbo->ip6j_payload_len = SCNtohl(jumbo->ip6j_payload_len);
                    }
                    else if (*ptr == IPV6OPT_HAO) 
                    {
                        hao->ip6hao_type = *(ptr);
                         hao->ip6hao_len  = ip6_optlen;
 
                         if (ip6_optlen < sizeof(hao->ip6hao_hoa)) {
                            ENGINE_SET_INVALID_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);
                             break;
                         }
 
                        memcpy(&hao->ip6hao_hoa, (ptr+2), sizeof(hao->ip6hao_hoa));
                        other_cnt++;
                    } else {
                        if (nh == IPPROTO_HOPOPTS)
                            ENGINE_SET_EVENT(p, IPV6_HOPOPTS_UNKNOWN_OPT);
                        else
                            ENGINE_SET_EVENT(p, IPV6_DSTOPTS_UNKNOWN_OPT);

                        other_cnt++;
                    }
                    uint16_t optlen = (*(ptr + 1) + 2);
                    ptr += optlen; 
                    offset += optlen;
                }
                
                if (padn_cnt > 0 && other_cnt == 0) {
                    if (nh == IPPROTO_HOPOPTS)
                        ENGINE_SET_EVENT(p, IPV6_HOPOPTS_ONLY_PADDING);
                    else
                        ENGINE_SET_EVENT(p, IPV6_DSTOPTS_ONLY_PADDING);
                }

                nh = *pkt;
                pkt += hdrextlen;
                plen -= hdrextlen;
                break;
            }

            case IPPROTO_FRAGMENT:
            {
                IPV6_SET_L4PROTO(p,nh);
                
                if (exthdr_fh_done == 0) {
                    p->ip6eh.fh_offset = pkt - orig_pkt;
                    exthdr_fh_done = 1;
                }

                 uint16_t prev_hdrextlen = hdrextlen;
                 hdrextlen = sizeof(IPV6FragHdr);
                 if (hdrextlen > plen) {
                    ENGINE_SET_INVALID_EVENT(p, IPV6_TRUNC_EXTHDR);
                     SCReturn;
                 }
 
                
                if (*(pkt + 1) != 0) {
                    ENGINE_SET_EVENT(p, IPV6_FH_NON_ZERO_RES_FIELD);
                    
                }

                if (IPV6_EXTHDR_ISSET_FH(p)) {
                    ENGINE_SET_EVENT(p, IPV6_EXTHDR_DUPL_FH);
                    nh = *pkt;
                    pkt += hdrextlen;
                    plen -= hdrextlen;
                    break;
                }

                
                IPV6_EXTHDR_SET_FH(p);

                
                DecodeIPV6FragHeader(p, pkt, hdrextlen, plen, prev_hdrextlen);

                
                if (p->ip6eh.fh_more_frags_set == 0 && p->ip6eh.fh_offset == 0) {
                    ENGINE_SET_EVENT(p, IPV6_EXTHDR_USELESS_FH);

                    nh = *pkt;
                    pkt += hdrextlen;
                    plen -= hdrextlen;
                    break;
                }

                
                p->flags |= PKT_IS_FRAGMENT;
                SCReturn;
            }
            case IPPROTO_ESP:
            {
                 IPV6_SET_L4PROTO(p,nh);
                 hdrextlen = sizeof(IPV6EspHdr);
                 if (hdrextlen > plen) {
                    ENGINE_SET_INVALID_EVENT(p, IPV6_TRUNC_EXTHDR);
                     SCReturn;
                 }
 
                if (eh) {
                    ENGINE_SET_EVENT(p, IPV6_EXTHDR_DUPL_EH);
                    SCReturn;
                }

                eh = 1;

                nh = IPPROTO_NONE;
                pkt += hdrextlen;
                plen -= hdrextlen;
                break;
            }
            case IPPROTO_AH:
            {
                IPV6_SET_L4PROTO(p,nh);
                
                hdrextlen = sizeof(IPV6AuthHdr);
                
                if (*(pkt+1) > 0)
                    hdrextlen += ((*(pkt+1) - 1) * 4);

                 SCLogDebug(""hdrextlen %""PRIu8, hdrextlen);
 
                 if (hdrextlen > plen) {
                    ENGINE_SET_INVALID_EVENT(p, IPV6_TRUNC_EXTHDR);
                     SCReturn;
                 }
 
                IPV6AuthHdr *ahhdr = (IPV6AuthHdr *)pkt;
                if (ahhdr->ip6ah_reserved != 0x0000) {
                    ENGINE_SET_EVENT(p, IPV6_EXTHDR_AH_RES_NOT_NULL);
                }

                if (ah) {
                    ENGINE_SET_EVENT(p, IPV6_EXTHDR_DUPL_AH);
                    nh = *pkt;
                    pkt += hdrextlen;
                    plen -= hdrextlen;
                    break;
                }

                ah = 1;

                nh = *pkt;
                pkt += hdrextlen;
                plen -= hdrextlen;
                break;
            }
            case IPPROTO_IPIP:
                IPV6_SET_L4PROTO(p,nh);
                DecodeIPv4inIPv6(tv, dtv, p, pkt, plen, pq);
                SCReturn;
            
            case IPPROTO_NONE:
                IPV6_SET_L4PROTO(p,nh);
                SCReturn;
            case IPPROTO_ICMP:
                ENGINE_SET_EVENT(p,IPV6_WITH_ICMPV4);
                SCReturn;
            
            case IPPROTO_MH:
            case IPPROTO_HIP:
             case IPPROTO_SHIM6:
                 hdrextlen = 8 + (*(pkt+1) * 8);  
                 if (hdrextlen > plen) {
                    ENGINE_SET_INVALID_EVENT(p, IPV6_TRUNC_EXTHDR);
                     SCReturn;
                 }
                 nh = *pkt;
                pkt += hdrextlen;
                plen -= hdrextlen;
                break;
            default:
                ENGINE_SET_EVENT(p, IPV6_UNKNOWN_NEXT_HEADER);
                IPV6_SET_L4PROTO(p,nh);
                SCReturn;
        }
    }

    SCReturn;
}
","1. uint8_t *orig_pkt = pkt;
2. uint16_t plen = len;
char dstopts = 0;
char exthdr_fh_done = 0;
3. SCReturn;
4. case IPPROTO_TCP:
5. DecodeICMPV6(tv, dtv, p, pkt, plen, pq);
6. nh = *pkt;
7. plen -= hdrextlen;
8. SCReturn;
9. if (nh == IPPROTO_HOPOPTS) {
10. pkt += hdrextlen;
11. hh = 1;
12. else if (nh == IPPROTO_DSTOPTS)
13. if (dstopts == 0) {
14. dstopts = 1;
15. nh = *pkt;
16. ENGINE_SET_INVALID_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);
17. uint16_t offset = 0;
while(offset < optslen)
18. padn_cnt++;
19. if (offset + 1 >= optslen) {
20. break;
21. ra->ip6ra_len  = ip6_optlen;
22. memcpy(&ra->ip6ra_value, (ptr + 2), sizeof(ra->ip6ra_value));
23. jumbo->ip6j_type = *(ptr);
24. break;
25. jumbo->ip6j_payload_len = SCNtohl(jumbo->ip6j_payload_len);
26. hao->ip6hao_len  = ip6_optlen;
27. offset += optlen;
28. p->ip6eh.fh_offset = pkt - orig_pkt;
29. uint16_t prev_hdrextlen = hdrextlen;
hdrextlen = sizeof(IPV6FragHdr);
30. ENGINE_SET_EVENT(p, IPV6_FH_NON_ZERO_RES_FIELD);
31. ENGINE_SET_EVENT(p, IPV6_EXTHDR_DUPL_FH);
32. pkt += hdrextlen;
33. break;
34. if (*(pkt+1) > 0)
35. if (hdrextlen > plen) {
36. break;
37. pkt += hdrextlen;
38. SCReturn;
39. case IPPROTO_HIP:
case IPPROTO_SHIM6:
hdrextlen = 8 + (*(pkt+1) * 8);","11
14-16
29
39
51
74
91
106
113
119
124
128
130
132
140
150
161-162
166
172
174
197
204
210
215
219
224
243
266
270-271
279
284
286
333
342
347
362
368
379
385-387","CWE-362,CWE-1284,CWE-125,CWE-787"
ReadMATImage_3,"
#define ExceptionInfo
#define ImageInfo

static Image *ReadMATImage_3(const ImageInfo *image_info,ExceptionInfo *exception)
{
  Image *image, *image2=NULL,
   *rotated_image;
  PixelPacket *q;

  unsigned int status;
  MATHeader MATLAB_HDR;
  size_t size;
  size_t CellType;
  QuantumInfo *quantum_info;
  ImageInfo *clone_info;
  int i;
  ssize_t ldblk;
  unsigned char *BImgBuff = NULL;
  double MinVal, MaxVal;
  size_t Unknown6;
  unsigned z, z2;
  unsigned Frames;
  int logging;
  int sample_size;
  MagickOffsetType filepos=0x80;
  BlobInfo *blob;
  size_t one;

  unsigned int (*ReadBlobXXXLong)(Image *image);
  unsigned short (*ReadBlobXXXShort)(Image *image);
  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);
  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);


  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickSignature);
  logging = LogMagickEvent(CoderEvent,GetMagickModule(),""enter"");

  
  image = AcquireImage(image_info);

  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  
  clone_info=CloneImageInfo(image_info);
  if(ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  MATLAB_HDR.Version = ReadBlobLSBShort(image);
  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");

  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),""  Endian %c%c"",
        MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);
  if (!strncmp(MATLAB_HDR.EndianIndicator, ""IM"", 2))
  {
    ReadBlobXXXLong = ReadBlobLSBLong;
    ReadBlobXXXShort = ReadBlobLSBShort;
    ReadBlobDoublesXXX = ReadBlobDoublesLSB;
    ReadBlobFloatsXXX = ReadBlobFloatsLSB;
    image->endian = LSBEndian;
  }
  else if (!strncmp(MATLAB_HDR.EndianIndicator, ""MI"", 2))
  {
    ReadBlobXXXLong = ReadBlobMSBLong;
    ReadBlobXXXShort = ReadBlobMSBShort;
    ReadBlobDoublesXXX = ReadBlobDoublesMSB;
    ReadBlobFloatsXXX = ReadBlobFloatsMSB;
    image->endian = MSBEndian;
  }
  else
    goto MATLAB_KO;    

  if (strncmp(MATLAB_HDR.identific, ""MATLAB"", 6))
MATLAB_KO: ThrowReaderException(CorruptImageError,""ImproperImageHeader"");

  filepos = TellBlob(image);
  while(!EOFBlob(image)) 
  {
    Frames = 1;
    (void) SeekBlob(image,filepos,SEEK_SET);
    

    MATLAB_HDR.DataType = ReadBlobXXXLong(image);
    if(EOFBlob(image)) break;
    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);
    if(EOFBlob(image)) break;
    filepos += MATLAB_HDR.ObjectSize + 4 + 4;

    image2 = image;
#if defined(MAGICKCORE_ZLIB_DELEGATE)
    if(MATLAB_HDR.DataType == miCOMPRESSED)
    {
      image2 = DecompressBlock(image,MATLAB_HDR.ObjectSize,clone_info,exception);
      if(image2==NULL) continue;
      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); 
    }
#endif

    if(MATLAB_HDR.DataType!=miMATRIX) continue;  

    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);
    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);

    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);
    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;
    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;

    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);
    if(image!=image2)
      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  
    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);
    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);
    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);
    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);


    switch(MATLAB_HDR.DimFlag)
    {
      case  8: z2=z=1; break;      
      case 12: z2=z = ReadBlobXXXLong(image2);  
           Unknown6 = ReadBlobXXXLong(image2);
           (void) Unknown6;
         if(z!=3) ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
         break;
      case 16: z2=z = ReadBlobXXXLong(image2);  
         if(z!=3 && z!=1)
           ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
          Frames = ReadBlobXXXLong(image2);
         break;
      default: ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
    }

    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);
    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);

    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
          ""MATLAB_HDR.StructureClass %d"",MATLAB_HDR.StructureClass);
    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&
        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    
        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    
        MATLAB_HDR.StructureClass != mxINT8_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    
        MATLAB_HDR.StructureClass != mxINT16_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    
        MATLAB_HDR.StructureClass != mxINT32_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    
        MATLAB_HDR.StructureClass != mxINT64_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    
      ThrowReaderException(CoderError,""UnsupportedCellTypeInTheMatrix"");

    switch (MATLAB_HDR.NameFlag)
    {
      case 0:
        size = ReadBlobXXXLong(image2);  
        size = 4 * (ssize_t) ((size + 3 + 1) / 4);
        (void) SeekBlob(image2, size, SEEK_CUR);
        break;
      case 1:
      case 2:
      case 3:
      case 4:
        (void) ReadBlob(image2, 4, (unsigned char *) &size); 
        break;
      default:
        goto MATLAB_KO;
    }

    CellType = ReadBlobXXXLong(image2);    
    if (logging)
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""MATLAB_HDR.CellType: %.20g"",(double) CellType);

    (void) ReadBlob(image2, 4, (unsigned char *) &size);     

NEXT_FRAME:
    switch (CellType)
    {
      case miINT8:
      case miUINT8:
        sample_size = 8;
        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)
          image->depth = 1;
        else
          image->depth = 8;         
        ldblk = (ssize_t) MATLAB_HDR.SizeX;
        break;
      case miINT16:
      case miUINT16:
        sample_size = 16;
        image->depth = 16;        
        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);
        break;
      case miINT32:
      case miUINT32:
        sample_size = 32;
        image->depth = 32;        
        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
        break;
      case miINT64:
      case miUINT64:
        sample_size = 64;
        image->depth = 64;        
        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
        break;
      case miSINGLE:
        sample_size = 32;
        image->depth = 32;        
        (void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
  {              
  }
        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
        break;
      case miDOUBLE:
        sample_size = 64;
        image->depth = 64;        
        (void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
DisableMSCWarning(4127)
        if (sizeof(double) != 8)
RestoreMSCWarning
          ThrowReaderException(CoderError, ""IncompatibleSizeOfDouble"");
        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
  {                         
  }
        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
        break;
      default:
        ThrowReaderException(CoderError, ""UnsupportedCellTypeInTheMatrix"");
    }
    (void) sample_size;
    image->columns = MATLAB_HDR.SizeX;
    image->rows = MATLAB_HDR.SizeY;
    quantum_info=AcquireQuantumInfo(clone_info,image);
    if (quantum_info == (QuantumInfo *) NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    one=1;
    image->colors = one << image->depth;
    if (image->columns == 0 || image->rows == 0)
      goto MATLAB_KO;
      
    if ((MATLAB_HDR.DimFlag == 8) &&
        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
      {
        SetImageColorspace(image,GRAYColorspace);
        image->type=GrayscaleType;
      }


    
    if (image_info->ping)
    {
      size_t temp = image->columns;
      image->columns = image->rows;
       image->rows = temp;
       goto done_reading; 
     }
    status=SetImageExtent(image,image->columns,image->rows);
    if (status == MagickFalse)
      {
        InheritException(exception,&image->exception);
        return(DestroyImageList(image));
      }
 
   
     BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(unsigned char));    
    if (BImgBuff == NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");

    MinVal = 0;
    MaxVal = 0;
    if (CellType==miDOUBLE || CellType==miSINGLE)        
    {
      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);
    }

    
    if(z==1) z=0; 
    
    do
    {
      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
      {
        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);
        if (q == (PixelPacket *) NULL)
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  MAT set image pixels returns unexpected NULL on a row %u."", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto done_reading;    
  }
        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
             ""  MAT cannot read scanrow %u from a file."", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto ExitLoop;
  }
        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))
        {
          FixLogical((unsigned char *)BImgBuff,ldblk);
          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
    {
ImportQuantumPixelsFailed:
      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  MAT failed to ImportQuantumPixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
      break;
    }
        }
        else
        {
          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
      goto ImportQuantumPixelsFailed;


          if (z<=1 &&       
          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))
      FixSignedValues(q,MATLAB_HDR.SizeX);
        }

        if (!SyncAuthenticPixels(image,exception))
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
            ""  MAT failed to sync image pixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto ExitLoop;
  }
      }
    } while(z-- >= 2);
ExitLoop:


    
    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
    {        
      CellType = ReadBlobXXXLong(image2);    
      i = ReadBlobXXXLong(image2);           

      if (CellType==miDOUBLE || CellType==miSINGLE)
      {
        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);
      }

      if (CellType==miDOUBLE)
        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
  {
          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);
          InsertComplexDoubleRow((double *)BImgBuff, i, image, MinVal, MaxVal);
  }

      if (CellType==miSINGLE)
        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
  {
          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);
          InsertComplexFloatRow((float *)BImgBuff, i, image, MinVal, MaxVal);
  }
    }

      
    if ((MATLAB_HDR.DimFlag == 8) &&
        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
      image->type=GrayscaleType;
    if (image->depth == 1)
      image->type=BilevelType;

    if(image2==image)
        image2 = NULL;    

      
    rotated_image = RotateImage(image, 90.0, exception);
    if (rotated_image != (Image *) NULL)
    {
        
      rotated_image->page.x=0;
      rotated_image->page.y=0;

      blob = rotated_image->blob;
      rotated_image->blob = image->blob;
      rotated_image->colors = image->colors;
      image->blob = blob;
      AppendImageToList(&image,rotated_image);
      DeleteImageFromList(&image);
    }

done_reading:

    if(image2!=NULL)
      if(image2!=image)
      {
        DeleteImageFromList(&image2);
  if(clone_info)
  {
          if(clone_info->file)
    {
            fclose(clone_info->file);
            clone_info->file = NULL;
            (void) remove_utf8(clone_info->filename);
    }
        }
      }

      
    AcquireNextImage(image_info,image);
    if (image->next == (Image *) NULL) break;
    image=SyncNextImageInList(image);
    image->columns=image->rows=0;
    image->colors=0;

      
    RelinquishMagickMemory(BImgBuff);
    BImgBuff = NULL;

    if(--Frames>0)
    {
      z = z2;
      if(image2==NULL) image2 = image;
      goto NEXT_FRAME;
    }

    if(image2!=NULL)
      if(image2!=image)   
      {

        DeleteImageFromList(&image2);
        if(clone_info)
        {
          if(clone_info->file)
          {
            fclose(clone_info->file);
            clone_info->file = NULL;
            (void) unlink(clone_info->filename);
          }
         }
       }
  }
  clone_info=DestroyImageInfo(clone_info);

  RelinquishMagickMemory(BImgBuff);
  CloseBlob(image);


  {
    Image *p;
    ssize_t scene=0;

    
    p=image;
    image=NULL;
    while (p != (Image *) NULL)
      {
        Image *tmp=p;
        if ((p->rows == 0) || (p->columns == 0)) {
          p=p->previous;
          DeleteImageFromList(&tmp);
        } else {
          image=p;
          p=p->previous;
        }
      }

    
    for (p=image; p != (Image *) NULL; p=p->next)
      p->scene=scene++;
  }

  if(clone_info != NULL)  
  {
    if(clone_info->file)
    {
      fclose(clone_info->file);
      clone_info->file = NULL;
      (void) remove_utf8(clone_info->filename);
    }
    DestroyImageInfo(clone_info);
    clone_info = NULL;
  }
  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),""return"");
  if(image==NULL)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  return (image);
}
","1. size = 4 * (ssize_t) ((size + 3 + 1) / 4);
2. image->depth = 1;
3. if (CellType==miSINGLE)
4. if(clone_info)","166
193
361
401","CWE-200,CWE-125"
cdxl_decode_frame_1,"
#define AVCodecContext
#define AVPacket

static int cdxl_decode_frame_1(AVCodecContext *avctx, void *data,
                             int *got_frame, AVPacket *pkt)
{
    CDXLVideoContext *c = avctx->priv_data;
    AVFrame * const p = data;
    int ret, w, h, encoding, aligned_width, buf_size = pkt->size;
    const uint8_t *buf = pkt->data;

    if (buf_size < 32)
        return AVERROR_INVALIDDATA;
    encoding        = buf[1] & 7;
    c->format       = buf[1] & 0xE0;
    w               = AV_RB16(&buf[14]);
    h               = AV_RB16(&buf[16]);
    c->bpp          = buf[19];
    c->palette_size = AV_RB16(&buf[20]);
    c->palette      = buf + 32;
    c->video        = c->palette + c->palette_size;
    c->video_size   = buf_size - c->palette_size - 32;

    if (c->palette_size > 512)
        return AVERROR_INVALIDDATA;
    if (buf_size < c->palette_size + 32)
        return AVERROR_INVALIDDATA;
    if (c->bpp < 1)
        return AVERROR_INVALIDDATA;
    if (c->format != BIT_PLANAR && c->format != BIT_LINE && c->format != CHUNKY) {
        avpriv_request_sample(avctx, ""Pixel format 0x%0x"", c->format);
        return AVERROR_PATCHWELCOME;
    }

    if ((ret = ff_set_dimensions(avctx, w, h)) < 0)
        return ret;

    if (c->format == CHUNKY)
        aligned_width = avctx->width;
    else
        aligned_width = FFALIGN(c->avctx->width, 16);
     c->padded_bits  = aligned_width - c->avctx->width;
     if (c->video_size < aligned_width * avctx->height * (int64_t)c->bpp / 8)
         return AVERROR_INVALIDDATA;
    if (!encoding && c->palette_size && c->bpp <= 8 && c->format != CHUNKY) {
         avctx->pix_fmt = AV_PIX_FMT_PAL8;
     } else if (encoding == 1 && (c->bpp == 6 || c->bpp == 8)) {
         if (c->palette_size != (1 << (c->bpp - 1)))
            return AVERROR_INVALIDDATA;
        avctx->pix_fmt = AV_PIX_FMT_BGR24;
    } else if (!encoding && c->bpp == 24 && c->format == CHUNKY &&
               !c->palette_size) {
        avctx->pix_fmt = AV_PIX_FMT_RGB24;
    } else {
        avpriv_request_sample(avctx, ""Encoding %d, bpp %d and format 0x%x"",
                              encoding, c->bpp, c->format);
        return AVERROR_PATCHWELCOME;
    }

    if ((ret = ff_get_buffer(avctx, p, 0)) < 0)
        return ret;
    p->pict_type = AV_PICTURE_TYPE_I;

    if (encoding) {
        av_fast_padded_malloc(&c->new_video, &c->new_video_size,
                              h * w + AV_INPUT_BUFFER_PADDING_SIZE);
        if (!c->new_video)
            return AVERROR(ENOMEM);
        if (c->bpp == 8)
            cdxl_decode_ham8(c, p);
        else
            cdxl_decode_ham6(c, p);
    } else if (avctx->pix_fmt == AV_PIX_FMT_PAL8) {
        cdxl_decode_rgb(c, p);
    } else {
        cdxl_decode_raw(c, p);
    }
    *got_frame = 1;

    return buf_size;
}
","1. encoding        = buf[1] & 7;
2. if (c->palette_size > 512)
3. return AVERROR_INVALIDDATA;
4. if (c->format == CHUNKY)
5. c->padded_bits  = aligned_width - c->avctx->width;
6. } else if (encoding == 1 && (c->bpp == 6 || c->bpp == 8)) {
7. return AVERROR_INVALIDDATA;
8. } else if (!encoding && c->bpp == 24 && c->format == CHUNKY &&
9. avpriv_request_sample(avctx, ""Encoding %d, bpp %d and format 0x%x"",
encoding, c->bpp, c->format);
10. if (!c->new_video)
11. } else if (avctx->pix_fmt == AV_PIX_FMT_PAL8) {
cdxl_decode_rgb(c, p);","15
25
30
39
43
48
50
52
56-57
68
74-75","CWE-190,CWE-119"
parse_notify_1-57534310488101,"static bool parse_notify_1(struct pool *pool, json_t *val)
{
	char *job_id, *prev_hash, *coinbase1, *coinbase2, *bbversion, *nbit,
	     *ntime, *header;
	size_t cb1_len, cb2_len, alloc_len;
	unsigned char *cb1, *cb2;
	bool clean, ret = false;
	int merkles, i;
	json_t *arr;

	arr = json_array_get(val, 4);
	if (!arr || !json_is_array(arr))
		goto out;

	merkles = json_array_size(arr);

	job_id = json_array_string(val, 0);
	prev_hash = json_array_string(val, 1);
	coinbase1 = json_array_string(val, 2);
	coinbase2 = json_array_string(val, 3);
	bbversion = json_array_string(val, 5);
	nbit = json_array_string(val, 6);
	ntime = json_array_string(val, 7);
	clean = json_is_true(json_array_get(val, 8));

	if (!job_id || !prev_hash || !coinbase1 || !coinbase2 || !bbversion || !nbit || !ntime) {
		
		if (job_id)
			free(job_id);
		if (prev_hash)
			free(prev_hash);
		if (coinbase1)
			free(coinbase1);
		if (coinbase2)
			free(coinbase2);
		if (bbversion)
			free(bbversion);
		if (nbit)
			free(nbit);
		if (ntime)
			free(ntime);
		goto out;
	}

	cg_wlock(&pool->data_lock);
	free(pool->swork.job_id);
	free(pool->swork.prev_hash);
	free(pool->swork.bbversion);
	free(pool->swork.nbit);
	free(pool->swork.ntime);
	pool->swork.job_id = job_id;
	pool->swork.prev_hash = prev_hash;
	cb1_len = strlen(coinbase1) / 2;
	cb2_len = strlen(coinbase2) / 2;
	pool->swork.bbversion = bbversion;
	pool->swork.nbit = nbit;
	pool->swork.ntime = ntime;
	pool->swork.clean = clean;
	alloc_len = pool->swork.cb_len = cb1_len + pool->n1_len + pool->n2size + cb2_len;
	pool->nonce2_offset = cb1_len + pool->n1_len;

	for (i = 0; i < pool->swork.merkles; i++)
		free(pool->swork.merkle_bin[i]);
	if (merkles) {
		pool->swork.merkle_bin = (unsigned char **)realloc(pool->swork.merkle_bin,
						 sizeof(char *) * merkles + 1);
		for (i = 0; i < merkles; i++) {
			char *merkle = json_array_string(arr, i);

			pool->swork.merkle_bin[i] = (unsigned char *)malloc(32);
			if (unlikely(!pool->swork.merkle_bin[i]))
				quit(1, ""Failed to malloc pool swork merkle_bin"");
			hex2bin(pool->swork.merkle_bin[i], merkle, 32);
			free(merkle);
		}
	}
	pool->swork.merkles = merkles;
	if (clean)
		pool->nonce2 = 0;
	pool->merkle_offset = strlen(pool->swork.bbversion) +
			      strlen(pool->swork.prev_hash);
	pool->swork.header_len = pool->merkle_offset +
		 32 +
				 strlen(pool->swork.ntime) +
				 strlen(pool->swork.nbit) +
			 8 +
		 96;
	pool->merkle_offset /= 2;
	pool->swork.header_len = pool->swork.header_len * 2 + 1;
	align_len(&pool->swork.header_len);
	header = (char *)alloca(pool->swork.header_len);
	snprintf(header, pool->swork.header_len,
		""%s%s%s%s%s%s%s"",
		pool->swork.bbversion,
		pool->swork.prev_hash,
		blank_merkel,
		pool->swork.ntime,
		pool->swork.nbit,
		""00000000"", 
		workpadding);
	if (unlikely(!hex2bin(pool->header_bin, header, 128))) {
		applog(LOG_WARNING, ""%s: Failed to convert header to header_bin, got %s"", __func__, header);
		pool_failed(pool);
		
		return false;
	}

	cb1 = (unsigned char *)calloc(cb1_len, 1);
	if (unlikely(!cb1))
		quithere(1, ""Failed to calloc cb1 in parse_notify_1"");
	hex2bin(cb1, coinbase1, cb1_len);

	cb2 = (unsigned char *)calloc(cb2_len, 1);
	if (unlikely(!cb2))
		quithere(1, ""Failed to calloc cb2 in parse_notify_1"");
	hex2bin(cb2, coinbase2, cb2_len);

	free(pool->coinbase);
	align_len(&alloc_len);
	pool->coinbase = (unsigned char *)calloc(alloc_len, 1);
	if (unlikely(!pool->coinbase))
		quit(1, ""Failed to calloc pool coinbase in parse_notify_1"");
	memcpy(pool->coinbase, cb1, cb1_len);
	memcpy(pool->coinbase + cb1_len, pool->nonce1bin, pool->n1_len);
	
	memcpy(pool->coinbase + cb1_len + pool->n1_len + pool->n2size, cb2, cb2_len);
	cg_wunlock(&pool->data_lock);

	if (opt_protocol) {
		applog(LOG_DEBUG, ""job_id: %s"", job_id);
		applog(LOG_DEBUG, ""prev_hash: %s"", prev_hash);
		applog(LOG_DEBUG, ""coinbase1: %s"", coinbase1);
		applog(LOG_DEBUG, ""coinbase2: %s"", coinbase2);
		applog(LOG_DEBUG, ""bbversion: %s"", bbversion);
		applog(LOG_DEBUG, ""nbit: %s"", nbit);
		applog(LOG_DEBUG, ""ntime: %s"", ntime);
		applog(LOG_DEBUG, ""clean: %s"", clean ? ""yes"" : ""no"");
	}
	free(coinbase1);
	free(coinbase2);
	free(cb1);
	free(cb2);

	
	pool->getwork_requested++;
	total_getworks++;
	ret = true;
	if (pool == current_pool())
		opt_work_update = true;
out:
	return ret;
}
","1. static bool parse_notify_1(struct pool *pool, json_t *val)
2. *ntime, *header;
size_t cb1_len, cb2_len, alloc_len;
3. bool clean, ret = false;
int merkles, i;
4. goto out;
5. prev_hash = json_array_string(val, 1);
6. nbit = json_array_string(val, 6);
ntime = json_array_string(val, 7);
7. if (job_id)
free(job_id);
8. free(coinbase2);
if (bbversion)
free(bbversion);
9. if (ntime)
free(ntime);
10. cg_wlock(&pool->data_lock);
free(pool->swork.job_id);
11. free(pool->swork.bbversion);
free(pool->swork.nbit);
free(pool->swork.ntime);
12. pool->swork.prev_hash = prev_hash;
cb1_len = strlen(coinbase1) / 2;
13. pool->swork.bbversion = bbversion;
pool->swork.nbit = nbit;
pool->swork.ntime = ntime;
14. pool->nonce2_offset = cb1_len + pool->n1_len;
15. for (i = 0; i < pool->swork.merkles; i++)
16. pool->swork.merkle_bin = (unsigned char **)realloc(pool->swork.merkle_bin,
17. char *merkle = json_array_string(arr, i);
18. if (unlikely(!pool->swork.merkle_bin[i]))
19. free(merkle);
20. if (clean)
pool->nonce2 = 0;
21. strlen(pool->swork.prev_hash);
pool->swork.header_len = pool->merkle_offset +
22. pool->swork.header_len = pool->swork.header_len * 2 + 1;
23. header = (char *)alloca(pool->swork.header_len);
snprintf(header, pool->swork.header_len,
24. pool->swork.ntime,
25. if (unlikely(!hex2bin(pool->header_bin, header, 128))) {
applog(LOG_WARNING, ""%s: Failed to convert header to header_bin, got %s"", __func__, header);
26. return false;
27. hex2bin(cb1, coinbase1, cb1_len);
28. quithere(1, ""Failed to calloc cb2 in parse_notify_1"");
hex2bin(cb2, coinbase2, cb2_len);
29. free(pool->coinbase);
30. if (unlikely(!pool->coinbase))
quit(1, ""Failed to calloc pool coinbase in parse_notify_1"");
31. memcpy(pool->coinbase + cb1_len, pool->nonce1bin, pool->n1_len);
32. memcpy(pool->coinbase + cb1_len + pool->n1_len + pool->n2size, cb2, cb2_len);
33. if (opt_protocol) {
34. applog(LOG_DEBUG, ""prev_hash: %s"", prev_hash);
35. applog(LOG_DEBUG, ""coinbase2: %s"", coinbase2);
applog(LOG_DEBUG, ""bbversion: %s"", bbversion);
36. applog(LOG_DEBUG, ""ntime: %s"", ntime);
37. free(coinbase2);
free(cb1);
free(cb2);
38. pool->getwork_requested++;
39. ret = true;
if (pool == current_pool())
40. return ret;","1
4-5
7-8
13
18
22-23
28-29
35-37
40-41
45-46
48-50
52-53
55-57
60
62
65
68
71
74
78-79
81-82
89
91-92
97
101-102
105
111
115-116
118
121-122
124
126
129
131
133-134
136
140-142
145
147-148
151","CWE-125,CWE-119"
ecryptfs_mount-116397508154777,"static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags,
			const char *dev_name, void *raw_data)
{
	struct super_block *s;
	struct ecryptfs_sb_info *sbi;
	struct ecryptfs_dentry_info *root_info;
	const char *err = ""Getting sb failed"";
	struct inode *inode;
	struct path path;
	uid_t check_ruid;
	int rc;

	sbi = kmem_cache_zalloc(ecryptfs_sb_info_cache, GFP_KERNEL);
	if (!sbi) {
		rc = -ENOMEM;
		goto out;
	}

	rc = ecryptfs_parse_options(sbi, raw_data, &check_ruid);
	if (rc) {
		err = ""Error parsing options"";
		goto out;
	}

	s = sget(fs_type, NULL, set_anon_super, NULL);
	if (IS_ERR(s)) {
		rc = PTR_ERR(s);
		goto out;
	}

	s->s_flags = flags;
	rc = bdi_setup_and_register(&sbi->bdi, ""ecryptfs"", BDI_CAP_MAP_COPY);
	if (rc)
		goto out1;

	ecryptfs_set_superblock_private(s, sbi);
	s->s_bdi = &sbi->bdi;

	
	sbi = NULL;
	s->s_op = &ecryptfs_sops;
	s->s_d_op = &ecryptfs_dops;

	err = ""Reading sb failed"";
	rc = kern_path(dev_name, LOOKUP_FOLLOW | LOOKUP_DIRECTORY, &path);
	if (rc) {
		ecryptfs_printk(KERN_WARNING, ""kern_path() failed\n"");
		goto out1;
	}
	if (path.dentry->d_sb->s_type == &ecryptfs_fs_type) {
		rc = -EINVAL;
		printk(KERN_ERR ""Mount on filesystem of type ""
			""eCryptfs explicitly disallowed due to ""
			""known incompatibilities\n"");
		goto out_free;
	}

	if (check_ruid && path.dentry->d_inode->i_uid != current_uid()) {
		rc = -EPERM;
		printk(KERN_ERR ""Mount of device (uid: %d) not owned by ""
		       ""requested user (uid: %d)\n"",
		       path.dentry->d_inode->i_uid, current_uid());
		goto out_free;
	}

	ecryptfs_set_superblock_lower(s, path.dentry->d_sb);
	s->s_maxbytes = path.dentry->d_sb->s_maxbytes;
	s->s_blocksize = path.dentry->d_sb->s_blocksize;
	s->s_magic = ECRYPTFS_SUPER_MAGIC;

	inode = ecryptfs_get_inode(path.dentry->d_inode, s);
	rc = PTR_ERR(inode);
	if (IS_ERR(inode))
		goto out_free;

	s->s_root = d_alloc_root(inode);
	if (!s->s_root) {
		iput(inode);
		rc = -ENOMEM;
		goto out_free;
	}

	rc = -ENOMEM;
	root_info = kmem_cache_zalloc(ecryptfs_dentry_info_cache, GFP_KERNEL);
	if (!root_info)
		goto out_free;

	
	ecryptfs_set_dentry_private(s->s_root, root_info);
	ecryptfs_set_dentry_lower(s->s_root, path.dentry);
	ecryptfs_set_dentry_lower_mnt(s->s_root, path.mnt);

	s->s_flags |= MS_ACTIVE;
	return dget(s->s_root);

out_free:
	path_put(&path);
out1:
	deactivate_locked_super(s);
out:
	if (sbi) {
		ecryptfs_destroy_mount_crypt_stat(&sbi->mount_crypt_stat);
		kmem_cache_free(ecryptfs_sb_info_cache, sbi);
	}
	printk(KERN_ERR ""%s; rc = [%d]\n"", err, rc);
	return ERR_PTR(rc);
}
","1. static struct dentry *ecryptfs_mount(struct file_system_type *fs_type, int flags,
2. rc = -ENOMEM;
3. rc = PTR_ERR(s);
goto out;
4. goto out1;
5. sbi = NULL;
6. goto out_free;
7. s->s_blocksize = path.dentry->d_sb->s_blocksize;
s->s_magic = ECRYPTFS_SUPER_MAGIC;
8. rc = PTR_ERR(inode);
9. goto out_free;
10. root_info = kmem_cache_zalloc(ecryptfs_dentry_info_cache, GFP_KERNEL);
11. s->s_flags |= MS_ACTIVE;
return dget(s->s_root);
12. out_free:
13. if (sbi) {
14. kmem_cache_free(ecryptfs_sb_info_cache, sbi);","1
15
27-28
34
40
55
68-69
72
80
84
93-94
96
101
103","CWE-772,CWE-264,CWE-119"
flatpak_dir_deploy-38267736105630,"
#define FlatpakDecomposed
#define FlatpakDir
#define GCancellable
#define GError

gboolean
flatpak_dir_deploy (FlatpakDir          *self,
                    const char          *origin,
                    FlatpakDecomposed   *ref,
                    const char          *checksum_or_latest,
                    const char * const * subpaths,
                    const char * const * previous_ids,
                    GCancellable        *cancellable,
                    GError             **error)
{
  g_autofree char *resolved_ref = NULL;
  g_autofree char *ref_id = NULL;
  g_autoptr(GFile) root = NULL;
  g_autoptr(GFile) deploy_base = NULL;
  g_autoptr(GFile) checkoutdir = NULL;
  g_autoptr(GFile) bindir = NULL;
  g_autofree char *checkoutdirpath = NULL;
  g_autoptr(GFile) real_checkoutdir = NULL;
  g_autoptr(GFile) dotref = NULL;
  g_autoptr(GFile) files_etc = NULL;
  g_autoptr(GFile) deploy_data_file = NULL;
  g_autoptr(GVariant) commit_data = NULL;
  g_autoptr(GBytes) deploy_data = NULL;
  g_autoptr(GFile) export = NULL;
  g_autoptr(GFile) extradir = NULL;
  g_autoptr(GKeyFile) keyfile = NULL;
  guint64 installed_size = 0;
  OstreeRepoCheckoutAtOptions options = { 0, };
  const char *checksum;
  glnx_autofd int checkoutdir_dfd = -1;
  g_autoptr(GFile) tmp_dir_template = NULL;
  g_autofree char *tmp_dir_path = NULL;
  const char *xa_ref = NULL;
  g_autofree char *checkout_basename = NULL;
  gboolean created_extra_data = FALSE;
  g_autoptr(GVariant) commit_metadata = NULL;
  g_auto(GLnxLockFile) lock = { 0, };
  g_autoptr(GFile) metadata_file = NULL;
  g_autofree char *metadata_contents = NULL;
  gsize metadata_size = 0;
  gboolean is_oci;
  const char *flatpak;

  if (!flatpak_dir_ensure_repo (self, cancellable, error))
    return FALSE;

  ref_id = flatpak_decomposed_dup_id (ref);

  
  if (!flatpak_dir_repo_lock (self, &lock, LOCK_SH, cancellable, error))
    return FALSE;

  deploy_base = flatpak_dir_get_deploy_dir (self, ref);

  if (checksum_or_latest == NULL)
    {
      g_debug (""No checksum specified, getting tip of %s from origin %s"", flatpak_decomposed_get_ref (ref), origin);

      resolved_ref = flatpak_dir_read_latest (self, origin, flatpak_decomposed_get_ref (ref), NULL, cancellable, error);
      if (resolved_ref == NULL)
        {
          g_prefix_error (error, _(""While trying to resolve ref %s: ""), flatpak_decomposed_get_ref (ref));
          return FALSE;
        }

      checksum = resolved_ref;
      g_debug (""tip resolved to: %s"", checksum);
    }
  else
    {
      checksum = checksum_or_latest;
      g_debug (""Looking for checksum %s in local repo"", checksum);
      if (!ostree_repo_read_commit (self->repo, checksum, NULL, NULL, cancellable, NULL))
        return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA, _(""%s is not available""), flatpak_decomposed_get_ref (ref));
    }

  if (!ostree_repo_load_commit (self->repo, checksum, &commit_data, NULL, error))
    return FALSE;

  commit_metadata = g_variant_get_child_value (commit_data, 0);
  checkout_basename = flatpak_dir_get_deploy_subdir (self, checksum, subpaths);

  real_checkoutdir = g_file_get_child (deploy_base, checkout_basename);
  if (g_file_query_exists (real_checkoutdir, cancellable))
    return flatpak_fail_error (error, FLATPAK_ERROR_ALREADY_INSTALLED,
                               _(""%s commit %s already installed""), flatpak_decomposed_get_ref (ref), checksum);

  g_autofree char *template = g_strdup_printf ("".%s-XXXXXX"", checkout_basename);
  tmp_dir_template = g_file_get_child (deploy_base, template);
  tmp_dir_path = g_file_get_path (tmp_dir_template);

  if (g_mkdtemp_full (tmp_dir_path, 0755) == NULL)
    {
      g_set_error_literal (error, G_IO_ERROR, G_IO_ERROR_FAILED,
                           _(""Can't create deploy directory""));
      return FALSE;
    }

  checkoutdir = g_file_new_for_path (tmp_dir_path);

  if (!ostree_repo_read_commit (self->repo, checksum, &root, NULL, cancellable, error))
    {
      g_prefix_error (error, _(""Failed to read commit %s: ""), checksum);
      return FALSE;
    }

  if (!flatpak_repo_collect_sizes (self->repo, root, &installed_size, NULL, cancellable, error))
    return FALSE;

  options.mode = OSTREE_REPO_CHECKOUT_MODE_USER;
  options.overwrite_mode = OSTREE_REPO_CHECKOUT_OVERWRITE_UNION_FILES;
  options.enable_fsync = FALSE; 
  options.bareuseronly_dirs = TRUE; 
  checkoutdirpath = g_file_get_path (checkoutdir);

  if (subpaths == NULL || *subpaths == NULL)
    {
      if (!ostree_repo_checkout_at (self->repo, &options,
                                    AT_FDCWD, checkoutdirpath,
                                    checksum,
                                    cancellable, error))
        {
          g_prefix_error (error, _(""While trying to checkout %s into %s: ""), checksum, checkoutdirpath);
          return FALSE;
        }
    }
  else
    {
      g_autoptr(GFile) files = g_file_get_child (checkoutdir, ""files"");
      int i;

      if (!g_file_make_directory_with_parents (files, cancellable, error))
        return FALSE;

      options.subpath = ""/metadata"";

      if (!ostree_repo_checkout_at (self->repo, &options,
                                    AT_FDCWD, checkoutdirpath,
                                    checksum,
                                    cancellable, error))
        {
          g_prefix_error (error, _(""While trying to checkout metadata subpath: ""));
          return FALSE;
        }

      for (i = 0; subpaths[i] != NULL; i++)
        {
          g_autofree char *subpath = g_build_filename (""/files"", subpaths[i], NULL);
          g_autofree char *dstpath = g_build_filename (checkoutdirpath, ""/files"", subpaths[i], NULL);
          g_autofree char *dstpath_parent = g_path_get_dirname (dstpath);
          g_autoptr(GFile) child = NULL;

          child = g_file_resolve_relative_path (root, subpath);

          if (!g_file_query_exists (child, cancellable))
            {
              g_debug (""subpath %s not in tree"", subpaths[i]);
              continue;
            }

          if (g_mkdir_with_parents (dstpath_parent, 0755))
            {
              glnx_set_error_from_errno (error);
              return FALSE;
            }

          options.subpath = subpath;
          if (!ostree_repo_checkout_at (self->repo, &options,
                                        AT_FDCWD, dstpath,
                                        checksum,
                                        cancellable, error))
            {
              g_prefix_error (error, _(""While trying to checkout subpath %s: ""), subpath);
              return FALSE;
            }
        }
    }

  
  extradir = g_file_resolve_relative_path (checkoutdir, ""files/extra"");
  if (!flatpak_rm_rf (extradir, cancellable, error))
    {
      g_prefix_error (error, _(""While trying to remove existing extra dir: ""));
      return FALSE;
    }

  if (!extract_extra_data (self, checksum, extradir, &created_extra_data, cancellable, error))
    return FALSE;

  if (created_extra_data)
    {
      if (!apply_extra_data (self, checkoutdir, cancellable, error))
        {
          g_prefix_error (error, _(""While trying to apply extra data: ""));
          return FALSE;
        }
    }

  g_variant_lookup (commit_metadata, ""xa.ref"", ""&s"", &xa_ref);
  if (xa_ref != NULL)
    {
      gboolean gpg_verify_summary;

      if (!ostree_repo_remote_get_gpg_verify_summary (self->repo, origin, &gpg_verify_summary, error))
        return FALSE;

      if (gpg_verify_summary)
        {
          
          FlatpakDecomposed *checkout_ref = ref;
          g_autoptr(FlatpakDecomposed) commit_ref = NULL;

          commit_ref = flatpak_decomposed_new_from_ref (xa_ref, error);
          if (commit_ref == NULL)
            {
              g_prefix_error (error, _(""Invalid commit ref %s: ""), xa_ref);
              return FALSE;
            }

          
          if (!flatpak_decomposed_equal_except_branch (checkout_ref, commit_ref))
            {
              g_set_error (error, G_IO_ERROR, G_IO_ERROR_PERMISSION_DENIED,
                           _(""Deployed ref %s does not match commit (%s)""),
                           flatpak_decomposed_get_ref (ref), xa_ref);
              return FALSE;
            }

          if (strcmp (flatpak_decomposed_get_branch (checkout_ref), flatpak_decomposed_get_branch (commit_ref)) != 0)
            g_warning (_(""Deployed ref %s branch does not match commit (%s)""),
                       flatpak_decomposed_get_ref (ref), xa_ref);
        }
      else if (strcmp (flatpak_decomposed_get_ref (ref), xa_ref) != 0)
        {
          g_set_error (error, G_IO_ERROR, G_IO_ERROR_PERMISSION_DENIED,
                       _(""Deployed ref %s does not match commit (%s)""), flatpak_decomposed_get_ref (ref), xa_ref);
          return FALSE;
        }
    }

  keyfile = g_key_file_new ();
  metadata_file = g_file_resolve_relative_path (checkoutdir, ""metadata"");
  if (g_file_load_contents (metadata_file, NULL,
                            &metadata_contents,
                            &metadata_size, NULL, NULL))
    {
      if (!g_key_file_load_from_data (keyfile,
                                      metadata_contents,
                                      metadata_size,
                                      0, error))
        return FALSE;

      if (!flatpak_check_required_version (flatpak_decomposed_get_ref (ref), keyfile, error))
        return FALSE;
    }

  
  is_oci = flatpak_dir_get_remote_oci (self, origin);
  if (!validate_commit_metadata (commit_data, flatpak_decomposed_get_ref (ref),
                                 metadata_contents, metadata_size, !is_oci, error))
    return FALSE;

  dotref = g_file_resolve_relative_path (checkoutdir, ""files/.ref"");
  if (!g_file_replace_contents (dotref, """", 0, NULL, FALSE,
                                G_FILE_CREATE_REPLACE_DESTINATION, NULL, cancellable, error))
    return FALSE;

  export = g_file_get_child (checkoutdir, ""export"");

  
  bindir = g_file_get_child (export, ""bin"");
  if (!flatpak_rm_rf (bindir, cancellable, error))
    return FALSE;

  if (flatpak_decomposed_is_runtime (ref))
    {
      
      files_etc = g_file_resolve_relative_path (checkoutdir, ""files/etc"");
      if (g_file_query_exists (files_etc, cancellable))
        {
          char *etcfiles[] = {""passwd"", ""group"", ""machine-id"" };
          g_autoptr(GFile) etc_resolve_conf = g_file_get_child (files_etc, ""resolv.conf"");
          int i;
          for (i = 0; i < G_N_ELEMENTS (etcfiles); i++)
            {
              g_autoptr(GFile) etc_file = g_file_get_child (files_etc, etcfiles[i]);
              GFileType type;

              type = g_file_query_file_type (etc_file, G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,
                                             cancellable);
              if (type == G_FILE_TYPE_REGULAR)
                continue;

              if (type != G_FILE_TYPE_UNKNOWN)
                {
                  
                  if (!g_file_delete (etc_file, cancellable, error))
                    return FALSE;
                }

              if (!g_file_replace_contents (etc_file, """", 0, NULL, FALSE,
                                            G_FILE_CREATE_REPLACE_DESTINATION,
                                            NULL, cancellable, error))
                return FALSE;
            }

          if (g_file_query_exists (etc_resolve_conf, cancellable) &&
              !g_file_delete (etc_resolve_conf, cancellable, error))
            return FALSE;

          if (!g_file_make_symbolic_link (etc_resolve_conf,
                                          ""/run/host/monitor/resolv.conf"",
                                          cancellable, error))
            return FALSE;
        }

      
      if (!flatpak_rm_rf (export, cancellable, error))
        return FALSE;
    }
  else 
    {
      g_autofree char *ref_arch = flatpak_decomposed_dup_arch (ref);
      g_autofree char *ref_branch = flatpak_decomposed_dup_branch (ref);
      g_autoptr(GFile) wrapper = g_file_get_child (bindir, ref_id);
      g_autofree char *escaped_app = maybe_quote (ref_id);
      g_autofree char *escaped_branch = maybe_quote (ref_branch);
      g_autofree char *escaped_arch = maybe_quote (ref_arch);
      g_autofree char *bin_data = NULL;
      int r;

      if (!flatpak_mkdir_p (bindir, cancellable, error))
        return FALSE;

      if (!flatpak_rewrite_export_dir (ref_id, ref_branch, ref_arch,
                                       keyfile, previous_ids, export,
                                       cancellable,
                                       error))
        return FALSE;
      if ((flatpak = g_getenv (""FLATPAK_BINARY"")) == NULL)
        flatpak = FLATPAK_BINDIR ""/flatpak"";

      bin_data = g_strdup_printf (""#!/bin/sh\nexec %s run --branch=%s --arch=%s %s \""$@\""\n"",
                                  flatpak, escaped_branch, escaped_arch, escaped_app);
      if (!g_file_replace_contents (wrapper, bin_data, strlen (bin_data), NULL, FALSE,
                                    G_FILE_CREATE_REPLACE_DESTINATION, NULL, cancellable, error))
        return FALSE;

      do
        r = fchmodat (AT_FDCWD, flatpak_file_get_path_cached (wrapper), 0755, 0);
      while (G_UNLIKELY (r == -1 && errno == EINTR));
      if (r == -1)
        return glnx_throw_errno_prefix (error, ""fchmodat"");
    }

  deploy_data = flatpak_dir_new_deploy_data (self,
                                             checkoutdir,
                                             commit_data,
                                             commit_metadata,
                                             keyfile,
                                             ref_id,
                                             origin,
                                             checksum,
                                             (char **) subpaths,
                                             installed_size,
                                             previous_ids);

  
  if (!flatpak_dir_check_parental_controls (self, flatpak_decomposed_get_ref (ref), deploy_data, cancellable, error))
    return FALSE;

  deploy_data_file = g_file_get_child (checkoutdir, ""deploy"");
  if (!flatpak_bytes_save (deploy_data_file, deploy_data, cancellable, error))
    return FALSE;

  if (!glnx_opendirat (AT_FDCWD, checkoutdirpath, TRUE, &checkoutdir_dfd, error))
    return FALSE;

  if (syncfs (checkoutdir_dfd) != 0)
    {
      glnx_set_error_from_errno (error);
      return FALSE;
    }

  if (!g_file_move (checkoutdir, real_checkoutdir, G_FILE_COPY_NO_FALLBACK_FOR_MOVE,
                    cancellable, NULL, NULL, error))
    return FALSE;

  if (!flatpak_dir_set_active (self, ref, checkout_basename, cancellable, error))
    return FALSE;

  if (!flatpak_dir_update_deploy_ref (self, flatpak_decomposed_get_ref (ref), checksum, error))
    return FALSE;

  return TRUE;
}
","1. flatpak_dir_deploy (FlatpakDir          *self,
2. g_autofree char *tmp_dir_path = NULL;
3. g_autofree char *template = g_strdup_printf ("".%s-XXXXXX"", checkout_basename);
4. AT_FDCWD, checkoutdirpath,
5. return FALSE;
6. commit_ref = flatpak_decomposed_new_from_ref (xa_ref, error);
7. flatpak_decomposed_get_ref (ref), xa_ref);
return FALSE;
8. &metadata_size, NULL, NULL))
9. GFileType type;
10. {
11. bin_data = g_strdup_printf (""#!/bin/sh\nexec %s run --branch=%s --arch=%s %s \""$@\""\n"",","8
38
96
127
203
226
238-239
258
306
341
362","CWE-200,CWE-20,CWE-276,CWE-399"
ReadMATImage_1,"
#define ExceptionInfo
#define ImageInfo

static Image *ReadMATImage_1(const ImageInfo *image_info,ExceptionInfo *exception)
{
  Image *image, *image2=NULL,
   *rotated_image;
  register Quantum *q;

  unsigned int status;
  MATHeader MATLAB_HDR;
  size_t size;
  size_t CellType;
  QuantumInfo *quantum_info;
  ImageInfo *clone_info;
  int i;
  ssize_t ldblk;
  unsigned char *BImgBuff = NULL;
  double MinVal, MaxVal;
  unsigned z, z2;
  unsigned Frames;
  int logging;
  int sample_size;
  MagickOffsetType filepos=0x80;
  BlobInfo *blob;
  size_t one;

  unsigned int (*ReadBlobXXXLong)(Image *image);
  unsigned short (*ReadBlobXXXShort)(Image *image);
  void (*ReadBlobDoublesXXX)(Image * image, size_t len, double *data);
  void (*ReadBlobFloatsXXX)(Image * image, size_t len, float *data);


  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  logging = LogMagickEvent(CoderEvent,GetMagickModule(),""enter"");

  
  image = AcquireImage(image_info,exception);

  status = OpenBlob(image_info, image, ReadBinaryBlobMode, exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  
  clone_info=CloneImageInfo(image_info);
  if (ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  if (strncmp(MATLAB_HDR.identific,""MATLAB"",6) != 0)
    {
      image2=ReadMATImageV4(image_info,image,exception);
      if (image2  == NULL)
        goto MATLAB_KO;
      image=image2;
      goto END_OF_READING;
    }
  MATLAB_HDR.Version = ReadBlobLSBShort(image);
  if(ReadBlob(image,2,(unsigned char *) &MATLAB_HDR.EndianIndicator) != 2)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");

  if (logging)
    (void) LogMagickEvent(CoderEvent,GetMagickModule(),""  Endian %c%c"",
      MATLAB_HDR.EndianIndicator[0],MATLAB_HDR.EndianIndicator[1]);
  if (!strncmp(MATLAB_HDR.EndianIndicator, ""IM"", 2))
  {
    ReadBlobXXXLong = ReadBlobLSBLong;
    ReadBlobXXXShort = ReadBlobLSBShort;
    ReadBlobDoublesXXX = ReadBlobDoublesLSB;
    ReadBlobFloatsXXX = ReadBlobFloatsLSB;
    image->endian = LSBEndian;
  }
  else if (!strncmp(MATLAB_HDR.EndianIndicator, ""MI"", 2))
  {
    ReadBlobXXXLong = ReadBlobMSBLong;
    ReadBlobXXXShort = ReadBlobMSBShort;
    ReadBlobDoublesXXX = ReadBlobDoublesMSB;
    ReadBlobFloatsXXX = ReadBlobFloatsMSB;
    image->endian = MSBEndian;
  }
  else
    goto MATLAB_KO;    

  if (strncmp(MATLAB_HDR.identific, ""MATLAB"", 6))
MATLAB_KO: ThrowReaderException(CorruptImageError,""ImproperImageHeader"");

  filepos = TellBlob(image);
  while(!EOFBlob(image)) 
  {
    Frames = 1;
    (void) SeekBlob(image,filepos,SEEK_SET);
    

    MATLAB_HDR.DataType = ReadBlobXXXLong(image);
    if(EOFBlob(image)) break;
    MATLAB_HDR.ObjectSize = ReadBlobXXXLong(image);
    if(EOFBlob(image)) break;
    filepos += MATLAB_HDR.ObjectSize + 4 + 4;

    image2 = image;
#if defined(MAGICKCORE_ZLIB_DELEGATE)
    if(MATLAB_HDR.DataType == miCOMPRESSED)
    {
      image2 = DecompressBlock(image,MATLAB_HDR.ObjectSize,clone_info,exception);
      if(image2==NULL) continue;
      MATLAB_HDR.DataType = ReadBlobXXXLong(image2); 
    }
#endif

    if(MATLAB_HDR.DataType!=miMATRIX) continue;  

    MATLAB_HDR.unknown1 = ReadBlobXXXLong(image2);
    MATLAB_HDR.unknown2 = ReadBlobXXXLong(image2);

    MATLAB_HDR.unknown5 = ReadBlobXXXLong(image2);
    MATLAB_HDR.StructureClass = MATLAB_HDR.unknown5 & 0xFF;
    MATLAB_HDR.StructureFlag = (MATLAB_HDR.unknown5>>8) & 0xFF;

    MATLAB_HDR.unknown3 = ReadBlobXXXLong(image2);
    if(image!=image2)
      MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);  
    MATLAB_HDR.unknown4 = ReadBlobXXXLong(image2);
    MATLAB_HDR.DimFlag = ReadBlobXXXLong(image2);
    MATLAB_HDR.SizeX = ReadBlobXXXLong(image2);
    MATLAB_HDR.SizeY = ReadBlobXXXLong(image2);


    switch(MATLAB_HDR.DimFlag)
    {
      case  8: z2=z=1; break;      
      case 12: z2=z = ReadBlobXXXLong(image2);  
           (void) ReadBlobXXXLong(image2);
         if(z!=3) ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
         break;
      case 16: z2=z = ReadBlobXXXLong(image2);  
         if(z!=3 && z!=1)
            ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
         Frames = ReadBlobXXXLong(image2);
         if (Frames == 0)
           ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
         break;
      default: ThrowReaderException(CoderError, ""MultidimensionalMatricesAreNotSupported"");
    }

    MATLAB_HDR.Flag1 = ReadBlobXXXShort(image2);
    MATLAB_HDR.NameFlag = ReadBlobXXXShort(image2);

    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
          ""MATLAB_HDR.StructureClass %d"",MATLAB_HDR.StructureClass);
    if (MATLAB_HDR.StructureClass != mxCHAR_CLASS &&
        MATLAB_HDR.StructureClass != mxSINGLE_CLASS &&    
        MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&    
        MATLAB_HDR.StructureClass != mxINT8_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT8_CLASS &&    
        MATLAB_HDR.StructureClass != mxINT16_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT16_CLASS &&    
        MATLAB_HDR.StructureClass != mxINT32_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT32_CLASS &&    
        MATLAB_HDR.StructureClass != mxINT64_CLASS &&
        MATLAB_HDR.StructureClass != mxUINT64_CLASS)    
      ThrowReaderException(CoderError,""UnsupportedCellTypeInTheMatrix"");

    switch (MATLAB_HDR.NameFlag)
    {
      case 0:
        size = ReadBlobXXXLong(image2);  
        size = 4 * (ssize_t) ((size + 3 + 1) / 4);
        (void) SeekBlob(image2, size, SEEK_CUR);
        break;
      case 1:
      case 2:
      case 3:
      case 4:
        (void) ReadBlob(image2, 4, (unsigned char *) &size); 
        break;
      default:
        goto MATLAB_KO;
    }

    CellType = ReadBlobXXXLong(image2);    
    if (logging)
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""MATLAB_HDR.CellType: %.20g"",(double) CellType);

    (void) ReadBlob(image2, 4, (unsigned char *) &size);     

    NEXT_FRAME:
    switch (CellType)
    {
      case miINT8:
      case miUINT8:
        sample_size = 8;
        if(MATLAB_HDR.StructureFlag & FLAG_LOGICAL)
          image->depth = 1;
        else
          image->depth = 8;         
        ldblk = (ssize_t) MATLAB_HDR.SizeX;
        break;
      case miINT16:
      case miUINT16:
        sample_size = 16;
        image->depth = 16;        
        ldblk = (ssize_t) (2 * MATLAB_HDR.SizeX);
        break;
      case miINT32:
      case miUINT32:
        sample_size = 32;
        image->depth = 32;        
        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
        break;
      case miINT64:
      case miUINT64:
        sample_size = 64;
        image->depth = 64;        
        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
        break;
      case miSINGLE:
        sample_size = 32;
        image->depth = 32;        
        (void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
  {              
  }
        ldblk = (ssize_t) (4 * MATLAB_HDR.SizeX);
        break;
      case miDOUBLE:
        sample_size = 64;
        image->depth = 64;        
        (void) SetImageOption(clone_info,""quantum:format"",""floating-point"");
DisableMSCWarning(4127)
        if (sizeof(double) != 8)
RestoreMSCWarning
          ThrowReaderException(CoderError, ""IncompatibleSizeOfDouble"");
        if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
  {                         
  }
        ldblk = (ssize_t) (8 * MATLAB_HDR.SizeX);
        break;
      default:
        ThrowReaderException(CoderError, ""UnsupportedCellTypeInTheMatrix"");
    }
    (void) sample_size;
    image->columns = MATLAB_HDR.SizeX;
    image->rows = MATLAB_HDR.SizeY;
    quantum_info=AcquireQuantumInfo(clone_info,image);
    if (quantum_info == (QuantumInfo *) NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    one=1;
    image->colors = one << image->depth;
    if (image->columns == 0 || image->rows == 0)
      goto MATLAB_KO;
    
    if ((MATLAB_HDR.DimFlag == 8) &&
        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
      {
        image->type=GrayscaleType;
        SetImageColorspace(image,GRAYColorspace,exception);
      }


    
    if (image_info->ping)
    {
      size_t temp = image->columns;
      image->columns = image->rows;
      image->rows = temp;
      goto done_reading; 
    }
    status=SetImageExtent(image,image->columns,image->rows,exception);
    if (status == MagickFalse)
      return(DestroyImageList(image));

  
     BImgBuff = (unsigned char *) AcquireQuantumMemory((size_t) (ldblk),sizeof(double));    
     if (BImgBuff == NULL)
       ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    (void) ResetMagickMemory(BImgBuff,0,ldblk*sizeof(double));
 
     MinVal = 0;
     MaxVal = 0;
    if (CellType==miDOUBLE || CellType==miSINGLE)        
    {
      CalcMinMax(image2, image_info->endian,  MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &quantum_info->minimum, &quantum_info->maximum);
    }

    
    if(z==1) z=0; 
    
    do
    {
      for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
      {
        q=GetAuthenticPixels(image,0,MATLAB_HDR.SizeY-i-1,image->columns,1,exception);
        if (q == (Quantum *) NULL)
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  MAT set image pixels returns unexpected NULL on a row %u."", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto done_reading;    
  }
        if(ReadBlob(image2,ldblk,(unsigned char *)BImgBuff) != (ssize_t) ldblk)
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
             ""  MAT cannot read scanrow %u from a file."", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto ExitLoop;
  }
        if((CellType==miINT8 || CellType==miUINT8) && (MATLAB_HDR.StructureFlag & FLAG_LOGICAL))
        {
          FixLogical((unsigned char *)BImgBuff,ldblk);
          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
    {
ImportQuantumPixelsFailed:
      if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  MAT failed to ImportQuantumPixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
      break;
    }
        }
        else
        {
          if(ImportQuantumPixels(image,(CacheView *) NULL,quantum_info,z2qtype[z],BImgBuff,exception) <= 0)
      goto ImportQuantumPixelsFailed;


          if (z<=1 &&       
          (CellType==miINT8 || CellType==miINT16 || CellType==miINT32 || CellType==miINT64))
      FixSignedValues(image,q,MATLAB_HDR.SizeX);
        }

        if (!SyncAuthenticPixels(image,exception))
  {
    if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),
            ""  MAT failed to sync image pixels for a row %u"", (unsigned)(MATLAB_HDR.SizeY-i-1));
    goto ExitLoop;
  }
      }
    } while(z-- >= 2);
    quantum_info=DestroyQuantumInfo(quantum_info);
ExitLoop:


    
    if (MATLAB_HDR.StructureFlag & FLAG_COMPLEX)
    {        
      CellType = ReadBlobXXXLong(image2);    
      i = ReadBlobXXXLong(image2);           

      if (CellType==miDOUBLE || CellType==miSINGLE)
      {
        CalcMinMax(image2,  image_info->endian, MATLAB_HDR.SizeX, MATLAB_HDR.SizeY, CellType, ldblk, BImgBuff, &MinVal, &MaxVal);
      }

      if (CellType==miDOUBLE)
        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
  {
          ReadBlobDoublesXXX(image2, ldblk, (double *)BImgBuff);
          InsertComplexDoubleRow(image, (double *)BImgBuff, i, MinVal, MaxVal,
            exception);
  }

      if (CellType==miSINGLE)
        for (i = 0; i < (ssize_t) MATLAB_HDR.SizeY; i++)
  {
          ReadBlobFloatsXXX(image2, ldblk, (float *)BImgBuff);
          InsertComplexFloatRow(image,(float *)BImgBuff,i,MinVal,MaxVal,
            exception);
  }
    }

      
    if ((MATLAB_HDR.DimFlag == 8) &&
        ((MATLAB_HDR.StructureFlag & FLAG_COMPLEX) == 0))
      image->type=GrayscaleType;
    if (image->depth == 1)
      image->type=BilevelType;

    if(image2==image)
        image2 = NULL;    

      
    rotated_image = RotateImage(image, 90.0, exception);
    if (rotated_image != (Image *) NULL)
    {
        
      rotated_image->page.x=0;
      rotated_image->page.y=0;

      blob = rotated_image->blob;
      rotated_image->blob = image->blob;
      rotated_image->colors = image->colors;
      image->blob = blob;
      AppendImageToList(&image,rotated_image);
      DeleteImageFromList(&image);
    }

done_reading:

    if(image2!=NULL)
      if(image2!=image)
      {
        DeleteImageFromList(&image2);
  if(clone_info)
  {
          if(clone_info->file)
    {
            fclose(clone_info->file);
            clone_info->file = NULL;
            (void) remove_utf8(clone_info->filename);
    }
        }
      }

      
    AcquireNextImage(image_info,image,exception);
    if (image->next == (Image *) NULL) break;
    image=SyncNextImageInList(image);
    image->columns=image->rows=0;
    image->colors=0;

      
    RelinquishMagickMemory(BImgBuff);
    BImgBuff = NULL;

    if(--Frames>0)
    {
      z = z2;
      if(image2==NULL) image2 = image;
      goto NEXT_FRAME;
    }
    if ((image2!=NULL) && (image2!=image))   
      {

        DeleteImageFromList(&image2);
        if(clone_info)
        {
          if(clone_info->file)
          {
            fclose(clone_info->file);
            clone_info->file = NULL;
            (void) remove_utf8(clone_info->filename);
          }
        }
        }
  }

  RelinquishMagickMemory(BImgBuff);
END_OF_READING:
  clone_info=DestroyImageInfo(clone_info);
  CloseBlob(image);


  {
    Image *p;
    ssize_t scene=0;

    
    p=image;
    image=NULL;
    while (p != (Image *) NULL)
      {
        Image *tmp=p;
        if ((p->rows == 0) || (p->columns == 0)) {
          p=p->previous;
          DeleteImageFromList(&tmp);
        } else {
          image=p;
          p=p->previous;
        }
      }

    
    for (p=image; p != (Image *) NULL; p=p->next)
      p->scene=scene++;
  }

  if(clone_info != NULL)  
  {
    if(clone_info->file)
    {
      fclose(clone_info->file);
      clone_info->file = NULL;
      (void) remove_utf8(clone_info->filename);
    }
    DestroyImageInfo(clone_info);
    clone_info = NULL;
  }
  if (logging) (void)LogMagickEvent(CoderEvent,GetMagickModule(),""return"");
  if(image==NULL)
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  return (image);
}
","1. if (ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)
2. (void) ReadBlobXXXLong(image2);
3. MATLAB_HDR.StructureClass != mxDOUBLE_CLASS &&
4. case 3:
5. image->depth = 16;
6. (void) sample_size;
image->columns = MATLAB_HDR.SizeX;
7. fclose(clone_info->file);
8. if(clone_info->file)","56
140
160
180
210
250-251
415
491","CWE-200,CWE-125,CWE-416"
gdImageWBMPCtx-168221686002109,"void gdImageWBMPCtx (gdImagePtr image, int fg, gdIOCtx * out)
{
	_gdImageWBMPCtx(image, fg, out);
}
","1. void gdImageWBMPCtx (gdImagePtr image, int fg, gdIOCtx * out)
2. _gdImageWBMPCtx(image, fg, out);","1
3",CWE-415
read_sequence_header,"void read_sequence_header(decoder_info_t *decoder_info, stream_t *stream) {
   decoder_info->width = get_flc(16, stream);
   decoder_info->height = get_flc(16, stream);
   decoder_info->log2_sb_size = get_flc(3, stream);
  decoder_info->log2_sb_size = clip(decoder_info->log2_sb_size, log2i(MIN_BLOCK_SIZE), log2i(MAX_SB_SIZE));
   decoder_info->pb_split = get_flc(1, stream);
   decoder_info->tb_split_enable = get_flc(1, stream);
   decoder_info->max_num_ref = get_flc(2, stream) + 1;
  decoder_info->interp_ref = get_flc(2, stream);
  decoder_info->max_delta_qp = get_flc(1, stream);
  decoder_info->deblocking = get_flc(1, stream);
  decoder_info->clpf = get_flc(1, stream);
  decoder_info->use_block_contexts = get_flc(1, stream);
  decoder_info->bipred = get_flc(2, stream);
  decoder_info->qmtx = get_flc(1, stream);
  if (decoder_info->qmtx) {
    decoder_info->qmtx_offset = get_flc(6, stream) - 32;
  }
  decoder_info->subsample = get_flc(2, stream);
    decoder_info->subsample = 
    (decoder_info->subsample & 1) * 20 + (decoder_info->subsample & 2) * 22 +
    ((decoder_info->subsample & 3) == 3) * 2 + 400;
  decoder_info->num_reorder_pics = get_flc(4, stream);
  if (decoder_info->subsample != 400) {
    decoder_info->cfl_intra = get_flc(1, stream);
    decoder_info->cfl_inter = get_flc(1, stream);
  }
  decoder_info->bitdepth = get_flc(1, stream) ? 10 : 8;
  if (decoder_info->bitdepth == 10)
    decoder_info->bitdepth += 2 * get_flc(1, stream);
  decoder_info->input_bitdepth = get_flc(1, stream) ? 10 : 8;
  if (decoder_info->input_bitdepth == 10)
    decoder_info->input_bitdepth += 2 * get_flc(1, stream);
}
","1. void read_sequence_header(decoder_info_t *decoder_info, stream_t *stream) {
2. decoder_info->max_num_ref = get_flc(2, stream) + 1;
3. decoder_info->qmtx_offset = get_flc(6, stream) - 32;
4. decoder_info->bitdepth += 2 * get_flc(1, stream);","1
8
17
30","CWE-1077,CWE-119"
pp_mil_k24-53444521223736,"static void pp_mil_k24(fp24_t r, ep4_t *t, ep4_t *q, ep_t *p, int m, bn_t a) {
	fp24_t l;
	ep_t *_p = RLC_ALLOCA(ep_t, m);
	ep4_t *_q = RLC_ALLOCA(ep4_t, m);
	size_t len = bn_bits(a) + 1;
	int i, j;
	int8_t s[RLC_FP_BITS + 1];

	if (m == 0) {
		return;
	}

	fp24_null(l);

	RLC_TRY {
		fp24_new(l);
		if (_p == NULL || _q == NULL) {
			RLC_THROW(ERR_NO_MEMORY);
		}
		for (j = 0; j < m; j++) {
			ep_null(_p[j]);
			ep4_null(_q[j]);
			ep_new(_p[j]);
			ep4_new(_q[j]);
			ep4_copy(t[j], q[j]);
			ep4_neg(_q[j], q[j]);
#if EP_ADD == BASIC
			ep_neg(_p[j], p[j]);
#else
			fp_add(_p[j]->x, p[j]->x, p[j]->x);
			fp_add(_p[j]->x, _p[j]->x, p[j]->x);
			fp_neg(_p[j]->y, p[j]->y);
#endif
		}

		fp24_zero(l);
		bn_rec_naf(s, &len, a, 2);
		pp_dbl_k24(r, t[0], t[0], _p[0]);
		for (j = 1; j < m; j++) {
			pp_dbl_k24(l, t[j], t[j], _p[j]);
			fp24_mul_dxs(r, r, l);
		}
		if (s[len - 2] > 0) {
			for (j = 0; j < m; j++) {
				pp_add_k24(l, t[j], q[j], p[j]);
				fp24_mul_dxs(r, r, l);
			}
		}
		if (s[len - 2] < 0) {
			for (j = 0; j < m; j++) {
				pp_add_k24(l, t[j], _q[j], p[j]);
				fp24_mul_dxs(r, r, l);
			}
		}

		for (i = len - 3; i >= 0; i--) {
			fp24_sqr(r, r);
			for (j = 0; j < m; j++) {
				pp_dbl_k24(l, t[j], t[j], _p[j]);
				fp24_mul_dxs(r, r, l);
				if (s[i] > 0) {
					pp_add_k24(l, t[j], q[j], p[j]);
					fp24_mul_dxs(r, r, l);
				}
				if (s[i] < 0) {
					pp_add_k24(l, t[j], _q[j], p[j]);
					fp24_mul_dxs(r, r, l);
				}
			}
		}
	}
	RLC_CATCH_ANY {
		RLC_THROW(ERR_CAUGHT);
	}
	RLC_FINALLY {
		fp24_free(l);
		for (j = 0; j < m; j++) {
			ep_free(_p[j]);
			ep4_free(_q[j]);
		}
		RLC_FREE(_p);
		RLC_FREE(_q);
	}
}
","1. fp24_t l;
2. size_t len = bn_bits(a) + 1;
3. if (m == 0) {
4. for (j = 0; j < m; j++) {
5. ep4_null(_q[j]);
6. pp_add_k24(l, t[j], _q[j], p[j]);
7. ep4_free(_q[j]);","2
5
9
20
22
66
79","CWE-190,CWE-20,CWE-120,CWE-399"
sanity_check_raw_super-124235306509986,"static int sanity_check_raw_super(struct f2fs_sb_info *sbi,
				struct buffer_head *bh)
{
	struct f2fs_super_block *raw_super = (struct f2fs_super_block *)
					(bh->b_data + F2FS_SUPER_OFFSET);
	struct super_block *sb = sbi->sb;
	unsigned int blocksize;

	if (F2FS_SUPER_MAGIC != le32_to_cpu(raw_super->magic)) {
		f2fs_msg(sb, KERN_INFO,
			""Magic Mismatch, valid(0x%x) - read(0x%x)"",
			F2FS_SUPER_MAGIC, le32_to_cpu(raw_super->magic));
		return 1;
	}

	
	if (F2FS_BLKSIZE != PAGE_SIZE) {
		f2fs_msg(sb, KERN_INFO,
			""Invalid page_cache_size (%lu), supports only 4KB\n"",
			PAGE_SIZE);
		return 1;
	}

	
	blocksize = 1 << le32_to_cpu(raw_super->log_blocksize);
	if (blocksize != F2FS_BLKSIZE) {
		f2fs_msg(sb, KERN_INFO,
			""Invalid blocksize (%u), supports only 4KB\n"",
			blocksize);
		return 1;
	}

	
	if (le32_to_cpu(raw_super->log_blocks_per_seg) != 9) {
		f2fs_msg(sb, KERN_INFO,
			""Invalid log blocks per segment (%u)\n"",
			le32_to_cpu(raw_super->log_blocks_per_seg));
		return 1;
	}

	
	if (le32_to_cpu(raw_super->log_sectorsize) >
				F2FS_MAX_LOG_SECTOR_SIZE ||
		le32_to_cpu(raw_super->log_sectorsize) <
				F2FS_MIN_LOG_SECTOR_SIZE) {
		f2fs_msg(sb, KERN_INFO, ""Invalid log sectorsize (%u)"",
			le32_to_cpu(raw_super->log_sectorsize));
		return 1;
	}
	if (le32_to_cpu(raw_super->log_sectors_per_block) +
		le32_to_cpu(raw_super->log_sectorsize) !=
			F2FS_MAX_LOG_SECTOR_SIZE) {
		f2fs_msg(sb, KERN_INFO,
			""Invalid log sectors per block(%u) log sectorsize(%u)"",
			le32_to_cpu(raw_super->log_sectors_per_block),
			le32_to_cpu(raw_super->log_sectorsize));
		return 1;
	}

	
	if (le32_to_cpu(raw_super->node_ino) != 1 ||
		le32_to_cpu(raw_super->meta_ino) != 2 ||
		le32_to_cpu(raw_super->root_ino) != 3) {
		f2fs_msg(sb, KERN_INFO,
			""Invalid Fs Meta Ino: node(%u) meta(%u) root(%u)"",
			le32_to_cpu(raw_super->node_ino),
			le32_to_cpu(raw_super->meta_ino),
			le32_to_cpu(raw_super->root_ino));
		return 1;
	}

	if (le32_to_cpu(raw_super->segment_count) > F2FS_MAX_SEGMENT) {
		f2fs_msg(sb, KERN_INFO,
			""Invalid segment count (%u)"",
			le32_to_cpu(raw_super->segment_count));
		return 1;
	}

	
	if (sanity_check_area_boundary(sbi, bh))
		return 1;

	return 0;
}
","1. ""Invalid page_cache_size (%lu), supports only 4KB\n"",
2. return 1;
3. F2FS_MIN_LOG_SECTOR_SIZE) {
f2fs_msg(sb, KERN_INFO, ""Invalid log sectorsize (%u)"",
4. return 1;
5. ""Invalid log sectors per block(%u) log sectorsize(%u)"",
6. le32_to_cpu(raw_super->log_sectorsize));
7. le32_to_cpu(raw_super->meta_ino) != 2 ||
8. ""Invalid Fs Meta Ino: node(%u) meta(%u) root(%u)"",
9. f2fs_msg(sb, KERN_INFO,
10. return 1;","19
38
45-46
48
54
56
62
65
73
81","CWE-476,CWE-347,CWE-18,CWE-17"
vcc_getsockopt,"
#define __user

int vcc_getsockopt(struct socket *sock, int level, int optname,
		   char __user *optval, int __user *optlen)
{
	struct atm_vcc *vcc;
	int len;

	if (get_user(len, optlen))
		return -EFAULT;
	if (__SO_LEVEL_MATCH(optname, level) && len != __SO_SIZE(optname))
		return -EINVAL;

	vcc = ATM_SD(sock);
	switch (optname) {
	case SO_ATMQOS:
		if (!test_bit(ATM_VF_HASQOS, &vcc->flags))
			return -EINVAL;
		return copy_to_user(optval, &vcc->qos, sizeof(vcc->qos))
			? -EFAULT : 0;
	case SO_SETCLP:
		return put_user(vcc->atm_options & ATM_ATMOPT_CLP ? 1 : 0,
				(unsigned long __user *)optval) ? -EFAULT : 0;
	case SO_ATMPVC:
	{
		struct sockaddr_atmpvc pvc;
 
 		if (!vcc->dev || !test_bit(ATM_VF_ADDR, &vcc->flags))
 			return -ENOTCONN;
		memset(&pvc, 0, sizeof(pvc));
 		pvc.sap_family = AF_ATMPVC;
 		pvc.sap_addr.itf = vcc->dev->number;
 		pvc.sap_addr.vpi = vcc->vpi;
		pvc.sap_addr.vci = vcc->vci;
		return copy_to_user(optval, &pvc, sizeof(pvc)) ? -EFAULT : 0;
	}
	default:
		if (level == SOL_SOCKET)
			return -EINVAL;
		break;
	}
	if (!vcc->dev || !vcc->dev->ops->getsockopt)
		return -EINVAL;
	return vcc->dev->ops->getsockopt(vcc, level, optname, optval, len);
}
","1. int len;
2. return -EINVAL;
3. return copy_to_user(optval, &vcc->qos, sizeof(vcc->qos))
4. (unsigned long __user *)optval) ? -EFAULT : 0;","8
13
20
24","CWE-120,CWE-200,CWE-125,CWE-416"
__ip6_append_data-137979335826561,"static int __ip6_append_data(struct sock *sk,
			     struct flowi6 *fl6,
			     struct sk_buff_head *queue,
			     struct inet_cork *cork,
			     struct inet6_cork *v6_cork,
			     struct page_frag *pfrag,
			     int getfrag(void *from, char *to, int offset,
					 int len, int odd, struct sk_buff *skb),
			     void *from, int length, int transhdrlen,
			     unsigned int flags, struct ipcm6_cookie *ipc6,
			     const struct sockcm_cookie *sockc)
{
	struct sk_buff *skb, *skb_prev = NULL;
	unsigned int maxfraglen, fragheaderlen, mtu, orig_mtu;
	int exthdrlen = 0;
	int dst_exthdrlen = 0;
	int hh_len;
	int copy;
	int err;
	int offset = 0;
	__u8 tx_flags = 0;
	u32 tskey = 0;
	struct rt6_info *rt = (struct rt6_info *)cork->dst;
	struct ipv6_txoptions *opt = v6_cork->opt;
	int csummode = CHECKSUM_NONE;
	unsigned int maxnonfragsize, headersize;

	skb = skb_peek_tail(queue);
	if (!skb) {
		exthdrlen = opt ? opt->opt_flen : 0;
		dst_exthdrlen = rt->dst.header_len - rt->rt6i_nfheader_len;
	}

	mtu = cork->fragsize;
	orig_mtu = mtu;

	hh_len = LL_RESERVED_SPACE(rt->dst.dev);

	fragheaderlen = sizeof(struct ipv6hdr) + rt->rt6i_nfheader_len +
			(opt ? opt->opt_nflen : 0);
	maxfraglen = ((mtu - fragheaderlen) & ~7) + fragheaderlen -
		     sizeof(struct frag_hdr);

	headersize = sizeof(struct ipv6hdr) +
		     (opt ? opt->opt_flen + opt->opt_nflen : 0) +
		     (dst_allfrag(&rt->dst) ?
		      sizeof(struct frag_hdr) : 0) +
		     rt->rt6i_nfheader_len;

	if (cork->length + length > mtu - headersize && ipc6->dontfrag &&
	    (sk->sk_protocol == IPPROTO_UDP ||
	     sk->sk_protocol == IPPROTO_RAW)) {
		ipv6_local_rxpmtu(sk, fl6, mtu - headersize +
				sizeof(struct ipv6hdr));
		goto emsgsize;
	}

	if (ip6_sk_ignore_df(sk))
		maxnonfragsize = sizeof(struct ipv6hdr) + IPV6_MAXPLEN;
	else
		maxnonfragsize = mtu;

	if (cork->length + length > maxnonfragsize - headersize) {
emsgsize:
		ipv6_local_error(sk, EMSGSIZE, fl6,
				 mtu - headersize +
				 sizeof(struct ipv6hdr));
		return -EMSGSIZE;
	}

	
	if (transhdrlen && sk->sk_protocol == IPPROTO_UDP &&
	    headersize == sizeof(struct ipv6hdr) &&
	    length <= mtu - headersize &&
	    !(flags & MSG_MORE) &&
	    rt->dst.dev->features & (NETIF_F_IPV6_CSUM | NETIF_F_HW_CSUM))
		csummode = CHECKSUM_PARTIAL;

	if (sk->sk_type == SOCK_DGRAM || sk->sk_type == SOCK_RAW) {
		sock_tx_timestamp(sk, sockc->tsflags, &tx_flags);
		if (tx_flags & SKBTX_ANY_SW_TSTAMP &&
		    sk->sk_tsflags & SOF_TIMESTAMPING_OPT_ID)
			tskey = sk->sk_tskey++;
	}

	

	cork->length += length;
	if ((((length + fragheaderlen) > mtu) ||
	     (skb && skb_is_gso(skb))) &&
	    (sk->sk_protocol == IPPROTO_UDP) &&
	    (rt->dst.dev->features & NETIF_F_UFO) && !dst_xfrm(&rt->dst) &&
	    (sk->sk_type == SOCK_DGRAM) && !udp_get_no_check6_tx(sk)) {
		err = ip6_ufo_append_data(sk, queue, getfrag, from, length,
					  hh_len, fragheaderlen, exthdrlen,
					  transhdrlen, mtu, flags, fl6);
		if (err)
			goto error;
		return 0;
	}

	if (!skb)
		goto alloc_new_skb;

	while (length > 0) {
		
		copy = (cork->length <= mtu && !(cork->flags & IPCORK_ALLFRAG) ? mtu : maxfraglen) - skb->len;
		if (copy < length)
			copy = maxfraglen - skb->len;

		if (copy <= 0) {
			char *data;
			unsigned int datalen;
			unsigned int fraglen;
			unsigned int fraggap;
			unsigned int alloclen;
alloc_new_skb:
			
			if (skb)
				fraggap = skb->len - maxfraglen;
			else
				fraggap = 0;
			
			if (!skb || !skb_prev)
				ip6_append_data_mtu(&mtu, &maxfraglen,
						    fragheaderlen, skb, rt,
						    orig_mtu);

			skb_prev = skb;

			
			datalen = length + fraggap;

			if (datalen > (cork->length <= mtu && !(cork->flags & IPCORK_ALLFRAG) ? mtu : maxfraglen) - fragheaderlen)
				datalen = maxfraglen - fragheaderlen - rt->dst.trailer_len;
			if ((flags & MSG_MORE) &&
			    !(rt->dst.dev->features&NETIF_F_SG))
				alloclen = mtu;
			else
				alloclen = datalen + fragheaderlen;

			alloclen += dst_exthdrlen;

			if (datalen != length + fraggap) {
				
				datalen += rt->dst.trailer_len;
			}

			alloclen += rt->dst.trailer_len;
			fraglen = datalen + fragheaderlen;

			
			alloclen += sizeof(struct frag_hdr);

			copy = datalen - transhdrlen - fraggap;
			if (copy < 0) {
				err = -EINVAL;
				goto error;
			}
			if (transhdrlen) {
				skb = sock_alloc_send_skb(sk,
						alloclen + hh_len,
						(flags & MSG_DONTWAIT), &err);
			} else {
				skb = NULL;
				if (atomic_read(&sk->sk_wmem_alloc) <=
				    2 * sk->sk_sndbuf)
					skb = sock_wmalloc(sk,
							   alloclen + hh_len, 1,
							   sk->sk_allocation);
				if (unlikely(!skb))
					err = -ENOBUFS;
			}
			if (!skb)
				goto error;
			
			skb->protocol = htons(ETH_P_IPV6);
			skb->ip_summed = csummode;
			skb->csum = 0;
			
			skb_reserve(skb, hh_len + sizeof(struct frag_hdr) +
				    dst_exthdrlen);

			
			skb_shinfo(skb)->tx_flags = tx_flags;
			tx_flags = 0;
			skb_shinfo(skb)->tskey = tskey;
			tskey = 0;

			
			data = skb_put(skb, fraglen);
			skb_set_network_header(skb, exthdrlen);
			data += fragheaderlen;
			skb->transport_header = (skb->network_header +
						 fragheaderlen);
			if (fraggap) {
				skb->csum = skb_copy_and_csum_bits(
					skb_prev, maxfraglen,
					data + transhdrlen, fraggap, 0);
				skb_prev->csum = csum_sub(skb_prev->csum,
							  skb->csum);
				data += fraggap;
				pskb_trim_unique(skb_prev, maxfraglen);
			}
			if (copy > 0 &&
			    getfrag(from, data + transhdrlen, offset,
				    copy, fraggap, skb) < 0) {
				err = -EFAULT;
				kfree_skb(skb);
				goto error;
			}

			offset += copy;
			length -= datalen - fraggap;
			transhdrlen = 0;
			exthdrlen = 0;
			dst_exthdrlen = 0;

			if ((flags & MSG_CONFIRM) && !skb_prev)
				skb_set_dst_pending_confirm(skb, 1);

			
			__skb_queue_tail(queue, skb);
			continue;
		}

		if (copy > length)
			copy = length;

		if (!(rt->dst.dev->features&NETIF_F_SG)) {
			unsigned int off;

			off = skb->len;
			if (getfrag(from, skb_put(skb, copy),
						offset, copy, off, skb) < 0) {
				__skb_trim(skb, off);
				err = -EFAULT;
				goto error;
			}
		} else {
			int i = skb_shinfo(skb)->nr_frags;

			err = -ENOMEM;
			if (!sk_page_frag_refill(sk, pfrag))
				goto error;

			if (!skb_can_coalesce(skb, i, pfrag->page,
					      pfrag->offset)) {
				err = -EMSGSIZE;
				if (i == MAX_SKB_FRAGS)
					goto error;

				__skb_fill_page_desc(skb, i, pfrag->page,
						     pfrag->offset, 0);
				skb_shinfo(skb)->nr_frags = ++i;
				get_page(pfrag->page);
			}
			copy = min_t(int, copy, pfrag->size - pfrag->offset);
			if (getfrag(from,
				    page_address(pfrag->page) + pfrag->offset,
				    offset, copy, skb->len, skb) < 0)
				goto error_efault;

			pfrag->offset += copy;
			skb_frag_size_add(&skb_shinfo(skb)->frags[i - 1], copy);
			skb->len += copy;
			skb->data_len += copy;
			skb->truesize += copy;
			atomic_add(copy, &sk->sk_wmem_alloc);
		}
		offset += copy;
		length -= copy;
	}

	return 0;

error_efault:
	err = -EFAULT;
error:
	cork->length -= length;
	IP6_INC_STATS(sock_net(sk), rt->rt6i_idev, IPSTATS_MIB_OUTDISCARDS);
	return err;
}
","1. struct sk_buff_head *queue,
2. int exthdrlen = 0;
int dst_exthdrlen = 0;
3. int err;
4. (opt ? opt->opt_flen + opt->opt_nflen : 0) +
5. (sk->sk_protocol == IPPROTO_UDP ||
6. maxnonfragsize = mtu;
7. emsgsize:
ipv6_local_error(sk, EMSGSIZE, fl6,
8. csummode = CHECKSUM_PARTIAL;
9. (skb && skb_is_gso(skb))) &&
(sk->sk_protocol == IPPROTO_UDP) &&
10. return 0;
11. copy = (cork->length <= mtu && !(cork->flags & IPCORK_ALLFRAG) ? mtu : maxfraglen) - skb->len;
12. copy = maxfraglen - skb->len;
13. if (copy <= 0) {
char *data;
14. datalen = length + fraggap;
15. alloclen = datalen + fragheaderlen;
16. if (datalen != length + fraggap) {
17. copy = datalen - transhdrlen - fraggap;
18. alloclen + hh_len,
19. if (atomic_read(&sk->sk_wmem_alloc) <=
20. goto error;
21. dst_exthdrlen);
22. tskey = 0;
23. skb->transport_header = (skb->network_header +
24. if (fraggap) {
skb->csum = skb_copy_and_csum_bits(
25. unsigned int off;
26. off = skb->len;
27. __skb_trim(skb, off);
err = -EFAULT;
28. int i = skb_shinfo(skb)->nr_frags;
29. if (getfrag(from,
30. length -= copy;","3
15-16
19
45
51
61
64-65
79
106-107
115
123
125
127-128
151
159
163
181
188
192
201
210
216
224
226-227
263
265
268-269
273
291
304","CWE-20,CWE-17,CWE-125"
grub_ext2_read_block-58678646090321,"static grub_disk_addr_t
grub_ext2_read_block (grub_fshelp_node_t node, grub_disk_addr_t fileblock)
{
  struct grub_ext2_data *data = node->data;
  struct grub_ext2_inode *inode = &node->inode;
  int blknr = -1;
  unsigned int blksz = EXT2_BLOCK_SIZE (data);
  int log2_blksz = LOG2_EXT2_BLOCK_SIZE (data);

  if (grub_le_to_cpu32(inode->flags) & EXT4_EXTENTS_FLAG)
    {
#ifndef _MSC_VER
	  char buf[EXT2_BLOCK_SIZE (data)];
#else
	  char * buf = grub_malloc (EXT2_BLOCK_SIZE(data));
#endif
      struct grub_ext4_extent_header *leaf;
      struct grub_ext4_extent *ext;
      int i;

      leaf = grub_ext4_find_leaf (data, buf,
		  (struct grub_ext4_extent_header *) inode->blocks.dir_blocks,
		  fileblock);
      if (! leaf)
        {
          grub_error (GRUB_ERR_BAD_FS, ""invalid extent"");
          return -1;
        }

      ext = (struct grub_ext4_extent *) (leaf + 1);
      for (i = 0; i < grub_le_to_cpu16 (leaf->entries); i++)
        {
          if (fileblock < grub_le_to_cpu32 (ext[i].block))
            break;
        }

      if (--i >= 0)
        {
          fileblock -= grub_le_to_cpu32 (ext[i].block);
          if (fileblock >= grub_le_to_cpu16 (ext[i].len))
            return 0;
          else
            {
              grub_disk_addr_t start;

              start = grub_le_to_cpu16 (ext[i].start_hi);
              start = (start << 32) + grub_le_to_cpu32 (ext[i].start);

              return fileblock + start;
            }
        }
      else
        {
          grub_error (GRUB_ERR_BAD_FS, ""something wrong with extent"");
          return -1;
        }
    }
  
  if (fileblock < INDIRECT_BLOCKS) {
    blknr = grub_le_to_cpu32 (inode->blocks.dir_blocks[fileblock]);
  
  } else if (fileblock < INDIRECT_BLOCKS + blksz / 4)
    {
      grub_uint32_t *indir;

      indir = grub_malloc (blksz);
      if (! indir)
	return grub_errno;

      if (grub_disk_read (data->disk,
			  ((grub_disk_addr_t)
			   grub_le_to_cpu32 (inode->blocks.indir_block))
			  << log2_blksz,
			  0, blksz, indir))
	return grub_errno;

      blknr = grub_le_to_cpu32 (indir[fileblock - INDIRECT_BLOCKS]);
      grub_free (indir);
    }
  
  else if (fileblock < (grub_disk_addr_t)(INDIRECT_BLOCKS + blksz / 4) \
		  * (grub_disk_addr_t)(blksz / 4 + 1))
    {
      unsigned int perblock = blksz / 4;
      unsigned int rblock = fileblock - (INDIRECT_BLOCKS
					 + blksz / 4);
      grub_uint32_t *indir;

      indir = grub_malloc (blksz);
      if (! indir)
	return grub_errno;

      if (grub_disk_read (data->disk,
			  ((grub_disk_addr_t)
			   grub_le_to_cpu32 (inode->blocks.double_indir_block))
			  << log2_blksz,
			  0, blksz, indir))
	return grub_errno;

      if (grub_disk_read (data->disk,
			  ((grub_disk_addr_t)
			   grub_le_to_cpu32 (indir[rblock / perblock]))
			  << log2_blksz,
			  0, blksz, indir))
	return grub_errno;

      blknr = grub_le_to_cpu32 (indir[rblock % perblock]);
            grub_free (indir);
    }
  
  else
    {
      grub_error (GRUB_ERR_NOT_IMPLEMENTED_YET,
		  ""ext2fs doesn't support triple indirect blocks"");
    }

  return blknr;
}
","1. static grub_disk_addr_t
2. struct grub_ext2_data *data = node->data;
3. unsigned int blksz = EXT2_BLOCK_SIZE (data);
4. (struct grub_ext4_extent_header *) inode->blocks.dir_blocks,
5. if (fileblock >= grub_le_to_cpu16 (ext[i].len))
return 0;
6. unsigned int rblock = fileblock - (INDIRECT_BLOCKS
+ blksz / 4);
grub_uint32_t *indir;
7. << log2_blksz,
8. return grub_errno;
9. ""ext2fs doesn't support triple indirect blocks"");
10. return blknr;","1
4
7
22
40-41
85-87
96
98
114
117","CWE-125,CWE-787,CWE-119"
bit_write_MC-147477474788625,"
#define BITCODE_MC
#define Bit_Chain

void
bit_write_MC (Bit_Chain *dat, BITCODE_MC val)
{
  int i, j;
  int negative = 0;
  unsigned char byte[5];
  BITCODE_UMC mask = 0x0000007f;
  BITCODE_UMC value = (BITCODE_UMC)val;

  if (val < 0)
    {
      negative = 1;
      value = (BITCODE_UMC)-val;
    }
  for (i = 4, j = 0; i >= 0; i--, j += 7)
    {
      byte[i] = (unsigned char)((value & mask) >> j);
      byte[i] |= 0x80;
      mask = mask << 7;
    }
  for (i = 0; i < 4; i++)
    if (byte[i] & 0x7f)
      break;

  if (byte[i] & 0x40 && i > 0)
    i--;
  byte[i] &= 0x7f;
  if (negative)
    byte[i] |= 0x40;
  for (j = 4; j >= i; j--)
    bit_write_RC (dat, byte[j]);
}
","1. bit_write_MC (Bit_Chain *dat, BITCODE_MC val)
2. BITCODE_UMC mask = 0x0000007f;
3. negative = 1;
value = (BITCODE_UMC)-val;
4. for (i = 4, j = 0; i >= 0; i--, j += 7)
5. byte[i] = (unsigned char)((value & mask) >> j);
byte[i] |= 0x80;
mask = mask << 7;
6. if (byte[i] & 0x7f)
7. i--;
8. byte[i] |= 0x40;","6
11
16-17
19
21-23
26
30
33","CWE-119,CWE-125,CWE-189"
Load_SBit_Png,"
#define FT_Bool
#define FT_Byte
#define FT_GlyphSlot
#define FT_Int
#define FT_Memory
#define FT_UInt
#define TT_SBit_Metrics

  Load_SBit_Png( FT_GlyphSlot     slot,
                 FT_Int           x_offset,
                 FT_Int           y_offset,
                 FT_Int           pix_bits,
                 TT_SBit_Metrics  metrics,
                 FT_Memory        memory,
                 FT_Byte*         data,
                 FT_UInt          png_len,
                 FT_Bool          populate_map_and_metrics )
  {
    FT_Bitmap    *map   = &slot->bitmap;
    FT_Error      error = FT_Err_Ok;
    FT_StreamRec  stream;

    png_structp  png;
    png_infop    info;
    png_uint_32  imgWidth, imgHeight;

    int         bitdepth, color_type, interlace;
    FT_Int      i;
    png_byte*  *rows = NULL; 


    if ( x_offset < 0 ||
         y_offset < 0 )
    {
      error = FT_THROW( Invalid_Argument );
       goto Exit;
     }
 
    if ( !populate_map_and_metrics                            &&
         ( (FT_UInt)x_offset + metrics->width  > map->width ||
           (FT_UInt)y_offset + metrics->height > map->rows  ||
           pix_bits != 32                                   ||
           map->pixel_mode != FT_PIXEL_MODE_BGRA            ) )
     {
       error = FT_THROW( Invalid_Argument );
       goto Exit;
    }

    FT_Stream_OpenMemory( &stream, data, png_len );

    png = png_create_read_struct( PNG_LIBPNG_VER_STRING,
                                  &error,
                                  error_callback,
                                  warning_callback );
    if ( !png )
    {
      error = FT_THROW( Out_Of_Memory );
      goto Exit;
    }

    info = png_create_info_struct( png );
    if ( !info )
    {
      error = FT_THROW( Out_Of_Memory );
      png_destroy_read_struct( &png, NULL, NULL );
      goto Exit;
    }

    if ( ft_setjmp( png_jmpbuf( png ) ) )
    {
      error = FT_THROW( Invalid_File_Format );
      goto DestroyExit;
    }

    png_set_read_fn( png, &stream, read_data_from_FT_Stream );

    png_read_info( png, info );
    png_get_IHDR( png, info,
                  &imgWidth, &imgHeight,
                  &bitdepth, &color_type, &interlace,
                  NULL, NULL );

    if ( error                                        ||
         ( !populate_map_and_metrics                &&
           ( (FT_Int)imgWidth  != metrics->width  ||
             (FT_Int)imgHeight != metrics->height ) ) )
      goto DestroyExit;

    if ( populate_map_and_metrics )
    {
      FT_Long  size;


      metrics->width  = (FT_Int)imgWidth;
      metrics->height = (FT_Int)imgHeight;

      map->width      = metrics->width;
      map->rows       = metrics->height;
      map->pixel_mode = FT_PIXEL_MODE_BGRA;
      map->pitch      = map->width * 4;
      map->num_grays  = 256;

      
      if ( map->rows > 0x7FFF || map->width > 0x7FFF )
      {
        error = FT_THROW( Array_Too_Large );
        goto DestroyExit;
      }

      size = map->rows * map->pitch;

      error = ft_glyphslot_alloc_bitmap( slot, size );
      if ( error )
        goto DestroyExit;
    }

    
    if ( color_type == PNG_COLOR_TYPE_PALETTE )
      png_set_palette_to_rgb( png );

    
    if ( color_type == PNG_COLOR_TYPE_GRAY )
    {
#if PNG_LIBPNG_VER >= 10209
      png_set_expand_gray_1_2_4_to_8( png );
#else
      png_set_gray_1_2_4_to_8( png );
#endif
    }

    
    if ( png_get_valid(png, info, PNG_INFO_tRNS ) )
      png_set_tRNS_to_alpha( png );

    if ( bitdepth == 16 )
      png_set_strip_16( png );

    if ( bitdepth < 8 )
      png_set_packing( png );

    
    if ( color_type == PNG_COLOR_TYPE_GRAY       ||
         color_type == PNG_COLOR_TYPE_GRAY_ALPHA )
      png_set_gray_to_rgb( png );

    if ( interlace != PNG_INTERLACE_NONE )
      png_set_interlace_handling( png );

    png_set_filler( png, 0xFF, PNG_FILLER_AFTER );

    
    png_read_update_info(png, info );
    png_get_IHDR( png, info,
                  &imgWidth, &imgHeight,
                  &bitdepth, &color_type, &interlace,
                  NULL, NULL );

    if ( bitdepth != 8                              ||
        !( color_type == PNG_COLOR_TYPE_RGB       ||
           color_type == PNG_COLOR_TYPE_RGB_ALPHA ) )
    {
      error = FT_THROW( Invalid_File_Format );
      goto DestroyExit;
    }

    switch ( color_type )
    {
    default:
      

    case PNG_COLOR_TYPE_RGB_ALPHA:
      png_set_read_user_transform_fn( png, premultiply_data );
      break;

    case PNG_COLOR_TYPE_RGB:
      
      png_set_read_user_transform_fn( png, convert_bytes_to_data );
      break;
    }

    if ( FT_NEW_ARRAY( rows, imgHeight ) )
    {
      error = FT_THROW( Out_Of_Memory );
      goto DestroyExit;
    }

    for ( i = 0; i < (FT_Int)imgHeight; i++ )
      rows[i] = map->buffer + ( y_offset + i ) * map->pitch + x_offset * 4;

    png_read_image( png, rows );

    FT_FREE( rows );

    png_read_end( png, info );

  DestroyExit:
    png_destroy_read_struct( &png, &info, NULL );
    FT_Stream_Close( &stream );

  Exit:
    return error;
  }
","1. png_byte*  *rows = NULL;
2. error = FT_THROW( Invalid_Argument );
3. png = png_create_read_struct( PNG_LIBPNG_VER_STRING,
4. if ( error                                        ||
5. if ( populate_map_and_metrics )
6. map->pixel_mode = FT_PIXEL_MODE_BGRA;
7. png_set_gray_1_2_4_to_8( png );
8. png_set_tRNS_to_alpha( png );
9. png_read_update_info(png, info );
10. if ( bitdepth != 8                              ||
11. default:
12. for ( i = 0; i < (FT_Int)imgHeight; i++ )","30
36
52
84
90
100
128
134
153
159
169
188","CWE-476,CWE-522,CWE-824,CWE-200"
__kvm_migrate_pit_timer-176469059872255,"void __kvm_migrate_pit_timer(struct kvm_vcpu *vcpu)
{
	struct kvm_pit *pit = vcpu->kvm->arch.vpit;
	struct hrtimer *timer;

	if (!kvm_vcpu_is_bsp(vcpu) || !pit)
		return;

	timer = &pit->pit_state.timer;
	mutex_lock(&pit->pit_state.lock);
	if (hrtimer_cancel(timer))
		hrtimer_start_expires(timer, HRTIMER_MODE_ABS);
	mutex_unlock(&pit->pit_state.lock);
}
","1. void __kvm_migrate_pit_timer(struct kvm_vcpu *vcpu)
2. struct kvm_pit *pit = vcpu->kvm->arch.vpit;
3. if (!kvm_vcpu_is_bsp(vcpu) || !pit)
4. timer = &pit->pit_state.timer;
mutex_lock(&pit->pit_state.lock);
if (hrtimer_cancel(timer))
5. mutex_unlock(&pit->pit_state.lock);","1
3
6
9-11
13","CWE-362,CWE-399"
ext4_write_begin-100995105360796,"static int ext4_write_begin(struct file *file, struct address_space *mapping,
			    loff_t pos, unsigned len, unsigned flags,
			    struct page **pagep, void **fsdata)
{
	struct inode *inode = mapping->host;
	int ret, needed_blocks;
	handle_t *handle;
	int retries = 0;
	struct page *page;
	pgoff_t index;
	unsigned from, to;

	trace_ext4_write_begin(inode, pos, len, flags);
	
	needed_blocks = ext4_writepage_trans_blocks(inode) + 1;
	index = pos >> PAGE_CACHE_SHIFT;
	from = pos & (PAGE_CACHE_SIZE - 1);
	to = from + len;

retry:
	handle = ext4_journal_start(inode, needed_blocks);
	if (IS_ERR(handle)) {
		ret = PTR_ERR(handle);
		goto out;
	}

	
	flags |= AOP_FLAG_NOFS;

	page = grab_cache_page_write_begin(mapping, index, flags);
	if (!page) {
		ext4_journal_stop(handle);
		ret = -ENOMEM;
		goto out;
	}
	*pagep = page;

	if (ext4_should_dioread_nolock(inode))
		ret = block_write_begin(file, mapping, pos, len, flags, pagep,
				fsdata, ext4_get_block_write);
	else
		ret = block_write_begin(file, mapping, pos, len, flags, pagep,
				fsdata, ext4_get_block);

	if (!ret && ext4_should_journal_data(inode)) {
		ret = walk_page_buffers(handle, page_buffers(page),
				from, to, NULL, do_journal_get_write_access);
	}

	if (ret) {
		unlock_page(page);
		page_cache_release(page);
		
		if (pos + len > inode->i_size && ext4_can_truncate(inode))
			ext4_orphan_add(handle, inode);

		ext4_journal_stop(handle);
		if (pos + len > inode->i_size) {
			ext4_truncate_failed_write(inode);
			
			if (inode->i_nlink)
				ext4_orphan_del(NULL, inode);
		}
	}

	if (ret == -ENOSPC && ext4_should_retry_alloc(inode->i_sb, &retries))
		goto retry;
out:
	return ret;
}
","1. struct inode *inode = mapping->host;
int ret, needed_blocks;
2. struct page *page;
3. trace_ext4_write_begin(inode, pos, len, flags);
4. needed_blocks = ext4_writepage_trans_blocks(inode) + 1;
index = pos >> PAGE_CACHE_SHIFT;
5. flags |= AOP_FLAG_NOFS;
6. ext4_journal_stop(handle);
ret = -ENOMEM;
goto out;
7. *pagep = page;
8. fsdata, ext4_get_block);
9. if (pos + len > inode->i_size && ext4_can_truncate(inode))
10. ext4_journal_stop(handle);
if (pos + len > inode->i_size) {
ext4_truncate_failed_write(inode);
11. if (inode->i_nlink)
12. goto retry;
out:
return ret;","5-6
9
13
18-19
32
36-38
40
47
65
68-70
77
83-85","CWE-362,CWE-200,CWE-125"
free_ep_req-74327853484104,"static inline void free_ep_req(struct usb_ep *ep, struct usb_request *req)
{
	WARN_ON(req->buf == NULL);
	kfree(req->buf);
	req->buf = NULL;
	usb_ep_free_request(ep, req);
}
","1. static inline void free_ep_req(struct usb_ep *ep, struct usb_request *req)
2. WARN_ON(req->buf == NULL);
kfree(req->buf);
req->buf = NULL;
usb_ep_free_request(ep, req);","1
3-6","CWE-264,CWE-416"
llc_sap_rcv,"static void llc_sap_rcv(struct llc_sap *sap, struct sk_buff *skb,
			struct sock *sk)
{
	struct llc_sap_state_ev *ev = llc_sap_ev(skb);
 
 	ev->type   = LLC_SAP_EV_TYPE_PDU;
 	ev->reason = 0;
	skb_orphan(skb);
	sock_hold(sk);
 	skb->sk = sk;
	skb->destructor = sock_efree;
 	llc_sap_state_process(sap, skb);
 }
","1. struct llc_sap_state_ev *ev = llc_sap_ev(skb);
2. skb_orphan(skb);","4
8","CWE-200,CWE-284"
labeljumps-147343806156532,"
#define JF

static void labeljumps(JF, js_Ast *stm, int baddr, int caddr)
{
	js_JumpList *jump = stm->jumps;
	while (jump) {
		js_JumpList *next = jump->next;
		if (jump->type == STM_BREAK)
			labelto(J, F, jump->inst, baddr);
		if (jump->type == STM_CONTINUE)
			labelto(J, F, jump->inst, caddr);
		js_free(J, jump);
		jump = next;
	}
	stm->jumps = NULL;
}
","1. static void labeljumps(JF, js_Ast *stm, int baddr, int caddr)
2. js_JumpList *next = jump->next;
3. if (jump->type == STM_CONTINUE)
4. js_free(J, jump);
jump = next;
5. stm->jumps = NULL;","4
8
11
13-14
16","CWE-362,CWE-287,CWE-119"
snd_timer_open-241907369367492,"int snd_timer_open(struct snd_timer_instance **ti,
		   char *owner, struct snd_timer_id *tid,
		   unsigned int slave_id)
{
	struct snd_timer *timer;
	struct snd_timer_instance *timeri = NULL;
	struct device *card_dev_to_put = NULL;
	int err;

	mutex_lock(&register_mutex);
	if (tid->dev_class == SNDRV_TIMER_CLASS_SLAVE) {
		
		if (tid->dev_sclass <= SNDRV_TIMER_SCLASS_NONE ||
		    tid->dev_sclass > SNDRV_TIMER_SCLASS_OSS_SEQUENCER) {
			pr_debug(""ALSA: timer: invalid slave class %i\n"",
				 tid->dev_sclass);
			err = -EINVAL;
			goto unlock;
		}
		timeri = snd_timer_instance_new(owner, NULL);
		if (!timeri) {
			err = -ENOMEM;
			goto unlock;
		}
		timeri->slave_class = tid->dev_sclass;
		timeri->slave_id = tid->device;
		timeri->flags |= SNDRV_TIMER_IFLG_SLAVE;
		list_add_tail(&timeri->open_list, &snd_timer_slave_list);
		err = snd_timer_check_slave(timeri);
		if (err < 0) {
			snd_timer_close_locked(timeri, &card_dev_to_put);
			timeri = NULL;
		}
		goto unlock;
	}

	
	timer = snd_timer_find(tid);
#ifdef CONFIG_MODULES
	if (!timer) {
		mutex_unlock(&register_mutex);
		snd_timer_request(tid);
		mutex_lock(&register_mutex);
		timer = snd_timer_find(tid);
	}
#endif
	if (!timer) {
		err = -ENODEV;
		goto unlock;
	}
	if (!list_empty(&timer->open_list_head)) {
		struct snd_timer_instance *t =
			list_entry(timer->open_list_head.next,
				    struct snd_timer_instance, open_list);
		if (t->flags & SNDRV_TIMER_IFLG_EXCLUSIVE) {
			err = -EBUSY;
			goto unlock;
		}
	}
	if (timer->num_instances >= timer->max_instances) {
		err = -EBUSY;
		goto unlock;
	}
	timeri = snd_timer_instance_new(owner, timer);
	if (!timeri) {
		err = -ENOMEM;
		goto unlock;
	}
	
	if (timer->card)
		get_device(&timer->card->card_dev);
	timeri->slave_class = tid->dev_sclass;
	timeri->slave_id = slave_id;

	if (list_empty(&timer->open_list_head) && timer->hw.open) {
		err = timer->hw.open(timer);
		if (err) {
			kfree(timeri->owner);
			kfree(timeri);
			timeri = NULL;

			if (timer->card)
				card_dev_to_put = &timer->card->card_dev;
			module_put(timer->module);
			goto unlock;
		}
	}

	list_add_tail(&timeri->open_list, &timer->open_list_head);
	timer->num_instances++;
	err = snd_timer_check_master(timeri);
	if (err < 0) {
		snd_timer_close_locked(timeri, &card_dev_to_put);
		timeri = NULL;
	}

 unlock:
	mutex_unlock(&register_mutex);
	
	if (card_dev_to_put)
		put_device(card_dev_to_put);
	*ti = timeri;
	return err;
}
","1. tid->dev_sclass > SNDRV_TIMER_SCLASS_OSS_SEQUENCER) {
2. timer = snd_timer_find(tid);
3. goto unlock;
4. goto unlock;
5. timeri = snd_timer_instance_new(owner, timer);
if (!timeri) {
6. timeri = NULL;
7. put_device(card_dev_to_put);","14
38
49
57
64-65
94
101","CWE-191,CWE-362,CWE-20,CWE-78"
cdf_read_property_info_1-226494136856714,"int
cdf_read_property_info_1(const cdf_stream_t *sst, const cdf_header_t *h,
    uint32_t offs, cdf_property_info_t **info, size_t *count, size_t *maxcount)
{
	const cdf_section_header_t *shp;
	cdf_section_header_t sh;
	const uint8_t *p, *q, *e;
	int16_t s16;
	int32_t s32;
	uint32_t u32;
	int64_t s64;
	uint64_t u64;
	cdf_timestamp_t tp;
	size_t i, o, o4, nelements, j;
	cdf_property_info_t *inp;

	if (offs > UINT32_MAX / 4) {
		errno = EFTYPE;
		goto out;
	}
	shp = CAST(const cdf_section_header_t *, (const void *)
	    ((const char *)sst->sst_tab + offs));
	if (cdf_check_stream_offset(sst, h, shp, sizeof(*shp), __LINE__) == -1)
		goto out;
	sh.sh_len = CDF_TOLE4(shp->sh_len);
#define CDF_SHLEN_LIMIT (UINT32_MAX / 8)
	if (sh.sh_len > CDF_SHLEN_LIMIT) {
		errno = EFTYPE;
		goto out;
	}
	sh.sh_properties = CDF_TOLE4(shp->sh_properties);
#define CDF_PROP_LIMIT (UINT32_MAX / (4 * sizeof(*inp)))
	if (sh.sh_properties > CDF_PROP_LIMIT)
		goto out;
	DPRINTF((""section len: %u properties %u\n"", sh.sh_len,
	    sh.sh_properties));
	if (*maxcount) {
		if (*maxcount > CDF_PROP_LIMIT)
			goto out;
		*maxcount += sh.sh_properties;
		inp = CAST(cdf_property_info_t *,
		    realloc(*info, *maxcount * sizeof(*inp)));
	} else {
		*maxcount = sh.sh_properties;
		inp = CAST(cdf_property_info_t *,
		    malloc(*maxcount * sizeof(*inp)));
	}
	if (inp == NULL)
		goto out;
	*info = inp;
	inp += *count;
	*count += sh.sh_properties;
	p = CAST(const uint8_t *, (const void *)
	    ((const char *)(const void *)sst->sst_tab +
	    offs + sizeof(sh)));
	e = CAST(const uint8_t *, (const void *)
	    (((const char *)(const void *)shp) + sh.sh_len));
	if (cdf_check_stream_offset(sst, h, e, 0, __LINE__) == -1)
		goto out;
	for (i = 0; i < sh.sh_properties; i++) {
		size_t ofs = CDF_GETUINT32(p, (i << 1) + 1);
		q = (const uint8_t *)(const void *)
		    ((const char *)(const void *)p + ofs
		    - 2 * sizeof(uint32_t));
		if (q > e) {
			DPRINTF((""Ran of the end %p > %p\n"", q, e));
			goto out;
		}
		inp[i].pi_id = CDF_GETUINT32(p, i << 1);
		inp[i].pi_type = CDF_GETUINT32(q, 0);
		DPRINTF((""%"" SIZE_T_FORMAT ""u) id=%x type=%x offs=0x%tx,0x%x\n"",
		    i, inp[i].pi_id, inp[i].pi_type, q - p, offs));
		if (inp[i].pi_type & CDF_VECTOR) {
			nelements = CDF_GETUINT32(q, 1);
			o = 2;
		} else {
			nelements = 1;
			o = 1;
		}
		o4 = o * sizeof(uint32_t);
		if (inp[i].pi_type & (CDF_ARRAY|CDF_BYREF|CDF_RESERVED))
			goto unknown;
		switch (inp[i].pi_type & CDF_TYPEMASK) {
		case CDF_NULL:
		case CDF_EMPTY:
			break;
		case CDF_SIGNED16:
			if (inp[i].pi_type & CDF_VECTOR)
				goto unknown;
			(void)memcpy(&s16, &q[o4], sizeof(s16));
			inp[i].pi_s16 = CDF_TOLE2(s16);
			break;
		case CDF_SIGNED32:
			if (inp[i].pi_type & CDF_VECTOR)
				goto unknown;
			(void)memcpy(&s32, &q[o4], sizeof(s32));
			inp[i].pi_s32 = CDF_TOLE4((uint32_t)s32);
			break;
		case CDF_BOOL:
		case CDF_UNSIGNED32:
			if (inp[i].pi_type & CDF_VECTOR)
				goto unknown;
			(void)memcpy(&u32, &q[o4], sizeof(u32));
			inp[i].pi_u32 = CDF_TOLE4(u32);
			break;
		case CDF_SIGNED64:
			if (inp[i].pi_type & CDF_VECTOR)
				goto unknown;
			(void)memcpy(&s64, &q[o4], sizeof(s64));
			inp[i].pi_s64 = CDF_TOLE8((uint64_t)s64);
			break;
		case CDF_UNSIGNED64:
			if (inp[i].pi_type & CDF_VECTOR)
				goto unknown;
			(void)memcpy(&u64, &q[o4], sizeof(u64));
			inp[i].pi_u64 = CDF_TOLE8((uint64_t)u64);
			break;
		case CDF_FLOAT:
			if (inp[i].pi_type & CDF_VECTOR)
				goto unknown;
			(void)memcpy(&u32, &q[o4], sizeof(u32));
			u32 = CDF_TOLE4(u32);
			memcpy(&inp[i].pi_f, &u32, sizeof(inp[i].pi_f));
			break;
		case CDF_DOUBLE:
			if (inp[i].pi_type & CDF_VECTOR)
				goto unknown;
			(void)memcpy(&u64, &q[o4], sizeof(u64));
			u64 = CDF_TOLE8((uint64_t)u64);
			memcpy(&inp[i].pi_d, &u64, sizeof(inp[i].pi_d));
			break;
		case CDF_LENGTH32_STRING:
		case CDF_LENGTH32_WSTRING:
			if (nelements > 1) {
				size_t nelem = inp - *info;
				if (*maxcount > CDF_PROP_LIMIT
				    || nelements > CDF_PROP_LIMIT)
					goto out;
				*maxcount += nelements;
				inp = CAST(cdf_property_info_t *,
				    realloc(*info, *maxcount * sizeof(*inp)));
				if (inp == NULL)
					goto out;
				*info = inp;
				inp = *info + nelem;
			}
			DPRINTF((""nelements = %"" SIZE_T_FORMAT ""u\n"",
			    nelements));
			for (j = 0; j < nelements; j++, i++) {
				uint32_t l = CDF_GETUINT32(q, o);
				inp[i].pi_str.s_len = l;
				inp[i].pi_str.s_buf = (const char *)
				    (const void *)(&q[o4 + sizeof(l)]);
				DPRINTF((""l = %d, r = %"" SIZE_T_FORMAT
				    ""u, s = %s\n"", l,
				    CDF_ROUND(l, sizeof(l)),
				    inp[i].pi_str.s_buf));
				if (l & 1)
					l++;
				o += l >> 1;
				if (q + o >= e)
					goto out;
				o4 = o * sizeof(uint32_t);
			}
			i--;
			break;
		case CDF_FILETIME:
			if (inp[i].pi_type & CDF_VECTOR)
				goto unknown;
			(void)memcpy(&tp, &q[o4], sizeof(tp));
			inp[i].pi_tp = CDF_TOLE8((uint64_t)tp);
			break;
		case CDF_CLIPBOARD:
			if (inp[i].pi_type & CDF_VECTOR)
				goto unknown;
			break;
		default:
		unknown:
			DPRINTF((""Don't know how to deal with %x\n"",
			    inp[i].pi_type));
			break;
		}
	}
	return 0;
out:
	free(*info);
	return -1;
}
","1. if (offs > UINT32_MAX / 4) {
2. if (sh.sh_properties > CDF_PROP_LIMIT)
3. break;
4. goto unknown;
5. o4 = o * sizeof(uint32_t);
6. unknown:","17
33
98
108
163
178","CWE-20,CWE-189,CWE-119"
i40e_setup_macvlans-268322690809132,"static int i40e_setup_macvlans(struct i40e_vsi *vsi, u16 macvlan_cnt, u16 qcnt,
			       struct net_device *vdev)
{
	struct i40e_pf *pf = vsi->back;
	struct i40e_hw *hw = &pf->hw;
	struct i40e_vsi_context ctxt;
	u16 sections, qmap, num_qps;
	struct i40e_channel *ch;
	int i, pow, ret = 0;
	u8 offset = 0;

	if (vsi->type != I40E_VSI_MAIN || !macvlan_cnt)
		return -EINVAL;

	num_qps = vsi->num_queue_pairs - (macvlan_cnt * qcnt);

	
	pow = fls(roundup_pow_of_two(num_qps) - 1);

	qmap = (offset << I40E_AQ_VSI_TC_QUE_OFFSET_SHIFT) |
		(pow << I40E_AQ_VSI_TC_QUE_NUMBER_SHIFT);

	
	sections = I40E_AQ_VSI_PROP_QUEUE_MAP_VALID;
	sections |= I40E_AQ_VSI_PROP_SCHED_VALID;
	memset(&ctxt, 0, sizeof(ctxt));
	ctxt.seid = vsi->seid;
	ctxt.pf_num = vsi->back->hw.pf_id;
	ctxt.vf_num = 0;
	ctxt.uplink_seid = vsi->uplink_seid;
	ctxt.info = vsi->info;
	ctxt.info.tc_mapping[0] = cpu_to_le16(qmap);
	ctxt.info.mapping_flags |= cpu_to_le16(I40E_AQ_VSI_QUE_MAP_CONTIG);
	ctxt.info.queue_mapping[0] = cpu_to_le16(vsi->base_queue);
	ctxt.info.valid_sections |= cpu_to_le16(sections);

	
	vsi->rss_size = max_t(u16, num_qps, qcnt);
	ret = i40e_vsi_config_rss(vsi);
	if (ret) {
		dev_info(&pf->pdev->dev,
			 ""Failed to reconfig RSS for num_queues (%u)\n"",
			 vsi->rss_size);
		return ret;
	}
	vsi->reconfig_rss = true;
	dev_dbg(&vsi->back->pdev->dev,
		""Reconfigured RSS with num_queues (%u)\n"", vsi->rss_size);
	vsi->next_base_queue = num_qps;
	vsi->cnt_q_avail = vsi->num_queue_pairs - num_qps;

	
	ret = i40e_aq_update_vsi_params(hw, &ctxt, NULL);
	if (ret) {
		dev_info(&pf->pdev->dev,
			 ""Update vsi tc config failed, err %s aq_err %s\n"",
			 i40e_stat_str(hw, ret),
			 i40e_aq_str(hw, hw->aq.asq_last_status));
		return ret;
	}
	
	i40e_vsi_update_queue_map(vsi, &ctxt);
	vsi->info.valid_sections = 0;

	
	INIT_LIST_HEAD(&vsi->macvlan_list);
	for (i = 0; i < macvlan_cnt; i++) {
		ch = kzalloc(sizeof(*ch), GFP_KERNEL);
		if (!ch) {
			ret = -ENOMEM;
			goto err_free;
		}
		INIT_LIST_HEAD(&ch->list);
		ch->num_queue_pairs = qcnt;
		if (!i40e_setup_channel(pf, vsi, ch)) {
			ret = -EINVAL;
			kfree(ch);
			goto err_free;
		}
		ch->parent_vsi = vsi;
		vsi->cnt_q_avail -= ch->num_queue_pairs;
		vsi->macvlan_cnt++;
		list_add_tail(&ch->list, &vsi->macvlan_list);
	}

	return ret;

err_free:
	dev_info(&pf->pdev->dev, ""Failed to setup macvlans\n"");
	i40e_free_macvlan_channels(vsi);

	return ret;
}
","1. struct i40e_pf *pf = vsi->back;
2. u16 sections, qmap, num_qps;
3. ctxt.info = vsi->info;
4. ctxt.info.queue_mapping[0] = cpu_to_le16(vsi->base_queue);
ctxt.info.valid_sections |= cpu_to_le16(sections);
5. ""Failed to reconfig RSS for num_queues (%u)\n"",
6. ""Reconfigured RSS with num_queues (%u)\n"", vsi->rss_size);
7. ret = i40e_aq_update_vsi_params(hw, &ctxt, NULL);
8. i40e_stat_str(hw, ret),
9. return ret;
10. vsi->info.valid_sections = 0;
11. for (i = 0; i < macvlan_cnt; i++) {
12. INIT_LIST_HEAD(&ch->list);
ch->num_queue_pairs = qcnt;
if (!i40e_setup_channel(pf, vsi, ch)) {
13. i40e_free_macvlan_channels(vsi);","4
7
31
34-35
42
48
55
59
61
65
69
75-77
92","CWE-787,CWE-17,CWE-404,CWE-415"
parse_config-258420094395796,"int parse_config(char *filename, bridge_t **bridges)
{
    dictionary *ubridge_config = NULL;
    const char *value;
    const char *bridge_name;
    int i, nsec;

    if ((ubridge_config = iniparser_load(filename, HIDE_ERRORED_LINE_CONTENT)) == NULL) {
       return FALSE;
    }

    nsec = iniparser_getnsec(ubridge_config);
    for (i = 0; i < nsec; i++) {
        bridge_t *bridge;
        nio_t *source_nio = NULL;
        nio_t *destination_nio = NULL;

        bridge_name = iniparser_getsecname(ubridge_config, i);
        printf(""Parsing %s\n"", bridge_name);
        if (getstr(ubridge_config, bridge_name, ""source_udp"", &value))
           source_nio = create_udp_tunnel(value);
        else if (getstr(ubridge_config, bridge_name, ""source_unix"", &value))
           source_nio = create_unix_socket(value);
        else if (getstr(ubridge_config, bridge_name, ""source_ethernet"", &value))
           source_nio = open_ethernet_device(value);
        else if (getstr(ubridge_config, bridge_name, ""source_tap"", &value))
           source_nio = open_tap_device(value);
#ifdef LINUX_RAW
        else if (getstr(ubridge_config, bridge_name, ""source_linux_raw"", &value))
           source_nio = open_linux_raw(value);
#endif
#ifdef __APPLE__
        else if (getstr(ubridge_config, bridge_name, ""source_fusion_vmnet"", &value))
           source_nio = open_fusion_vmnet(value);
#endif
        else
           fprintf(stderr, ""source NIO not found\n"");

        if (getstr(ubridge_config, bridge_name, ""destination_udp"", &value))
           destination_nio = create_udp_tunnel(value);
        else if (getstr(ubridge_config, bridge_name, ""destination_unix"", &value))
           destination_nio = create_unix_socket(value);
        else if (getstr(ubridge_config, bridge_name, ""destination_ethernet"", &value))
           destination_nio = open_ethernet_device(value);
        else if (getstr(ubridge_config, bridge_name, ""destination_tap"", &value))
           destination_nio = open_tap_device(value);
#ifdef LINUX_RAW
        else if (getstr(ubridge_config, bridge_name, ""destination_linux_raw"", &value))
           source_nio = open_linux_raw(value);
#endif
#ifdef __APPLE__
        else if (getstr(ubridge_config, bridge_name, ""destination_fusion_vmnet"", &value))
           destination_nio = open_fusion_vmnet(value);
#endif
        else
           fprintf(stderr, ""destination NIO not found\n"");

        if (source_nio && destination_nio) {
           bridge = add_bridge(bridges);
           bridge->source_nio = source_nio;
           bridge->destination_nio = destination_nio;
           if (!(bridge->name = strdup(bridge_name))) {
              fprintf(stderr, ""bridge creation: insufficient memory\n"");
              return FALSE;
           }
           parse_capture(ubridge_config, bridge_name, bridge);
           parse_filter(ubridge_config, bridge_name, bridge);
        }
        else if (source_nio != NULL)
           free_nio(source_nio);
        else if (destination_nio != NULL)
           free_nio(destination_nio);
    }
    iniparser_freedict(ubridge_config);
    return TRUE;
}
","1. dictionary *ubridge_config = NULL;
2. if ((ubridge_config = iniparser_load(filename, HIDE_ERRORED_LINE_CONTENT)) == NULL) {
3. nsec = iniparser_getnsec(ubridge_config);
4. if (getstr(ubridge_config, bridge_name, ""source_udp"", &value))
5. else if (getstr(ubridge_config, bridge_name, ""source_ethernet"", &value))
6. source_nio = open_tap_device(value);
7. fprintf(stderr, ""source NIO not found\n"");
8. destination_nio = create_udp_tunnel(value);
9. destination_nio = create_unix_socket(value);
10. bridge->source_nio = source_nio;
bridge->destination_nio = destination_nio;
11. fprintf(stderr, ""bridge creation: insufficient memory\n"");
12. parse_capture(ubridge_config, bridge_name, bridge);
13. else if (source_nio != NULL)
14. else if (destination_nio != NULL)
15. iniparser_freedict(ubridge_config);","3
8
12
20
24
27
37
40
42
60-61
63
66
69
71
74","CWE-416,CWE-134,CWE-119"
latm_dmx_process-244153499490981,"
#define GF_Filter

GF_Err latm_dmx_process(GF_Filter *filter)
{
	GF_LATMDmxCtx *ctx = gf_filter_get_udta(filter);
	GF_FilterPacket *pck, *dst_pck;
	u32 pos;
	u8 *data=NULL, *output;
	u32 pck_size=0, prev_pck_size;
	u64 cts = GF_FILTER_NO_TS;

	if (ctx->in_error)
		return ctx->in_error;

	
	if (!ctx->duration.num)
		latm_dmx_check_dur(filter, ctx);

	if (ctx->opid && !ctx->is_playing)
		return GF_OK;

	pck = gf_filter_pid_get_packet(ctx->ipid);
	if (!pck) {
		if (gf_filter_pid_is_eos(ctx->ipid)) {
			if (!ctx->latm_buffer_size) {
				if (ctx->opid)
					gf_filter_pid_set_eos(ctx->opid);
				if (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);
				ctx->src_pck = NULL;
				return GF_EOS;
			}
		} else {
			return GF_OK;
		}
	} else {
		data = (char *) gf_filter_pck_get_data(pck, &pck_size);
	}

	
	if (ctx->timescale && pck) {
		cts = gf_filter_pck_get_cts(pck);
	}

	prev_pck_size = ctx->latm_buffer_size;

	if (pck && !ctx->resume_from) {
		if (ctx->latm_buffer_size + pck_size > ctx->latm_buffer_alloc) {
			ctx->latm_buffer_alloc = ctx->latm_buffer_size + pck_size;
			ctx->latm_buffer = gf_realloc(ctx->latm_buffer, ctx->latm_buffer_alloc);
		}
		memcpy(ctx->latm_buffer + ctx->latm_buffer_size, data, pck_size);
		ctx->latm_buffer_size += pck_size;
	}

	if (!ctx->bs) ctx->bs = gf_bs_new(ctx->latm_buffer, ctx->latm_buffer_size, GF_BITSTREAM_READ);
	else gf_bs_reassign_buffer(ctx->bs, ctx->latm_buffer, ctx->latm_buffer_size);

	if (ctx->resume_from) {
		gf_bs_seek(ctx->bs, ctx->resume_from-1);
		ctx->resume_from = 0;
	}

	if (cts == GF_FILTER_NO_TS)
		prev_pck_size = 0;


	while (1) {
		pos = (u32) gf_bs_get_position(ctx->bs);
		u8 latm_buffer[4096];
		u32 latm_frame_size = 4096;
		if (!latm_dmx_sync_frame_bs(ctx->bs,&ctx->acfg, &latm_frame_size, latm_buffer, NULL)) break;

		if (ctx->in_seek) {
			u64 nb_samples_at_seek = (u64) (ctx->start_range * GF_M4ASampleRates[ctx->sr_idx]);
			if (ctx->cts + ctx->dts_inc >= nb_samples_at_seek) {
				
				ctx->in_seek = GF_FALSE;
			}
		}

		latm_dmx_check_pid(filter, ctx);

		if (!ctx->is_playing) {
			ctx->resume_from = pos+1;
			return GF_OK;
		}

		if (!ctx->in_seek) {
			GF_FilterSAPType sap = GF_FILTER_SAP_1;

			dst_pck = gf_filter_pck_new_alloc(ctx->opid, latm_frame_size, &output);
			if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck);

			memcpy(output, latm_buffer, latm_frame_size);

			gf_filter_pck_set_cts(dst_pck, ctx->cts);
			gf_filter_pck_set_duration(dst_pck, ctx->dts_inc);
			gf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_TRUE);

			
			if (ctx->acfg.base_object_type==GF_CODECID_USAC) {
				if (latm_frame_size && (output[0] & 0x80) && !ctx->prev_sap) {
					sap = GF_FILTER_SAP_1;
					ctx->prev_sap = GF_TRUE;
				} else {
					sap = GF_FILTER_SAP_NONE;
					ctx->prev_sap = GF_FALSE;
				}
			}
			gf_filter_pck_set_sap(dst_pck, sap);

			gf_filter_pck_send(dst_pck);
		}
		latm_dmx_update_cts(ctx);

		if (prev_pck_size) {
			pos = (u32) gf_bs_get_position(ctx->bs);
			if (prev_pck_size<=pos) {
				prev_pck_size=0;
				if (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);
				ctx->src_pck = pck;
				if (pck)
					gf_filter_pck_ref_props(&ctx->src_pck);
			}
		}
	}

	if (pck) {
		pos = (u32) gf_bs_get_position(ctx->bs);
		assert(ctx->latm_buffer_size >= pos);
		memmove(ctx->latm_buffer, ctx->latm_buffer+pos, ctx->latm_buffer_size - pos);
		ctx->latm_buffer_size -= pos;
		gf_filter_pid_drop_packet(ctx->ipid);
		assert(!ctx->resume_from);
	} else {
		ctx->latm_buffer_size = 0;
		return latm_dmx_process(filter);
	}
	return GF_OK;
}
","1. return GF_OK;
2. if (ctx->resume_from) {
3. latm_dmx_check_pid(filter, ctx);","21
59
82","CWE-125,CWE-404,CWE-399"
perf_pmu_register-66204154776721,"int perf_pmu_register(struct pmu *pmu, const char *name, int type)
{
	int cpu, ret;

	mutex_lock(&pmus_lock);
	ret = -ENOMEM;
	pmu->pmu_disable_count = alloc_percpu(int);
	if (!pmu->pmu_disable_count)
		goto unlock;

	pmu->type = -1;
	if (!name)
		goto skip_type;
	pmu->name = name;

	if (type < 0) {
		type = idr_alloc(&pmu_idr, pmu, PERF_TYPE_MAX, 0, GFP_KERNEL);
		if (type < 0) {
			ret = type;
			goto free_pdc;
		}
	}
	pmu->type = type;

	if (pmu_bus_running) {
		ret = pmu_dev_alloc(pmu);
		if (ret)
			goto free_idr;
	}

skip_type:
	pmu->pmu_cpu_context = find_pmu_context(pmu->task_ctx_nr);
	if (pmu->pmu_cpu_context)
		goto got_cpu_context;

	ret = -ENOMEM;
	pmu->pmu_cpu_context = alloc_percpu(struct perf_cpu_context);
	if (!pmu->pmu_cpu_context)
		goto free_dev;

	for_each_possible_cpu(cpu) {
		struct perf_cpu_context *cpuctx;

		cpuctx = per_cpu_ptr(pmu->pmu_cpu_context, cpu);
		__perf_event_init_context(&cpuctx->ctx);
		lockdep_set_class(&cpuctx->ctx.mutex, &cpuctx_mutex);
		lockdep_set_class(&cpuctx->ctx.lock, &cpuctx_lock);
		cpuctx->ctx.pmu = pmu;

		__perf_cpu_hrtimer_init(cpuctx, cpu);

		INIT_LIST_HEAD(&cpuctx->rotation_list);
		cpuctx->unique_pmu = pmu;
	}

got_cpu_context:
	if (!pmu->start_txn) {
		if (pmu->pmu_enable) {
			
			pmu->start_txn  = perf_pmu_start_txn;
			pmu->commit_txn = perf_pmu_commit_txn;
			pmu->cancel_txn = perf_pmu_cancel_txn;
		} else {
			pmu->start_txn  = perf_pmu_nop_void;
			pmu->commit_txn = perf_pmu_nop_int;
			pmu->cancel_txn = perf_pmu_nop_void;
		}
	}

	if (!pmu->pmu_enable) {
		pmu->pmu_enable  = perf_pmu_nop_void;
		pmu->pmu_disable = perf_pmu_nop_void;
	}

	if (!pmu->event_idx)
		pmu->event_idx = perf_event_idx_default;

	list_add_rcu(&pmu->entry, &pmus);
	ret = 0;
unlock:
	mutex_unlock(&pmus_lock);

	return ret;

free_dev:
	device_del(pmu->dev);
	put_device(pmu->dev);

free_idr:
	if (pmu->type >= PERF_TYPE_MAX)
		idr_remove(&pmu_idr, pmu->type);

free_pdc:
	free_percpu(pmu->pmu_disable_count);
	goto unlock;
}
","1. if (!pmu->pmu_disable_count)
2. pmu->type = -1;
3. pmu->name = name;
4. if (!pmu->pmu_enable) {","8
11
14
74","CWE-824,CWE-20,CWE-264,CWE-399"
main_8,"int main_8(int argc, char **argv) {
 if (!parse_args(argc, argv)) {
    usage(argv[0]);
 }

 if (bond && discoverable) {
    fprintf(stderr, ""Can only select either bond or discoverable, not both\n"");
    usage(argv[0]);
 }

 if (sco_listen && sco_connect) {
    fprintf(stderr, ""Can only select either sco_listen or sco_connect, not both\n"");
    usage(argv[0]);
 }

 if (!bond && !discover && !discoverable && !up && !get_name && !set_name && !sco_listen && !sco_connect) {
    fprintf(stderr, ""Must specify one command\n"");
    usage(argv[0]);
 }

 if (signal(SIGINT, sig_handler) == SIG_ERR) {
    fprintf(stderr, ""Will be unable to catch signals\n"");
 }

  fprintf(stdout, ""Bringing up bluetooth adapter\n"");
 if (!hal_open(callbacks_get_adapter_struct())) {
    fprintf(stderr, ""Unable to open Bluetooth HAL.\n"");
 return 1;

   }
 
   if (discover) {
    CALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);
     fprintf(stdout, ""BT adapter is up\n"");
 
     fprintf(stdout, ""Starting to start discovery\n"");
    CALL_AND_WAIT(bt_interface->start_discovery(), discovery_state_changed);
    fprintf(stdout, ""Started discovery for %d seconds\n"", timeout_in_sec);

    sleep(timeout_in_sec);

    fprintf(stdout, ""Starting to cancel discovery\n"");
    CALL_AND_WAIT(bt_interface->cancel_discovery(), discovery_state_changed);
    fprintf(stdout, ""Cancelled discovery after %d seconds\n"", timeout_in_sec);

   }
 
   if (discoverable) {
    CALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);
     fprintf(stdout, ""BT adapter is up\n"");
 
     bt_property_t *property = property_new_scan_mode(BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE);

 int rc = bt_interface->set_adapter_property(property);
    fprintf(stdout, ""Set rc:%d device as discoverable for %d seconds\n"", rc, timeout_in_sec);

    sleep(timeout_in_sec);

    property_free(property);
 }

 if (bond) {
 if (bdaddr_is_empty(&bt_remote_bdaddr)) {
      fprintf(stderr, ""Must specify a remote device address [ --bdaddr=xx:yy:zz:aa:bb:cc ]\n"");

       exit(1);
     }
 
    CALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);
     fprintf(stdout, ""BT adapter is up\n"");
 
     int rc = bt_interface->create_bond(&bt_remote_bdaddr, 0 );
    fprintf(stdout, ""Started bonding:%d for %d seconds\n"", rc, timeout_in_sec);

    sleep(timeout_in_sec);

   }
 
   if (up) {
    CALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);
     fprintf(stdout, ""BT adapter is up\n"");
 
     fprintf(stdout, ""Waiting for %d seconds\n"", timeout_in_sec);
    sleep(timeout_in_sec);

   }
 
   if (get_name) {
    CALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);
     fprintf(stdout, ""BT adapter is up\n"");
     int error;
     CALL_AND_WAIT(error = bt_interface->get_adapter_property(BT_PROPERTY_BDNAME), adapter_properties);
 if (error != BT_STATUS_SUCCESS) {
      fprintf(stderr, ""Unable to get adapter property\n"");
      exit(1);
 }
 bt_property_t *property = adapter_get_property(BT_PROPERTY_BDNAME);
 const bt_bdname_t *name = property_as_name(property);
 if (name)
      printf(""Queried bluetooth device name:%s\n"", name->name);
 else
      printf(""No name\n"");

   }
 
   if (set_name) {
    CALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);
     fprintf(stdout, ""BT adapter is up\n"");
 
     bt_property_t *property = property_new_name(bd_name);
    printf(""Setting bluetooth device name to:%s\n"", bd_name);
 int error;
    CALL_AND_WAIT(error = bt_interface->set_adapter_property(property), adapter_properties);
 if (error != BT_STATUS_SUCCESS) {
      fprintf(stderr, ""Unable to set adapter property\n"");
      exit(1);
 }
    CALL_AND_WAIT(error = bt_interface->get_adapter_property(BT_PROPERTY_BDNAME), adapter_properties);
 if (error != BT_STATUS_SUCCESS) {
      fprintf(stderr, ""Unable to get adapter property\n"");
      exit(1);
 }
    property_free(property);
    sleep(timeout_in_sec);

   }
 
   if (sco_listen) {
    CALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);
     fprintf(stdout, ""BT adapter is up\n"");
 
     bt_property_t *property = property_new_scan_mode(BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE);
    CALL_AND_WAIT(bt_interface->set_adapter_property(property), adapter_properties);
    property_free(property);

 const btsock_interface_t *sock = bt_interface->get_profile_interface(BT_PROFILE_SOCKETS_ID);

 int rfcomm_fd = INVALID_FD;
 int error = sock->listen(BTSOCK_RFCOMM, ""meow"", (const uint8_t *)&HFP_AG_UUID, 0, &rfcomm_fd, 0);
 if (error != BT_STATUS_SUCCESS) {
      fprintf(stderr, ""Unable to listen for incoming RFCOMM socket: %d\n"", error);
      exit(1);
 }

 int sock_fd = INVALID_FD;
    error = sock->listen(BTSOCK_SCO, NULL, NULL, 5, &sock_fd, 0);
 if (error != BT_STATUS_SUCCESS) {
      fprintf(stderr, ""Unable to listen for incoming SCO sockets: %d\n"", error);
      exit(1);
 }
    fprintf(stdout, ""Waiting for incoming SCO connections...\n"");
    sleep(timeout_in_sec);
 }

 if (sco_connect) {
 if (bdaddr_is_empty(&bt_remote_bdaddr)) {
      fprintf(stderr, ""Must specify a remote device address [ --bdaddr=xx:yy:zz:aa:bb:cc ]\n"");

       exit(1);
     }
 
    CALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);
     fprintf(stdout, ""BT adapter is up\n"");
 
     const btsock_interface_t *sock = bt_interface->get_profile_interface(BT_PROFILE_SOCKETS_ID);

 int rfcomm_fd = INVALID_FD;
 int error = sock->connect(&bt_remote_bdaddr, BTSOCK_RFCOMM, (const uint8_t *)&HFP_AG_UUID, 0, &rfcomm_fd, 0);
 if (error != BT_STATUS_SUCCESS) {
      fprintf(stderr, ""Unable to connect to RFCOMM socket: %d.\n"", error);
      exit(1);
 }

    WAIT(acl_state_changed);

    fprintf(stdout, ""Establishing SCO connection...\n"");

 int sock_fd = INVALID_FD;
    error = sock->connect(&bt_remote_bdaddr, BTSOCK_SCO, NULL, 5, &sock_fd, 0);
 if (error != BT_STATUS_SUCCESS) {
      fprintf(stderr, ""Unable to connect to SCO socket: %d.\n"", error);
      exit(1);
 }
    sleep(timeout_in_sec);
 }

  CALL_AND_WAIT(bt_interface->disable(), adapter_state_changed);
  fprintf(stdout, ""BT adapter is down\n"");
}
","1. if (bond && discoverable) {
2. usage(argv[0]);
3. if (sco_listen && sco_connect) {
4. property_free(property);
5. int rc = bt_interface->create_bond(&bt_remote_bdaddr, 0 );
fprintf(stdout, ""Started bonding:%d for %d seconds\n"", rc, timeout_in_sec);
6. if (up) {
7. CALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);
8. fprintf(stderr, ""Unable to set adapter property\n"");
9. if (error != BT_STATUS_SUCCESS) {
fprintf(stderr, ""Unable to get adapter property\n"");
10. fprintf(stdout, ""BT adapter is up\n"");
11. error = sock->listen(BTSOCK_SCO, NULL, NULL, 5, &sock_fd, 0);
12. exit(1);
13. CALL_AND_WAIT(bt_interface->enable(false), adapter_state_changed);
14. const btsock_interface_t *sock = bt_interface->get_profile_interface(BT_PROFILE_SOCKETS_ID);
15. if (error != BT_STATUS_SUCCESS) {
fprintf(stderr, ""Unable to connect to RFCOMM socket: %d.\n"", error);
16. WAIT(acl_state_changed);
17. exit(1);
18. fprintf(stdout, ""BT adapter is down\n"");","6
8
11
59
72-73
79
107
115
119-120
130
146
159
162
165
169-170
174
182
188","CWE-20,CWE-787,CWE-119"
match_4-127716192662865,"static int match_4(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, struct chan_iax2_pvt *cur, int full_frame)
{
	if ((cur->addr.sin_addr.s_addr == sin->sin_addr.s_addr) &&
		(cur->addr.sin_port == sin->sin_port)) {
		
		if ( (cur->peercallno == 0 || cur->peercallno == callno) &&
			 (full_frame ? dcallno == cur->callno : 1) ) {
			
			return 1;
		}
	}
	if ((cur->transfer.sin_addr.s_addr == sin->sin_addr.s_addr) &&
	    (cur->transfer.sin_port == sin->sin_port) && (cur->transferring)) {
		
		if ((dcallno == cur->callno) || (cur->transferring == TRANSFER_MEDIAPASS && cur->transfercallno == callno))
			return 1;
	}
	return 0;
}
","1. static int match_4(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, struct chan_iax2_pvt *cur, int full_frame)
2. if ((cur->addr.sin_addr.s_addr == sin->sin_addr.s_addr) &&
(cur->addr.sin_port == sin->sin_port)) {
3. if ( (cur->peercallno == 0 || cur->peercallno == callno) &&
(full_frame ? dcallno == cur->callno : 1) ) {
4. return 1;
5. if ((cur->transfer.sin_addr.s_addr == sin->sin_addr.s_addr) &&
(cur->transfer.sin_port == sin->sin_port) && (cur->transferring)) {
6. if ((dcallno == cur->callno) || (cur->transferring == TRANSFER_MEDIAPASS && cur->transfercallno == callno))
return 1;
7. return 0;","1
3-4
6-7
9
12-13
15-16
18",CWE-287
check_ptr_alignment,"static int check_ptr_alignment(struct bpf_verifier_env *env,
			       const struct bpf_reg_state *reg,
			       int off, int size)
{
	bool strict = env->strict_alignment;
	const char *pointer_desc = """";

	switch (reg->type) {
	case PTR_TO_PACKET:
	case PTR_TO_PACKET_META:
		
		return check_pkt_ptr_alignment(env, reg, off, size, strict);
	case PTR_TO_MAP_VALUE:
		pointer_desc = ""value "";
		break;
	case PTR_TO_CTX:
		pointer_desc = ""context "";
 		break;
 	case PTR_TO_STACK:
 		pointer_desc = ""stack "";
		
		strict = true;
 		break;
 	default:
 		break;
	}
	return check_generic_ptr_alignment(env, reg, pointer_desc, off, size,
					   strict);
}
","1. int off, int size)
2. switch (reg->type) {
3. pointer_desc = ""value "";
4. break;
5. return check_generic_ptr_alignment(env, reg, pointer_desc, off, size,","3
8
16
30
32","CWE-264,CWE-125,CWE-399,CWE-119"
nfc_llcp_send_connect,"int nfc_llcp_send_connect(struct nfc_llcp_sock *sock)
{
	struct nfc_llcp_local *local;
	struct sk_buff *skb;
	u8 *service_name_tlv = NULL, service_name_tlv_length;
	u8 *miux_tlv = NULL, miux_tlv_length;
	u8 *rw_tlv = NULL, rw_tlv_length, rw;
	int err;
	u16 size = 0;
	__be16 miux;

	pr_debug(""Sending CONNECT\n"");

	local = sock->local;
	if (local == NULL)
		return -ENODEV;

	if (sock->service_name != NULL) {
		service_name_tlv = nfc_llcp_build_tlv(LLCP_TLV_SN,
 						      sock->service_name,
 						      sock->service_name_len,
 						      &service_name_tlv_length);
		if (!service_name_tlv) {
			err = -ENOMEM;
			goto error_tlv;
		}
 		size += service_name_tlv_length;
 	}
 
	
	miux = be16_to_cpu(sock->miux) > LLCP_MAX_MIUX ?
		local->miux : sock->miux;
	rw = sock->rw > LLCP_MAX_RW ? local->rw : sock->rw;
 
 	miux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&miux, 0,
 				      &miux_tlv_length);
	if (!miux_tlv) {
		err = -ENOMEM;
		goto error_tlv;
	}
 	size += miux_tlv_length;
 
 	rw_tlv = nfc_llcp_build_tlv(LLCP_TLV_RW, &rw, 0, &rw_tlv_length);
	if (!rw_tlv) {
		err = -ENOMEM;
		goto error_tlv;
	}
 	size += rw_tlv_length;
 
 	pr_debug(""SKB size %d SN length %zu\n"", size, sock->service_name_len);

	skb = llcp_allocate_pdu(sock, LLCP_PDU_CONNECT, size);
	if (skb == NULL) {
		err = -ENOMEM;
		goto error_tlv;
	}

	llcp_add_tlv(skb, service_name_tlv, service_name_tlv_length);
	llcp_add_tlv(skb, miux_tlv, miux_tlv_length);
	llcp_add_tlv(skb, rw_tlv, rw_tlv_length);

	skb_queue_tail(&local->tx_queue, skb);

	err = 0;

error_tlv:
	if (err)
		pr_err(""error %d\n"", err);

	kfree(service_name_tlv);
	kfree(miux_tlv);
	kfree(rw_tlv);

	return err;
}
","1. int nfc_llcp_send_connect(struct nfc_llcp_sock *sock)
2. struct sk_buff *skb;
u8 *service_name_tlv = NULL, service_name_tlv_length;
3. u16 size = 0;
4. pr_debug(""Sending CONNECT\n"");
5. local = sock->local;
if (local == NULL)
return -ENODEV;
6. service_name_tlv = nfc_llcp_build_tlv(LLCP_TLV_SN,
7. if (!service_name_tlv) {
err = -ENOMEM;
goto error_tlv;
8. miux = be16_to_cpu(sock->miux) > LLCP_MAX_MIUX ?
local->miux : sock->miux;
rw = sock->rw > LLCP_MAX_RW ? local->rw : sock->rw;
9. miux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&miux, 0,
&miux_tlv_length);
if (!miux_tlv) {
10. goto error_tlv;
11. rw_tlv = nfc_llcp_build_tlv(LLCP_TLV_RW, &rw, 0, &rw_tlv_length);
12. err = -ENOMEM;
goto error_tlv;
13. pr_debug(""SKB size %d SN length %zu\n"", size, sock->service_name_len);
14. err = -ENOMEM;
goto error_tlv;
15. llcp_add_tlv(skb, miux_tlv, miux_tlv_length);
llcp_add_tlv(skb, rw_tlv, rw_tlv_length);
16. skb_queue_tail(&local->tx_queue, skb);
17. err = 0;
18. error_tlv:
19. kfree(miux_tlv);
kfree(rw_tlv);
20. return err;","1
4-5
9
12
14-16
19
23-25
31-33
35-37
39
43
45-46
50
54-55
59-60
62
64
66
71-72
74","CWE-476,CWE-120,CWE-119"
sc_pkcs15emu_esteid_init,"sc_pkcs15emu_esteid_init (sc_pkcs15_card_t * p15card)
{
	sc_card_t *card = p15card->card;
	unsigned char buff[128];
	int r, i;
	size_t field_length = 0, modulus_length = 0;
	sc_path_t tmppath;

	set_string (&p15card->tokeninfo->label, ""ID-kaart"");
	set_string (&p15card->tokeninfo->manufacturer_id, ""AS Sertifitseerimiskeskus"");

	
	sc_format_path (""3f00eeee5044"", &tmppath);
	r = sc_select_file (card, &tmppath, NULL);
	SC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, ""select esteid PD failed"");

 	
 	r = sc_read_record (card, SC_ESTEID_PD_DOCUMENT_NR, buff, sizeof(buff), SC_RECORD_BY_REC_NR);
 	SC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, ""read document number failed"");
	buff[MIN((size_t) r, (sizeof buff)-1)] = '\0';
 	set_string (&p15card->tokeninfo->serial_number, (const char *) buff);
 
 	p15card->tokeninfo->flags = SC_PKCS15_TOKEN_PRN_GENERATION
				  | SC_PKCS15_TOKEN_EID_COMPLIANT
				  | SC_PKCS15_TOKEN_READONLY;

	
	for (i = 0; i < 2; i++) {
		static const char *esteid_cert_names[2] = {
			""Isikutuvastus"",
			""Allkirjastamine""};
		static char const *esteid_cert_paths[2] = {
			""3f00eeeeaace"",
			""3f00eeeeddce""};
		static int esteid_cert_ids[2] = {1, 2};

		struct sc_pkcs15_cert_info cert_info;
		struct sc_pkcs15_object cert_obj;

		memset(&cert_info, 0, sizeof(cert_info));
		memset(&cert_obj, 0, sizeof(cert_obj));

		cert_info.id.value[0] = esteid_cert_ids[i];
		cert_info.id.len = 1;
		sc_format_path(esteid_cert_paths[i], &cert_info.path);
		strlcpy(cert_obj.label, esteid_cert_names[i], sizeof(cert_obj.label));
		r = sc_pkcs15emu_add_x509_cert(p15card, &cert_obj, &cert_info);
		if (r < 0)
			return SC_ERROR_INTERNAL;
		if (i == 0) {
			sc_pkcs15_cert_t *cert = NULL;
			r = sc_pkcs15_read_certificate(p15card, &cert_info, &cert);
			if (r < 0)
				return SC_ERROR_INTERNAL;
			if (cert->key->algorithm == SC_ALGORITHM_EC)
				field_length = cert->key->u.ec.params.field_length;
			else
				modulus_length = cert->key->u.rsa.modulus.len * 8;
			if (r == SC_SUCCESS) {
				static const struct sc_object_id cn_oid = {{ 2, 5, 4, 3, -1 }};
				u8 *cn_name = NULL;
				size_t cn_len = 0;
				sc_pkcs15_get_name_from_dn(card->ctx, cert->subject,
					cert->subject_len, &cn_oid, &cn_name, &cn_len);
				if (cn_len > 0) {
					char *token_name = malloc(cn_len+1);
					if (token_name) {
						memcpy(token_name, cn_name, cn_len);
						token_name[cn_len] = '\0';
						set_string(&p15card->tokeninfo->label, (const char*)token_name);
						free(token_name);
					}
				}
				free(cn_name);
				sc_pkcs15_free_certificate(cert);
			}
		}
	}

	
	sc_format_path (""3f000016"", &tmppath);
	r = sc_select_file (card, &tmppath, NULL);
	if (r < 0)
		return SC_ERROR_INTERNAL;

	
	for (i = 0; i < 3; i++) {
		unsigned char tries_left;
		static const char *esteid_pin_names[3] = {
			""PIN1"",
			""PIN2"",
			""PUK"" };
			
		static const int esteid_pin_min[3] = {4, 5, 8};
		static const int esteid_pin_ref[3] = {1, 2, 0};
		static const int esteid_pin_authid[3] = {1, 2, 3};
		static const int esteid_pin_flags[3] = {0, 0, SC_PKCS15_PIN_FLAG_UNBLOCKING_PIN};
		
		struct sc_pkcs15_auth_info pin_info;
		struct sc_pkcs15_object pin_obj;

		memset(&pin_info, 0, sizeof(pin_info));
		memset(&pin_obj, 0, sizeof(pin_obj));

		
		r = sc_read_record (card, i + 1, buff, sizeof(buff), SC_RECORD_BY_REC_NR);
		if (r < 0)
			return SC_ERROR_INTERNAL;
		tries_left = buff[5];

		pin_info.auth_id.len = 1;
		pin_info.auth_id.value[0] = esteid_pin_authid[i];
		pin_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;
		pin_info.attrs.pin.reference = esteid_pin_ref[i];
		pin_info.attrs.pin.flags = esteid_pin_flags[i];
		pin_info.attrs.pin.type = SC_PKCS15_PIN_TYPE_ASCII_NUMERIC;
		pin_info.attrs.pin.min_length = esteid_pin_min[i];
		pin_info.attrs.pin.stored_length = 12;
		pin_info.attrs.pin.max_length = 12;
		pin_info.attrs.pin.pad_char = '\0';
		pin_info.tries_left = (int)tries_left;
		pin_info.max_tries = 3;

		strlcpy(pin_obj.label, esteid_pin_names[i], sizeof(pin_obj.label));
		pin_obj.flags = esteid_pin_flags[i];

		
		if (i < 2) {
			pin_obj.auth_id.len = 1;
			pin_obj.auth_id.value[0] = 3;
		}

		r = sc_pkcs15emu_add_pin_obj(p15card, &pin_obj, &pin_info);
		if (r < 0)
			return SC_ERROR_INTERNAL;
	}

	
	for (i = 0; i < 2; i++) {
		static int prkey_pin[2] = {1, 2};

		static const char *prkey_name[2] = {
			""Isikutuvastus"",
			""Allkirjastamine""};

		struct sc_pkcs15_prkey_info prkey_info;
		struct sc_pkcs15_object prkey_obj;

		memset(&prkey_info, 0, sizeof(prkey_info));
		memset(&prkey_obj, 0, sizeof(prkey_obj));

		prkey_info.id.len = 1;
		prkey_info.id.value[0] = prkey_pin[i];
		prkey_info.native = 1;
		prkey_info.key_reference = i + 1;
		prkey_info.field_length = field_length;
		prkey_info.modulus_length = modulus_length;
		if (i == 1)
			prkey_info.usage = SC_PKCS15_PRKEY_USAGE_NONREPUDIATION;
		else if(field_length > 0) 
			prkey_info.usage = SC_PKCS15_PRKEY_USAGE_SIGN | SC_PKCS15_PRKEY_USAGE_DERIVE;
		else
			prkey_info.usage = SC_PKCS15_PRKEY_USAGE_SIGN | SC_PKCS15_PRKEY_USAGE_ENCRYPT | SC_PKCS15_PRKEY_USAGE_DECRYPT;

		strlcpy(prkey_obj.label, prkey_name[i], sizeof(prkey_obj.label));
		prkey_obj.auth_id.len = 1;
		prkey_obj.auth_id.value[0] = prkey_pin[i];
		prkey_obj.user_consent = 0;
		prkey_obj.flags = SC_PKCS15_CO_FLAG_PRIVATE;

		if(field_length > 0)
			r = sc_pkcs15emu_add_ec_prkey(p15card, &prkey_obj, &prkey_info);
		else
			r = sc_pkcs15emu_add_rsa_prkey(p15card, &prkey_obj, &prkey_info);
		if (r < 0)
			return SC_ERROR_INTERNAL;
	}

	return SC_SUCCESS;
}
","1. r = sc_select_file (card, &tmppath, NULL);
2. memset(&cert_obj, 0, sizeof(cert_obj));
3. modulus_length = cert->key->u.rsa.modulus.len * 8;","14
41
58","CWE-358,CWE-362,CWE-264,CWE-190,CWE-787"
sf_open-124645810000022,"
#define SF_INFO

SNDFILE*
sf_open	(const char *path, int mode, SF_INFO *sfinfo)
{	SF_PRIVATE 	*psf ;

	
	assert (sizeof (sf_count_t) == 8) ;

	if ((psf = psf_allocate ()) == NULL)
	{	sf_errno = SFE_MALLOC_FAILED ;
		return	NULL ;
		} ;

	psf_init_files (psf) ;

	psf_log_printf (psf, ""File : %s\n"", path) ;

	if (copy_filename (psf, path) != 0)
	{	sf_errno = psf->error ;
		return	NULL ;
		} ;

	psf->file.mode = mode ;
	if (strcmp (path, ""-"") == 0)
		psf->error = psf_set_stdio (psf) ;
	else
		psf->error = psf_fopen (psf) ;

	return psf_open_file (psf, sfinfo) ;
} 
","1. sf_open	(const char *path, int mode, SF_INFO *sfinfo)
2. assert (sizeof (sf_count_t) == 8) ;
3. if ((psf = psf_allocate ()) == NULL)
4. return	NULL ;
5. psf_log_printf (psf, ""File : %s\n"", path) ;
6. if (copy_filename (psf, path) != 0)
{	sf_errno = psf->error ;
7. if (strcmp (path, ""-"") == 0)
8. return psf_open_file (psf, sfinfo) ;","5
9
11
13
18
20-21
26
31","CWE-120,CWE-347,CWE-200,CWE-119,CWE-116"
pixBlockconvGray-264359558452578,"
#define PIX

PIX *
pixBlockconvGray(PIX     *pixs,
                 PIX     *pixacc,
                 l_int32  wc,
                 l_int32  hc)
{
l_int32    w, h, d, wpl, wpla;
l_uint32  *datad, *dataa;
PIX       *pixd, *pixt;

    PROCNAME(""pixBlockconvGray"");

    if (!pixs)
        return (PIX *)ERROR_PTR(""pixs not defined"", procName, NULL);
    pixGetDimensions(pixs, &w, &h, &d);
    if (d != 8)
        return (PIX *)ERROR_PTR(""pixs not 8 bpp"", procName, NULL);
    if (wc <= 0 || hc <= 0)   
        return pixCopy(NULL, pixs);
    if (w < 2 * wc + 1 || h < 2 * hc + 1) {
        L_ERROR(""kernel is too large: w = %d, wc = %d, h = %d, hc = %d\n"",
                procName, w, wc, h, hc);
        return pixCopy(NULL, pixs);
    }

    if (pixacc) {
        if (pixGetDepth(pixacc) == 32) {
            pixt = pixClone(pixacc);
        } else {
            L_WARNING(""pixacc not 32 bpp; making new one\n"", procName);
            if ((pixt = pixBlockconvAccum(pixs)) == NULL)
                return (PIX *)ERROR_PTR(""pixt not made"", procName, NULL);
        }
    } else {
        if ((pixt = pixBlockconvAccum(pixs)) == NULL)
            return (PIX *)ERROR_PTR(""pixt not made"", procName, NULL);
    }

    if ((pixd = pixCreateTemplate(pixs)) == NULL) {
        pixDestroy(&pixt);
        return (PIX *)ERROR_PTR(""pixd not made"", procName, NULL);
    }

    pixSetPadBits(pixt, 0);
    wpl = pixGetWpl(pixd);
    wpla = pixGetWpl(pixt);
    datad = pixGetData(pixd);
    dataa = pixGetData(pixt);
    blockconvLow(datad, w, h, wpl, dataa, wpla, wc, hc);

    pixDestroy(&pixt);
    return pixd;
}
","1. PIX *
2. PIX     *pixacc,
l_int32  wc,
3. l_uint32  *datad, *dataa;
4. PROCNAME(""pixBlockconvGray"");
5. pixGetDimensions(pixs, &w, &h, &d);
6. return pixCopy(NULL, pixs);
if (w < 2 * wc + 1 || h < 2 * hc + 1) {
7. return pixCopy(NULL, pixs);
8. if (pixacc) {
if (pixGetDepth(pixacc) == 32) {
9. } else {
10. } else {
11. if ((pixd = pixCreateTemplate(pixs)) == NULL) {
pixDestroy(&pixt);
12. pixSetPadBits(pixt, 0);
13. wpla = pixGetWpl(pixt);
datad = pixGetData(pixd);
14. return pixd;","4
6-7
11
14
18
22-23
26
29-30
32
37
42-43
47
49-50
55","CWE-119,CWE-17,CWE-125,CWE-369"
auth_select_file,"auth_select_file(struct sc_card *card, const struct sc_path *in_path,
				 struct sc_file **file_out)
{
	struct sc_path path;
	struct sc_file *tmp_file = NULL;
	size_t offs, ii;
	int rv;

	LOG_FUNC_CALLED(card->ctx);
	assert(card != NULL && in_path != NULL);
 
 	memcpy(&path, in_path, sizeof(struct sc_path));
 
	if (!auth_current_df)
		return SC_ERROR_OBJECT_NOT_FOUND;

 	sc_log(card->ctx, ""in_path; type=%d, path=%s, out %p"",
 			in_path->type, sc_print_path(in_path), file_out);
 	sc_log(card->ctx, ""current path; type=%d, path=%s"",
			auth_current_df->path.type, sc_print_path(&auth_current_df->path));
	if (auth_current_ef)
		sc_log(card->ctx, ""current file; type=%d, path=%s"",
				auth_current_ef->path.type, sc_print_path(&auth_current_ef->path));

	if (path.type == SC_PATH_TYPE_PARENT || path.type == SC_PATH_TYPE_FILE_ID)   {
		sc_file_free(auth_current_ef);
		auth_current_ef = NULL;

		rv = iso_ops->select_file(card, &path, &tmp_file);
		LOG_TEST_RET(card->ctx, rv, ""select file failed"");
		if (!tmp_file)
			return SC_ERROR_OBJECT_NOT_FOUND;

		if (path.type == SC_PATH_TYPE_PARENT)   {
			memcpy(&tmp_file->path, &auth_current_df->path, sizeof(struct sc_path));
			if (tmp_file->path.len > 2)
				tmp_file->path.len -= 2;

			sc_file_free(auth_current_df);
			sc_file_dup(&auth_current_df, tmp_file);
		}
		else   {
			if (tmp_file->type == SC_FILE_TYPE_DF)   {
				sc_concatenate_path(&tmp_file->path, &auth_current_df->path, &path);

				sc_file_free(auth_current_df);
				sc_file_dup(&auth_current_df, tmp_file);
			}
			else   {
				sc_file_free(auth_current_ef);

				sc_file_dup(&auth_current_ef, tmp_file);
				sc_concatenate_path(&auth_current_ef->path, &auth_current_df->path, &path);
			}
		}
		if (file_out)
			sc_file_dup(file_out, tmp_file);

		sc_file_free(tmp_file);
	}
	else if (path.type == SC_PATH_TYPE_DF_NAME)   {
		rv = iso_ops->select_file(card, &path, NULL);
		if (rv)   {
			sc_file_free(auth_current_ef);
			auth_current_ef = NULL;
		}
		LOG_TEST_RET(card->ctx, rv, ""select file failed"");
	}
	else   {
		for (offs = 0; offs < path.len && offs < auth_current_df->path.len; offs += 2)
			if (path.value[offs] != auth_current_df->path.value[offs] ||
					path.value[offs + 1] != auth_current_df->path.value[offs + 1])
				break;

		sc_log(card->ctx, ""offs %""SC_FORMAT_LEN_SIZE_T""u"", offs);
		if (offs && offs < auth_current_df->path.len)   {
			size_t deep = auth_current_df->path.len - offs;

			sc_log(card->ctx, ""deep %""SC_FORMAT_LEN_SIZE_T""u"",
			       deep);
			for (ii=0; ii<deep; ii+=2)   {
				struct sc_path tmp_path;

				memcpy(&tmp_path, &auth_current_df->path,  sizeof(struct sc_path));
				tmp_path.type = SC_PATH_TYPE_PARENT;

				rv = auth_select_file (card, &tmp_path, file_out);
				LOG_TEST_RET(card->ctx, rv, ""select file failed"");
			}
		}

		if (path.len - offs > 0)   {
			struct sc_path tmp_path;

			memset(&tmp_path, 0, sizeof(struct sc_path));
			tmp_path.type = SC_PATH_TYPE_FILE_ID;
			tmp_path.len = 2;

			for (ii=0; ii < path.len - offs; ii+=2)   {
				memcpy(tmp_path.value, path.value + offs + ii, 2);

				rv = auth_select_file(card, &tmp_path, file_out);
				LOG_TEST_RET(card->ctx, rv, ""select file failed"");
			}
		}
		else if (path.len - offs == 0 && file_out)  {
			if (sc_compare_path(&path, &auth_current_df->path))
				sc_file_dup(file_out, auth_current_df);
			else  if (auth_current_ef)
				sc_file_dup(file_out, auth_current_ef);
			else
				LOG_TEST_RET(card->ctx, SC_ERROR_INTERNAL, ""No current EF"");
		}
	}

	LOG_FUNC_RETURN(card->ctx, 0);
}
","1. if (path.type == SC_PATH_TYPE_PARENT || path.type == SC_PATH_TYPE_FILE_ID)   {
2. auth_current_ef = NULL;
3. LOG_TEST_RET(card->ctx, rv, ""select file failed"");
if (!tmp_file)
4. if (tmp_file->path.len > 2)
5. sc_file_free(auth_current_df);
sc_file_dup(&auth_current_df, tmp_file);
6. sc_concatenate_path(&tmp_file->path, &auth_current_df->path, &path);
7. sc_file_dup(file_out, tmp_file);
8. else if (path.type == SC_PATH_TYPE_DF_NAME)   {
9. else   {
for (offs = 0; offs < path.len && offs < auth_current_df->path.len; offs += 2)
10. size_t deep = auth_current_df->path.len - offs;
11. memcpy(&tmp_path, &auth_current_df->path,  sizeof(struct sc_path));
12. rv = auth_select_file (card, &tmp_path, file_out);
13. if (path.len - offs > 0)   {
14. tmp_path.type = SC_PATH_TYPE_FILE_ID;
15. rv = auth_select_file(card, &tmp_path, file_out);
16. else if (path.len - offs == 0 && file_out)  {
if (sc_compare_path(&path, &auth_current_df->path))
17. LOG_FUNC_RETURN(card->ctx, 0);","25
27
30-31
36
39-40
44
57
61
69-70
77
84
87
92
96
102
106-107
116","CWE-20,CWE-125,CWE-59"
ReadPSDLayersInternal_1,"
#define ExceptionInfo
#define Image
#define ImageInfo
#define MagickBooleanType
#define PSDInfo

static MagickBooleanType ReadPSDLayersInternal_1(Image *image,
  const ImageInfo *image_info,const PSDInfo *psd_info,
  const MagickBooleanType skip_layers,ExceptionInfo *exception)
{
  char
    type[4];

  LayerInfo
    *layer_info;

  MagickSizeType
    size;

  MagickBooleanType
    status;

  register ssize_t
    i;

  ssize_t
    count,
    j,
    number_layers;

  size=GetPSDSize(psd_info,image);
  if (size == 0)
    {
      
      (void) ReadBlobLong(image);
      count=ReadBlob(image,4,(unsigned char *) type);
      ReversePSDString(image,type,4);
      status=MagickFalse;
      if ((count == 0) || (LocaleNCompare(type,""8BIM"",4) != 0))
        return(MagickTrue);
      else
        {
          count=ReadBlob(image,4,(unsigned char *) type);
          ReversePSDString(image,type,4);
          if ((count != 0) && (LocaleNCompare(type,""Lr16"",4) == 0))
            size=GetPSDSize(psd_info,image);
          else
            return(MagickTrue);
        }
    }
  status=MagickTrue;
  if (size != 0)
    {
      layer_info=(LayerInfo *) NULL;
      number_layers=(short) ReadBlobShort(image);

      if (number_layers < 0)
        {
          
          number_layers=MagickAbsoluteValue(number_layers);
          if (image->debug != MagickFalse)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  negative layer count corrected for"");
          image->matte=MagickTrue;
        }

      
      if (skip_layers != MagickFalse)
        return(MagickTrue);

      if (image->debug != MagickFalse)
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""  image contains %.20g layers"",(double) number_layers);

      if (number_layers == 0)
        ThrowBinaryException(CorruptImageError,""InvalidNumberOfLayers"",
          image->filename);

      layer_info=(LayerInfo *) AcquireQuantumMemory((size_t) number_layers,
        sizeof(*layer_info));
      if (layer_info == (LayerInfo *) NULL)
        {
          if (image->debug != MagickFalse)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  allocation of LayerInfo failed"");
          ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"",
            image->filename);
        }
      (void) ResetMagickMemory(layer_info,0,(size_t) number_layers*
        sizeof(*layer_info));

      for (i=0; i < number_layers; i++)
      {
        ssize_t
          x,
          y;

        if (image->debug != MagickFalse)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""  reading layer #%.20g"",(double) i+1);
        layer_info[i].page.y=ReadBlobSignedLong(image);
        layer_info[i].page.x=ReadBlobSignedLong(image);
        y=ReadBlobSignedLong(image);
        x=ReadBlobSignedLong(image);
        layer_info[i].page.width=(size_t) (x-layer_info[i].page.x);
        layer_info[i].page.height=(size_t) (y-layer_info[i].page.y);
        layer_info[i].channels=ReadBlobShort(image);
        if (layer_info[i].channels > MaxPSDChannels)
          {
            layer_info=DestroyLayerInfo(layer_info,number_layers);
            ThrowBinaryException(CorruptImageError,""MaximumChannelsExceeded"",
              image->filename);
          }
        if (image->debug != MagickFalse)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""    offset(%.20g,%.20g), size(%.20g,%.20g), channels=%.20g"",
            (double) layer_info[i].page.x,(double) layer_info[i].page.y,
            (double) layer_info[i].page.height,(double)
            layer_info[i].page.width,(double) layer_info[i].channels);
        for (j=0; j < (ssize_t) layer_info[i].channels; j++)
        {
          layer_info[i].channel_info[j].type=(short) ReadBlobShort(image);
          layer_info[i].channel_info[j].size=(size_t) GetPSDSize(psd_info,
            image);
          if (image->debug != MagickFalse)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""    channel[%.20g]: type=%.20g, size=%.20g"",(double) j,
              (double) layer_info[i].channel_info[j].type,
              (double) layer_info[i].channel_info[j].size);
        }
        count=ReadBlob(image,4,(unsigned char *) type);
        ReversePSDString(image,type,4);
        if ((count == 0) || (LocaleNCompare(type,""8BIM"",4) != 0))
          {
            if (image->debug != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""  layer type was %.4s instead of 8BIM"", type);
            layer_info=DestroyLayerInfo(layer_info,number_layers);
            ThrowBinaryException(CorruptImageError,""ImproperImageHeader"",
              image->filename);
          }
        (void) ReadBlob(image,4,(unsigned char *) layer_info[i].blendkey);
        ReversePSDString(image,layer_info[i].blendkey,4);
        layer_info[i].opacity=(Quantum) ScaleCharToQuantum((unsigned char)
          ReadBlobByte(image));
        layer_info[i].clipping=(unsigned char) ReadBlobByte(image);
        layer_info[i].flags=(unsigned char) ReadBlobByte(image);
        layer_info[i].visible=!(layer_info[i].flags & 0x02);
        if (image->debug != MagickFalse)
          (void) LogMagickEvent(CoderEvent,GetMagickModule(),
            ""   blend=%.4s, opacity=%.20g, clipping=%s, flags=%d, visible=%s"",
            layer_info[i].blendkey,(double) layer_info[i].opacity,
            layer_info[i].clipping ? ""true"" : ""false"",layer_info[i].flags,
            layer_info[i].visible ? ""true"" : ""false"");
        (void) ReadBlobByte(image);  

        size=ReadBlobLong(image);
        if (size != 0)
          {
            MagickSizeType
              combined_length,
              length;

            if (image->debug != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""    layer contains additional info"");
            length=ReadBlobLong(image);
            combined_length=length+4;
            if (length != 0)
              {
                
                layer_info[i].mask.page.y=ReadBlobSignedLong(image);
                layer_info[i].mask.page.x=ReadBlobSignedLong(image);
                layer_info[i].mask.page.height=(size_t) (ReadBlobSignedLong(image)-
                  layer_info[i].mask.page.y);
                layer_info[i].mask.page.width=(size_t) (ReadBlobSignedLong(image)-
                  layer_info[i].mask.page.x);
                layer_info[i].mask.background=(unsigned char) ReadBlobByte(
                  image);
                layer_info[i].mask.flags=(unsigned char) ReadBlobByte(image);
                if (!(layer_info[i].mask.flags & 0x01))
                  {
                    layer_info[i].mask.page.y=layer_info[i].mask.page.y-
                      layer_info[i].page.y;
                    layer_info[i].mask.page.x=layer_info[i].mask.page.x-
                      layer_info[i].page.x;
                  }
                if (image->debug != MagickFalse)
                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                    ""      layer mask: offset(%.20g,%.20g), size(%.20g,%.20g), length=%.20g"",
                    (double) layer_info[i].mask.page.x,(double)
                    layer_info[i].mask.page.y,(double) layer_info[i].mask.page.width,
                    (double) layer_info[i].mask.page.height,(double)
                    ((MagickOffsetType) length)-18);
                
                if (DiscardBlobBytes(image,(MagickSizeType) (length-18)) == MagickFalse)
                  {
                    layer_info=DestroyLayerInfo(layer_info,number_layers);
                    ThrowBinaryException(CorruptImageError,""UnexpectedEndOfFile"",
                      image->filename);
                  }
              }
            length=ReadBlobLong(image);
            combined_length+=length+4;
            if (length != 0)
              {
                
                if (image->debug != MagickFalse)
                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                    ""      layer blending ranges: length=%.20g"",(double)
                    ((MagickOffsetType) length));
                
                for (j=0; j < (ssize_t) length; j+=8)
                 {
                   size_t blend_source=ReadBlobLong(image);
                   size_t blend_dest=ReadBlobLong(image);
                  if (EOFBlob(image) != MagickFalse)
                    {
                      layer_info=DestroyLayerInfo(layer_info,number_layers);
                      ThrowBinaryException(CorruptImageError,
                        ""InsufficientImageDataInFile"",image->filename);
                    }
                   if (image->debug != MagickFalse)
                     (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                       ""        source(%x), dest(%x)"",(unsigned int)
                      blend_source,(unsigned int) blend_dest);
                }
              }
            
            length=(MagickSizeType) (unsigned char) ReadBlobByte(image);
            combined_length+=length+1;
            if (length > 0)
              (void) ReadBlob(image,(size_t) length++,layer_info[i].name);
            layer_info[i].name[length]='\0';
            if (image->debug != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""      layer name: %s"",layer_info[i].name);
            if ((length % 4) != 0)
              {
                length=4-(length % 4);
                combined_length+=length;
                
                if (DiscardBlobBytes(image,length) == MagickFalse)
                  {
                    layer_info=DestroyLayerInfo(layer_info,number_layers);
                    ThrowBinaryException(CorruptImageError,
                      ""UnexpectedEndOfFile"",image->filename);
                  }
              }
            length=(MagickSizeType) size-combined_length;
            if (length > 0)
              {
                unsigned char
                  *info;

                if (length > GetBlobSize(image))
                  {
                    layer_info=DestroyLayerInfo(layer_info,number_layers);
                    ThrowBinaryException(CorruptImageError,
                      ""InsufficientImageDataInFile"",image->filename);
                  }
                layer_info[i].info=AcquireStringInfo((const size_t) length);
                info=GetStringInfoDatum(layer_info[i].info);
                (void) ReadBlob(image,(const size_t) length,info);
              }
          }
      }

      for (i=0; i < number_layers; i++)
      {
        if ((layer_info[i].page.width == 0) ||
              (layer_info[i].page.height == 0))
          {
            if (image->debug != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""      layer data is empty"");
            if (layer_info[i].info != (StringInfo *) NULL)
              layer_info[i].info=DestroyStringInfo(layer_info[i].info);
            continue;
          }

        
        layer_info[i].image=CloneImage(image,layer_info[i].page.width,
          layer_info[i].page.height,MagickFalse,exception);
        if (layer_info[i].image == (Image *) NULL)
          {
            layer_info=DestroyLayerInfo(layer_info,number_layers);
            if (image->debug != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""  allocation of image for layer %.20g failed"",(double) i);
            ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"",
              image->filename);
          }

        if (layer_info[i].info != (StringInfo *) NULL)
          {
            (void) SetImageProfile(layer_info[i].image,""psd:additional-info"",
              layer_info[i].info);
            layer_info[i].info=DestroyStringInfo(layer_info[i].info);
          }
      }

      if (image_info->ping == MagickFalse)
        {
          for (i=0; i < number_layers; i++)
          {
            if (layer_info[i].image == (Image *) NULL)
              {
                for (j=0; j < layer_info[i].channels; j++)
                {
                  if (DiscardBlobBytes(image,(MagickSizeType)
                      layer_info[i].channel_info[j].size) == MagickFalse)
                    {
                      layer_info=DestroyLayerInfo(layer_info,number_layers);
                      ThrowBinaryException(CorruptImageError,
                        ""UnexpectedEndOfFile"",image->filename);
                    }
                }
                continue;
              }

            if (image->debug != MagickFalse)
              (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                ""  reading data for layer %.20g"",(double) i);
            status=ReadPSDLayer(image,image_info,psd_info,&layer_info[i],
              exception);
            if (status == MagickFalse)
              break;

            status=SetImageProgress(image,LoadImagesTag,i,(MagickSizeType)
              number_layers);
            if (status == MagickFalse)
              break;
          }
        }

      if (status != MagickFalse)
        {
          for (i=0; i < number_layers; i++)
          {
            if (layer_info[i].image == (Image *) NULL)
              {
                for (j=i; j < number_layers - 1; j++)
                  layer_info[j] = layer_info[j+1];
                number_layers--;
                i--;
              }
          }

          if (number_layers > 0)
            {
              for (i=0; i < number_layers; i++)
              {
                if (i > 0)
                  layer_info[i].image->previous=layer_info[i-1].image;
                if (i < (number_layers-1))
                  layer_info[i].image->next=layer_info[i+1].image;
                layer_info[i].image->page=layer_info[i].page;
              }
              image->next=layer_info[0].image;
              layer_info[0].image->previous=image;
            }
          layer_info=(LayerInfo *) RelinquishMagickMemory(layer_info);
        }
      else
        layer_info=DestroyLayerInfo(layer_info,number_layers);
    }

  return(status);
}
","1. static MagickBooleanType ReadPSDLayersInternal_1(Image *image,
2. (void) ReadBlobLong(image);
3. if (size != 0)
4. if (image->debug != MagickFalse)
5. ""  negative layer count corrected for"");
image->matte=MagickTrue;
6. if (image->debug != MagickFalse)
7. sizeof(*layer_info));
8. (void) LogMagickEvent(CoderEvent,GetMagickModule(),
9. (void) ResetMagickMemory(layer_info,0,(size_t) number_layers*
sizeof(*layer_info));
10. (void) LogMagickEvent(CoderEvent,GetMagickModule(),
11. layer_info[i].page.x=ReadBlobSignedLong(image);
12. layer_info[i].channels=ReadBlobShort(image);
13. layer_info=DestroyLayerInfo(layer_info,number_layers);
14. ""    offset(%.20g,%.20g), size(%.20g,%.20g), channels=%.20g"",
15. (double) layer_info[i].page.height,(double)
16. layer_info[i].channel_info[j].size=(size_t) GetPSDSize(psd_info,
17. if (image->debug != MagickFalse)
18. layer_info=DestroyLayerInfo(layer_info,number_layers);
19. (void) ReadBlob(image,4,(unsigned char *) layer_info[i].blendkey);
20. layer_info[i].clipping ? ""true"" : ""false"",layer_info[i].flags,
layer_info[i].visible ? ""true"" : ""false"");
21. if (image->debug != MagickFalse)
(void) LogMagickEvent(CoderEvent,GetMagickModule(),
""    layer contains additional info"");
22. layer_info[i].mask.page.y=ReadBlobSignedLong(image);
23. layer_info[i].mask.page.height=(size_t) (ReadBlobSignedLong(image)-
layer_info[i].mask.page.y);
layer_info[i].mask.page.width=(size_t) (ReadBlobSignedLong(image)-
24. image);
25. layer_info[i].mask.page.y=layer_info[i].mask.page.y-
26. if (DiscardBlobBytes(image,(MagickSizeType) (length-18)) == MagickFalse)
27. layer_info=DestroyLayerInfo(layer_info,number_layers);
ThrowBinaryException(CorruptImageError,""UnexpectedEndOfFile"",
image->filename);
28. ((MagickOffsetType) length));
29. blend_source,(unsigned int) blend_dest);
30. ""      layer name: %s"",layer_info[i].name);
31. ""UnexpectedEndOfFile"",image->filename);
32. if (length > 0)
33. layer_info=DestroyLayerInfo(layer_info,number_layers);
34. (void) ReadBlob(image,(const size_t) length,info);
35. if ((layer_info[i].page.width == 0) ||
(layer_info[i].page.height == 0))
36. continue;
37. if (layer_info[i].image == (Image *) NULL)
38. if (image->debug != MagickFalse)
39. (void) SetImageProfile(layer_info[i].image,""psd:additional-info"",
layer_info[i].info);
40. for (i=0; i < number_layers; i++)
41. if (layer_info[i].image == (Image *) NULL)
42. for (j=0; j < layer_info[i].channels; j++)
43. layer_info=DestroyLayerInfo(layer_info,number_layers);
ThrowBinaryException(CorruptImageError,
44. if (image->debug != MagickFalse)
45. status=SetImageProgress(image,LoadImagesTag,i,(MagickSizeType)
number_layers);
46. if (number_layers > 0)
47. if (i > 0)
layer_info[i].image->previous=layer_info[i-1].image;
48. image->next=layer_info[0].image;","8
38
55
67
69-70
79
88
92
97-98
107
110
115
118
124
126
131
143
146
150
161-162
172-174
182
184-186
189
193
208
210-212
225
242
255
265
269
276
282
289-290
297
305
308
317-318
325
327
329
334-335
342
350-351
370
374-375
380","CWE-772,CWE-20,CWE-834,CWE-787"
nfs4_file_open-195572891589264,"static int
nfs4_file_open(struct inode *inode, struct file *filp)
{
	struct nfs_open_context *ctx;
	struct dentry *dentry = file_dentry(filp);
	struct dentry *parent = NULL;
	struct inode *dir;
	unsigned openflags = filp->f_flags;
	struct iattr attr;
	int err;

	

	dprintk(""NFS: open file(%pd2)\n"", dentry);

	err = nfs_check_flags(openflags);
	if (err)
		return err;

	if ((openflags & O_ACCMODE) == 3)
		openflags--;

	
	openflags &= ~(O_CREAT|O_EXCL);

	parent = dget_parent(dentry);
	dir = d_inode(parent);

	ctx = alloc_nfs_open_context(file_dentry(filp), filp->f_mode, filp);
	err = PTR_ERR(ctx);
	if (IS_ERR(ctx))
		goto out;

	attr.ia_valid = ATTR_OPEN;
	if (openflags & O_TRUNC) {
		attr.ia_valid |= ATTR_SIZE;
		attr.ia_size = 0;
		filemap_write_and_wait(inode->i_mapping);
	}

	inode = NFS_PROTO(dir)->open_context(dir, ctx, openflags, &attr, NULL);
	if (IS_ERR(inode)) {
		err = PTR_ERR(inode);
		switch (err) {
		default:
			goto out_put_ctx;
		case -ENOENT:
		case -ESTALE:
		case -EISDIR:
		case -ENOTDIR:
		case -ELOOP:
			goto out_drop;
		}
	}
	if (inode != d_inode(dentry))
		goto out_drop;

	nfs_file_set_open_context(filp, ctx);
	nfs_fscache_open_file(inode, filp);
	err = 0;

out_put_ctx:
	put_nfs_open_context(ctx);
out:
	dput(parent);
	return err;

out_drop:
	d_drop(dentry);
	err = -EOPENSTALE;
	goto out_put_ctx;
}
","1. dir = d_inode(parent);
2. if (openflags & O_TRUNC) {
3. attr.ia_size = 0;
4. if (IS_ERR(inode)) {
5. case -ELOOP:
6. if (inode != d_inode(dentry))
goto out_drop;
7. out_put_ctx:
8. out_drop:","34
42
44
49
58
62-63
69
75","CWE-362,CWE-1284,CWE-189"
php_wddx_pop_element,"
#define XML_Char

static void php_wddx_pop_element(void *user_data, const XML_Char *name)
{
	st_entry 			*ent1, *ent2;
	wddx_stack 			*stack = (wddx_stack *)user_data;
	HashTable 			*target_hash;
	zend_class_entry 	**pce;
	zval				*obj;
	zval				*tmp;
	TSRMLS_FETCH();


	if (stack->top == 0) {
		return;
	}

	if (!strcmp(name, EL_STRING) || !strcmp(name, EL_NUMBER) ||
		!strcmp(name, EL_BOOLEAN) || !strcmp(name, EL_NULL) ||
	  	!strcmp(name, EL_ARRAY) || !strcmp(name, EL_STRUCT) ||
		!strcmp(name, EL_RECORDSET) || !strcmp(name, EL_BINARY) ||
                !strcmp(name, EL_DATETIME)) {
                wddx_stack_top(stack, (void**)&ent1);
 
               if (!ent1->data) {
                       if (stack->top > 1) {
                               stack->top--;
                       } else {
                               stack->done = 1;
                       }
                       efree(ent1);
                       return;
               }

                if (!strcmp(name, EL_BINARY)) {
                        int new_len=0;
                        unsigned char *new_str;

			MAKE_STD_ZVAL(fname);
			ZVAL_STRING(fname, ""__wakeup"", 1);

			call_user_function_ex(NULL, &ent1->data, fname, &retval, 0, 0, 0, NULL TSRMLS_CC);

			zval_dtor(fname);
			FREE_ZVAL(fname);
			if (retval) {
				zval_ptr_dtor(&retval);
			}
		}

		if (stack->top > 1) {
			stack->top--;
			wddx_stack_top(stack, (void**)&ent2);

			
			if (ent2->type == ST_FIELD && ent2->data == NULL) {
				zval_ptr_dtor(&ent1->data);
				efree(ent1);
				return;
			}

			if (Z_TYPE_P(ent2->data) == IS_ARRAY || Z_TYPE_P(ent2->data) == IS_OBJECT) {
				target_hash = HASH_OF(ent2->data);

				if (ent1->varname) {
					if (!strcmp(ent1->varname, PHP_CLASS_NAME_VAR) &&
						Z_TYPE_P(ent1->data) == IS_STRING && Z_STRLEN_P(ent1->data) &&
						ent2->type == ST_STRUCT && Z_TYPE_P(ent2->data) == IS_ARRAY) {
						zend_bool incomplete_class = 0;

						zend_str_tolower(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));
						if (zend_hash_find(EG(class_table), Z_STRVAL_P(ent1->data),
										   Z_STRLEN_P(ent1->data)+1, (void **) &pce)==FAILURE) {
							incomplete_class = 1;
							pce = &PHP_IC_ENTRY;
						}

						
						MAKE_STD_ZVAL(obj);
						object_init_ex(obj, *pce);

						
						zend_hash_merge(Z_OBJPROP_P(obj),
										Z_ARRVAL_P(ent2->data),
										(void (*)(void *)) zval_add_ref,
										(void *) &tmp, sizeof(zval *), 0);

						if (incomplete_class) {
							php_store_class_name(obj, Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));
						}

						
						zval_ptr_dtor(&ent2->data);

						
						ent2->data = obj;

						
						zval_ptr_dtor(&ent1->data);
					} else if (Z_TYPE_P(ent2->data) == IS_OBJECT) {
						zend_class_entry *old_scope = EG(scope);

						EG(scope) = Z_OBJCE_P(ent2->data);
						Z_DELREF_P(ent1->data);
						add_property_zval(ent2->data, ent1->varname, ent1->data);
						EG(scope) = old_scope;
					} else {
						zend_symtable_update(target_hash, ent1->varname, strlen(ent1->varname)+1, &ent1->data, sizeof(zval *), NULL);
					}
					efree(ent1->varname);
				} else	{
					zend_hash_next_index_insert(target_hash, &ent1->data, sizeof(zval *), NULL);
				}
			}
			efree(ent1);
		} else {
			stack->done = 1;
		}
	} else if (!strcmp(name, EL_VAR) && stack->varname) {
		efree(stack->varname);
	} else if (!strcmp(name, EL_FIELD)) {
		st_entry *ent;
		wddx_stack_top(stack, (void **)&ent);
		efree(ent);
		stack->top--;
	}
}
","1. wddx_stack 			*stack = (wddx_stack *)user_data;
2. zend_class_entry 	**pce;
3. if (stack->top > 1) {
4. stack->done = 1;
5. unsigned char *new_str;
6. stack->top--;
wddx_stack_top(stack, (void**)&ent2);
7. target_hash = HASH_OF(ent2->data);
8. Z_TYPE_P(ent1->data) == IS_STRING && Z_STRLEN_P(ent1->data) &&
ent2->type == ST_STRUCT && Z_TYPE_P(ent2->data) == IS_ARRAY) {
9. zend_class_entry *old_scope = EG(scope);
10. efree(ent);","7
9
27
30
38
53-54
64
68-69
102
125","CWE-476,CWE-125,CWE-116,CWE-78"
ReadRLEImage_3,"
#define ExceptionInfo
#define ImageInfo

static Image *ReadRLEImage_3(const ImageInfo *image_info,ExceptionInfo *exception)
{
#define SkipLinesOp  0x01
#define SetColorOp  0x02
#define SkipPixelsOp  0x03
 #define ByteDataOp  0x05
 #define RunDataOp  0x06
 #define EOFOp  0x07
#define ThrowRLEException(exception,message) \
{ \
  if (colormap != (unsigned char *) NULL) \
    colormap=(unsigned char *) RelinquishMagickMemory(colormap); \
  if (pixel_info != (MemoryInfo *) NULL) \
    pixel_info=RelinquishVirtualMemory(pixel_info); \
  ThrowReaderException((exception),(message)); \
}

 
   char
     magick[12];

  Image
    *image;

  IndexPacket
    index;

  int
    opcode,
    operand,
    status;

  MagickStatusType
    flags;

  MagickSizeType
    number_pixels;

  MemoryInfo
    *pixel_info;

  register IndexPacket
    *indexes;

  register ssize_t
    x;

  register PixelPacket
    *q;

  register ssize_t
    i;

  register unsigned char
    *p;

  size_t
    bits_per_pixel,
    map_length,
    number_colormaps,
    number_planes,
    number_planes_filled,
    one,
    pixel_info_length;

  ssize_t
    count,
    offset,
    y;

  unsigned char
    background_color[256],
    *colormap,
    pixel,
    plane,
    *pixels;

  
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickSignature);
  image=AcquireImage(image_info);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    return(DestroyImageList(image));
   
  colormap=(unsigned char *) NULL;
  pixel_info=(MemoryInfo *) NULL;
   count=ReadBlob(image,2,(unsigned char *) magick);
   if ((count != 2) || (memcmp(magick,""\122\314"",2) != 0))
     ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  do
  {
     
    image->page.x=(ssize_t) ReadBlobLSBShort(image);
    image->page.y=(ssize_t) ReadBlobLSBShort(image);
     image->columns=ReadBlobLSBShort(image);
     image->rows=ReadBlobLSBShort(image);
     flags=(MagickStatusType) ReadBlobByte(image);
    image->matte=flags & 0x04 ? MagickTrue : MagickFalse;
    number_planes=(size_t) ReadBlobByte(image);
    bits_per_pixel=(size_t) ReadBlobByte(image);
    number_colormaps=(size_t) ReadBlobByte(image);
     map_length=(unsigned char) ReadBlobByte(image);
     if (map_length >= 22)
       ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    if (EOFBlob(image) != MagickFalse)
      ThrowRLEException(CorruptImageError,""UnexpectedEndOfFile"");
     one=1;
     map_length=one << map_length;
     if ((number_planes == 0) || (number_planes == 2) ||
        ((flags & 0x04) && (number_colormaps > 254)) || (bits_per_pixel != 8) ||
        (image->columns == 0))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    if (flags & 0x02)
      {
        
        for (i=0; i < (ssize_t) number_planes; i++)
          background_color[i]=0;
        (void) ReadBlobByte(image);
      }
    else
      {
        
        p=background_color;
        for (i=0; i < (ssize_t) number_planes; i++)
          *p++=(unsigned char) ReadBlobByte(image);
      }
     if ((number_planes & 0x01) == 0)
       (void) ReadBlobByte(image);
     if (EOFBlob(image) != MagickFalse)
      ThrowRLEException(CorruptImageError,""UnexpectedEndOfFile"");
     colormap=(unsigned char *) NULL;
     if (number_colormaps != 0)
       {
        
        colormap=(unsigned char *) AcquireQuantumMemory(number_colormaps,
          3*map_length*sizeof(*colormap));
        if (colormap == (unsigned char *) NULL)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
         p=colormap;
         for (i=0; i < (ssize_t) number_colormaps; i++)
           for (x=0; x < (ssize_t) map_length; x++)
          {
             *p++=(unsigned char) ScaleQuantumToChar(ScaleShortToQuantum(
               ReadBlobLSBShort(image)));
            if (EOFBlob(image) != MagickFalse)
              ThrowRLEException(CorruptImageError,""UnexpectedEndOfFile"");
          }
       }
     if ((flags & 0x08) != 0)
       {
        char
          *comment;

        size_t
          length;

        
        length=ReadBlobLSBShort(image);
        if (length != 0)
          {
            comment=(char *) AcquireQuantumMemory(length,sizeof(*comment));
            if (comment == (char *) NULL)
              ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
            (void) ReadBlob(image,length-1,(unsigned char *) comment);
            comment[length-1]='\0';
            (void) SetImageProperty(image,""comment"",comment);
            comment=DestroyString(comment);
            if ((length & 0x01) == 0)
              (void) ReadBlobByte(image);
           }
       }
     if (EOFBlob(image) != MagickFalse)
      ThrowRLEException(CorruptImageError,""UnexpectedEndOfFile"");
     if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))
       if (image->scene >= (image_info->scene+image_info->number_scenes-1))
         break;
    status=SetImageExtent(image,image->columns,image->rows);
    if (status == MagickFalse)
      {
        InheritException(exception,&image->exception);
        return(DestroyImageList(image));
      }
    
    if (image->matte != MagickFalse)
      number_planes++;
    number_pixels=(MagickSizeType) image->columns*image->rows;
    number_planes_filled=(number_planes % 2 == 0) ? number_planes :
      number_planes+1;
    if ((number_pixels*number_planes_filled) != (size_t) (number_pixels*
         number_planes_filled))
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    pixel_info=AcquireVirtualMemory(image->columns,image->rows*
      MagickMax(number_planes_filled,4)*sizeof(*pixels));
    if (pixel_info == (MemoryInfo *) NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    pixel_info_length=image->columns*image->rows*
      MagickMax(number_planes_filled,4);
    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
    (void) ResetMagickMemory(pixels,0,pixel_info_length);
    if ((flags & 0x01) && !(flags & 0x02))
      {
        ssize_t
          j;

        
        p=pixels;
        for (i=0; i < (ssize_t) number_pixels; i++)
        {
          if (image->matte == MagickFalse)
            for (j=0; j < (ssize_t) number_planes; j++)
              *p++=background_color[j];
          else
            {
              for (j=0; j < (ssize_t) (number_planes-1); j++)
                *p++=background_color[j];
              *p++=0;  
            }
        }
      }
    
    plane=0;
     x=0;
     y=0;
     opcode=ReadBlobByte(image);
    if (opcode == EOF)
      ThrowRLEException(CorruptImageError,""UnexpectedEndOfFile"");
     do
     {
       switch (opcode & 0x3f)
       {
         case SkipLinesOp:
         {
           operand=ReadBlobByte(image);
          if (opcode == EOF)
            ThrowRLEException(CorruptImageError,""UnexpectedEndOfFile"");
           if (opcode & 0x40)
            {
              operand=ReadBlobLSBSignedShort(image);
              if (opcode == EOF)
                ThrowRLEException(CorruptImageError,""UnexpectedEndOfFile"");
            }
           x=0;
           y+=operand;
           break;
         }
         case SetColorOp:
         {
           operand=ReadBlobByte(image);
          if (opcode == EOF)
            ThrowRLEException(CorruptImageError,""UnexpectedEndOfFile"");
           plane=(unsigned char) operand;
           if (plane == 255)
             plane=(unsigned char) (number_planes-1);
          x=0;
          break;
        }
         case SkipPixelsOp:
         {
           operand=ReadBlobByte(image);
          if (opcode == EOF)
            ThrowRLEException(CorruptImageError,""UnexpectedEndOfFile"");
           if (opcode & 0x40)
            {
              operand=ReadBlobLSBSignedShort(image);
              if (opcode == EOF)
                ThrowRLEException(CorruptImageError,""UnexpectedEndOfFile"");
            }
           x+=operand;
           break;
         }
         case ByteDataOp:
         {
           operand=ReadBlobByte(image);
          if (opcode == EOF)
            ThrowRLEException(CorruptImageError,""UnexpectedEndOfFile"");
           if (opcode & 0x40)
            {
              operand=ReadBlobLSBSignedShort(image);
              if (opcode == EOF)
                ThrowRLEException(CorruptImageError,""UnexpectedEndOfFile"");
            }
          offset=(ssize_t) (((image->rows-y-1)*image->columns*number_planes)+x*
            number_planes+plane);
           operand++;
           if ((offset < 0) ||
              ((offset+operand*number_planes) > (ssize_t) pixel_info_length))
             {
               if (number_colormaps != 0)
                 colormap=(unsigned char *) RelinquishMagickMemory(colormap);
              pixel_info=RelinquishVirtualMemory(pixel_info);
              ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
            }
          p=pixels+offset;
          for (i=0; i < (ssize_t) operand; i++)
          {
            pixel=(unsigned char) ReadBlobByte(image);
            if ((y < (ssize_t) image->rows) &&
                ((x+i) < (ssize_t) image->columns))
              *p=pixel;
            p+=number_planes;
          }
          if (operand & 0x01)
            (void) ReadBlobByte(image);
          x+=operand;
          break;
        }
         case RunDataOp:
         {
           operand=ReadBlobByte(image);
          if (opcode == EOF)
            ThrowRLEException(CorruptImageError,""UnexpectedEndOfFile"");
           if (opcode & 0x40)
            {
              operand=ReadBlobLSBSignedShort(image);
              if (opcode == EOF)
                ThrowRLEException(CorruptImageError,""UnexpectedEndOfFile"");
            }
           pixel=(unsigned char) ReadBlobByte(image);
           (void) ReadBlobByte(image);
           operand++;
          offset=(ssize_t) (((image->rows-y-1)*image->columns*number_planes)+x*
            number_planes+plane);
           if ((offset < 0) ||
              ((offset+operand*number_planes) > (ssize_t) pixel_info_length))
             {
               if (number_colormaps != 0)
                 colormap=(unsigned char *) RelinquishMagickMemory(colormap);
              pixel_info=RelinquishVirtualMemory(pixel_info);
              ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
            }
          p=pixels+offset;
          for (i=0; i < (ssize_t) operand; i++)
          {
            if ((y < (ssize_t) image->rows) &&
                ((x+i) < (ssize_t) image->columns))
              *p=pixel;
            p+=number_planes;
          }
          x+=operand;
          break;
        }
        default:
           break;
       }
       opcode=ReadBlobByte(image);
      if (opcode == EOF)
        ThrowRLEException(CorruptImageError,""UnexpectedEndOfFile"");
     } while (((opcode & 0x3f) != EOFOp) && (opcode != EOF));
     if (number_colormaps != 0)
       {
        MagickStatusType
          mask;

        
        mask=(MagickStatusType) (map_length-1);
        p=pixels;
        x=(ssize_t) number_planes;
         if (number_colormaps == 1)
           for (i=0; i < (ssize_t) number_pixels; i++)
           {
            if (IsValidColormapIndex(image,(ssize_t) (*p & mask),&index,exception) ==
                 MagickFalse)
               break;
             *p=colormap[(ssize_t) index];
            p++;
          }
        else
          if ((number_planes >= 3) && (number_colormaps >= 3))
             for (i=0; i < (ssize_t) number_pixels; i++)
               for (x=0; x < (ssize_t) number_planes; x++)
               {
                if (IsValidColormapIndex(image,(ssize_t) (x*map_length+
                     (*p & mask)),&index,exception) == MagickFalse)
                   break;
                 *p=colormap[(ssize_t) index];
                p++;
              }
        if ((i < (ssize_t) number_pixels) || (x < (ssize_t) number_planes))
          {
            colormap=(unsigned char *) RelinquishMagickMemory(colormap);
            pixel_info=RelinquishVirtualMemory(pixel_info);
            ThrowReaderException(CorruptImageError,""UnableToReadImageData"");
          }
      }
    
    if (number_planes >= 3)
      {
        
        p=pixels;
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
          if (q == (PixelPacket *) NULL)
            break;
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            SetPixelRed(q,ScaleCharToQuantum(*p++));
            SetPixelGreen(q,ScaleCharToQuantum(*p++));
            SetPixelBlue(q,ScaleCharToQuantum(*p++));
            if (image->matte != MagickFalse)
              SetPixelAlpha(q,ScaleCharToQuantum(*p++));
            q++;
          }
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
      }
    else
      {
        
        if (number_colormaps == 0)
          map_length=256;
        if (AcquireImageColormap(image,map_length) == MagickFalse)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        p=colormap;
        if (number_colormaps == 1)
          for (i=0; i < (ssize_t) image->colors; i++)
          {
            
            image->colormap[i].red=ScaleCharToQuantum((unsigned char) i);
            image->colormap[i].green=ScaleCharToQuantum((unsigned char) i);
            image->colormap[i].blue=ScaleCharToQuantum((unsigned char) i);
          }
        else
          if (number_colormaps > 1)
            for (i=0; i < (ssize_t) image->colors; i++)
            {
              image->colormap[i].red=ScaleCharToQuantum(*p);
              image->colormap[i].green=ScaleCharToQuantum(*(p+map_length));
              image->colormap[i].blue=ScaleCharToQuantum(*(p+map_length*2));
              p++;
            }
        p=pixels;
        if (image->matte == MagickFalse)
          {
            
            for (y=0; y < (ssize_t) image->rows; y++)
            {
              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
              if (q == (PixelPacket *) NULL)
                break;
              indexes=GetAuthenticIndexQueue(image);
              for (x=0; x < (ssize_t) image->columns; x++)
                SetPixelIndex(indexes+x,*p++);
              if (SyncAuthenticPixels(image,exception) == MagickFalse)
                break;
              if (image->previous == (Image *) NULL)
                {
                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                    y,image->rows);
                  if (status == MagickFalse)
                    break;
                }
            }
            (void) SyncImage(image);
          }
        else
          {
            
            for (y=0; y < (ssize_t) image->rows; y++)
            {
              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
              if (q == (PixelPacket *) NULL)
                 break;
               for (x=0; x < (ssize_t) image->columns; x++)
               {
                if (IsValidColormapIndex(image,(ssize_t) *p++,&index,exception) ==
                     MagickFalse)
                   break;
                 SetPixelRed(q,image->colormap[(ssize_t) index].red);
                if (IsValidColormapIndex(image,(ssize_t) *p++,&index,exception) ==
                     MagickFalse)
                   break;
                 SetPixelGreen(q,image->colormap[(ssize_t) index].green);
                if (IsValidColormapIndex(image,(ssize_t) *p++,&index,exception) ==
                     MagickFalse)
                   break;
                 SetPixelBlue(q,image->colormap[(ssize_t) index].blue);
                SetPixelAlpha(q,ScaleCharToQuantum(*p++));
                q++;
              }
              if (x < (ssize_t) image->columns)
                break;
              if (SyncAuthenticPixels(image,exception) == MagickFalse)
                break;
              if (image->previous == (Image *) NULL)
                {
                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                    y,image->rows);
                  if (status == MagickFalse)
                    break;
                }
            }
            image->colormap=(PixelPacket *) RelinquishMagickMemory(
              image->colormap);
            image->storage_class=DirectClass;
            image->colors=0;
          }
      }
    if (number_colormaps != 0)
      colormap=(unsigned char *) RelinquishMagickMemory(colormap);
    pixel_info=RelinquishVirtualMemory(pixel_info);
    if (EOFBlob(image) != MagickFalse)
      {
        ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
          image->filename);
        break;
      }
    
    if (image_info->number_scenes != 0)
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    (void) ReadBlobByte(image);
    count=ReadBlob(image,2,(unsigned char *) magick);
    if ((count != 0) && (memcmp(magick,""\122\314"",2) == 0))
      {
        
        AcquireNextImage(image_info,image);
        if (GetNextImageInList(image) == (Image *) NULL)
          {
            image=DestroyImageList(image);
            return((Image *) NULL);
          }
        image=SyncNextImageInList(image);
        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
          GetBlobSize(image));
        if (status == MagickFalse)
          break;
      }
  } while ((count != 0) && (memcmp(magick,""\122\314"",2) == 0));
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}
","1. image_info->filename);
2. pixel_info=(MemoryInfo *) NULL;
3. if ((count != 2) || (memcmp(magick,""\122\314"",2) != 0))
4. map_length=one << map_length;
5. (image->columns == 0))
6. p=background_color;
7. InheritException(exception,&image->exception);
return(DestroyImageList(image));
8. if (image->matte != MagickFalse)
9. *p++=background_color[j];
*p++=0;
10. x=0;
11. case RunDataOp:
12. ((offset+operand*number_planes) > (ssize_t) pixel_info_length))
13. x=(ssize_t) number_planes;
14. if (number_planes >= 3)
15. for (y=0; y < (ssize_t) image->rows; y++)
16. q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
17. for (i=0; i < (ssize_t) image->colors; i++)
18. image->colormap[i].blue=ScaleCharToQuantum((unsigned char) i);
19. SetPixelRed(q,image->colormap[(ssize_t) index].red);
20. SetPixelAlpha(q,ScaleCharToQuantum(*p++));
21. image->colormap);
22. if (number_colormaps != 0)
23. status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
GetBlobSize(image));","89
100
102
124
127
143
204-205
210
243-244
272
337
354
389
420
426
428
462
469
521
530
546
551
580-581","CWE-772,CWE-190,CWE-131,CWE-119"
copy_to_user_policy," static void copy_to_user_policy(struct xfrm_policy *xp, struct xfrm_userpolicy_info *p, int dir)
 {
	memset(p, 0, sizeof(*p));
 	memcpy(&p->sel, &xp->selector, sizeof(p->sel));
 	memcpy(&p->lft, &xp->lft, sizeof(p->lft));
 	memcpy(&p->curlft, &xp->curlft, sizeof(p->curlft));
	p->priority = xp->priority;
	p->index = xp->index;
	p->sel.family = xp->family;
	p->dir = dir;
	p->action = xp->action;
	p->flags = xp->flags;
	p->share = XFRM_SHARE_ANY; 
}
","1. memset(p, 0, sizeof(*p));
memcpy(&p->sel, &xp->selector, sizeof(p->sel));
2. memcpy(&p->curlft, &xp->curlft, sizeof(p->curlft));
3. p->index = xp->index;
p->sel.family = xp->family;
p->dir = dir;
p->action = xp->action;
p->flags = xp->flags;
p->share = XFRM_SHARE_ANY;","3-4
6
8-13","CWE-772,CWE-190,CWE-200,CWE-20"
drdynvc_process_data_first,"
#define Sp

static UINT drdynvc_process_data_first(drdynvcPlugin* drdynvc, int Sp,
                                       int cbChId, wStream* s)
{
 	UINT status;
 	UINT32 Length;
 	UINT32 ChannelId;

	if (Stream_GetRemainingLength(s) < drdynvc_cblen_to_bytes(cbChId) + drdynvc_cblen_to_bytes(Sp))
		return ERROR_INVALID_DATA;

 	ChannelId = drdynvc_read_variable_uint(s, cbChId);
 	Length = drdynvc_read_variable_uint(s, Sp);
 	WLog_Print(drdynvc->log, WLOG_DEBUG,
	           ""process_data_first: Sp=%d cbChId=%d, ChannelId=%""PRIu32"" Length=%""PRIu32"""", Sp,
	           cbChId, ChannelId, Length);
	status = dvcman_receive_channel_data_first(drdynvc, drdynvc->channel_mgr, ChannelId,
	         Length);

	if (status)
		return status;

	return dvcman_receive_channel_data(drdynvc, drdynvc->channel_mgr, ChannelId, s);
}
","1. int cbChId, wStream* s)
2. UINT32 Length;
UINT32 ChannelId;
3. Length = drdynvc_read_variable_uint(s, Sp);
4. Length);
5. if (status)
return status;
6. return dvcman_receive_channel_data(drdynvc, drdynvc->channel_mgr, ChannelId, s);","5
8-9
15
20
22-23
25","CWE-190,CWE-20,CWE-674,CWE-119"
makepol-134647174227433,"
#define QPRS_STATE

static int32
makepol(QPRS_STATE *state)
{
	int32		val = 0,
				type;
	int32		lenval = 0;
	char	   *strval = NULL;
	int32		stack[STACKDEPTH];
	int32		lenstack = 0;
	uint16		flag = 0;

	
	check_stack_depth();

	while ((type = gettoken_query(state, &val, &lenval, &strval, &flag)) != END)
	{
		switch (type)
		{
			case VAL:
				pushval_asis(state, VAL, strval, lenval, flag);
				while (lenstack && (stack[lenstack - 1] == (int32) '&' ||
									stack[lenstack - 1] == (int32) '!'))
				{
					lenstack--;
					pushquery(state, OPR, stack[lenstack], 0, 0, 0);
				}
				break;
			case OPR:
				if (lenstack && val == (int32) '|')
					pushquery(state, OPR, val, 0, 0, 0);
				else
				{
					if (lenstack == STACKDEPTH)
						
						elog(ERROR, ""stack too short"");
					stack[lenstack] = val;
					lenstack++;
				}
				break;
			case OPEN:
				if (makepol(state) == ERR)
					return ERR;
				while (lenstack && (stack[lenstack - 1] == (int32) '&' ||
									stack[lenstack - 1] == (int32) '!'))
				{
					lenstack--;
					pushquery(state, OPR, stack[lenstack], 0, 0, 0);
				}
				break;
			case CLOSE:
				while (lenstack)
				{
					lenstack--;
					pushquery(state, OPR, stack[lenstack], 0, 0, 0);
				};
				return END;
				break;
			case ERR:
			default:
				ereport(ERROR,
						(errcode(ERRCODE_SYNTAX_ERROR),
						 errmsg(""syntax error"")));

				return ERR;

		}
	}
	while (lenstack)
	{
		lenstack--;
		pushquery(state, OPR, stack[lenstack], 0, 0, 0);
	};
	return END;
}
","1. type;
2. int32		lenstack = 0;
3. if (lenstack && val == (int32) '|')
pushquery(state, OPR, val, 0, 0, 0);
4. return ERR;
while (lenstack && (stack[lenstack - 1] == (int32) '&' ||
5. break;
6. ereport(ERROR,
(errcode(ERRCODE_SYNTAX_ERROR),
7. while (lenstack)
8. lenstack--;","8
12
32-33
45-46
52
63-64
71
73","CWE-476,CWE-125,CWE-119"
session_new-235940182377901,"static int session_new(nghttp2_session **session_ptr,
                       const nghttp2_session_callbacks *callbacks,
                       void *user_data, int server,
                       const nghttp2_option *option, nghttp2_mem *mem) {
  int rv;
  size_t nbuffer;
  size_t max_deflate_dynamic_table_size =
      NGHTTP2_HD_DEFAULT_MAX_DEFLATE_BUFFER_SIZE;

  if (mem == NULL) {
    mem = nghttp2_mem_default();
  }

  *session_ptr = nghttp2_mem_calloc(mem, 1, sizeof(nghttp2_session));
  if (*session_ptr == NULL) {
    rv = NGHTTP2_ERR_NOMEM;
    goto fail_session;
  }

  (*session_ptr)->mem = *mem;
  mem = &(*session_ptr)->mem;

  

  nghttp2_stream_init(&(*session_ptr)->root, 0, NGHTTP2_STREAM_FLAG_NONE,
                      NGHTTP2_STREAM_IDLE, NGHTTP2_DEFAULT_WEIGHT, 0, 0, NULL,
                      mem);

  (*session_ptr)->remote_window_size = NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE;
  (*session_ptr)->recv_window_size = 0;
  (*session_ptr)->consumed_size = 0;
  (*session_ptr)->recv_reduction = 0;
  (*session_ptr)->local_window_size = NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE;

  (*session_ptr)->goaway_flags = NGHTTP2_GOAWAY_NONE;
  (*session_ptr)->local_last_stream_id = (1u << 31) - 1;
  (*session_ptr)->remote_last_stream_id = (1u << 31) - 1;

  (*session_ptr)->pending_local_max_concurrent_stream =
      NGHTTP2_DEFAULT_MAX_CONCURRENT_STREAMS;
  (*session_ptr)->pending_enable_push = 1;

  if (server) {
    (*session_ptr)->server = 1;
  }

  init_settings(&(*session_ptr)->remote_settings);
  init_settings(&(*session_ptr)->local_settings);

  (*session_ptr)->max_incoming_reserved_streams =
      NGHTTP2_MAX_INCOMING_RESERVED_STREAMS;

  
  (*session_ptr)->remote_settings.max_concurrent_streams = 100;

  (*session_ptr)->max_send_header_block_length = NGHTTP2_MAX_HEADERSLEN;
  (*session_ptr)->max_outbound_ack = NGHTTP2_DEFAULT_MAX_OBQ_FLOOD_ITEM;
  (*session_ptr)->max_settings = NGHTTP2_DEFAULT_MAX_SETTINGS;

  if (option) {
    if ((option->opt_set_mask & NGHTTP2_OPT_NO_AUTO_WINDOW_UPDATE) &&
        option->no_auto_window_update) {

      (*session_ptr)->opt_flags |= NGHTTP2_OPTMASK_NO_AUTO_WINDOW_UPDATE;
    }

    if (option->opt_set_mask & NGHTTP2_OPT_PEER_MAX_CONCURRENT_STREAMS) {

      (*session_ptr)->remote_settings.max_concurrent_streams =
          option->peer_max_concurrent_streams;
    }

    if (option->opt_set_mask & NGHTTP2_OPT_MAX_RESERVED_REMOTE_STREAMS) {

      (*session_ptr)->max_incoming_reserved_streams =
          option->max_reserved_remote_streams;
    }

    if ((option->opt_set_mask & NGHTTP2_OPT_NO_RECV_CLIENT_MAGIC) &&
        option->no_recv_client_magic) {

      (*session_ptr)->opt_flags |= NGHTTP2_OPTMASK_NO_RECV_CLIENT_MAGIC;
    }

    if ((option->opt_set_mask & NGHTTP2_OPT_NO_HTTP_MESSAGING) &&
        option->no_http_messaging) {

      (*session_ptr)->opt_flags |= NGHTTP2_OPTMASK_NO_HTTP_MESSAGING;
    }

    if (option->opt_set_mask & NGHTTP2_OPT_USER_RECV_EXT_TYPES) {
      memcpy((*session_ptr)->user_recv_ext_types, option->user_recv_ext_types,
             sizeof((*session_ptr)->user_recv_ext_types));
    }

    if (option->opt_set_mask & NGHTTP2_OPT_BUILTIN_RECV_EXT_TYPES) {
      (*session_ptr)->builtin_recv_ext_types = option->builtin_recv_ext_types;
    }

    if ((option->opt_set_mask & NGHTTP2_OPT_NO_AUTO_PING_ACK) &&
        option->no_auto_ping_ack) {
      (*session_ptr)->opt_flags |= NGHTTP2_OPTMASK_NO_AUTO_PING_ACK;
    }

    if (option->opt_set_mask & NGHTTP2_OPT_MAX_SEND_HEADER_BLOCK_LENGTH) {
      (*session_ptr)->max_send_header_block_length =
          option->max_send_header_block_length;
    }

    if (option->opt_set_mask & NGHTTP2_OPT_MAX_DEFLATE_DYNAMIC_TABLE_SIZE) {
      max_deflate_dynamic_table_size = option->max_deflate_dynamic_table_size;
    }

    if ((option->opt_set_mask & NGHTTP2_OPT_NO_CLOSED_STREAMS) &&
        option->no_closed_streams) {
      (*session_ptr)->opt_flags |= NGHTTP2_OPTMASK_NO_CLOSED_STREAMS;
    }

    if (option->opt_set_mask & NGHTTP2_OPT_MAX_OUTBOUND_ACK) {
      (*session_ptr)->max_outbound_ack = option->max_outbound_ack;
    }

    if ((option->opt_set_mask & NGHTTP2_OPT_MAX_SETTINGS) &&
        option->max_settings) {
      (*session_ptr)->max_settings = option->max_settings;
    }
  }

  rv = nghttp2_hd_deflate_init2(&(*session_ptr)->hd_deflater,
                                max_deflate_dynamic_table_size, mem);
  if (rv != 0) {
    goto fail_hd_deflater;
  }
  rv = nghttp2_hd_inflate_init(&(*session_ptr)->hd_inflater, mem);
  if (rv != 0) {
    goto fail_hd_inflater;
  }
  rv = nghttp2_map_init(&(*session_ptr)->streams, mem);
  if (rv != 0) {
    goto fail_map;
  }

  nbuffer = ((*session_ptr)->max_send_header_block_length +
             NGHTTP2_FRAMEBUF_CHUNKLEN - 1) /
            NGHTTP2_FRAMEBUF_CHUNKLEN;

  if (nbuffer == 0) {
    nbuffer = 1;
  }

  
  rv = nghttp2_bufs_init3(&(*session_ptr)->aob.framebufs,
                          NGHTTP2_FRAMEBUF_CHUNKLEN, nbuffer, 1,
                          NGHTTP2_FRAME_HDLEN + 1, mem);
  if (rv != 0) {
    goto fail_aob_framebuf;
  }

  active_outbound_item_reset(&(*session_ptr)->aob, mem);

  (*session_ptr)->callbacks = *callbacks;
  (*session_ptr)->user_data = user_data;

  session_inbound_frame_reset(*session_ptr);

  if (nghttp2_enable_strict_preface) {
    nghttp2_inbound_frame *iframe = &(*session_ptr)->iframe;

    if (server && ((*session_ptr)->opt_flags &
                   NGHTTP2_OPTMASK_NO_RECV_CLIENT_MAGIC) == 0) {
      iframe->state = NGHTTP2_IB_READ_CLIENT_MAGIC;
      iframe->payloadleft = NGHTTP2_CLIENT_MAGIC_LEN;
    } else {
      iframe->state = NGHTTP2_IB_READ_FIRST_SETTINGS;
    }

    if (!server) {
      (*session_ptr)->aob.state = NGHTTP2_OB_SEND_CLIENT_MAGIC;
      nghttp2_bufs_add(&(*session_ptr)->aob.framebufs, NGHTTP2_CLIENT_MAGIC,
                       NGHTTP2_CLIENT_MAGIC_LEN);
    }
  }

  return 0;

fail_aob_framebuf:
  nghttp2_map_free(&(*session_ptr)->streams);
fail_map:
  nghttp2_hd_inflate_free(&(*session_ptr)->hd_inflater);
fail_hd_inflater:
  nghttp2_hd_deflate_free(&(*session_ptr)->hd_deflater);
fail_hd_deflater:
  nghttp2_mem_free(mem, *session_ptr);
fail_session:
  return rv;
}
","1. (*session_ptr)->goaway_flags = NGHTTP2_GOAWAY_NONE;
2. sizeof((*session_ptr)->user_recv_ext_types));
3. (*session_ptr)->max_outbound_ack = option->max_outbound_ack;
4. if (rv != 0) {
goto fail_hd_inflater;
5. nghttp2_inbound_frame *iframe = &(*session_ptr)->iframe;
6. nghttp2_hd_deflate_free(&(*session_ptr)->hd_deflater);","36
94
121
136-137
168
192","CWE-200,CWE-285,CWE-20,CWE-416"
ast_for_atom_2-199722912488726,"static expr_ty
ast_for_atom_2(struct compiling *c, const node *n)
{
    
    node *ch = CHILD(n, 0);

    switch (TYPE(ch)) {
    case NAME: {
        PyObject *name;
        const char *s = STR(ch);
        size_t len = strlen(s);
        if (len >= 4 && len <= 5) {
            if (!strcmp(s, ""None""))
                return NameConstant(Py_None, LINENO(n), n->n_col_offset, c->c_arena);
            if (!strcmp(s, ""True""))
                return NameConstant(Py_True, LINENO(n), n->n_col_offset, c->c_arena);
            if (!strcmp(s, ""False""))
                return NameConstant(Py_False, LINENO(n), n->n_col_offset, c->c_arena);
        }
        name = new_identifier(s, c);
        if (!name)
            return NULL;
        
        return Name(name, Load, LINENO(n), n->n_col_offset, c->c_arena);
    }
    case STRING: {
        expr_ty str = parsestrplus(c, n);
        if (!str) {
            const char *errtype = NULL;
            if (PyErr_ExceptionMatches(PyExc_UnicodeError))
                errtype = ""unicode error"";
            else if (PyErr_ExceptionMatches(PyExc_ValueError))
                errtype = ""value error"";
            if (errtype) {
                char buf[128];
                const char *s = NULL;
                PyObject *type, *value, *tback, *errstr;
                PyErr_Fetch(&type, &value, &tback);
                errstr = PyObject_Str(value);
                if (errstr)
                    s = PyUnicode_AsUTF8(errstr);
                if (s) {
                    PyOS_snprintf(buf, sizeof(buf), ""(%s) %s"", errtype, s);
                } else {
                    PyErr_Clear();
                    PyOS_snprintf(buf, sizeof(buf), ""(%s) unknown error"", errtype);
                }
                Py_XDECREF(errstr);
                ast_error(c, n, buf);
                Py_DECREF(type);
                Py_XDECREF(value);
                Py_XDECREF(tback);
            }
            return NULL;
        }
        return str;
    }
    case NUMBER: {
        PyObject *pynum;
        const char *s = STR(ch);
        
        
        if (c->c_feature_version < 6 && strchr(s, '_') != NULL) {
            ast_error(c, ch,
                    ""Underscores in numeric literals are only supported in Python 3.6 and greater"");
            return NULL;
        }
        pynum = parsenumber(c, STR(ch));
        if (!pynum)
            return NULL;

        if (PyArena_AddPyObject(c->c_arena, pynum) < 0) {
            Py_DECREF(pynum);
            return NULL;
        }
        return Num(pynum, LINENO(n), n->n_col_offset, c->c_arena);
    }
    case ELLIPSIS: 
        return Ellipsis(LINENO(n), n->n_col_offset, c->c_arena);
    case LPAR: 
        ch = CHILD(n, 1);

        if (TYPE(ch) == RPAR)
            return Tuple(NULL, Load, LINENO(n), n->n_col_offset, c->c_arena);

        if (TYPE(ch) == yield_expr)
            return ast_for_expr(c, ch);

        
        if ((NCH(ch) > 1) && (TYPE(CHILD(ch, 1)) == comp_for))
            return ast_for_genexp(c, ch);

        return ast_for_testlist(c, ch);
    case LSQB: 
        ch = CHILD(n, 1);

        if (TYPE(ch) == RSQB)
            return List(NULL, Load, LINENO(n), n->n_col_offset, c->c_arena);

        REQ(ch, testlist_comp);
        if (NCH(ch) == 1 || TYPE(CHILD(ch, 1)) == COMMA) {
            asdl_seq *elts = seq_for_testlist(c, ch);
            if (!elts)
                return NULL;

            return List(elts, Load, LINENO(n), n->n_col_offset, c->c_arena);
        }
        else
            return ast_for_listcomp(c, ch);
    case LBRACE: {
        
        expr_ty res;
        ch = CHILD(n, 1);
        if (TYPE(ch) == RBRACE) {
            
            return Dict(NULL, NULL, LINENO(n), n->n_col_offset, c->c_arena);
        }
        else {
            int is_dict = (TYPE(CHILD(ch, 0)) == DOUBLESTAR);
            if (NCH(ch) == 1 ||
                    (NCH(ch) > 1 &&
                     TYPE(CHILD(ch, 1)) == COMMA)) {
                
                res = ast_for_setdisplay(c, ch);
            }
            else if (NCH(ch) > 1 &&
                    TYPE(CHILD(ch, 1)) == comp_for) {
                
                res = ast_for_setcomp(c, ch);
            }
            else if (NCH(ch) > 3 - is_dict &&
                    TYPE(CHILD(ch, 3 - is_dict)) == comp_for) {
                
                if (is_dict) {
                    ast_error(c, n, ""dict unpacking cannot be used in ""
                            ""dict comprehension"");
                    return NULL;
                }
                res = ast_for_dictcomp(c, ch);
            }
            else {
                
                res = ast_for_dictdisplay(c, ch);
            }
            if (res) {
                res->lineno = LINENO(n);
                res->col_offset = n->n_col_offset;
            }
            return res;
        }
    }
    default:
        PyErr_Format(PyExc_SystemError, ""unhandled atom %d"", TYPE(ch));
        return NULL;
    }
}
","1. Py_XDECREF(value);
2. pynum = parsenumber(c, STR(ch));
3. if (PyArena_AddPyObject(c->c_arena, pynum) < 0) {
4. case ELLIPSIS:
5. case LPAR:
6. return ast_for_expr(c, ch);
7. return NULL;","54
71
75
81
83
90
160","CWE-20,CWE-22,CWE-125,CWE-17,CWE-59"
ip6_ufo_append_data_2,"static inline int ip6_ufo_append_data_2(struct sock *sk,
 			int getfrag(void *from, char *to, int offset, int len,
 			int odd, struct sk_buff *skb),
 			void *from, int length, int hh_len, int fragheaderlen,
			int transhdrlen, int mtu,unsigned int flags,
			struct rt6_info *rt)
 
 {
 	struct sk_buff *skb;
	int err;

	
	if ((skb = skb_peek_tail(&sk->sk_write_queue)) == NULL) {
		skb = sock_alloc_send_skb(sk,
			hh_len + fragheaderlen + transhdrlen + 20,
			(flags & MSG_DONTWAIT), &err);
		if (skb == NULL)
			return -ENOMEM;

		
		skb_reserve(skb, hh_len);

		
		skb_put(skb,fragheaderlen + transhdrlen);

		
		skb_reset_network_header(skb);

		
		skb->transport_header = skb->network_header + fragheaderlen;

		skb->ip_summed = CHECKSUM_PARTIAL;
		skb->csum = 0;
	}

	err = skb_append_datato_frags(sk,skb, getfrag, from,
				      (length - transhdrlen));
	if (!err) {
		struct frag_hdr fhdr;

		
 		skb_shinfo(skb)->gso_size = (mtu - fragheaderlen -
 					     sizeof(struct frag_hdr)) & ~7;
 		skb_shinfo(skb)->gso_type = SKB_GSO_UDP;
		ipv6_select_ident(&fhdr, rt);
 		skb_shinfo(skb)->ip6_frag_id = fhdr.identification;
 		__skb_queue_tail(&sk->sk_write_queue, skb);
 
		return 0;
	}
	
	kfree_skb(skb);

	return err;
}
","1. int getfrag(void *from, char *to, int offset, int len,
2. struct sk_buff *skb;
int err;
3. if ((skb = skb_peek_tail(&sk->sk_write_queue)) == NULL) {
skb = sock_alloc_send_skb(sk,
hh_len + fragheaderlen + transhdrlen + 20,
4. return -ENOMEM;
5. skb_reset_network_header(skb);
6. err = skb_append_datato_frags(sk,skb, getfrag, from,
7. struct frag_hdr fhdr;
8. skb_shinfo(skb)->gso_size = (mtu - fragheaderlen -
9. skb_shinfo(skb)->gso_type = SKB_GSO_UDP;
10. skb_shinfo(skb)->ip6_frag_id = fhdr.identification;
11. return 0;
12. kfree_skb(skb);","2
9-10
16-18
21
30
39
42
47
49
51
54
59","CWE-476,CWE-787,CWE-119"
atusb_read_reg-114451637020344,"static int atusb_read_reg(struct atusb *atusb, uint8_t reg)
{
	struct usb_device *usb_dev = atusb->usb_dev;
	int ret;
	uint8_t *buffer;
	uint8_t value;

	buffer = kmalloc(1, GFP_KERNEL);
	if (!buffer)
		return -ENOMEM;

	dev_dbg(&usb_dev->dev, ""atusb: reg = 0x%x\n"", reg);
	ret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),
				ATUSB_REG_READ, ATUSB_REQ_FROM_DEV,
				0, reg, buffer, 1, 1000);

	if (ret >= 0) {
		value = buffer[0];
		kfree(buffer);
		return value;
	} else {
		kfree(buffer);
		return ret;
	}
}
","1. static int atusb_read_reg(struct atusb *atusb, uint8_t reg)
2. struct usb_device *usb_dev = atusb->usb_dev;
int ret;
uint8_t *buffer;
uint8_t value;
3. buffer = kmalloc(1, GFP_KERNEL);
if (!buffer)
return -ENOMEM;
4. dev_dbg(&usb_dev->dev, ""atusb: reg = 0x%x\n"", reg);
ret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),
ATUSB_REG_READ, ATUSB_REQ_FROM_DEV,
5. if (ret >= 0) {
value = buffer[0];
6. } else {
kfree(buffer);
return ret;","1
3-6
8-10
12-14
17-18
21-23",CWE-119
cbs_jpeg_split_fragment-117064329879008,"
#define CodedBitstreamContext
#define CodedBitstreamFragment

static int cbs_jpeg_split_fragment(CodedBitstreamContext *ctx,
                                   CodedBitstreamFragment *frag,
                                   int header)
{
    AVBufferRef *data_ref;
    uint8_t *data;
    size_t data_size;
    int unit, start, end, marker, next_start, next_marker;
    int err, i, j, length;

    if (frag->data_size < 4) {
        
        return AVERROR_INVALIDDATA;
    }

    for (i = 0; i + 1 < frag->data_size && frag->data[i] != 0xff; i++);
    if (i > 0) {
        av_log(ctx->log_ctx, AV_LOG_WARNING, ""Discarding %d bytes at ""
               ""beginning of image.\n"", i);
    }
    for (++i; i + 1 < frag->data_size && frag->data[i] == 0xff; i++);
    if (i + 1 >= frag->data_size && frag->data[i]) {
        av_log(ctx->log_ctx, AV_LOG_ERROR, ""Invalid JPEG image: ""
               ""no SOI marker found.\n"");
        return AVERROR_INVALIDDATA;
    }
    marker = frag->data[i];
    if (marker != JPEG_MARKER_SOI) {
        av_log(ctx->log_ctx, AV_LOG_ERROR, ""Invalid JPEG image: first ""
               ""marker is %02x, should be SOI.\n"", marker);
        return AVERROR_INVALIDDATA;
    }
    for (++i; i + 1 < frag->data_size && frag->data[i] == 0xff; i++);
    if (i + 1 >= frag->data_size) {
        av_log(ctx->log_ctx, AV_LOG_ERROR, ""Invalid JPEG image: ""
               ""no image content found.\n"");
        return AVERROR_INVALIDDATA;
    }
    marker = frag->data[i];
    start  = i + 1;

    for (unit = 0;; unit++) {
        if (marker == JPEG_MARKER_EOI) {
            break;
        } else if (marker == JPEG_MARKER_SOS) {
            for (i = start; i + 1 < frag->data_size; i++) {
                if (frag->data[i] != 0xff)
                    continue;
                end = i;
                for (++i; i + 1 < frag->data_size &&
                          frag->data[i] == 0xff; i++);
                if (i + 1 >= frag->data_size) {
                    next_marker = -1;
                } else {
                    if (frag->data[i] == 0x00)
                        continue;
                    next_marker = frag->data[i];
                    next_start  = i + 1;
                }
                break;
            }
        } else {
            i = start;
            if (i + 2 > frag->data_size) {
                av_log(ctx->log_ctx, AV_LOG_ERROR, ""Invalid JPEG image: ""
                       ""truncated at %02x marker.\n"", marker);
                return AVERROR_INVALIDDATA;
            }
            length = AV_RB16(frag->data + i);
            if (i + length > frag->data_size) {
                av_log(ctx->log_ctx, AV_LOG_ERROR, ""Invalid JPEG image: ""
                       ""truncated at %02x marker segment.\n"", marker);
                return AVERROR_INVALIDDATA;
            }
            end = start + length;

            i = end;
            if (frag->data[i] != 0xff) {
                next_marker = -1;
            } else {
                for (++i; i + 1 < frag->data_size &&
                          frag->data[i] == 0xff; i++);
                if (i + 1 >= frag->data_size) {
                    next_marker = -1;
                } else {
                    next_marker = frag->data[i];
                    next_start  = i + 1;
                }
            }
        }

        if (marker == JPEG_MARKER_SOS) {
            length = AV_RB16(frag->data + start);

            if (length > end - start)
                return AVERROR_INVALIDDATA;

            data_ref = NULL;
            data     = av_malloc(end - start +
                                 AV_INPUT_BUFFER_PADDING_SIZE);
            if (!data)
                return AVERROR(ENOMEM);

            memcpy(data, frag->data + start, length);
            for (i = start + length, j = length; i < end; i++, j++) {
                if (frag->data[i] == 0xff) {
                    while (frag->data[i] == 0xff)
                        ++i;
                    data[j] = 0xff;
                } else {
                    data[j] = frag->data[i];
                }
            }
            data_size = j;

            memset(data + data_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);

        } else {
            data      = frag->data + start;
            data_size = end - start;
            data_ref  = frag->data_ref;
        }

        err = ff_cbs_insert_unit_data(ctx, frag, unit, marker,
                                      data, data_size, data_ref);
        if (err < 0)
            return err;

        if (next_marker == -1)
            break;
        marker = next_marker;
        start  = next_start;
    }

    return 0;
}
","1. int unit, start, end, marker, next_start, next_marker;
2. return AVERROR_INVALIDDATA;
3. if (i + 1 >= frag->data_size) {
4. for (++i; i + 1 < frag->data_size &&
5. data     = av_malloc(end - start +","12
29
38
54
103","CWE-476,CWE-20,CWE-189,CWE-552"
copy_to_user_auth,"static int copy_to_user_auth(struct xfrm_algo_auth *auth, struct sk_buff *skb)
{
	struct xfrm_algo *algo;
	struct nlattr *nla;

	nla = nla_reserve(skb, XFRMA_ALG_AUTH,
			  sizeof(*algo) + (auth->alg_key_len + 7) / 8);
	if (!nla)
 		return -EMSGSIZE;
 
 	algo = nla_data(nla);
	strncpy(algo->alg_name, auth->alg_name, sizeof(algo->alg_name));
 	memcpy(algo->alg_key, auth->alg_key, (auth->alg_key_len + 7) / 8);
 	algo->alg_key_len = auth->alg_key_len;
 
	return 0;
}
","1. static int copy_to_user_auth(struct xfrm_algo_auth *auth, struct sk_buff *skb)
2. if (!nla)
3. algo = nla_data(nla);
4. memcpy(algo->alg_key, auth->alg_key, (auth->alg_key_len + 7) / 8);
algo->alg_key_len = auth->alg_key_len;","1
8
11
13-14","CWE-362,CWE-476,CWE-200,CWE-59"
prealloc_elems_and_freelist-121953620021199,"static int prealloc_elems_and_freelist(struct bpf_stack_map *smap)
{
	u64 elem_size = sizeof(struct stack_map_bucket) +
			(u64)smap->map.value_size;
	int err;

	smap->elems = bpf_map_area_alloc(elem_size * smap->map.max_entries,
					 smap->map.numa_node);
	if (!smap->elems)
		return -ENOMEM;

	err = pcpu_freelist_init(&smap->freelist);
	if (err)
		goto free_elems;

	pcpu_freelist_populate(&smap->freelist, smap->elems, elem_size,
			       smap->map.max_entries);
	return 0;

free_elems:
	bpf_map_area_free(smap->elems);
	return err;
}
","1. return -ENOMEM;
2. bpf_map_area_free(smap->elems);","10
21","CWE-264,CWE-59,CWE-399"
nsc_rle_decode,"
#define BYTE
#define UINT32

static void nsc_rle_decode(BYTE* in, BYTE* out, UINT32 originalSize)
static BOOL nsc_rle_decode(BYTE* in, BYTE* out, UINT32 outSize, UINT32 originalSize)
 {
 	UINT32 len;
 	UINT32 left;
	BYTE value;
	left = originalSize;

	while (left > 4)
	{
		value = *in++;
 
 		if (left == 5)
 		{
			if (outSize < 1)
				return FALSE;

			outSize--;
 			*out++ = value;
 			left--;
 		}
		else if (value == *in)
		{
			in++;

			if (*in < 0xFF)
			{
				len = (UINT32) * in++;
				len += 2;
			}
			else
			{
				in++;
				len = *((UINT32*) in);
 				in += 4;
 			}
 
			if (outSize < len)
				return FALSE;

			outSize -= len;
 			FillMemory(out, len, value);
 			out += len;
 			left -= len;
 		}
 		else
 		{
			if (outSize < 1)
				return FALSE;

			outSize--;
 			*out++ = value;
 			left--;
 		}
 	}
 
	if ((outSize < 4) || (left < 4))
		return FALSE;

	memcpy(out, in, 4);
	return TRUE;
 }
","1. static BOOL nsc_rle_decode(BYTE* in, BYTE* out, UINT32 outSize, UINT32 originalSize)
2. UINT32 len;
UINT32 left;
BYTE value;
left = originalSize;
3. while (left > 4)
4. if (left == 5)
5. if (outSize < 1)
return FALSE;
6. outSize--;
*out++ = value;
left--;
7. else if (value == *in)
8. in++;
9. len = (UINT32) * in++;
len += 2;
10. {
in++;
len = *((UINT32*) in);
in += 4;
11. return FALSE;
12. outSize -= len;
FillMemory(out, len, value);
out += len;
left -= len;
13. if (outSize < 1)
14. outSize--;
*out++ = value;
15. if ((outSize < 4) || (left < 4))
return FALSE;
16. memcpy(out, in, 4);
return TRUE;","6
8-11
13
17
19-20
22-24
26
28
32-33
36-39
43
45-48
52
55-56
61-62
64-65","CWE-125,CWE-787,CWE-119"
check_entry_size_and_hooks_2,"check_entry_size_and_hooks_2(struct ipt_entry *e,
			   struct xt_table_info *newinfo,
			   const unsigned char *base,
			   const unsigned char *limit,
			   const unsigned int *hook_entries,
			   const unsigned int *underflows,
			   unsigned int valid_hooks)
{
	unsigned int h;
	int err;

	if ((unsigned long)e % __alignof__(struct ipt_entry) != 0 ||
	    (unsigned char *)e + sizeof(struct ipt_entry) >= limit ||
	    (unsigned char *)e + e->next_offset > limit) {
		duprintf(""Bad offset %p\n"", e);
		return -EINVAL;
	}

	if (e->next_offset
	    < sizeof(struct ipt_entry) + sizeof(struct xt_entry_target)) {
		duprintf(""checking: element %p size %u\n"",
			 e, e->next_offset);
		return -EINVAL;
	}

	err = check_entry(e);
	if (err)
		return err;

	
	for (h = 0; h < NF_INET_NUMHOOKS; h++) {
		if (!(valid_hooks & (1 << h)))
			continue;
		if ((unsigned char *)e - base == hook_entries[h])
 			newinfo->hook_entry[h] = hook_entries[h];
 		if ((unsigned char *)e - base == underflows[h]) {
 			if (!check_underflow(e)) {
				pr_debug(""Underflows must be unconditional and ""
					 ""use the STANDARD target with ""
					 ""ACCEPT/DROP\n"");
 				return -EINVAL;
 			}
 			newinfo->underflow[h] = underflows[h];
		}
	}

	
	e->counters = ((struct xt_counters) { 0, 0 });
	e->comefrom = 0;
	return 0;
}
","1. unsigned int valid_hooks)
2. duprintf(""checking: element %p size %u\n"",
e, e->next_offset);
return -EINVAL;","7
21-23",CWE-119
construct_get_dest_keyring,"
#define _dest_keyring

static void construct_get_dest_keyring(struct key **_dest_keyring)
static int construct_get_dest_keyring(struct key **_dest_keyring)
 {
 	struct request_key_auth *rka;
 	const struct cred *cred = current_cred();
 	struct key *dest_keyring = *_dest_keyring, *authkey;
	int ret;
 
 	kenter(""%p"", dest_keyring);
 
	
	if (dest_keyring) {
 		
 		key_get(dest_keyring);
 	} else {
		bool do_perm_check = true;

 		
 		switch (cred->jit_keyring) {
		case KEY_REQKEY_DEFL_DEFAULT:
		case KEY_REQKEY_DEFL_REQUESTOR_KEYRING:
			if (cred->request_key_auth) {
				authkey = cred->request_key_auth;
				down_read(&authkey->sem);
				rka = authkey->payload.data[0];
				if (!test_bit(KEY_FLAG_REVOKED,
					      &authkey->flags))
 					dest_keyring =
 						key_get(rka->dest_keyring);
 				up_read(&authkey->sem);
				if (dest_keyring) {
					do_perm_check = false;
 					break;
				}
 			}
 
 		case KEY_REQKEY_DEFL_THREAD_KEYRING:
			dest_keyring = key_get(cred->thread_keyring);
			if (dest_keyring)
				break;

		case KEY_REQKEY_DEFL_PROCESS_KEYRING:
			dest_keyring = key_get(cred->process_keyring);
			if (dest_keyring)
				break;

		case KEY_REQKEY_DEFL_SESSION_KEYRING:
			rcu_read_lock();
			dest_keyring = key_get(
				rcu_dereference(cred->session_keyring));
			rcu_read_unlock();

			if (dest_keyring)
				break;

		case KEY_REQKEY_DEFL_USER_SESSION_KEYRING:
			dest_keyring =
				key_get(cred->user->session_keyring);
			break;

		case KEY_REQKEY_DEFL_USER_KEYRING:
			dest_keyring = key_get(cred->user->uid_keyring);
			break;

		case KEY_REQKEY_DEFL_GROUP_KEYRING:
 		default:
 			BUG();
 		}

		
		if (dest_keyring && do_perm_check) {
			ret = key_permission(make_key_ref(dest_keyring, 1),
					     KEY_NEED_WRITE);
			if (ret) {
				key_put(dest_keyring);
				return ret;
			}
		}
 	}
 
 	*_dest_keyring = dest_keyring;
 	kleave("" [dk %d]"", key_serial(dest_keyring));
	return 0;
 }
","1. static int construct_get_dest_keyring(struct key **_dest_keyring)
2. const struct cred *cred = current_cred();
3. int ret;
4. kenter(""%p"", dest_keyring);
5. if (dest_keyring) {
6. } else {
7. switch (cred->jit_keyring) {
case KEY_REQKEY_DEFL_DEFAULT:
case KEY_REQKEY_DEFL_REQUESTOR_KEYRING:
if (cred->request_key_auth) {
8. rka = authkey->payload.data[0];
9. &authkey->flags))
10. key_get(rka->dest_keyring);
11. do_perm_check = false;
break;
12. case KEY_REQKEY_DEFL_THREAD_KEYRING:
dest_keyring = key_get(cred->thread_keyring);
13. break;
14. case KEY_REQKEY_DEFL_PROCESS_KEYRING:
dest_keyring = key_get(cred->process_keyring);
15. case KEY_REQKEY_DEFL_SESSION_KEYRING:
rcu_read_lock();
16. rcu_read_unlock();
17. if (dest_keyring)
break;
18. case KEY_REQKEY_DEFL_USER_SESSION_KEYRING:
dest_keyring =
19. break;
20. case KEY_REQKEY_DEFL_GROUP_KEYRING:
default:
BUG();
21. if (dest_keyring && do_perm_check) {
ret = key_permission(make_key_ref(dest_keyring, 1),
22. if (ret) {
key_put(dest_keyring);
23. *_dest_keyring = dest_keyring;
kleave("" [dk %d]"", key_serial(dest_keyring));
return 0;","5
8
10
12
15
18
23-26
29
31
33
36-37
41-42
44
46-47
51-52
55
57-58
60-61
67
69-71
83-84
86-87
93-95","CWE-862,CWE-200,CWE-20,CWE-59"
rpza_decode_stream,"
#define RpzaContext

static void rpza_decode_stream(RpzaContext *s)
{
    int width = s->avctx->width;
    int stride = s->frame.linesize[0] / 2;
    int row_inc = stride - 4;
    int stream_ptr = 0;
    int chunk_size;
    unsigned char opcode;
    int n_blocks;
    unsigned short colorA = 0, colorB;
    unsigned short color4[4];
    unsigned char index, idx;
    unsigned short ta, tb;
     unsigned short *pixels = (unsigned short *)s->frame.data[0];
 
     int row_ptr = 0;
    int pixel_ptr = -4;
     int block_ptr;
     int pixel_x, pixel_y;
     int total_blocks;

    
    if (s->buf[stream_ptr] != 0xe1)
        av_log(s->avctx, AV_LOG_ERROR, ""First chunk byte is 0x%02x instead of 0xe1\n"",
            s->buf[stream_ptr]);

    
    chunk_size = AV_RB32(&s->buf[stream_ptr]) & 0x00FFFFFF;
    stream_ptr += 4;

    
    if (chunk_size != s->size)
        av_log(s->avctx, AV_LOG_ERROR, ""MOV chunk size != encoded chunk size; using MOV chunk size\n"");

    chunk_size = s->size;

    
    total_blocks = ((s->avctx->width + 3) / 4) * ((s->avctx->height + 3) / 4);

    
    while (stream_ptr < chunk_size) {
        opcode = s->buf[stream_ptr++]; 

        n_blocks = (opcode & 0x1f) + 1; 

        
        if ((opcode & 0x80) == 0) {
            colorA = (opcode << 8) | (s->buf[stream_ptr++]);
            opcode = 0;
            if ((s->buf[stream_ptr] & 0x80) != 0) {
                
                opcode = 0x20;
                n_blocks = 1;
            }
        }

        switch (opcode & 0xe0) {

        
        case 0x80:
            while (n_blocks--) {
              ADVANCE_BLOCK();
            }
            break;

        
        case 0xa0:
             colorA = AV_RB16 (&s->buf[stream_ptr]);
             stream_ptr += 2;
             while (n_blocks--) {
                ADVANCE_BLOCK()
                 block_ptr = row_ptr + pixel_ptr;
                 for (pixel_y = 0; pixel_y < 4; pixel_y++) {
                     for (pixel_x = 0; pixel_x < 4; pixel_x++){
                        pixels[block_ptr] = colorA;
                        block_ptr++;
                     }
                     block_ptr += row_inc;
                 }
             }
             break;
 
        
        case 0xc0:
            colorA = AV_RB16 (&s->buf[stream_ptr]);
            stream_ptr += 2;
        case 0x20:
            colorB = AV_RB16 (&s->buf[stream_ptr]);
            stream_ptr += 2;

            
            color4[0] = colorB;
            color4[1] = 0;
            color4[2] = 0;
            color4[3] = colorA;

            
            ta = (colorA >> 10) & 0x1F;
            tb = (colorB >> 10) & 0x1F;
            color4[1] |= ((11 * ta + 21 * tb) >> 5) << 10;
            color4[2] |= ((21 * ta + 11 * tb) >> 5) << 10;

            
            ta = (colorA >> 5) & 0x1F;
            tb = (colorB >> 5) & 0x1F;
            color4[1] |= ((11 * ta + 21 * tb) >> 5) << 5;
            color4[2] |= ((21 * ta + 11 * tb) >> 5) << 5;

            
            ta = colorA & 0x1F;
            tb = colorB & 0x1F;
            color4[1] |= ((11 * ta + 21 * tb) >> 5);
            color4[2] |= ((21 * ta + 11 * tb) >> 5);

             if (s->size - stream_ptr < n_blocks * 4)
                 return;
             while (n_blocks--) {
                ADVANCE_BLOCK();
                 block_ptr = row_ptr + pixel_ptr;
                 for (pixel_y = 0; pixel_y < 4; pixel_y++) {
                     index = s->buf[stream_ptr++];
                    for (pixel_x = 0; pixel_x < 4; pixel_x++){
                        idx = (index >> (2 * (3 - pixel_x))) & 0x03;
                        pixels[block_ptr] = color4[idx];
                        block_ptr++;
                     }
                     block_ptr += row_inc;
                 }
             }
             break;
 
         
         case 0x00:
             if (s->size - stream_ptr < 16)
                 return;
            ADVANCE_BLOCK();
             block_ptr = row_ptr + pixel_ptr;
             for (pixel_y = 0; pixel_y < 4; pixel_y++) {
                 for (pixel_x = 0; pixel_x < 4; pixel_x++){
                    
                    if ((pixel_y != 0) || (pixel_x !=0)) {
                        colorA = AV_RB16 (&s->buf[stream_ptr]);
                        stream_ptr += 2;
                    }
                    pixels[block_ptr] = colorA;
                    block_ptr++;
                 }
                 block_ptr += row_inc;
             }
             break;
 
         
        default:
            av_log(s->avctx, AV_LOG_ERROR, ""Unknown opcode %d in rpza chunk.""
                 "" Skip remaining %d bytes of chunk data.\n"", opcode,
                 chunk_size - stream_ptr);
            return;
        } 
    }
}
","1. if (s->buf[stream_ptr] != 0xe1)
2. n_blocks = (opcode & 0x1f) + 1;
3. if ((opcode & 0x80) == 0) {
4. stream_ptr += 2;
5. tb = (colorB >> 5) & 0x1F;
6. color4[1] |= ((11 * ta + 21 * tb) >> 5);
7. return;
8. return;","26
47
50
74
110
117
121
162","CWE-119,CWE-190,CWE-787,CWE-400,CWE-125"
nsc_process_message,"
#define BYTE
#define DstFormat
#define NSC_CONTEXT
#define UINT16
#define UINT32

BOOL nsc_process_message(NSC_CONTEXT* context, UINT16 bpp,
                         UINT32 width, UINT32 height,
                         const BYTE* data, UINT32 length,
                         BYTE* pDstData, UINT32 DstFormat,
                         UINT32 nDstStride,
                         UINT32 nXDst, UINT32 nYDst, UINT32 nWidth,
                         UINT32 nHeight, UINT32 flip)
{
	wStream* s;
	BOOL ret;
	s = Stream_New((BYTE*)data, length);

	if (!s)
		return FALSE;

	if (nDstStride == 0)
		nDstStride = nWidth * GetBytesPerPixel(DstFormat);

	switch (bpp)
	{
		case 32:
			context->format = PIXEL_FORMAT_BGRA32;
			break;

		case 24:
			context->format = PIXEL_FORMAT_BGR24;
			break;

		case 16:
			context->format = PIXEL_FORMAT_BGR16;
			break;

		case 8:
			context->format = PIXEL_FORMAT_RGB8;
			break;

		case 4:
			context->format = PIXEL_FORMAT_A4;
			break;

		default:
			Stream_Free(s, TRUE);
			return FALSE;
	}

	context->width = width;
	context->height = height;
	ret = nsc_context_initialize(context, s);
	Stream_Free(s, FALSE);

	if (!ret)
 		return FALSE;
 
 	
	{
		BOOL rc;
		PROFILER_ENTER(context->priv->prof_nsc_rle_decompress_data)
		rc = nsc_rle_decompress_data(context);
		PROFILER_EXIT(context->priv->prof_nsc_rle_decompress_data)

		if (!rc)
			return FALSE;
	}
 	
	{
		BOOL rc;
		PROFILER_ENTER(context->priv->prof_nsc_decode)
		rc = context->decode(context);
		PROFILER_EXIT(context->priv->prof_nsc_decode)

		if (!rc)
			return FALSE;
	}
 
 	if (!freerdp_image_copy(pDstData, DstFormat, nDstStride, nXDst, nYDst,
 	                        width, height, context->BitmapData,
	                        PIXEL_FORMAT_BGRA32, 0, 0, 0, NULL, flip))
		return FALSE;

	return TRUE;
}
","1. BOOL nsc_process_message(NSC_CONTEXT* context, UINT16 bpp,
2. const BYTE* data, UINT32 length,
3. UINT32 nXDst, UINT32 nYDst, UINT32 nWidth,
UINT32 nHeight, UINT32 flip)
4. if (nDstStride == 0)
nDstStride = nWidth * GetBytesPerPixel(DstFormat);
5. switch (bpp)
6. case 24:
7. break;
8. case 8:
context->format = PIXEL_FORMAT_RGB8;
break;
9. case 4:
10. context->width = width;
11. Stream_Free(s, FALSE);
12. if (!ret)
13. PROFILER_EXIT(context->priv->prof_nsc_rle_decompress_data)
14. return FALSE;
15. PROFILER_ENTER(context->priv->prof_nsc_decode)
rc = context->decode(context);
PROFILER_EXIT(context->priv->prof_nsc_decode)
16. if (!rc)
return FALSE;
17. if (!freerdp_image_copy(pDstData, DstFormat, nDstStride, nXDst, nYDst,","8
10
13-14
23-24
26
32
38
40-42
44
53
56
58
66
69
74-76
78-79
82","CWE-20,CWE-476,CWE-787,CWE-862,CWE-125"
kvm_iommu_map_pages,"int kvm_iommu_map_pages(struct kvm *kvm, struct kvm_memory_slot *slot)
{
	gfn_t gfn, end_gfn;
	pfn_t pfn;
	int r = 0;
	struct iommu_domain *domain = kvm->arch.iommu_domain;
	int flags;

	
	if (!domain)
		return 0;

	gfn     = slot->base_gfn;
	end_gfn = gfn + slot->npages;

	flags = IOMMU_READ;
	if (!(slot->flags & KVM_MEM_READONLY))
		flags |= IOMMU_WRITE;
	if (!kvm->arch.iommu_noncoherent)
		flags |= IOMMU_CACHE;


	while (gfn < end_gfn) {
		unsigned long page_size;

		
		if (iommu_iova_to_phys(domain, gfn_to_gpa(gfn))) {
			gfn += 1;
			continue;
		}

		
		page_size = kvm_host_page_size(kvm, gfn);

		
		while ((gfn + (page_size >> PAGE_SHIFT)) > end_gfn)
			page_size >>= 1;

		
		while ((gfn << PAGE_SHIFT) & (page_size - 1))
			page_size >>= 1;

		
		while (__gfn_to_hva_memslot(slot, gfn) & (page_size - 1))
			page_size >>= 1;

		
		pfn = kvm_pin_pages(slot, gfn, page_size >> PAGE_SHIFT);
 		if (is_error_noslot_pfn(pfn)) {
 			gfn += 1;
 			continue;
		}

		
		r = iommu_map(domain, gfn_to_gpa(gfn), pfn_to_hpa(pfn),
			      page_size, flags);
 		if (r) {
 			printk(KERN_ERR ""kvm_iommu_map_address:""
 			       ""iommu failed to map pfn=%llx\n"", pfn);
			kvm_unpin_pages(kvm, pfn, page_size >> PAGE_SHIFT);
 			goto unmap_pages;
 		}
 
		gfn += page_size >> PAGE_SHIFT;


	}

	return 0;

unmap_pages:
	kvm_iommu_put_pages(kvm, slot->base_gfn, gfn - slot->base_gfn);
	return r;
}
","1. gfn_t gfn, end_gfn;
2. if (!(slot->flags & KVM_MEM_READONLY))
3. flags |= IOMMU_CACHE;
4. unsigned long page_size;
5. if (iommu_iova_to_phys(domain, gfn_to_gpa(gfn))) {
6. continue;
7. page_size = kvm_host_page_size(kvm, gfn);
8. while ((gfn + (page_size >> PAGE_SHIFT)) > end_gfn)
9. while ((gfn << PAGE_SHIFT) & (page_size - 1))
page_size >>= 1;
10. gfn += 1;
11. if (r) {
12. return 0;","3
17
20
24
27
29
33
36
40-41
53
60
72","CWE-787,CWE-189,CWE-119"
picolcd_raw_event-87883450839863,"static int picolcd_raw_event(struct hid_device *hdev,
		struct hid_report *report, u8 *raw_data, int size)
{
	struct picolcd_data *data = hid_get_drvdata(hdev);
	unsigned long flags;
	int ret = 0;

	if (!data)
		return 1;

	if (size > 64) {
		hid_warn(hdev, ""invalid size value (%d) for picolcd raw event\n"",
				size);
		return 0;
	}

	if (report->id == REPORT_KEY_STATE) {
		if (data->input_keys)
			ret = picolcd_raw_keypad(data, report, raw_data+1, size-1);
	} else if (report->id == REPORT_IR_DATA) {
		ret = picolcd_raw_cir(data, report, raw_data+1, size-1);
	} else {
		spin_lock_irqsave(&data->lock, flags);
		
		if (data->pending) {
			memcpy(data->pending->raw_data, raw_data+1, size-1);
			data->pending->raw_size  = size-1;
			data->pending->in_report = report;
			complete(&data->pending->ready);
		}
		spin_unlock_irqrestore(&data->lock, flags);
	}

	picolcd_debug_raw_event(data, hdev, report, raw_data, size);
	return 1;
}
","1. struct hid_report *report, u8 *raw_data, int size)
2. int ret = 0;
3. return 1;
4. size);
return 0;
5. if (data->input_keys)
6. } else if (report->id == REPORT_IR_DATA) {
7. } else {
8. if (data->pending) {
9. data->pending->in_report = report;
complete(&data->pending->ready);
10. spin_unlock_irqrestore(&data->lock, flags);
11. return 1;","2
6
9
13-14
18
20
22
28
31-32
34
38","CWE-617,CWE-200,CWE-125,CWE-119"
extract_sockaddr,"bool extract_sockaddr(char *url, char **sockaddr_url, char **sockaddr_port)
{
	char *url_begin, *url_end, *ipv6_begin, *ipv6_end, *port_start = NULL;
	char url_address[256], port[6];
	int url_len, port_len = 0;

	*sockaddr_url = url;
	url_begin = strstr(url, ""
	if (!url_begin)
		url_begin = url;
	else
		url_begin += 2;

	
	ipv6_begin = strstr(url_begin, ""["");
	ipv6_end = strstr(url_begin, ""]"");
	if (ipv6_begin && ipv6_end && ipv6_end > ipv6_begin)
		url_end = strstr(ipv6_end, "":"");
	else
		url_end = strstr(url_begin, "":"");
	if (url_end) {
		url_len = url_end - url_begin;
		port_len = strlen(url_begin) - url_len - 1;
		if (port_len < 1)
			return false;
		port_start = url_end + 1;
	} else
		url_len = strlen(url_begin);

 	if (url_len < 1)
 		return false;
 
	snprintf(url_address, 254, ""%.*s"", url_len, url_begin);
 
 	if (port_len) {
 		char *slash;

		snprintf(port, 6, ""%.*s"", port_len, port_start);
		slash = strchr(port, '/');
		if (slash)
			*slash = '\0';
	} else
		strcpy(port, ""80"");

	*sockaddr_port = strdup(port);
	*sockaddr_url = strdup(url_address);

	return true;
}
","1. bool extract_sockaddr(char *url, char **sockaddr_url, char **sockaddr_port)
2. char *url_begin, *url_end, *ipv6_begin, *ipv6_end, *port_start = NULL;
3. url_len = url_end - url_begin;
4. return false;
5. url_len = strlen(url_begin);
6. snprintf(url_address, 254, ""%.*s"", url_len, url_begin);
7. slash = strchr(port, '/');","1
3
22
25
28
33
39","CWE-787,CWE-119"
psf_close,"
#define SF_PRIVATE

psf_close (SF_PRIVATE *psf)
{	uint32_t k ;
	int	error = 0 ;

	if (psf->codec_close)
	{	error = psf->codec_close (psf) ;
		
		psf->codec_close = NULL ;
		} ;

	if (psf->container_close)
		error = psf->container_close (psf) ;

	error = psf_fclose (psf) ;
 	psf_close_rsrc (psf) ;
 
 	
	free (psf->header.ptr) ;
 	free (psf->container_data) ;
 	free (psf->codec_data) ;
 	free (psf->interleave) ;
	free (psf->dither) ;
	free (psf->peak_info) ;
	free (psf->broadcast_16k) ;
	free (psf->loop_info) ;
	free (psf->instrument) ;
	free (psf->cues) ;
	free (psf->channel_map) ;
	free (psf->format_desc) ;
	free (psf->strings.storage) ;

	if (psf->wchunks.chunks)
		for (k = 0 ; k < psf->wchunks.used ; k++)
			free (psf->wchunks.chunks [k].data) ;
	free (psf->rchunks.chunks) ;
	free (psf->wchunks.chunks) ;
	free (psf->iterator) ;
	free (psf->cart_16k) ;

	memset (psf, 0, sizeof (SF_PRIVATE)) ;
	free (psf) ;

	return error ;
} 
","1. psf->codec_close = NULL ;
2. free (psf->dither) ;
3. free (psf->loop_info) ;
4. free (psf->channel_map) ;
5. if (psf->wchunks.chunks)","11
25
28
31
35","CWE-200,CWE-264,CWE-119"
njs_typed_array_set_value-148457487378644,"njs_int_t
njs_typed_array_set_value(njs_vm_t *vm, njs_typed_array_t *array,
    uint32_t index, njs_value_t *setval)
{
    double              num;
    njs_int_t           ret;
    njs_array_buffer_t  *buffer;

    ret = njs_value_to_number(vm, setval, &num);
    if (njs_slow_path(ret != NJS_OK)) {
        return ret;
    }

    buffer = njs_typed_array_writable(vm, array);
    if (njs_slow_path(buffer == NULL)) {
        return NJS_ERROR;
    }

    njs_typed_array_prop_set(vm, array, index, num);

    return NJS_OK;
}
","1. njs_int_t
2. buffer = njs_typed_array_writable(vm, array);
3. return NJS_OK;","1
14
21","CWE-476,CWE-362,CWE-20,CWE-416"
bpf_map_get_with_uref-226557290432751,"struct bpf_map *bpf_map_get_with_uref(u32 ufd)
{
	struct fd f = fdget(ufd);
	struct bpf_map *map;

	map = __bpf_map_get(f);
	if (IS_ERR(map))
		return map;

	map = bpf_map_inc(map, true);
	fdput(f);

	return map;
}
","1. struct fd f = fdget(ufd);
struct bpf_map *map;
2. if (IS_ERR(map))
return map;
3. fdput(f);
4. return map;","3-4
7-8
11
13","CWE-476,CWE-190,CWE-264,CWE-119"
ptaReadStream-267383662529572,"
#define FILE

PTA *
ptaReadStream(FILE  *fp)
{
char       typestr[128];  
l_int32    i, n, ix, iy, type, version;
l_float32  x, y;
PTA       *pta;

    PROCNAME(""ptaReadStream"");

    if (!fp)
        return (PTA *)ERROR_PTR(""stream not defined"", procName, NULL);

    if (fscanf(fp, ""\n Pta Version %d\n"", &version) != 1)
        return (PTA *)ERROR_PTR(""not a pta file"", procName, NULL);
    if (version != PTA_VERSION_NUMBER)
        return (PTA *)ERROR_PTR(""invalid pta version"", procName, NULL);
    if (fscanf(fp, "" Number of pts = %d; format = %127s\n"", &n, typestr) != 2)
        return (PTA *)ERROR_PTR(""not a pta file"", procName, NULL);
    if (!strcmp(typestr, ""float""))
        type = 0;
    else  
        type = 1;

    if ((pta = ptaCreate(n)) == NULL)
        return (PTA *)ERROR_PTR(""pta not made"", procName, NULL);
    for (i = 0; i < n; i++) {
        if (type == 0) {  
            if (fscanf(fp, ""   (%f, %f)\n"", &x, &y) != 2) {
                ptaDestroy(&pta);
                return (PTA *)ERROR_PTR(""error reading floats"", procName, NULL);
            }
            ptaAddPt(pta, x, y);
        } else {   
            if (fscanf(fp, ""   (%d, %d)\n"", &ix, &iy) != 2) {
                ptaDestroy(&pta);
                return (PTA *)ERROR_PTR(""error reading ints"", procName, NULL);
            }
            ptaAddPt(pta, ix, iy);
        }
    }

    return pta;
}
","1. char       typestr[128];
2. l_float32  x, y;
3. type = 1;
4. return (PTA *)ERROR_PTR(""pta not made"", procName, NULL);
for (i = 0; i < n; i++) {
5. ptaAddPt(pta, x, y);
6. return (PTA *)ERROR_PTR(""error reading ints"", procName, NULL);
7. return pta;","7
9
26
29-30
36
40
46","CWE-191,CWE-190,CWE-125"
mincore_pmd_range,"static void mincore_pmd_range(struct vm_area_struct *vma, pud_t *pud,
			unsigned long addr, unsigned long end,
			unsigned char *vec)
{
	unsigned long next;
	pmd_t *pmd;

	pmd = pmd_offset(pud, addr);
	do {
		next = pmd_addr_end(addr, end);
		if (pmd_trans_huge(*pmd)) {
			if (mincore_huge_pmd(vma, pmd, addr, next, vec)) {
				vec += (next - addr) >> PAGE_SHIFT;
				continue;
 			}
 			
 		}
		if (pmd_none_or_trans_huge_or_clear_bad(pmd))
 			mincore_unmapped_range(vma, addr, next, vec);
 		else
 			mincore_pte_range(vma, pmd, addr, next, vec);
		vec += (next - addr) >> PAGE_SHIFT;
	} while (pmd++, addr = next, addr != end);
}
","1. unsigned long next;
pmd_t *pmd;
2. do {
next = pmd_addr_end(addr, end);
3. vec += (next - addr) >> PAGE_SHIFT;
4. mincore_pte_range(vma, pmd, addr, next, vec);
vec += (next - addr) >> PAGE_SHIFT;","5-6
9-10
13
21-22","CWE-20,CWE-264,CWE-399"
validate_T,"validate_T(void)
 

 {
    unsigned int i;
 
   for (i=0; i<TTABLE_SIZE; ++i) if (transform_info[i].name != NULL)
    {
       if (transform_info[i].when & TRANSFORM_R)
          read_transforms |= transform_info[i].transform;

 if (transform_info[i].when & TRANSFORM_W)
         write_transforms |= transform_info[i].transform;
 }

 
   rw_transforms = read_transforms & write_transforms;
}
","1. unsigned int i;
2. for (i=0; i<TTABLE_SIZE; ++i) if (transform_info[i].name != NULL)","5
7","CWE-787,CWE-674,CWE-358,CWE-74"
unimac_mdio_probe-122699866480932,"static int unimac_mdio_probe(struct platform_device *pdev)
{
	struct unimac_mdio_pdata *pdata = pdev->dev.platform_data;
	struct unimac_mdio_priv *priv;
	struct device_node *np;
	struct mii_bus *bus;
	struct resource *r;
	int ret;

	np = pdev->dev.of_node;

	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
	if (!priv)
		return -ENOMEM;

	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
	if (!r)
		return -EINVAL;

	
	priv->base = devm_ioremap(&pdev->dev, r->start, resource_size(r));
	if (!priv->base) {
		dev_err(&pdev->dev, ""failed to remap register\n"");
		return -ENOMEM;
	}

	priv->mii_bus = mdiobus_alloc();
	if (!priv->mii_bus)
		return -ENOMEM;

	bus = priv->mii_bus;
	bus->priv = priv;
	if (pdata) {
		bus->name = pdata->bus_name;
		priv->wait_func = pdata->wait_func;
		priv->wait_func_data = pdata->wait_func_data;
		bus->phy_mask = ~pdata->phy_mask;
	} else {
		bus->name = ""unimac MII bus"";
		priv->wait_func_data = priv;
		priv->wait_func = unimac_mdio_poll;
	}
	bus->parent = &pdev->dev;
	bus->read = unimac_mdio_read;
	bus->write = unimac_mdio_write;
	bus->reset = unimac_mdio_reset;
	snprintf(bus->id, MII_BUS_ID_SIZE, ""%s-%d"", pdev->name, pdev->id);

	ret = of_mdiobus_register(bus, np);
	if (ret) {
		dev_err(&pdev->dev, ""MDIO bus registration failed\n"");
		goto out_mdio_free;
	}

	platform_set_drvdata(pdev, priv);

	dev_info(&pdev->dev, ""Broadcom UniMAC MDIO bus at 0x%p\n"", priv->base);

	return 0;

out_mdio_free:
	mdiobus_free(bus);
	return ret;
}
","1. static int unimac_mdio_probe(struct platform_device *pdev)
2. struct resource *r;
3. priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
4. return -EINVAL;
5. priv->mii_bus = mdiobus_alloc();
6. bus->write = unimac_mdio_write;
7. snprintf(bus->id, MII_BUS_ID_SIZE, ""%s-%d"", pdev->name, pdev->id);","1
7
12
18
29
47
49","CWE-476,CWE-119"
ex_substitute_4-54041152869529,"    void
ex_substitute_4(exarg_T *eap)
{
    linenr_T	lnum;
    long	i = 0;
    regmmatch_T regmatch;
    static subflags_T subflags = {FALSE, FALSE, FALSE, TRUE, FALSE,
							      FALSE, FALSE, 0};
#ifdef FEAT_EVAL
    subflags_T	subflags_save;
#endif
    int		save_do_all;		
    int		save_do_ask;		
    char_u	*pat = NULL, *sub = NULL;	
    char_u	*sub_copy = NULL;
    int		delimiter;
    int		sublen;
    int		got_quit = FALSE;
    int		got_match = FALSE;
    int		which_pat;
    char_u	*cmd;
    int		save_State;
    linenr_T	first_line = 0;		
    linenr_T	last_line= 0;		
					
    linenr_T	old_line_count = curbuf->b_ml.ml_line_count;
    linenr_T	line2;
    long	nmatch;			
    char_u	*sub_firstline;		
    int		endcolumn = FALSE;	
    pos_T	old_cursor = curwin->w_cursor;
    int		start_nsubs;
#ifdef FEAT_EVAL
    int		save_ma = 0;
    int		save_sandbox = 0;
#endif
#ifdef FEAT_PROP_POPUP
    textprop_T	*text_props = NULL;
#endif

    cmd = eap->arg;
    if (!global_busy)
    {
	sub_nsubs = 0;
	sub_nlines = 0;
    }
    start_nsubs = sub_nsubs;

    if (eap->cmdidx == CMD_tilde)
	which_pat = RE_LAST;	
    else
	which_pat = RE_SUBST;	

				
    if (eap->cmd[0] == 's' && *cmd != NUL && !VIM_ISWHITE(*cmd)
		&& vim_strchr((char_u *)""0123456789cegriIp|\"""", *cmd) == NULL)
    {
				
	if (check_regexp_delim(*cmd) == FAIL)
	    return;
#ifdef FEAT_EVAL
	if (in_vim9script() && check_global_and_subst(eap->cmd, eap->arg)
								      == FAIL)
	    return;
#endif

	
	if (*cmd == '\\')
	{
	    if (in_vim9script())
	    {
		emsg(_(e_cannot_use_s_backslash_in_vim9_script));
		return;
	    }
	    ++cmd;
	    if (vim_strchr((char_u *)""/?&"", *cmd) == NULL)
	    {
		emsg(_(e_backslash_should_be_followed_by));
		return;
	    }
	    if (*cmd != '&')
		which_pat = RE_SEARCH;	    
	    pat = (char_u *)"""";		    
	    delimiter = *cmd++;		    
	}
	else		
	{
	    which_pat = RE_LAST;	    
	    delimiter = *cmd++;		    
	    pat = cmd;			    
	    cmd = skip_regexp_ex(cmd, delimiter, magic_isset(),
							&eap->arg, NULL, NULL);
	    if (cmd[0] == delimiter)	    
		*cmd++ = NUL;		    
	}

	
	sub = cmd;	    
	cmd = skip_substitute(cmd, delimiter);

	if (!eap->skip)
	{
	    
	    if (STRCMP(sub, ""%"") == 0
				 && vim_strchr(p_cpo, CPO_SUBPERCENT) != NULL)
	    {
		if (old_sub == NULL)	
		{
		    emsg(_(e_no_previous_substitute_regular_expression));
		    return;
		}
		sub = old_sub;
	    }
	    else
	    {
		vim_free(old_sub);
		old_sub = vim_strsave(sub);
	    }
	}
    }
    else if (!eap->skip)	
    {
	if (old_sub == NULL)	
	{
	    emsg(_(e_no_previous_substitute_regular_expression));
	    return;
	}
	pat = NULL;		
	sub = old_sub;

	
	
	endcolumn = (curwin->w_curswant == MAXCOL);
    }

    
    
    
    
    if (pat != NULL && STRCMP(pat, ""\\n"") == 0
	    && *sub == NUL
	    && (*cmd == NUL || (cmd[1] == NUL && (*cmd == 'g' || *cmd == 'l'
					     || *cmd == 'p' || *cmd == '#'))))
    {
	linenr_T    joined_lines_count;

	if (eap->skip)
	    return;
	curwin->w_cursor.lnum = eap->line1;
	if (*cmd == 'l')
	    eap->flags = EXFLAG_LIST;
	else if (*cmd == '#')
	    eap->flags = EXFLAG_NR;
	else if (*cmd == 'p')
	    eap->flags = EXFLAG_PRINT;

	
	
	joined_lines_count = eap->line2 - eap->line1 + 1;
	if (eap->line2 < curbuf->b_ml.ml_line_count)
	    ++joined_lines_count;
	if (joined_lines_count > 1)
	{
	    (void)do_join(joined_lines_count, FALSE, TRUE, FALSE, TRUE);
	    sub_nsubs = joined_lines_count - 1;
	    sub_nlines = 1;
	    (void)do_sub_msg(FALSE);
	    ex_may_print(eap);
	}

	if ((cmdmod.cmod_flags & CMOD_KEEPPATTERNS) == 0)
	    save_re_pat(RE_SUBST, pat, magic_isset());
	
	add_to_history(HIST_SEARCH, pat, TRUE, NUL);

	return;
    }

    
    if (*cmd == '&')
	++cmd;
    else
    {
#ifdef FEAT_EVAL
	if (in_vim9script())
	{
	    
	    subflags.do_all = FALSE;
	    subflags.do_ask = FALSE;
	}
	else
#endif
	if (!p_ed)
	{
	    if (p_gd)		
		subflags.do_all = TRUE;
	    else
		subflags.do_all = FALSE;
	    subflags.do_ask = FALSE;
	}
	subflags.do_error = TRUE;
	subflags.do_print = FALSE;
	subflags.do_list = FALSE;
	subflags.do_count = FALSE;
	subflags.do_number = FALSE;
	subflags.do_ic = 0;
    }
    while (*cmd)
    {
	
	if (*cmd == 'g')
	    subflags.do_all = !subflags.do_all;
	else if (*cmd == 'c')
	    subflags.do_ask = !subflags.do_ask;
	else if (*cmd == 'n')
	    subflags.do_count = TRUE;
	else if (*cmd == 'e')
	    subflags.do_error = !subflags.do_error;
	else if (*cmd == 'r')	    
	    which_pat = RE_LAST;
	else if (*cmd == 'p')
	    subflags.do_print = TRUE;
	else if (*cmd == '#')
	{
	    subflags.do_print = TRUE;
	    subflags.do_number = TRUE;
	}
	else if (*cmd == 'l')
	{
	    subflags.do_print = TRUE;
	    subflags.do_list = TRUE;
	}
	else if (*cmd == 'i')	    
	    subflags.do_ic = 'i';
	else if (*cmd == 'I')	    
	    subflags.do_ic = 'I';
	else
	    break;
	++cmd;
    }
    if (subflags.do_count)
	subflags.do_ask = FALSE;

    save_do_all = subflags.do_all;
    save_do_ask = subflags.do_ask;

    
    cmd = skipwhite(cmd);
    if (VIM_ISDIGIT(*cmd))
    {
	i = getdigits(&cmd);
	if (i <= 0 && !eap->skip && subflags.do_error)
	{
	    emsg(_(e_positive_count_required));
	    return;
	}
	eap->line1 = eap->line2;
	eap->line2 += i - 1;
	if (eap->line2 > curbuf->b_ml.ml_line_count)
	    eap->line2 = curbuf->b_ml.ml_line_count;
    }

    
    cmd = skipwhite(cmd);
    if (*cmd && *cmd != '""')	    
    {
	set_nextcmd(eap, cmd);
	if (eap->nextcmd == NULL)
	{
	    semsg(_(e_trailing_characters_str), cmd);
	    return;
	}
    }

    if (eap->skip)	    
	return;

    if (!subflags.do_count && !curbuf->b_p_ma)
    {
	
	emsg(_(e_cannot_make_changes_modifiable_is_off));
	return;
    }

    if (search_regcomp(pat, NULL, RE_SUBST, which_pat, SEARCH_HIS, &regmatch) == FAIL)
    {
	if (subflags.do_error)
	    emsg(_(e_invalid_command));
	return;
    }

    
    if (subflags.do_ic == 'i')
	regmatch.rmm_ic = TRUE;
    else if (subflags.do_ic == 'I')
	regmatch.rmm_ic = FALSE;

    sub_firstline = NULL;

    
    if (sub[0] == '\\' && sub[1] == '=')
    {
	sub = vim_strsave(sub);
	if (sub == NULL)
	    return;
	sub_copy = sub;
    }
    else
    {
	char_u *newsub = regtilde(sub, magic_isset());

	if (newsub != sub)
	{
	    
	    sub_copy = newsub;
	    sub = newsub;
	}
    }

    
    line2 = eap->line2;
    for (lnum = eap->line1; lnum <= line2 && !(got_quit
#if defined(FEAT_EVAL)
		|| aborting()
#endif
		); ++lnum)
    {
	nmatch = vim_regexec_multi(&regmatch, curwin, curbuf, lnum,
						       (colnr_T)0, NULL);
	if (nmatch)
	{
	    colnr_T	copycol;
	    colnr_T	matchcol;
	    colnr_T	prev_matchcol = MAXCOL;
	    char_u	*new_end, *new_start = NULL;
	    unsigned	new_start_len = 0;
	    char_u	*p1;
	    int		did_sub = FALSE;
	    int		lastone;
	    int		len, copy_len, needed_len;
	    long	nmatch_tl = 0;	
	    int		do_again;	
	    int		skip_match = FALSE;
	    linenr_T	sub_firstlnum;	
#ifdef FEAT_PROP_POPUP
	    int		apc_flags = APC_SAVE_FOR_UNDO | APC_SUBSTITUTE;
	    colnr_T	total_added =  0;
	    int		text_prop_count = 0;
#endif

	    
	    sub_firstlnum = lnum;
	    copycol = 0;
	    matchcol = 0;

	    
	    if (!got_match)
	    {
		setpcmark();
		got_match = TRUE;
	    }

	    
	    for (;;)
	    {
		
		
		
		if (regmatch.startpos[0].lnum > 0)
		{
		    lnum += regmatch.startpos[0].lnum;
		    sub_firstlnum += regmatch.startpos[0].lnum;
		    nmatch -= regmatch.startpos[0].lnum;
		    VIM_CLEAR(sub_firstline);
		}

		
		
		if (lnum > curbuf->b_ml.ml_line_count)
		    break;

		if (sub_firstline == NULL)
		{
		    sub_firstline = vim_strsave(ml_get(sub_firstlnum));
		    if (sub_firstline == NULL)
		    {
			vim_free(new_start);
			goto outofmem;
		    }
		}

		
		
		curwin->w_cursor.lnum = lnum;
		do_again = FALSE;

		
		if (matchcol == prev_matchcol
			&& regmatch.endpos[0].lnum == 0
			&& matchcol == regmatch.endpos[0].col)
		{
		    if (sub_firstline[matchcol] == NUL)
			
			
			skip_match = TRUE;
		    else
		    {
			 
			if (has_mbyte)
			    matchcol += mb_ptr2len(sub_firstline + matchcol);
			else
			    ++matchcol;
		    }
		    goto skip;
		}

		
		
		matchcol = regmatch.endpos[0].col;
		prev_matchcol = matchcol;

		
		if (subflags.do_count)
		{
		    
		    
		    
		    
		    if (nmatch > 1)
		    {
			matchcol = (colnr_T)STRLEN(sub_firstline);
			nmatch = 1;
			skip_match = TRUE;
		    }
		    sub_nsubs++;
		    did_sub = TRUE;
#ifdef FEAT_EVAL
		    
		    
		    if (!(sub[0] == '\\' && sub[1] == '='))
#endif
			goto skip;
		}

		if (subflags.do_ask)
		{
		    int typed = 0;

		    
		    
		    save_State = State;
		    State = MODE_CONFIRM;
		    setmouse();		
		    curwin->w_cursor.col = regmatch.startpos[0].col;
		    if (curwin->w_p_crb)
			do_check_cursorbind();

		    
		    
		    if (vim_strchr(p_cpo, CPO_UNDO) != NULL)
			++no_u_sync;

		    
		    while (subflags.do_ask)
		    {
			if (exmode_active)
			{
			    char_u	*resp;
			    colnr_T	sc, ec;

			    print_line_no_prefix(lnum,
					 subflags.do_number, subflags.do_list);

			    getvcol(curwin, &curwin->w_cursor, &sc, NULL, NULL);
			    curwin->w_cursor.col = regmatch.endpos[0].col - 1;
			    if (curwin->w_cursor.col < 0)
				curwin->w_cursor.col = 0;
			    getvcol(curwin, &curwin->w_cursor, NULL, NULL, &ec);
			    curwin->w_cursor.col = regmatch.startpos[0].col;
			    if (subflags.do_number || curwin->w_p_nu)
			    {
				int numw = number_width(curwin) + 1;
				sc += numw;
				ec += numw;
			    }
			    msg_start();
			    for (i = 0; i < (long)sc; ++i)
				msg_putchar(' ');
			    for ( ; i <= (long)ec; ++i)
				msg_putchar('^');

			    resp = getexmodeline('?', NULL, 0, TRUE);
			    if (resp != NULL)
			    {
				typed = *resp;
				vim_free(resp);
				
				
				
				if (ex_normal_busy && typed == NUL)
				    typed = 'q';
			    }
			}
			else
			{
			    char_u *orig_line = NULL;
			    int    len_change = 0;
			    int	   save_p_lz = p_lz;
#ifdef FEAT_FOLDING
			    int save_p_fen = curwin->w_p_fen;

			    curwin->w_p_fen = FALSE;
#endif
			    
			    
			    int save_RedrawingDisabled = RedrawingDisabled;
			    RedrawingDisabled = 0;

			    
			    p_lz = FALSE;

			    if (new_start != NULL)
			    {
				
				
				
				
				
				orig_line = vim_strsave(ml_get(lnum));
				if (orig_line != NULL)
				{
				    char_u *new_line = concat_str(new_start,
						     sub_firstline + copycol);

				    if (new_line == NULL)
					VIM_CLEAR(orig_line);
				    else
				    {
					
					
					
					
					
					len_change = (int)STRLEN(new_line)
						     - (int)STRLEN(orig_line);
					curwin->w_cursor.col += len_change;
					ml_replace(lnum, new_line, FALSE);
				    }
				}
			    }

			    search_match_lines = regmatch.endpos[0].lnum
						  - regmatch.startpos[0].lnum;
			    search_match_endcol = regmatch.endpos[0].col
								 + len_change;
			    if (search_match_lines == 0
						   && search_match_endcol == 0)
				
				search_match_endcol = 1;
			    highlight_match = TRUE;

			    update_topline();
			    validate_cursor();
			    update_screen(UPD_SOME_VALID);
			    highlight_match = FALSE;
			    redraw_later(UPD_SOME_VALID);

#ifdef FEAT_FOLDING
			    curwin->w_p_fen = save_p_fen;
#endif
			    if (msg_row == Rows - 1)
				msg_didout = FALSE;	
			    msg_starthere();
			    i = msg_scroll;
			    msg_scroll = 0;		
							
			    msg_no_more = TRUE;
			    
			    
			    smsg_attr(HL_ATTR(HLF_R),
				_(""replace with %s (y/n/a/q/l/^E/^Y)?""), sub);
			    msg_no_more = FALSE;
			    msg_scroll = i;
			    showruler(TRUE);
			    windgoto(msg_row, msg_col);
			    RedrawingDisabled = save_RedrawingDisabled;

#ifdef USE_ON_FLY_SCROLL
			    dont_scroll = FALSE; 
#endif
			    ++no_mapping;	
			    ++allow_keys;	
			    typed = plain_vgetc();
			    --allow_keys;
			    --no_mapping;

			    
			    msg_didout = FALSE;	
			    msg_col = 0;
			    gotocmdline(TRUE);
			    p_lz = save_p_lz;

			    
			    if (orig_line != NULL)
				ml_replace(lnum, orig_line, FALSE);
			}

			need_wait_return = FALSE; 
			if (typed == 'q' || typed == ESC || typed == Ctrl_C
#ifdef UNIX
				|| typed == intr_char
#endif
				)
			{
			    got_quit = TRUE;
			    break;
			}
			if (typed == 'n')
			    break;
			if (typed == 'y')
			    break;
			if (typed == 'l')
			{
			    
			    subflags.do_all = FALSE;
			    line2 = lnum;
			    break;
			}
			if (typed == 'a')
			{
			    subflags.do_ask = FALSE;
			    break;
			}
			if (typed == Ctrl_E)
			    scrollup_clamp();
			else if (typed == Ctrl_Y)
			    scrolldown_clamp();
		    }
		    State = save_State;
		    setmouse();
		    if (vim_strchr(p_cpo, CPO_UNDO) != NULL)
			--no_u_sync;

		    if (typed == 'n')
		    {
			
			
			
			
			
			if (nmatch > 1)
			{
			    matchcol = (colnr_T)STRLEN(sub_firstline);
			    skip_match = TRUE;
			}
			goto skip;
		    }
		    if (got_quit)
			goto skip;
		}

		
		
		curwin->w_cursor.col = regmatch.startpos[0].col;

		
#ifdef FEAT_EVAL
		save_ma = curbuf->b_p_ma;
		save_sandbox = sandbox;
		if (subflags.do_count)
		{
		    
		    curbuf->b_p_ma = FALSE;
		    sandbox++;
		}
		
		
		subflags_save = subflags;

		
		++textlock;
#endif
		
		
		sublen = vim_regsub_multi(&regmatch,
				    sub_firstlnum - regmatch.startpos[0].lnum,
			       sub, sub_firstline, 0,
			       REGSUB_BACKSLASH
				    | (magic_isset() ? REGSUB_MAGIC : 0));
#ifdef FEAT_EVAL
		--textlock;

		
		
		
		subflags = subflags_save;
		if (sublen == 0 || aborting() || subflags.do_count)
		{
		    curbuf->b_p_ma = save_ma;
		    sandbox = save_sandbox;
		    goto skip;
		}
#endif

		
		
		if (nmatch > curbuf->b_ml.ml_line_count - sub_firstlnum + 1)
		{
		    nmatch = curbuf->b_ml.ml_line_count - sub_firstlnum + 1;
		    skip_match = TRUE;
		    
		    if (nmatch < 0)
			goto skip;
		}

		
		
		
		
		
		
		
		if (nmatch == 1)
		{
		    p1 = sub_firstline;
#ifdef FEAT_PROP_POPUP
		    if (curbuf->b_has_textprop)
		    {
			int bytes_added = sublen - 1 - (regmatch.endpos[0].col
						   - regmatch.startpos[0].col);

			
			
			if (adjust_prop_columns(lnum,
					total_added + regmatch.startpos[0].col,
						       bytes_added, apc_flags))
			    apc_flags &= ~APC_SAVE_FOR_UNDO;
			
			
			total_added += bytes_added;
		    }
#endif
		}
		else
		{
		    linenr_T	lastlnum = sub_firstlnum + nmatch - 1;
#ifdef FEAT_PROP_POPUP
		    if (curbuf->b_has_textprop)
		    {
			char_u	*prop_start;

			
			if (adjust_prop_columns(lnum,
					total_added + regmatch.startpos[0].col,
						       -MAXCOL, apc_flags))
			    apc_flags &= ~APC_SAVE_FOR_UNDO;
			total_added -= (colnr_T)STRLEN(
				     sub_firstline + regmatch.startpos[0].col);

			
			if (adjust_prop_columns(lastlnum,
					0, -regmatch.endpos[0].col, apc_flags))
			    
			    
			    apc_flags &= ~APC_SAVE_FOR_UNDO;

			
			
			text_prop_count = get_text_props(curbuf, lastlnum,
							   &prop_start, FALSE);
			if (text_prop_count > 0)
			{
			    
			    vim_free(text_props);
			    text_props = ALLOC_MULT(textprop_T,
							      text_prop_count);
			    if (text_props != NULL)
			    {
				int pi;

				mch_memmove(text_props, prop_start,
					 text_prop_count * sizeof(textprop_T));
				
				
				for (pi = 0; pi < text_prop_count; ++pi)
				    text_props[pi].tp_col +=
					 regmatch.startpos[0].col + sublen - 1;
			    }
			}
		    }
#endif
		    p1 = ml_get(lastlnum);
		    nmatch_tl += nmatch - 1;
#ifdef FEAT_PROP_POPUP
		    if (curbuf->b_has_textprop)
			total_added += (colnr_T)STRLEN(
						  p1 + regmatch.endpos[0].col);
#endif
		}
		copy_len = regmatch.startpos[0].col - copycol;
		needed_len = copy_len + ((unsigned)STRLEN(p1)
				       - regmatch.endpos[0].col) + sublen + 1;
		if (new_start == NULL)
		{
		    
		    new_start_len = needed_len + 50;
		    if ((new_start = alloc(new_start_len)) == NULL)
			goto outofmem;
		    *new_start = NUL;
		    new_end = new_start;
		}
		else
		{
		    
		    len = (unsigned)STRLEN(new_start);
		    needed_len += len;
		    if (needed_len > (int)new_start_len)
		    {
			new_start_len = needed_len + 50;
			if ((p1 = alloc(new_start_len)) == NULL)
			{
			    vim_free(new_start);
			    goto outofmem;
			}
			mch_memmove(p1, new_start, (size_t)(len + 1));
			vim_free(new_start);
			new_start = p1;
		    }
		    new_end = new_start + len;
		}

		
		mch_memmove(new_end, sub_firstline + copycol, (size_t)copy_len);
		new_end += copy_len;

		if ((int)new_start_len - copy_len < sublen)
		    sublen = new_start_len - copy_len - 1;

#ifdef FEAT_EVAL
		++textlock;
#endif
		(void)vim_regsub_multi(&regmatch,
				    sub_firstlnum - regmatch.startpos[0].lnum,
				      sub, new_end, sublen,
				      REGSUB_COPY | REGSUB_BACKSLASH
					 | (magic_isset() ? REGSUB_MAGIC : 0));
#ifdef FEAT_EVAL
		--textlock;
#endif
		sub_nsubs++;
		did_sub = TRUE;

		
		
		curwin->w_cursor.col = 0;

		
		
		if (nmatch > 1)
		{
		    sub_firstlnum += nmatch - 1;
		    vim_free(sub_firstline);
		    sub_firstline = vim_strsave(ml_get(sub_firstlnum));
		    
		    if (sub_firstlnum <= line2)
			do_again = TRUE;
		    else
			subflags.do_all = FALSE;
		}

		
		copycol = regmatch.endpos[0].col;

		if (skip_match)
		{
		    
		    
		    vim_free(sub_firstline);
		    sub_firstline = vim_strsave((char_u *)"""");
		    copycol = 0;
		}

		
		for (p1 = new_end; *p1; ++p1)
		{
		    if (p1[0] == '\\' && p1[1] != NUL)  
		    {
			STRMOVE(p1, p1 + 1);
#ifdef FEAT_PROP_POPUP
			if (curbuf->b_has_textprop)
			{
			    
			    
			    if (adjust_prop_columns(lnum,
					(colnr_T)(p1 - new_start), -1,
					apc_flags))
				apc_flags &= ~APC_SAVE_FOR_UNDO;
			}
#endif
		    }
		    else if (*p1 == CAR)
		    {
			if (u_inssub(lnum) == OK)   
			{
			    colnr_T	plen = (colnr_T)(p1 - new_start + 1);

			    *p1 = NUL;		    
			    ml_append(lnum - 1, new_start, plen, FALSE);
			    mark_adjust(lnum + 1, (linenr_T)MAXLNUM, 1L, 0L);
			    if (subflags.do_ask)
				appended_lines(lnum - 1, 1L);
			    else
			    {
				if (first_line == 0)
				    first_line = lnum;
				last_line = lnum + 1;
			    }
#ifdef FEAT_PROP_POPUP
			    adjust_props_for_split(lnum + 1, lnum,
							       plen, 1, FALSE);
#endif
			    
			    ++sub_firstlnum;
			    ++lnum;
			    ++line2;
			    
			    ++curwin->w_cursor.lnum;
			    
			    STRMOVE(new_start, p1 + 1);
			    p1 = new_start - 1;
			}
		    }
		    else if (has_mbyte)
			p1 += (*mb_ptr2len)(p1) - 1;
		}

		
skip:
		
		
		
		
		
		lastone = (skip_match
			|| got_int
			|| got_quit
			|| lnum > line2
			|| !(subflags.do_all || do_again)
			|| (sub_firstline[matchcol] == NUL && nmatch <= 1
					 && !re_multiline(regmatch.regprog)));
		nmatch = -1;

		
		if (lastone
			|| nmatch_tl > 0
			|| (nmatch = vim_regexec_multi(&regmatch, curwin,
							curbuf, sub_firstlnum,
						    matchcol, NULL)) == 0
			|| regmatch.startpos[0].lnum > 0)
		{
		    if (new_start != NULL)
		    {
			
			STRCAT(new_start, sub_firstline + copycol);
			matchcol = (colnr_T)STRLEN(sub_firstline) - matchcol;
			prev_matchcol = (colnr_T)STRLEN(sub_firstline)
							      - prev_matchcol;

			if (u_savesub(lnum) != OK)
			    break;
			ml_replace(lnum, new_start, TRUE);
#ifdef FEAT_PROP_POPUP
			if (text_props != NULL)
			    add_text_props(lnum, text_props, text_prop_count);
#endif
			if (nmatch_tl > 0)
			{
			    
			    ++lnum;
			    if (u_savedel(lnum, nmatch_tl) != OK)
				break;
			    for (i = 0; i < nmatch_tl; ++i)
				ml_delete(lnum);
			    mark_adjust(lnum, lnum + nmatch_tl - 1,
						   (long)MAXLNUM, -nmatch_tl);
			    if (subflags.do_ask)
				deleted_lines(lnum, nmatch_tl);
			    --lnum;
			    line2 -= nmatch_tl; 
			    nmatch_tl = 0;
			}

			
			
			if (subflags.do_ask)
			    changed_bytes(lnum, 0);
			else
			{
			    if (first_line == 0)
				first_line = lnum;
			    last_line = lnum + 1;
			}

			sub_firstlnum = lnum;
			vim_free(sub_firstline);    
			sub_firstline = new_start;
			new_start = NULL;
			matchcol = (colnr_T)STRLEN(sub_firstline) - matchcol;
			prev_matchcol = (colnr_T)STRLEN(sub_firstline)
							      - prev_matchcol;
			copycol = 0;
		    }
		    if (nmatch == -1 && !lastone)
			nmatch = vim_regexec_multi(&regmatch, curwin, curbuf,
					  sub_firstlnum, matchcol, NULL);

		    
		    if (nmatch <= 0)
		    {
			
			
			
			if (nmatch == -1)
			    lnum -= regmatch.startpos[0].lnum;
			break;
		    }
		}

		line_breakcheck();
	    }

	    if (did_sub)
		++sub_nlines;
	    vim_free(new_start);	
	    VIM_CLEAR(sub_firstline);	
	}

	line_breakcheck();
    }

    if (first_line != 0)
    {
	
	
	
	i = curbuf->b_ml.ml_line_count - old_line_count;
	changed_lines(first_line, 0, last_line - i, i);
    }

outofmem:
    vim_free(sub_firstline); 

#ifdef FEAT_PROP_POPUP
    vim_free(text_props);
#endif

    
    if (subflags.do_count)
	curwin->w_cursor = old_cursor;

    if (sub_nsubs > start_nsubs)
    {
	if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)
	{
	    
	    curbuf->b_op_start.lnum = eap->line1;
	    curbuf->b_op_end.lnum = line2;
	    curbuf->b_op_start.col = curbuf->b_op_end.col = 0;
	}

	if (!global_busy)
	{
	    
	    if (!subflags.do_ask)
	    {
		if (endcolumn)
		    coladvance((colnr_T)MAXCOL);
		else
		    beginline(BL_WHITE | BL_FIX);
	    }
	    if (!do_sub_msg(subflags.do_count) && subflags.do_ask)
		msg("""");
	}
	else
	    global_need_beginline = TRUE;
	if (subflags.do_print)
	    print_line(curwin->w_cursor.lnum,
					 subflags.do_number, subflags.do_list);
    }
    else if (!global_busy)
    {
	if (got_int)		
	    emsg(_(e_interrupted));
	else if (got_match)	
	    msg("""");
	else if (subflags.do_error)	
	    semsg(_(e_pattern_not_found_str), get_search_pat());
    }

#ifdef FEAT_FOLDING
    if (subflags.do_ask && hasAnyFolding(curwin))
	
	changed_window_setting();
#endif

    vim_regfree(regmatch.regprog);
    vim_free(sub_copy);

    
    subflags.do_all = save_do_all;
    subflags.do_ask = save_do_ask;
}
","1. semsg(_(e_pattern_not_found_str), get_search_pat());",1226,"CWE-119,CWE-125,CWE-189,CWE-416"
StoreExistingGroupExistingCache,"  void StoreExistingGroupExistingCache() {

     MakeCacheAndGroup(kManifestUrl, 1, 1, true);
    EXPECT_EQ(kDefaultEntrySize + kDefaultEntryPadding,
              storage()->usage_map_[kOrigin]);
 
     base::Time now = base::Time::Now();
    cache_->AddEntry(kEntryUrl, AppCacheEntry(AppCacheEntry::EXPLICIT,
                                              1,
                                              100,
                                              10));
     cache_->set_update_time(now);
 
     PushNextTask(base::BindOnce(
        &AppCacheStorageImplTest::Verify_StoreExistingGroupExistingCache,
        base::Unretained(this), now));

    EXPECT_EQ(cache_.get(), group_->newest_complete_cache());
    storage()->StoreGroupAndNewestCache(group_.get(), cache_.get(), delegate());
    EXPECT_FALSE(delegate()->stored_group_success_);
  }
","1. EXPECT_EQ(kDefaultEntrySize + kDefaultEntryPadding,
storage()->usage_map_[kOrigin]);
2. cache_->set_update_time(now);
3. EXPECT_EQ(cache_.get(), group_->newest_complete_cache());
storage()->StoreGroupAndNewestCache(group_.get(), cache_.get(), delegate());
EXPECT_FALSE(delegate()->stored_group_success_);","4-5
12
18-20","CWE-200,CWE-787,CWE-284"
handle_pte_fault-168861715198189,"static int handle_pte_fault(struct mm_struct *mm,
		     struct vm_area_struct *vma, unsigned long address,
		     pte_t *pte, pmd_t *pmd, unsigned int flags)
{
	pte_t entry;
	spinlock_t *ptl;

	
	entry = *pte;
	barrier();
	if (!pte_present(entry)) {
		if (pte_none(entry)) {
			if (vma->vm_ops)
				return do_fault(mm, vma, address, pte, pmd,
						flags, entry);

			return do_anonymous_page(mm, vma, address, pte, pmd,
					flags);
		}
		return do_swap_page(mm, vma, address,
					pte, pmd, flags, entry);
	}

	if (pte_protnone(entry))
		return do_numa_page(mm, vma, address, entry, pte, pmd);

	ptl = pte_lockptr(mm, pmd);
	spin_lock(ptl);
	if (unlikely(!pte_same(*pte, entry)))
		goto unlock;
	if (flags & FAULT_FLAG_WRITE) {
		if (!pte_write(entry))
			return do_wp_page(mm, vma, address,
					pte, pmd, ptl, entry);
		entry = pte_mkdirty(entry);
	}
	entry = pte_mkyoung(entry);
	if (ptep_set_access_flags(vma, address, pte, entry, flags & FAULT_FLAG_WRITE)) {
		update_mmu_cache(vma, address, pte);
	} else {
		
		if (flags & FAULT_FLAG_WRITE)
			flush_tlb_fix_spurious_fault(vma, address);
	}
unlock:
	pte_unmap_unlock(pte, ptl);
	return 0;
}
","1. pte_t *pte, pmd_t *pmd, unsigned int flags)
2. pte_t entry;
3. entry = *pte;
4. if (!pte_present(entry)) {
5. flags);
6. return do_swap_page(mm, vma, address,
pte, pmd, flags, entry);
7. goto unlock;
if (flags & FAULT_FLAG_WRITE) {
8. pte, pmd, ptl, entry);
9. entry = pte_mkyoung(entry);
10. update_mmu_cache(vma, address, pte);
} else {
11. return 0;","3
5
16
18
25
27-28
37-38
41
44
46-47
59","CWE-476,CWE-347,CWE-200,CWE-17"
sqlite3EndTable-245746700810760,"
#define Parse
#define Select
#define Token

void sqlite3EndTable(
  Parse *pParse,          
  Token *pCons,           
  Token *pEnd,            
  u8 tabOpts,             
  Select *pSelect         
){
  Table *p;                 
  sqlite3 *db = pParse->db; 
  int iDb;                  
  Index *pIdx;              

  if( pEnd==0 && pSelect==0 ){
    return;
  }
  assert( !db->mallocFailed );
  p = pParse->pNewTable;
  if( p==0 ) return;

  if( pSelect==0 && sqlite3ShadowTableName(db, p->zName) ){
    p->tabFlags |= TF_Shadow;
  }

  
  if( db->init.busy ){
    if( pSelect ){
      sqlite3ErrorMsg(pParse, """");
      return;
    }
    p->tnum = db->init.newTnum;
    if( p->tnum==1 ) p->tabFlags |= TF_Readonly;
  }

  assert( (p->tabFlags & TF_HasPrimaryKey)==0
       || p->iPKey>=0 || sqlite3PrimaryKeyIndex(p)!=0 );
  assert( (p->tabFlags & TF_HasPrimaryKey)!=0
       || (p->iPKey<0 && sqlite3PrimaryKeyIndex(p)==0) );

  
  if( tabOpts & TF_WithoutRowid ){
    if( (p->tabFlags & TF_Autoincrement) ){
      sqlite3ErrorMsg(pParse,
          ""AUTOINCREMENT not allowed on WITHOUT ROWID tables"");
      return;
    }
    if( (p->tabFlags & TF_HasPrimaryKey)==0 ){
      sqlite3ErrorMsg(pParse, ""PRIMARY KEY missing on table %s"", p->zName);
      return;
    }
    p->tabFlags |= TF_WithoutRowid | TF_NoVisibleRowid;
    convertToWithoutRowidTable(pParse, p);
  }
  iDb = sqlite3SchemaToIndex(db, p->pSchema);

#ifndef SQLITE_OMIT_CHECK
  
  if( p->pCheck ){
    sqlite3ResolveSelfReference(pParse, p, NC_IsCheck, 0, p->pCheck);
  }
#endif 
#ifndef SQLITE_OMIT_GENERATED_COLUMNS
  if( p->tabFlags & TF_HasGenerated ){
    int ii, nNG = 0;
    testcase( p->tabFlags & TF_HasVirtual );
    testcase( p->tabFlags & TF_HasStored );
    for(ii=0; ii<p->nCol; ii++){
      u32 colFlags = p->aCol[ii].colFlags;
      if( (colFlags & COLFLAG_GENERATED)!=0 ){
        testcase( colFlags & COLFLAG_VIRTUAL );
        testcase( colFlags & COLFLAG_STORED );
        sqlite3ResolveSelfReference(pParse, p, NC_GenCol, 
                                    p->aCol[ii].pDflt, 0);
      }else{
        nNG++;
      }
    }
    if( nNG==0 ){
      sqlite3ErrorMsg(pParse, ""must have at least one non-generated column"");
      return;
    }
  }
#endif

  
  estimateTableWidth(p);
  for(pIdx=p->pIndex; pIdx; pIdx=pIdx->pNext){
    estimateIndexWidth(pIdx);
  }

  
  if( !db->init.busy ){
    int n;
    Vdbe *v;
    char *zType;    
    char *zType2;   
    char *zStmt;    

    v = sqlite3GetVdbe(pParse);
    if( NEVER(v==0) ) return;

    sqlite3VdbeAddOp1(v, OP_Close, 0);

    
    if( p->pSelect==0 ){
      
      zType = ""table"";
      zType2 = ""TABLE"";
#ifndef SQLITE_OMIT_VIEW
    }else{
      
      zType = ""view"";
      zType2 = ""VIEW"";
#endif
    }

    
    if( pSelect ){
      SelectDest dest;    
      int regYield;       
      int addrTop;        
      int regRec;         
      int regRowid;       
      int addrInsLoop;    
      Table *pSelTab;     

      regYield = ++pParse->nMem;
      regRec = ++pParse->nMem;
      regRowid = ++pParse->nMem;
      assert(pParse->nTab==1);
      sqlite3MayAbort(pParse);
      sqlite3VdbeAddOp3(v, OP_OpenWrite, 1, pParse->regRoot, iDb);
      sqlite3VdbeChangeP5(v, OPFLAG_P2ISREG);
      pParse->nTab = 2;
      addrTop = sqlite3VdbeCurrentAddr(v) + 1;
      sqlite3VdbeAddOp3(v, OP_InitCoroutine, regYield, 0, addrTop);
      if( pParse->nErr ) return;
      pSelTab = sqlite3ResultSetOfSelect(pParse, pSelect, SQLITE_AFF_BLOB);
      if( pSelTab==0 ) return;
      assert( p->aCol==0 );
      p->nCol = p->nNVCol = pSelTab->nCol;
      p->aCol = pSelTab->aCol;
      pSelTab->nCol = 0;
      pSelTab->aCol = 0;
      sqlite3DeleteTable(db, pSelTab);
      sqlite3SelectDestInit(&dest, SRT_Coroutine, regYield);
      sqlite3Select(pParse, pSelect, &dest);
      if( pParse->nErr ) return;
      sqlite3VdbeEndCoroutine(v, regYield);
      sqlite3VdbeJumpHere(v, addrTop - 1);
      addrInsLoop = sqlite3VdbeAddOp1(v, OP_Yield, dest.iSDParm);
      VdbeCoverage(v);
      sqlite3VdbeAddOp3(v, OP_MakeRecord, dest.iSdst, dest.nSdst, regRec);
      sqlite3TableAffinity(v, p, 0);
      sqlite3VdbeAddOp2(v, OP_NewRowid, 1, regRowid);
      sqlite3VdbeAddOp3(v, OP_Insert, 1, regRec, regRowid);
      sqlite3VdbeGoto(v, addrInsLoop);
      sqlite3VdbeJumpHere(v, addrInsLoop);
      sqlite3VdbeAddOp1(v, OP_Close, 1);
    }

    
    if( pSelect ){
      zStmt = createTableStmt(db, p);
    }else{
      Token *pEnd2 = tabOpts ? &pParse->sLastToken : pEnd;
      n = (int)(pEnd2->z - pParse->sNameToken.z);
      if( pEnd2->z[0]!=';' ) n += pEnd2->n;
      zStmt = sqlite3MPrintf(db, 
          ""CREATE %s %.*s"", zType2, n, pParse->sNameToken.z
      );
    }

    
    sqlite3NestedParse(pParse,
      ""UPDATE %Q.%s ""
         ""SET type='%s', name=%Q, tbl_name=%Q, rootpage=#%d, sql=%Q ""
       ""WHERE rowid=#%d"",
      db->aDb[iDb].zDbSName, MASTER_NAME,
      zType,
      p->zName,
      p->zName,
      pParse->regRoot,
      zStmt,
      pParse->regRowid
    );
    sqlite3DbFree(db, zStmt);
    sqlite3ChangeCookie(pParse, iDb);

#ifndef SQLITE_OMIT_AUTOINCREMENT
    
    if( (p->tabFlags & TF_Autoincrement)!=0 ){
      Db *pDb = &db->aDb[iDb];
      assert( sqlite3SchemaMutexHeld(db, iDb, 0) );
      if( pDb->pSchema->pSeqTab==0 ){
        sqlite3NestedParse(pParse,
          ""CREATE TABLE %Q.sqlite_sequence(name,seq)"",
          pDb->zDbSName
        );
      }
    }
#endif

    
    sqlite3VdbeAddParseSchemaOp(v, iDb,
           sqlite3MPrintf(db, ""tbl_name='%q' AND type!='trigger'"", p->zName));
  }

  
  if( db->init.busy ){
    Table *pOld;
    Schema *pSchema = p->pSchema;
    assert( sqlite3SchemaMutexHeld(db, iDb, 0) );
    pOld = sqlite3HashInsert(&pSchema->tblHash, p->zName, p);
    if( pOld ){
      assert( p==pOld );  
      sqlite3OomFault(db);
      return;
    }
    pParse->pNewTable = 0;
    db->mDbFlags |= DBFLAG_SchemaChange;

#ifndef SQLITE_OMIT_ALTERTABLE
    if( !p->pSelect ){
      const char *zName = (const char *)pParse->sNameToken.z;
      int nName;
      assert( !pSelect && pCons && pEnd );
      if( pCons->z==0 ){
        pCons = pEnd;
      }
      nName = (int)((const char *)pCons->z - zName);
      p->addColOffset = 13 + sqlite3Utf8CharLen(zName, nName);
    }
#endif
  }
}
","1. u8 tabOpts,
2. sqlite3ErrorMsg(pParse, ""PRIMARY KEY missing on table %s"", p->zName);
return;
3. int ii, nNG = 0;
4. return;
5. assert( p->aCol==0 );
6. p->aCol = pSelTab->aCol;
7. db->aDb[iDb].zDbSName, MASTER_NAME,
8. sqlite3MPrintf(db, ""tbl_name='%q' AND type!='trigger'"", p->zName));
9. assert( p==pOld );
10. pCons = pEnd;","10
60-61
77
93
172
174
214
243
254
267","CWE-416,CWE-89,CWE-190,CWE-347,CWE-119"
_anetTcpServer-236603416162466,"static int _anetTcpServer(char *err, int port, char *bindaddr, int af, int backlog)
{
    int s = -1, rv;
    char _port[6];  
    struct addrinfo hints, *servinfo, *p;

    snprintf(_port,6,""%d"",port);
    memset(&hints,0,sizeof(hints));
    hints.ai_family = af;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags = AI_PASSIVE;    
    if (bindaddr && !strcmp(""*"", bindaddr))
        bindaddr = NULL;
    if (af == AF_INET6 && bindaddr && !strcmp(""::*"", bindaddr))
        bindaddr = NULL;

    if ((rv = getaddrinfo(bindaddr,_port,&hints,&servinfo)) != 0) {
        anetSetError(err, ""%s"", gai_strerror(rv));
        return ANET_ERR;
    }
    for (p = servinfo; p != NULL; p = p->ai_next) {
        if ((s = socket(p->ai_family,p->ai_socktype,p->ai_protocol)) == -1)
            continue;

        if (af == AF_INET6 && anetV6Only(err,s) == ANET_ERR) goto error;
        if (anetSetReuseAddr(err,s) == ANET_ERR) goto error;
        if (anetListen(err,s,p->ai_addr,p->ai_addrlen,backlog,0) == ANET_ERR) s = ANET_ERR;
        goto end;
    }
    if (p == NULL) {
        anetSetError(err, ""unable to bind socket, errno: %d"", errno);
        goto error;
    }

error:
    if (s != -1) close(s);
    s = ANET_ERR;
end:
    freeaddrinfo(servinfo);
    return s;
}
","1. memset(&hints,0,sizeof(hints));
2. for (p = servinfo; p != NULL; p = p->ai_next) {
if ((s = socket(p->ai_family,p->ai_socktype,p->ai_protocol)) == -1)
3. if (anetSetReuseAddr(err,s) == ANET_ERR) goto error;
4. error:","8
21-22
26
35","CWE-269,CWE-20,CWE-200,CWE-416"
gf_m2ts_process_pat-59998419010020,"
#define GF_List
#define GF_M2TS_Demuxer
#define GF_M2TS_SECTION_ES

static void gf_m2ts_process_pat(GF_M2TS_Demuxer *ts, GF_M2TS_SECTION_ES *ses, GF_List *sections, u8 table_id, u16 ex_table_id, u8 version_number, u8 last_section_number, u32 status)
{
	GF_M2TS_Program *prog;
	GF_M2TS_SECTION_ES *pmt;
	u32 i, nb_progs, evt_type;
	u32 nb_sections;
	u32 data_size;
	unsigned char *data;
	GF_M2TS_Section *section;

	
	if (!(status&GF_M2TS_TABLE_END)) return;

	
	if (status&GF_M2TS_TABLE_REPEAT) {
		if (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_PAT_REPEAT, NULL);
		return;
	}

	nb_sections = gf_list_count(sections);
	if (nb_sections > 1) {
		GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""PAT on multiple sections not supported\n""));
	}

	section = (GF_M2TS_Section *)gf_list_get(sections, 0);
	data = section->data;
	data_size = section->data_size;

	if (!(status&GF_M2TS_TABLE_UPDATE) && gf_list_count(ts->programs)) {
		if (ts->pat->demux_restarted) {
			ts->pat->demux_restarted = 0;
		} else {
			GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""Multiple different PAT on single TS found, ignoring new PAT declaration (table id %d - extended table id %d)\n"", table_id, ex_table_id));
		}
		return;
	}
	nb_progs = data_size / 4;

	for (i=0; i<nb_progs; i++) {
		u16 number, pid;
		number = (data[0]<<8) | data[1];
		pid = (data[2]&0x1f)<<8 | data[3];
		data += 4;
		if (number==0) {
			if (!ts->nit) {
				ts->nit = gf_m2ts_section_filter_new(gf_m2ts_process_nit, 0);
			}
		} else if (!pid) {
			GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""Broken PAT found reserved PID 0, ignoring\n"", pid));
		} else if (! ts->ess[pid]) {
			GF_SAFEALLOC(prog, GF_M2TS_Program);
			if (!prog) {
				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""Fail to allocate program for pid %d\n"", pid));
				return;
			}
			prog->streams = gf_list_new();
			prog->pmt_pid = pid;
			prog->number = number;
			prog->ts = ts;
			gf_list_add(ts->programs, prog);
			GF_SAFEALLOC(pmt, GF_M2TS_SECTION_ES);
			if (!pmt) {
				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""Fail to allocate pmt filter for pid %d\n"", pid));
				return;
			}
			pmt->flags = GF_M2TS_ES_IS_SECTION;
			gf_list_add(prog->streams, pmt);
			pmt->pid = prog->pmt_pid;
			pmt->program = prog;
			ts->ess[pmt->pid] = (GF_M2TS_ES *)pmt;
			pmt->sec = gf_m2ts_section_filter_new(gf_m2ts_process_pmt, 0);
		}
	}

	evt_type = (status&GF_M2TS_TABLE_UPDATE) ? GF_M2TS_EVT_PAT_UPDATE : GF_M2TS_EVT_PAT_FOUND;
	if (ts->on_event) ts->on_event(ts, evt_type, NULL);
}
","1. GF_M2TS_Section *section;
2. if (!(status&GF_M2TS_TABLE_END)) return;
3. data = section->data;
4. for (i=0; i<nb_progs; i++) {
5. } else if (! ts->ess[pid]) {
6. return;
7. prog->ts = ts;
8. return;
9. evt_type = (status&GF_M2TS_TABLE_UPDATE) ? GF_M2TS_EVT_PAT_UPDATE : GF_M2TS_EVT_PAT_FOUND;","14
17
31
44
55
59
64
69
80","CWE-369,CWE-120,CWE-189,CWE-190,CWE-399"
gf_text_get_utf8_line_1-168177892622581,"
#define FILE

char *gf_text_get_utf8_line_1(char *szLine, u32 lineSize, FILE *txt_in, s32 unicode_type)
{
	u32 i, j, len;
	char *sOK;
	char szLineConv[2048];
	unsigned short *sptr;

	memset(szLine, 0, sizeof(char)*lineSize);
	sOK = gf_fgets(szLine, lineSize, txt_in);
	if (!sOK) return NULL;
	if (unicode_type<=1) {
		j=0;
		len = (u32) strlen(szLine);
		for (i=0; i<len; i++) {
			if (!unicode_type && (szLine[i] & 0x80)) {
				
				if ((szLine[i+1] & 0xc0) != 0x80) {
					if (j >= GF_ARRAY_LENGTH(szLineConv))
						break;
					szLineConv[j] = 0xc0 | ( (szLine[i] >> 6) & 0x3 );
					j++;
					szLine[i] &= 0xbf;
				}
				
				else if ( (szLine[i] & 0xe0) == 0xc0) {
					if (j >= GF_ARRAY_LENGTH(szLineConv))
						break;
					szLineConv[j] = szLine[i];
					i++;
					j++;
				}
				
				else if ( (szLine[i] & 0xf0) == 0xe0) {
					if (j+1 >= GF_ARRAY_LENGTH(szLineConv))
						break;
					szLineConv[j] = szLine[i];
					i++;
					j++;
					szLineConv[j] = szLine[i];
					i++;
					j++;
				}
				
				else if ( (szLine[i] & 0xf8) == 0xf0) {
					if (j+2 >= GF_ARRAY_LENGTH(szLineConv))
						break;
					szLineConv[j] = szLine[i];
					i++;
					j++;
					szLineConv[j] = szLine[i];
					i++;
					j++;
					szLineConv[j] = szLine[i];
					i++;
					j++;
				} else {
					i+=1;
					continue;
				}
			}

			if (j >= GF_ARRAY_LENGTH(szLineConv))
				break;

			szLineConv[j] = szLine[i];
			j++;


		}
		if ( j >= GF_ARRAY_LENGTH(szLineConv) ) {
			GF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (""[TXTIn] Line too long to convert to utf8 (len: %d)\n"", len));
			j = GF_ARRAY_LENGTH(szLineConv) -1 ;
		}
		szLineConv[j] = 0;
		strcpy(szLine, szLineConv);
		return sOK;
	}

#ifdef GPAC_BIG_ENDIAN
	if (unicode_type==3)
#else
	if (unicode_type==2)
#endif
	{
		i=0;
		while (1) {
			char c;
			if (!szLine[i] && !szLine[i+1]) break;
			c = szLine[i+1];
			szLine[i+1] = szLine[i];
			szLine[i] = c;
			i+=2;
		}
	}
	sptr = (u16 *)szLine;
	i = gf_utf8_wcstombs(szLineConv, 2048, (const unsigned short **) &sptr);
	if (i == GF_UTF8_FAIL) i = 0;
	szLineConv[i] = 0;
	strcpy(szLine, szLineConv);
	
	if (unicode_type==3) gf_fgetc(txt_in);
	return sOK;
}
","1. memset(szLine, 0, sizeof(char)*lineSize);
2. if (j >= GF_ARRAY_LENGTH(szLineConv))
3. if (j >= GF_ARRAY_LENGTH(szLineConv))
4. szLineConv[j] = szLine[i];
5. j++;
6. i++;
j++;
7. if ( j >= GF_ARRAY_LENGTH(szLineConv) ) {
8. strcpy(szLine, szLineConv);
9. strcpy(szLine, szLineConv);","11
21
29
42
44
54-55
73
78
102","CWE-401,CWE-125,CWE-787,CWE-415"
xsltParseStylesheetAttributeSet,"xsltParseStylesheetAttributeSet(xsltStylesheetPtr style, xmlNodePtr cur) {
    const xmlChar *ncname;
    const xmlChar *prefix;
    xmlChar *value;
    xmlNodePtr child;
    xsltAttrElemPtr attrItems;

    if ((cur == NULL) || (style == NULL) || (cur->type != XML_ELEMENT_NODE))
 	return;
 
     value = xmlGetNsProp(cur, (const xmlChar *)""name"", NULL);
    if ((value == NULL) || (*value == 0)) {
 	xsltGenericError(xsltGenericErrorContext,
 	     ""xsl:attribute-set : name is missing\n"");
        if (value)
	    xmlFree(value);
 	return;
     }
 
    ncname = xsltSplitQName(style->dict, value, &prefix);
    xmlFree(value);
    value = NULL;

    if (style->attributeSets == NULL) {
#ifdef WITH_XSLT_DEBUG_ATTRIBUTES
	xsltGenericDebug(xsltGenericDebugContext,
	    ""creating attribute set table\n"");
#endif
	style->attributeSets = xmlHashCreate(10);
    }
    if (style->attributeSets == NULL)
	return;

    attrItems = xmlHashLookup2(style->attributeSets, ncname, prefix);

    
    child = cur->children;
    while (child != NULL) {
	
	if ((child->type != XML_ELEMENT_NODE) ||
	    (child->ns == NULL) ||
	    (! IS_XSLT_ELEM(child)))
	{
	    if (child->type == XML_ELEMENT_NODE)
		xsltTransformError(NULL, style, child,
			""xsl:attribute-set : unexpected child %s\n"",
		                 child->name);
	    else
		xsltTransformError(NULL, style, child,
			""xsl:attribute-set : child of unexpected type\n"");
	} else if (!IS_XSLT_NAME(child, ""attribute"")) {
	    xsltTransformError(NULL, style, child,
		""xsl:attribute-set : unexpected child xsl:%s\n"",
		child->name);
	} else {
#ifdef XSLT_REFACTORED
	    xsltAttrElemPtr nextAttr, curAttr;

	    

#ifdef WITH_XSLT_DEBUG_ATTRIBUTES
	    xsltGenericDebug(xsltGenericDebugContext,
		""add attribute to list %s\n"", ncname);
#endif
	    
	    if (attrItems == NULL) {
		attrItems = xsltNewAttrElem(child);
	    } else {
		curAttr = attrItems;
		while (curAttr != NULL) {
		    nextAttr = curAttr->next;
		    if (curAttr->attr == child) {
			
			attrItems = curAttr;
			goto next_child;
		    }
		    if (curAttr->next == NULL)
			curAttr->next = xsltNewAttrElem(child);
		    curAttr = nextAttr;
		}
	    }
	    
	    xsltParseAnyXSLTElem(XSLT_CCTXT(style), child);
#else
#ifdef WITH_XSLT_DEBUG_ATTRIBUTES
	    xsltGenericDebug(xsltGenericDebugContext,
		""add attribute to list %s\n"", ncname);
#endif
	    
	    attrItems = xsltAddAttrElemList(attrItems, child);
#endif
	}

#ifdef XSLT_REFACTORED
next_child:
#endif
	child = child->next;
    }

    
    
    value = xmlGetNsProp(cur, (const xmlChar *)""use-attribute-sets"",
	NULL);
    if (value != NULL) {
	const xmlChar *curval, *endval;
	curval = value;
	while (*curval != 0) {
	    while (IS_BLANK(*curval)) curval++;
	    if (*curval == 0)
		break;
	    endval = curval;
	    while ((*endval != 0) && (!IS_BLANK(*endval))) endval++;
	    curval = xmlDictLookup(style->dict, curval, endval - curval);
	    if (curval) {
		const xmlChar *ncname2 = NULL;
		const xmlChar *prefix2 = NULL;
		xsltAttrElemPtr refAttrItems;

#ifdef WITH_XSLT_DEBUG_ATTRIBUTES
		xsltGenericDebug(xsltGenericDebugContext,
		    ""xsl:attribute-set : %s adds use %s\n"", ncname, curval);
#endif
		ncname2 = xsltSplitQName(style->dict, curval, &prefix2);
		refAttrItems = xsltNewAttrElem(NULL);
		if (refAttrItems != NULL) {
		    refAttrItems->set = ncname2;
		    refAttrItems->ns = prefix2;
		    attrItems = xsltMergeAttrElemList(style,
			attrItems, refAttrItems);
		    xsltFreeAttrElem(refAttrItems);
		}
	    }
	    curval = endval;
	}
	xmlFree(value);
	value = NULL;
    }

    
    
    if (attrItems == NULL)
	attrItems = xsltNewAttrElem(NULL);
    xmlHashUpdateEntry2(style->attributeSets, ncname, prefix, attrItems, NULL);
#ifdef WITH_XSLT_DEBUG_ATTRIBUTES
    xsltGenericDebug(xsltGenericDebugContext,
	""updated attribute list %s\n"", ncname);
#endif
}
","1. xmlChar *value;
2. xsltGenericError(xsltGenericErrorContext,
3. xmlFree(value);
4. if (style->attributeSets == NULL) {
5. style->attributeSets = xmlHashCreate(10);
6. return;
7. if ((child->type != XML_ELEMENT_NODE) ||
8. ""xsl:attribute-set : unexpected child %s\n"",
9. xsltTransformError(NULL, style, child,
10. } else if (!IS_XSLT_NAME(child, ""attribute"")) {
11. ""xsl:attribute-set : unexpected child xsl:%s\n"",
12. NULL);
13. while (IS_BLANK(*curval)) curval++;
if (*curval == 0)
14. while ((*endval != 0) && (!IS_BLANK(*endval))) endval++;
15. xsltFreeAttrElem(refAttrItems);
16. value = NULL;
17. xmlHashUpdateEntry2(style->attributeSets, ncname, prefix, attrItems, NULL);","4
13
16
24
29
32
44
50
53
55
57
124
129-130
133
151
157
168","CWE-190,CWE-125,CWE-787,CWE-119"
ex_history-168843709711912,"    void
ex_history(exarg_T *eap)
{
    histentry_T	*hist;
    int		histype1 = HIST_CMD;
    int		histype2 = HIST_CMD;
    int		hisidx1 = 1;
    int		hisidx2 = -1;
    int		idx;
    int		i, j, k;
    char_u	*end;
    char_u	*arg = eap->arg;

    if (hislen == 0)
    {
	msg(_(""'history' option is zero""));
	return;
    }

    if (!(VIM_ISDIGIT(*arg) || *arg == '-' || *arg == ','))
    {
	end = arg;
	while (ASCII_ISALPHA(*end)
		|| vim_strchr((char_u *)"":=@>/?"", *end) != NULL)
	    end++;
	i = *end;
	*end = NUL;
	histype1 = get_histtype(arg);
	if (histype1 == -1)
	{
	    if (STRNICMP(arg, ""all"", STRLEN(arg)) == 0)
	    {
		histype1 = 0;
		histype2 = HIST_COUNT-1;
	    }
	    else
	    {
		*end = i;
		semsg(_(e_trailing_characters_str), arg);
		return;
	    }
	}
	else
	    histype2 = histype1;
	*end = i;
    }
    else
	end = arg;
    if (!get_list_range(&end, &hisidx1, &hisidx2) || *end != NUL)
    {
	if (*end != NUL)
	    semsg(_(e_trailing_characters_str), end);
	else
	    semsg(_(e_val_too_large), arg);
	return;
    }

    for (; !got_int && histype1 <= histype2; ++histype1)
    {
	STRCPY(IObuff, ""\n      #  "");
	STRCAT(STRCAT(IObuff, history_names[histype1]), "" history"");
	msg_puts_title((char *)IObuff);
	idx = hisidx[histype1];
	hist = history[histype1];
	j = hisidx1;
	k = hisidx2;
	if (j < 0)
	    j = (-j > hislen) ? 0 : hist[(hislen+j+idx+1) % hislen].hisnum;
	if (k < 0)
	    k = (-k > hislen) ? 0 : hist[(hislen+k+idx+1) % hislen].hisnum;
	if (idx >= 0 && j <= k)
	    for (i = idx + 1; !got_int; ++i)
	    {
		if (i == hislen)
		    i = 0;
		if (hist[i].hisstr != NULL
			&& hist[i].hisnum >= j && hist[i].hisnum <= k)
		{
		    msg_putchar('\n');
		    sprintf((char *)IObuff, ""%c%6d  "", i == idx ? '>' : ' ',
							      hist[i].hisnum);
		    if (vim_strsize(hist[i].hisstr) > (int)Columns - 10)
			trunc_string(hist[i].hisstr, IObuff + STRLEN(IObuff),
			     (int)Columns - 10, IOSIZE - (int)STRLEN(IObuff));
		    else
			STRCAT(IObuff, hist[i].hisstr);
		    msg_outtrans(IObuff);
		    out_flush();
		}
		if (i == idx)
		    break;
	    }
    }
}
","1. if (STRNICMP(arg, ""all"", STRLEN(arg)) == 0)
2. for (; !got_int && histype1 <= histype2; ++histype1)","31
58","CWE-190,CWE-120,CWE-74"
gvdb_table_write_contents_async-126358668487806,"
#define GAsyncReadyCallback
#define GCancellable
#define GHashTable

void
gvdb_table_write_contents_async (GHashTable          *table,
                                 const gchar         *filename,
                                 gboolean             byteswap,
                                 GCancellable        *cancellable,
                                 GAsyncReadyCallback  callback,
                                 gpointer             user_data)
{
  struct gvdb_pointer root;
  FileBuilder *fb;
  WriteContentsData *data;
  GString *str;
  GBytes *bytes;
  GFile *file;
  GTask *task;

  g_return_if_fail (table != NULL);
  g_return_if_fail (filename != NULL);
  g_return_if_fail (cancellable == NULL || G_IS_CANCELLABLE (cancellable));

  fb = file_builder_new (byteswap);
  file_builder_add_hash (fb, table, &root);
  str = file_builder_serialise (fb, root);
  bytes = g_string_free_to_bytes (str);
  file_builder_free (fb);

  file = g_file_new_for_path (filename);
  data = write_contents_data_new (bytes, file);

  task = g_task_new (NULL, cancellable, callback, user_data);
  g_task_set_task_data (task, data, (GDestroyNotify)write_contents_data_free);
  g_task_set_source_tag (task, gvdb_table_write_contents_async);

  g_file_replace_contents_async (file,
                                 g_bytes_get_data (bytes, NULL),
                                 g_bytes_get_size (bytes),
                                 NULL, FALSE,
                                 G_FILE_CREATE_PRIVATE | G_FILE_CREATE_REPLACE_DESTINATION,
                                 cancellable, replace_contents_cb, g_steal_pointer (&task));

  g_bytes_unref (bytes);
  g_object_unref (file);
}
","1. gboolean             byteswap,
GCancellable        *cancellable,
GAsyncReadyCallback  callback,
2. struct gvdb_pointer root;
FileBuilder *fb;
WriteContentsData *data;
GString *str;
3. g_return_if_fail (cancellable == NULL || G_IS_CANCELLABLE (cancellable));
4. fb = file_builder_new (byteswap);
5. bytes = g_string_free_to_bytes (str);
6. task = g_task_new (NULL, cancellable, callback, user_data);
7. g_task_set_source_tag (task, gvdb_table_write_contents_async);
8. g_file_replace_contents_async (file,
g_bytes_get_data (bytes, NULL),
9. NULL, FALSE,
G_FILE_CREATE_PRIVATE | G_FILE_CREATE_REPLACE_DESTINATION,
cancellable, replace_contents_cb, g_steal_pointer (&task));","9-11
14-17
24
26
29
35
37
39-40
42-44","CWE-20,CWE-552,CWE-89,CWE-190,CWE-200"
bond_enslave,"int bond_enslave(struct net_device *bond_dev, struct net_device *slave_dev)
{
	struct bonding *bond = netdev_priv(bond_dev);
	const struct net_device_ops *slave_ops = slave_dev->netdev_ops;
	struct slave *new_slave = NULL;
	struct netdev_hw_addr *ha;
	struct sockaddr addr;
	int link_reporting;
	int res = 0;

	if (!bond->params.use_carrier && slave_dev->ethtool_ops == NULL &&
		slave_ops->ndo_do_ioctl == NULL) {
		pr_warning(""%s: Warning: no link monitoring support for %s\n"",
			   bond_dev->name, slave_dev->name);
	}

	
	if (slave_dev->flags & IFF_SLAVE) {
		pr_debug(""Error, Device was already enslaved\n"");
		return -EBUSY;
	}

	
	
	if (slave_dev->features & NETIF_F_VLAN_CHALLENGED) {
		pr_debug(""%s: NETIF_F_VLAN_CHALLENGED\n"", slave_dev->name);
		if (bond_vlan_used(bond)) {
			pr_err(""%s: Error: cannot enslave VLAN challenged slave %s on VLAN enabled bond %s\n"",
			       bond_dev->name, slave_dev->name, bond_dev->name);
			return -EPERM;
		} else {
			pr_warning(""%s: Warning: enslaved VLAN challenged slave %s. Adding VLANs will be blocked as long as %s is part of bond %s\n"",
				   bond_dev->name, slave_dev->name,
				   slave_dev->name, bond_dev->name);
		}
	} else {
		pr_debug(""%s: ! NETIF_F_VLAN_CHALLENGED\n"", slave_dev->name);
	}

	
	if ((slave_dev->flags & IFF_UP)) {
		pr_err(""%s is up. This may be due to an out of date ifenslave.\n"",
		       slave_dev->name);
		res = -EPERM;
		goto err_undo_flags;
	}

	
	if (bond->slave_cnt == 0) {
		if (bond_dev->type != slave_dev->type) {
			pr_debug(""%s: change device type from %d to %d\n"",
				 bond_dev->name,
				 bond_dev->type, slave_dev->type);

			res = netdev_bonding_change(bond_dev,
						    NETDEV_PRE_TYPE_CHANGE);
			res = notifier_to_errno(res);
			if (res) {
				pr_err(""%s: refused to change device type\n"",
				       bond_dev->name);
				res = -EBUSY;
				goto err_undo_flags;
			}

			
			dev_uc_flush(bond_dev);
			dev_mc_flush(bond_dev);
 
 			if (slave_dev->type != ARPHRD_ETHER)
 				bond_setup_by_slave(bond_dev, slave_dev);
			else {
 				ether_setup(bond_dev);
				bond_dev->priv_flags &= ~IFF_TX_SKB_SHARING;
			}
 
 			netdev_bonding_change(bond_dev,
 					      NETDEV_POST_TYPE_CHANGE);
		}
	} else if (bond_dev->type != slave_dev->type) {
		pr_err(""%s ether type (%d) is different from other slaves (%d), can not enslave it.\n"",
		       slave_dev->name,
		       slave_dev->type, bond_dev->type);
		res = -EINVAL;
		goto err_undo_flags;
	}

	if (slave_ops->ndo_set_mac_address == NULL) {
		if (bond->slave_cnt == 0) {
			pr_warning(""%s: Warning: The first slave device specified does not support setting the MAC address. Setting fail_over_mac to active."",
				   bond_dev->name);
			bond->params.fail_over_mac = BOND_FOM_ACTIVE;
		} else if (bond->params.fail_over_mac != BOND_FOM_ACTIVE) {
			pr_err(""%s: Error: The slave device specified does not support setting the MAC address, but fail_over_mac is not set to active.\n"",
			       bond_dev->name);
			res = -EOPNOTSUPP;
			goto err_undo_flags;
		}
	}

	call_netdevice_notifiers(NETDEV_JOIN, slave_dev);

	
	if (is_zero_ether_addr(bond->dev->dev_addr))
		memcpy(bond->dev->dev_addr, slave_dev->dev_addr,
		       slave_dev->addr_len);


	new_slave = kzalloc(sizeof(struct slave), GFP_KERNEL);
	if (!new_slave) {
		res = -ENOMEM;
		goto err_undo_flags;
	}

	
	new_slave->queue_id = 0;

	
	new_slave->original_mtu = slave_dev->mtu;
	res = dev_set_mtu(slave_dev, bond->dev->mtu);
	if (res) {
		pr_debug(""Error %d calling dev_set_mtu\n"", res);
		goto err_free;
	}

	
	memcpy(new_slave->perm_hwaddr, slave_dev->dev_addr, ETH_ALEN);

	if (!bond->params.fail_over_mac) {
		
		memcpy(addr.sa_data, bond_dev->dev_addr, bond_dev->addr_len);
		addr.sa_family = slave_dev->type;
		res = dev_set_mac_address(slave_dev, &addr);
		if (res) {
			pr_debug(""Error %d calling set_mac_address\n"", res);
			goto err_restore_mtu;
		}
	}

	res = netdev_set_bond_master(slave_dev, bond_dev);
	if (res) {
		pr_debug(""Error %d calling netdev_set_bond_master\n"", res);
		goto err_restore_mac;
	}

	
	res = dev_open(slave_dev);
	if (res) {
		pr_debug(""Opening slave %s failed\n"", slave_dev->name);
		goto err_unset_master;
	}

	new_slave->bond = bond;
	new_slave->dev = slave_dev;
	slave_dev->priv_flags |= IFF_BONDING;

	if (bond_is_lb(bond)) {
		
		res = bond_alb_init_slave(bond, new_slave);
		if (res)
			goto err_close;
	}

	
	if (!USES_PRIMARY(bond->params.mode)) {
		
		if (bond_dev->flags & IFF_PROMISC) {
			res = dev_set_promiscuity(slave_dev, 1);
			if (res)
				goto err_close;
		}

		
		if (bond_dev->flags & IFF_ALLMULTI) {
			res = dev_set_allmulti(slave_dev, 1);
			if (res)
				goto err_close;
		}

		netif_addr_lock_bh(bond_dev);
		
		netdev_for_each_mc_addr(ha, bond_dev)
			dev_mc_add(slave_dev, ha->addr);
		netif_addr_unlock_bh(bond_dev);
	}

	if (bond->params.mode == BOND_MODE_8023AD) {
		
		u8 lacpdu_multicast[ETH_ALEN] = MULTICAST_LACPDU_ADDR;

		dev_mc_add(slave_dev, lacpdu_multicast);
	}

	bond_add_vlans_on_slave(bond, slave_dev);

	write_lock_bh(&bond->lock);

	bond_attach_slave(bond, new_slave);

	new_slave->delay = 0;
	new_slave->link_failure_count = 0;

	write_unlock_bh(&bond->lock);

	bond_compute_features(bond);

	read_lock(&bond->lock);

	new_slave->last_arp_rx = jiffies;

	if (bond->params.miimon && !bond->params.use_carrier) {
		link_reporting = bond_check_dev_link(bond, slave_dev, 1);

		if ((link_reporting == -1) && !bond->params.arp_interval) {
			
			pr_warning(""%s: Warning: MII and ETHTOOL support not available for interface %s, and arp_interval/arp_ip_target module parameters not specified, thus bonding will not detect link failures! see bonding.txt for details.\n"",
			       bond_dev->name, slave_dev->name);
		} else if (link_reporting == -1) {
			
			pr_warning(""%s: Warning: can't get link status from interface %s; the network driver associated with this interface does not support MII or ETHTOOL link status reporting, thus miimon has no effect on this interface.\n"",
				   bond_dev->name, slave_dev->name);
		}
	}

	
	if (!bond->params.miimon ||
	    (bond_check_dev_link(bond, slave_dev, 0) == BMSR_LSTATUS)) {
		if (bond->params.updelay) {
			pr_debug(""Initial state of slave_dev is BOND_LINK_BACK\n"");
			new_slave->link  = BOND_LINK_BACK;
			new_slave->delay = bond->params.updelay;
		} else {
			pr_debug(""Initial state of slave_dev is BOND_LINK_UP\n"");
			new_slave->link  = BOND_LINK_UP;
		}
		new_slave->jiffies = jiffies;
	} else {
		pr_debug(""Initial state of slave_dev is BOND_LINK_DOWN\n"");
		new_slave->link  = BOND_LINK_DOWN;
	}

	if (bond_update_speed_duplex(new_slave) &&
	    (new_slave->link != BOND_LINK_DOWN)) {
		pr_warning(""%s: Warning: failed to get speed and duplex from %s, assumed to be 100Mb/sec and Full.\n"",
			   bond_dev->name, new_slave->dev->name);

		if (bond->params.mode == BOND_MODE_8023AD) {
			pr_warning(""%s: Warning: Operation of 802.3ad mode requires ETHTOOL support in base driver for proper aggregator selection.\n"",
				   bond_dev->name);
		}
	}

	if (USES_PRIMARY(bond->params.mode) && bond->params.primary[0]) {
		
		if (strcmp(bond->params.primary, new_slave->dev->name) == 0) {
			bond->primary_slave = new_slave;
			bond->force_primary = true;
		}
	}

	write_lock_bh(&bond->curr_slave_lock);

	switch (bond->params.mode) {
	case BOND_MODE_ACTIVEBACKUP:
		bond_set_slave_inactive_flags(new_slave);
		bond_select_active_slave(bond);
		break;
	case BOND_MODE_8023AD:
		
		bond_set_slave_inactive_flags(new_slave);
		
		if (bond->slave_cnt == 1) {
			SLAVE_AD_INFO(new_slave).id = 1;
			
			bond_3ad_initialize(bond, 1000/AD_TIMER_INTERVAL);
		} else {
			SLAVE_AD_INFO(new_slave).id =
				SLAVE_AD_INFO(new_slave->prev).id + 1;
		}

		bond_3ad_bind_slave(new_slave);
		break;
	case BOND_MODE_TLB:
	case BOND_MODE_ALB:
		bond_set_active_slave(new_slave);
		bond_set_slave_inactive_flags(new_slave);
		bond_select_active_slave(bond);
		break;
	default:
		pr_debug(""This slave is always active in trunk mode\n"");

		
		bond_set_active_slave(new_slave);

		
		if (!bond->curr_active_slave)
			bond->curr_active_slave = new_slave;

		break;
	} 

	write_unlock_bh(&bond->curr_slave_lock);

	bond_set_carrier(bond);

#ifdef CONFIG_NET_POLL_CONTROLLER
	slave_dev->npinfo = bond_netpoll_info(bond);
	if (slave_dev->npinfo) {
		if (slave_enable_netpoll(new_slave)) {
			read_unlock(&bond->lock);
			pr_info(""Error, %s: master_dev is using netpoll, ""
				 ""but new slave device does not support netpoll.\n"",
				 bond_dev->name);
			res = -EBUSY;
			goto err_close;
		}
	}
#endif

	read_unlock(&bond->lock);

	res = bond_create_slave_symlinks(bond_dev, slave_dev);
	if (res)
		goto err_close;

	res = netdev_rx_handler_register(slave_dev, bond_handle_frame,
					 new_slave);
	if (res) {
		pr_debug(""Error %d calling netdev_rx_handler_register\n"", res);
		goto err_dest_symlinks;
	}

	pr_info(""%s: enslaving %s as a%s interface with a%s link.\n"",
		bond_dev->name, slave_dev->name,
		bond_is_active_slave(new_slave) ? ""n active"" : "" backup"",
		new_slave->link != BOND_LINK_DOWN ? ""n up"" : "" down"");

	
	return 0;


err_dest_symlinks:
	bond_destroy_slave_symlinks(bond_dev, slave_dev);

err_close:
	dev_close(slave_dev);

err_unset_master:
	netdev_set_bond_master(slave_dev, NULL);

err_restore_mac:
	if (!bond->params.fail_over_mac) {
		
		memcpy(addr.sa_data, new_slave->perm_hwaddr, ETH_ALEN);
		addr.sa_family = slave_dev->type;
		dev_set_mac_address(slave_dev, &addr);
	}

err_restore_mtu:
	dev_set_mtu(slave_dev, new_slave->original_mtu);

err_free:
	kfree(new_slave);

err_undo_flags:
	bond_compute_features(bond);

	return res;
}
","1. struct bonding *bond = netdev_priv(bond_dev);
2. struct sockaddr addr;
int link_reporting;
3. slave_ops->ndo_do_ioctl == NULL) {
4. bond_dev->name, slave_dev->name);
5. if (slave_dev->flags & IFF_SLAVE) {
6. if (bond_vlan_used(bond)) {
pr_err(""%s: Error: cannot enslave VLAN challenged slave %s on VLAN enabled bond %s\n"",
7. } else {
pr_warning(""%s: Warning: enslaved VLAN challenged slave %s. Adding VLANs will be blocked as long as %s is part of bond %s\n"",
8. slave_dev->name, bond_dev->name);
9. } else {
pr_debug(""%s: ! NETIF_F_VLAN_CHALLENGED\n"", slave_dev->name);
10. res = -EPERM;
goto err_undo_flags;
11. if (bond->slave_cnt == 0) {
12. bond_dev->name,
bond_dev->type, slave_dev->type);
13. res = netdev_bonding_change(bond_dev,
14. bond_dev->name);
15. if (slave_dev->type != ARPHRD_ETHER)
bond_setup_by_slave(bond_dev, slave_dev);
else {
16. } else if (bond_dev->type != slave_dev->type) {
pr_err(""%s ether type (%d) is different from other slaves (%d), can not enslave it.\n"",
slave_dev->name,
17. goto err_undo_flags;
18. if (slave_ops->ndo_set_mac_address == NULL) {
if (bond->slave_cnt == 0) {
19. } else if (bond->params.fail_over_mac != BOND_FOM_ACTIVE) {
pr_err(""%s: Error: The slave device specified does not support setting the MAC address, but fail_over_mac is not set to active.\n"",
20. call_netdevice_notifiers(NETDEV_JOIN, slave_dev);
21. memcpy(bond->dev->dev_addr, slave_dev->dev_addr,
slave_dev->addr_len);
22. new_slave->queue_id = 0;
23. if (!bond->params.fail_over_mac) {
24. addr.sa_family = slave_dev->type;
25. goto err_restore_mtu;
26. res = netdev_set_bond_master(slave_dev, bond_dev);
if (res) {
27. res = dev_open(slave_dev);
28. new_slave->bond = bond;
29. res = bond_alb_init_slave(bond, new_slave);
30. res = dev_set_allmulti(slave_dev, 1);
31. netif_addr_lock_bh(bond_dev);
32. u8 lacpdu_multicast[ETH_ALEN] = MULTICAST_LACPDU_ADDR;
33. new_slave->delay = 0;
34. new_slave->last_arp_rx = jiffies;
35. if (bond->params.miimon && !bond->params.use_carrier) {
link_reporting = bond_check_dev_link(bond, slave_dev, 1);
36. pr_warning(""%s: Warning: MII and ETHTOOL support not available for interface %s, and arp_interval/arp_ip_target module parameters not specified, thus bonding will not detect link failures! see bonding.txt for details.\n"",
37. } else if (link_reporting == -1) {
38. bond_dev->name, slave_dev->name);
39. pr_debug(""Initial state of slave_dev is BOND_LINK_BACK\n"");
new_slave->link  = BOND_LINK_BACK;
40. pr_debug(""Initial state of slave_dev is BOND_LINK_DOWN\n"");
41. if (bond_update_speed_duplex(new_slave) &&
42. bond_dev->name, new_slave->dev->name);
43. if (bond->params.mode == BOND_MODE_8023AD) {
44. bond->primary_slave = new_slave;
bond->force_primary = true;
45. write_lock_bh(&bond->curr_slave_lock);
46. case BOND_MODE_ACTIVEBACKUP:
47. bond_set_slave_inactive_flags(new_slave);
48. bond_3ad_bind_slave(new_slave);
break;
49. case BOND_MODE_ALB:
50. bond_select_active_slave(bond);
51. bond_set_active_slave(new_slave);
52. bond->curr_active_slave = new_slave;
53. break;
54. err_dest_symlinks:
55. if (!bond->params.fail_over_mac) {
56. dev_set_mac_address(slave_dev, &addr);
57. err_undo_flags:","3
7-8
12
14
18
27-28
31-32
34
36-37
49-50
60
63-64
66
71
80-82
90-92
95
98-99
103-104
111
116-117
130
147
153
157
161-162
168
174
182
202
207
216
227
236
238-239
251
253
256
264-265
273
277
280
282
291-292
296
299
308
321-322
324
327
333
340
342
385
395
402
411","CWE-264,CWE-19,CWE-119"
ftrace_syscall_exit-20577119495284,"static void ftrace_syscall_exit(void *data, struct pt_regs *regs, long ret)
{
	struct trace_array *tr = data;
	struct ftrace_event_file *ftrace_file;
	struct syscall_trace_exit *entry;
	struct syscall_metadata *sys_data;
	struct ring_buffer_event *event;
	struct ring_buffer *buffer;
	unsigned long irq_flags;
	int pc;
	int syscall_nr;

	syscall_nr = trace_get_syscall_nr(current, regs);
	if (syscall_nr < 0 || syscall_nr >= NR_syscalls)
		return;

	
	ftrace_file = rcu_dereference_sched(tr->exit_syscall_files[syscall_nr]);
	if (!ftrace_file)
		return;

	if (ftrace_trigger_soft_disabled(ftrace_file))
		return;

	sys_data = syscall_nr_to_meta(syscall_nr);
	if (!sys_data)
		return;

	local_save_flags(irq_flags);
	pc = preempt_count();

	buffer = tr->trace_buffer.buffer;
	event = trace_buffer_lock_reserve(buffer,
			sys_data->exit_event->event.type, sizeof(*entry),
			irq_flags, pc);
	if (!event)
		return;

	entry = ring_buffer_event_data(event);
	entry->nr = syscall_nr;
	entry->ret = syscall_get_return_value(current, regs);

	event_trigger_unlock_commit(ftrace_file, buffer, event, entry,
				    irq_flags, pc);
}
","1. static void ftrace_syscall_exit(void *data, struct pt_regs *regs, long ret)
2. struct syscall_trace_exit *entry;
3. if (syscall_nr < 0 || syscall_nr >= NR_syscalls)
4. pc = preempt_count();
5. irq_flags, pc);
if (!event)
6. irq_flags, pc);","1
5
14
30
35-36
44","CWE-190,CWE-264,CWE-125"
set_pte_at-70909735326996,"static inline void set_pte_at(struct mm_struct *mm, unsigned long addr,
			      pte_t *ptep, pte_t pte)
{
	if (pte_valid_user(pte)) {
		if (!pte_special(pte) && pte_exec(pte))
			__sync_icache_dcache(pte, addr);
		if (pte_dirty(pte) && pte_write(pte))
			pte_val(pte) &= ~PTE_RDONLY;
		else
			pte_val(pte) |= PTE_RDONLY;
	}

	set_pte(ptep, pte);
}
","1. pte_t *ptep, pte_t pte)
2. if (pte_dirty(pte) && pte_write(pte))
pte_val(pte) &= ~PTE_RDONLY;
3. pte_val(pte) |= PTE_RDONLY;
4. set_pte(ptep, pte);","2
7-8
10
13","CWE-190,CWE-18,CWE-264,CWE-189"
otp_verify,"otp_verify(krb5_context context, krb5_data *req_pkt, krb5_kdc_req *request,
           krb5_enc_tkt_part *enc_tkt_reply, krb5_pa_data *pa,
           krb5_kdcpreauth_callbacks cb, krb5_kdcpreauth_rock rock,
           krb5_kdcpreauth_moddata moddata,
           krb5_kdcpreauth_verify_respond_fn respond, void *arg)
{
    krb5_keyblock *armor_key = NULL;
    krb5_pa_otp_req *req = NULL;
    struct request_state *rs;
    krb5_error_code retval;
     krb5_data d, plaintext;
     char *config;
 
     
     armor_key = cb->fast_armor(context, rock);
     if (armor_key == NULL) {
        retval = KRB5KDC_ERR_PREAUTH_FAILED;
        com_err(""otp"", retval, ""No armor key found when verifying padata"");
        goto error;
    }

    
    d = make_data(pa->contents, pa->length);
    retval = decode_krb5_pa_otp_req(&d, &req);
    if (retval != 0) {
        com_err(""otp"", retval, ""Unable to decode OTP request"");
        goto error;
    }

    
    retval = decrypt_encdata(context, armor_key, req, &plaintext);
    if (retval != 0) {
        com_err(""otp"", retval, ""Unable to decrypt nonce"");
        goto error;
    }

    
    retval = nonce_verify(context, armor_key, &plaintext);
    if (retval != 0)
        retval = timestamp_verify(context, &plaintext);
    krb5_free_data_contents(context, &plaintext);
    if (retval != 0) {
        com_err(""otp"", retval, ""Unable to verify nonce or timestamp"");
         goto error;
     }
 
    
     rs = k5alloc(sizeof(struct request_state), &retval);
     if (rs == NULL)
         goto error;
     rs->arg = arg;
     rs->respond = respond;
    rs->enc_tkt_reply = enc_tkt_reply;
 
     
     retval = cb->get_string(context, rock, ""otp"", &config);
    if (retval == 0 && config == NULL)
        retval = KRB5_PREAUTH_FAILED;
    if (retval != 0) {
        free(rs);
        goto error;
    }

    
    otp_state_verify((otp_state *)moddata, cb->event_context(context, rock),
                     request->client, config, req, on_response, rs);
    cb->free_string(context, rock, config);

    k5_free_pa_otp_req(context, req);
    return;

error:
    k5_free_pa_otp_req(context, req);
    (*respond)(arg, retval, NULL, NULL, NULL);
}
","1. krb5_keyblock *armor_key = NULL;
2. goto error;","7
19","CWE-295,CWE-200,CWE-787,CWE-835"
fp54_exp_cyc_sps-102105593159304,"void fp54_exp_cyc_sps(fp54_t c, const fp54_t a, const int *b, size_t len,
		int sign) {
	size_t i, j, k, w = len;
    fp54_t t, *u = RLC_ALLOCA(fp54_t, w);

	if (len == 0) {
		RLC_FREE(u);
		fp54_set_dig(c, 1);
		return;
	}

	fp54_null(t);

	RLC_TRY {
		if (u == NULL) {
			RLC_THROW(ERR_NO_MEMORY);
		}
		for (i = 0; i < w; i++) {
			fp54_null(u[i]);
			fp54_new(u[i]);
		}
		fp54_new(t);

		fp54_copy(t, a);
		if (b[0] == 0) {
			for (j = 0, i = 1; i < len; i++) {
				k = (b[i] < 0 ? -b[i] : b[i]);
				for (; j < k; j++) {
					fp54_sqr_pck(t, t);
				}
				if (b[i] < 0) {
					fp54_inv_cyc(u[i - 1], t);
				} else {
					fp54_copy(u[i - 1], t);
				}
			}

			fp54_back_cyc_sim(u, u, w - 1);

			fp54_copy(c, a);
			for (i = 0; i < w - 1; i++) {
				fp54_mul(c, c, u[i]);
			}
		} else {
			for (j = 0, i = 0; i < len; i++) {
				k = (b[i] < 0 ? -b[i] : b[i]);
				for (; j < k; j++) {
					fp54_sqr_pck(t, t);
				}
				if (b[i] < 0) {
					fp54_inv_cyc(u[i], t);
				} else {
					fp54_copy(u[i], t);
				}
			}

			fp54_back_cyc_sim(u, u, w);

			fp54_copy(c, u[0]);
			for (i = 1; i < w; i++) {
				fp54_mul(c, c, u[i]);
			}
		}

		if (sign == RLC_NEG) {
			fp54_inv_cyc(c, c);
		}
	}
	RLC_CATCH_ANY {
		RLC_THROW(ERR_CAUGHT);
	}
	RLC_FINALLY {
		for (i = 0; i < w; i++) {
			fp54_free(u[i]);
		}
		fp54_free(t);
		RLC_FREE(u);
	}
}
","1. fp54_t t, *u = RLC_ALLOCA(fp54_t, w);
2. if (len == 0) {
RLC_FREE(u);
fp54_set_dig(c, 1);
3. RLC_THROW(ERR_NO_MEMORY);
4. fp54_new(u[i]);
5. k = (b[i] < 0 ? -b[i] : b[i]);
for (; j < k; j++) {
6. if (b[i] < 0) {
7. fp54_back_cyc_sim(u, u, w - 1);
8. fp54_copy(c, a);
9. } else {
10. for (; j < k; j++) {
fp54_sqr_pck(t, t);
11. if (b[i] < 0) {
fp54_inv_cyc(u[i], t);
12. fp54_back_cyc_sim(u, u, w);
13. fp54_copy(c, u[0]);
14. fp54_inv_cyc(c, c);
15. RLC_FINALLY {
16. fp54_free(t);","4
6-8
16
20
27-28
31
38
40
44
47-48
50-51
57
59
66
72
76","CWE-119,CWE-190,CWE-400"
pptp_bind-189689262818968,"static int pptp_bind(struct socket *sock, struct sockaddr *uservaddr,
	int sockaddr_len)
{
	struct sock *sk = sock->sk;
	struct sockaddr_pppox *sp = (struct sockaddr_pppox *) uservaddr;
	struct pppox_sock *po = pppox_sk(sk);
	struct pptp_opt *opt = &po->proto.pptp;
	int error = 0;

	if (sockaddr_len < sizeof(struct sockaddr_pppox))
		return -EINVAL;

	lock_sock(sk);

	opt->src_addr = sp->sa_addr.pptp;
	if (add_chan(po))
		error = -EBUSY;

	release_sock(sk);
	return error;
}
","1. static int pptp_bind(struct socket *sock, struct sockaddr *uservaddr,
2. struct sock *sk = sock->sk;
struct sockaddr_pppox *sp = (struct sockaddr_pppox *) uservaddr;
struct pppox_sock *po = pppox_sk(sk);
struct pptp_opt *opt = &po->proto.pptp;
int error = 0;
3. if (sockaddr_len < sizeof(struct sockaddr_pppox))
return -EINVAL;
4. error = -EBUSY;
5. return error;","1
4-8
10-11
17
20","CWE-310,CWE-20,CWE-200,CWE-119,CWE-674"
scsi_free_request,"
#define SCSIRequest

 static void scsi_free_request(SCSIRequest *req)
 {
     SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);
 
    if (r->iov.iov_base) {
        qemu_vfree(r->iov.iov_base);
    }
 }
","1. static void scsi_free_request(SCSIRequest *req)
2. SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);
3. if (r->iov.iov_base) {
qemu_vfree(r->iov.iov_base);","4
6
8-9","CWE-125,CWE-119"
LocaleLowercase," MagickExport int LocaleLowercase(const int c)
 {
  if (c < 0)
    return(c);
 #if defined(MAGICKCORE_LOCALE_SUPPORT)
   if (c_locale != (locale_t) NULL)
     return(tolower_l((int) ((unsigned char) c),c_locale));
#endif
  return(tolower((int) ((unsigned char) c)));
}
","1. MagickExport int LocaleLowercase(const int c)
2. if (c < 0)
return(c);
3. return(tolower((int) ((unsigned char) c)));","1
3-4
9","CWE-125,CWE-787"
propagate_one_1-55320523891928,"static int propagate_one_1(struct mount *m)
{
	struct mount *child;
	int type;
	
	if (IS_MNT_NEW(m))
		return 0;
	
	if (!is_subdir(mp->m_dentry, m->mnt.mnt_root))
		return 0;
	if (peers(m, last_dest)) {
		type = CL_MAKE_SHARED;
	} else {
		struct mount *n, *p;
		bool done;
		for (n = m; ; n = p) {
			p = n->mnt_master;
			if (p == dest_master || IS_MNT_MARKED(p))
				break;
		}
		do {
			struct mount *parent = last_source->mnt_parent;
			if (last_source == first_source)
				break;
			done = parent->mnt_master == p;
			if (done && peers(n, parent))
				break;
			last_source = last_source->mnt_master;
		} while (!done);

		type = CL_SLAVE;
		
		if (IS_MNT_SHARED(m))
			type |= CL_MAKE_SHARED;
	}
		
	
	if (m->mnt_ns->user_ns != user_ns)
		type |= CL_UNPRIVILEGED;
	child = copy_tree(last_source, last_source->mnt.mnt_root, type);
	if (IS_ERR(child))
		return PTR_ERR(child);
	child->mnt.mnt_flags &= ~MNT_LOCKED;
	mnt_set_mountpoint(m, mp, child);
	last_dest = m;
	last_source = child;
	if (m->mnt_master != dest_master) {
		read_seqlock_excl(&mount_lock);
		SET_MNT_MARK(m->mnt_master);
		read_sequnlock_excl(&mount_lock);
	}
	hlist_add_head(&child->mnt_hash, list);
	return count_mounts(m->mnt_ns, child);
}
","1. int type;
2. if (IS_MNT_NEW(m))
3. bool done;
4. if (p == dest_master || IS_MNT_MARKED(p))
5. struct mount *parent = last_source->mnt_parent;
6. } while (!done);
7. return PTR_ERR(child);
8. mnt_set_mountpoint(m, mp, child);
9. read_seqlock_excl(&mount_lock);
SET_MNT_MARK(m->mnt_master);
read_sequnlock_excl(&mount_lock);
10. return count_mounts(m->mnt_ns, child);","4
6
15
18
22
29
42
44
48-50
53","CWE-264,CWE-400,CWE-787,CWE-119,CWE-125"
stbl_AddDTS-192013247958511,"
#define DTS
#define GF_SampleTableBox
#define LastAUDefDuration

GF_Err stbl_AddDTS(GF_SampleTableBox *stbl, u64 DTS, u32 *sampleNumber, u32 LastAUDefDuration, u32 nb_pack)
{
	u32 i, j, sampNum;
	u64 *DTSs, curDTS;
	Bool inserted;
	GF_SttsEntry *ent;

	GF_TimeToSampleBox *stts = stbl->TimeToSample;

	
	stts->r_FirstSampleInEntry = 0;

	*sampleNumber = 0;

	CHECK_PACK(GF_BAD_PARAM)


	
	if (!stts->nb_entries) {
		
		if (DTS) return GF_BAD_PARAM;
		stts->alloc_size = 1;
		stts->nb_entries = 1;
		stts->entries = gf_malloc(sizeof(GF_SttsEntry));
		if (!stts->entries) return GF_OUT_OF_MEM;
		stts->entries[0].sampleCount = nb_pack;
		stts->entries[0].sampleDelta = (nb_pack>1) ? 0 : LastAUDefDuration;
		(*sampleNumber) = 1;
		stts->w_currentSampleNum = nb_pack;
		return GF_OK;
	}
	
	if (DTS >= stts->w_LastDTS) {
		u32 nb_extra = 0;
		ent = &stts->entries[stts->nb_entries-1];
		if (!ent->sampleDelta && (ent->sampleCount>1)) {
			ent->sampleDelta = (u32) ( DTS / ent->sampleCount);
			stts->w_LastDTS = DTS - ent->sampleDelta;
		}
		
		if ((DTS == stts->w_LastDTS + ent->sampleDelta)
			
			
			|| ((nb_pack>1) && ((DTS == stts->w_LastDTS) || (DTS == stts->w_LastDTS + 2*ent->sampleDelta) ))
		) {
			(*sampleNumber) = stts->w_currentSampleNum + 1;
			ent->sampleCount += nb_pack;
			stts->w_currentSampleNum += nb_pack;
			stts->w_LastDTS = DTS + ent->sampleDelta * (nb_pack-1);
			return GF_OK;
		}
		
		if (ent->sampleCount == 1) {
			
#if 0
			if (stts->w_LastDTS)
				ent->sampleDelta += (u32) (DTS - stts->w_LastDTS);
			else
				ent->sampleDelta = (u32) DTS;
#else
			
			ent->sampleDelta = (u32) (DTS - stts->w_LastDTS);
#endif

			ent->sampleCount ++;
			
			if ((stts->nb_entries>=2) && (ent->sampleDelta== stts->entries[stts->nb_entries-2].sampleDelta)) {
				stts->entries[stts->nb_entries-2].sampleCount += ent->sampleCount;
				stts->nb_entries--;
			}
			stts->w_currentSampleNum ++;
			stts->w_LastDTS = DTS;
			(*sampleNumber) = stts->w_currentSampleNum;
			return GF_OK;
		}
		
		ent->sampleCount --;

		if (nb_pack>1)
			nb_extra = 1;

		if (stts->alloc_size <= stts->nb_entries + nb_extra) {
			ALLOC_INC(stts->alloc_size);
			stts->entries = gf_realloc(stts->entries, sizeof(GF_SttsEntry)*stts->alloc_size);
			if (!stts->entries) return GF_OUT_OF_MEM;
			memset(&stts->entries[stts->nb_entries], 0, sizeof(GF_SttsEntry)*(stts->alloc_size-stts->nb_entries) );
		}

		if (nb_extra)
			nb_extra = stts->entries[stts->nb_entries-1].sampleDelta;

		ent = &stts->entries[stts->nb_entries];
		stts->nb_entries++;

		if (nb_pack==1) {
			ent->sampleCount = 2;
			ent->sampleDelta = (u32) (DTS - stts->w_LastDTS);
			stts->w_LastDTS = DTS;
			(*sampleNumber) = stts->w_currentSampleNum+1;
			stts->w_currentSampleNum += 1;
			return GF_OK;
		}

		ent->sampleCount = 1;
		ent->sampleDelta = (u32) (DTS - stts->w_LastDTS);

		ent = &stts->entries[stts->nb_entries];
		stts->nb_entries++;

		ent->sampleCount = nb_pack;
		ent->sampleDelta = nb_extra;
		stts->w_LastDTS = DTS;
		(*sampleNumber) = stts->w_currentSampleNum + 1;
		stts->w_currentSampleNum += nb_pack;
		return GF_OK;
	}


	
	DTSs = (u64*)gf_malloc(sizeof(u64) * (stbl->SampleSize->sampleCount+2) );
	if (!DTSs) return GF_OUT_OF_MEM;
	curDTS = 0;
	sampNum = 0;
	ent = NULL;
	inserted = 0;
	for (i=0; i<stts->nb_entries; i++) {
		ent = & stts->entries[i];
		for (j = 0; j<ent->sampleCount; j++) {
			if (!inserted && (curDTS > DTS)) {
				DTSs[sampNum] = DTS;
				sampNum++;
				*sampleNumber = sampNum;
				inserted = 1;
			}
			DTSs[sampNum] = curDTS;
			curDTS += ent->sampleDelta;
			sampNum ++;
		}
	}
	if (!inserted) {
		gf_free(DTSs);
		return GF_BAD_PARAM;
	}

	
	if (stts->nb_entries+3 >= stts->alloc_size) {
		stts->alloc_size += 3;
		stts->entries = gf_realloc(stts->entries, sizeof(GF_SttsEntry)*stts->alloc_size);
		if (!stts->entries) return GF_OUT_OF_MEM;
		memset(&stts->entries[stts->nb_entries], 0, sizeof(GF_SttsEntry)*(stts->alloc_size - stts->nb_entries) );
	}

	
	j=0;
	stts->nb_entries = 1;
	stts->entries[0].sampleCount = 1;
	stts->entries[0].sampleDelta = (u32) DTSs[1] ;
	for (i=1; i<stbl->SampleSize->sampleCount+1; i++) {
		if (i == stbl->SampleSize->sampleCount) {
			
			stts->entries[j].sampleCount++;
		} else if (stts->entries[j].sampleDelta == (u32) ( DTSs[i+1] - DTSs[i]) ) {
			stts->entries[j].sampleCount ++;
		} else {
			stts->nb_entries ++;
			j++;
			stts->entries[j].sampleCount = 1;
			stts->entries[j].sampleDelta = (u32) (DTSs[i+1] - DTSs[i]);
		}
	}
	gf_free(DTSs);

	
	stts->w_currentSampleNum = stbl->SampleSize->sampleCount + 1;
	return GF_OK;
}
","1. u64 *DTSs, curDTS;
2. if (DTS) return GF_BAD_PARAM;
3. stts->nb_entries = 1;
4. if (!stts->entries) return GF_OUT_OF_MEM;
5. return GF_OK;
6. if (DTS >= stts->w_LastDTS) {
7. if (!ent->sampleDelta && (ent->sampleCount>1)) {
8. ent->sampleDelta = (u32) (DTS - stts->w_LastDTS);
9. ent->sampleCount ++;
10. if ((stts->nb_entries>=2) && (ent->sampleDelta== stts->entries[stts->nb_entries-2].sampleDelta)) {
11. return GF_OK;
12. if (nb_pack>1)
13. if (!stts->entries) return GF_OUT_OF_MEM;
memset(&stts->entries[stts->nb_entries], 0, sizeof(GF_SttsEntry)*(stts->alloc_size-stts->nb_entries) );
14. (*sampleNumber) = stts->w_currentSampleNum+1;
15. stts->nb_entries++;
16. ent->sampleDelta = nb_extra;
17. if (!DTSs) return GF_OUT_OF_MEM;
18. sampNum++;
19. return GF_BAD_PARAM;
20. if (i == stbl->SampleSize->sampleCount) {
21. } else if (stts->entries[j].sampleDelta == (u32) ( DTSs[i+1] - DTSs[i]) ) {
22. return GF_OK;","9
26
28
30
35
38
41
67
70
72
79
84
90-91
104
113
116
126
136
147
164
167
180","CWE-264,CWE-200,CWE-20,CWE-189"
__rds_conn_create_1-4204558988374,"
#define __be32

static struct rds_connection *__rds_conn_create_1(struct net *net,
						__be32 laddr, __be32 faddr,
				       struct rds_transport *trans, gfp_t gfp,
				       int is_outgoing)
{
	struct rds_connection *conn, *parent = NULL;
	struct hlist_head *head = rds_conn_bucket(laddr, faddr);
	struct rds_transport *loop_trans;
	unsigned long flags;
	int ret;

	rcu_read_lock();
	conn = rds_conn_lookup(net, head, laddr, faddr, trans);
	if (conn && conn->c_loopback && conn->c_trans != &rds_loop_transport &&
	    laddr == faddr && !is_outgoing) {
		
		parent = conn;
		conn = parent->c_passive;
	}
	rcu_read_unlock();
	if (conn)
		goto out;

	conn = kmem_cache_zalloc(rds_conn_slab, gfp);
	if (!conn) {
		conn = ERR_PTR(-ENOMEM);
		goto out;
	}

	INIT_HLIST_NODE(&conn->c_hash_node);
	conn->c_laddr = laddr;
	conn->c_faddr = faddr;
	spin_lock_init(&conn->c_lock);
	conn->c_next_tx_seq = 1;
	rds_conn_net_set(conn, net);

	init_waitqueue_head(&conn->c_waitq);
	INIT_LIST_HEAD(&conn->c_send_queue);
	INIT_LIST_HEAD(&conn->c_retrans);

	ret = rds_cong_get_maps(conn);
	if (ret) {
		kmem_cache_free(rds_conn_slab, conn);
		conn = ERR_PTR(ret);
		goto out;
	}

	
	loop_trans = rds_trans_get_preferred(net, faddr);
	if (loop_trans) {
		rds_trans_put(loop_trans);
		conn->c_loopback = 1;
		if (is_outgoing && trans->t_prefer_loopback) {
			
			trans = &rds_loop_transport;
		}
	}

	conn->c_trans = trans;

	ret = trans->conn_alloc(conn, gfp);
	if (ret) {
		kmem_cache_free(rds_conn_slab, conn);
		conn = ERR_PTR(ret);
		goto out;
	}

	atomic_set(&conn->c_state, RDS_CONN_DOWN);
	conn->c_send_gen = 0;
	conn->c_outgoing = (is_outgoing ? 1 : 0);
	conn->c_reconnect_jiffies = 0;
	INIT_DELAYED_WORK(&conn->c_send_w, rds_send_worker);
	INIT_DELAYED_WORK(&conn->c_recv_w, rds_recv_worker);
	INIT_DELAYED_WORK(&conn->c_conn_w, rds_connect_worker);
	INIT_WORK(&conn->c_down_w, rds_shutdown_worker);
	mutex_init(&conn->c_cm_lock);
	conn->c_flags = 0;

	rdsdebug(""allocated conn %p for %pI4 -> %pI4 over %s %s\n"",
	  conn, &laddr, &faddr,
	  trans->t_name ? trans->t_name : ""[unknown]"",
	  is_outgoing ? ""(outgoing)"" : """");

	
	spin_lock_irqsave(&rds_conn_lock, flags);
	if (parent) {
		
		if (parent->c_passive) {
			trans->conn_free(conn->c_transport_data);
			kmem_cache_free(rds_conn_slab, conn);
			conn = parent->c_passive;
		} else {
			parent->c_passive = conn;
			rds_cong_add_conn(conn);
			rds_conn_count++;
		}
	} else {
		
		struct rds_connection *found;

		found = rds_conn_lookup(net, head, laddr, faddr, trans);
		if (found) {
			trans->conn_free(conn->c_transport_data);
			kmem_cache_free(rds_conn_slab, conn);
			conn = found;
		} else {
			hlist_add_head_rcu(&conn->c_hash_node, head);
			rds_cong_add_conn(conn);
			rds_conn_count++;
		}
	}
	spin_unlock_irqrestore(&rds_conn_lock, flags);

out:
	return conn;
}
","1. int is_outgoing)
2. unsigned long flags;
3. rcu_read_lock();
conn = rds_conn_lookup(net, head, laddr, faddr, trans);
if (conn && conn->c_loopback && conn->c_trans != &rds_loop_transport &&
4. parent = conn;
conn = parent->c_passive;
5. conn = kmem_cache_zalloc(rds_conn_slab, gfp);
6. goto out;
7. conn->c_laddr = laddr;
8. spin_lock_init(&conn->c_lock);
9. rds_conn_net_set(conn, net);
10. init_waitqueue_head(&conn->c_waitq);
11. goto out;
12. rds_trans_put(loop_trans);
13. conn = ERR_PTR(ret);
goto out;
14. conn->c_send_gen = 0;
15. INIT_DELAYED_WORK(&conn->c_recv_w, rds_recv_worker);
16. INIT_WORK(&conn->c_down_w, rds_shutdown_worker);
17. conn, &laddr, &faddr,
18. is_outgoing ? ""(outgoing)"" : """");
19. conn = parent->c_passive;
} else {
parent->c_passive = conn;
20. } else {
21. conn = found;
22. rds_cong_add_conn(conn);
23. out:","7
12
15-17
23-24
30
33
37
39
41
43
51
61
77-78
82
86
88
93
95
110-112
116
124
127
133","CWE-362,CWE-416"
ascii_load_sockaddr-154242812543493,"static int
ascii_load_sockaddr(struct sockaddr_storage *ss, char *buf)
{
	if (!strcmp(""local"", buf)) {
		ss->ss_family = AF_LOCAL;
	}
	else if (buf[0] == '[' && buf[strlen(buf)-1] == ']') {
		struct addrinfo hints, *res0;
		
		buf[strlen(buf)-1] = '\0';

		
		memset(&hints, 0, sizeof(hints));
		hints.ai_family = AF_INET6;
		hints.ai_flags = AI_NUMERICHOST;
		if (getaddrinfo(buf+1, NULL, &hints, &res0) != 0)
			return 0;
		memcpy(ss, res0->ai_addr, res0->ai_addrlen);
		ss->ss_len = res0->ai_addrlen;
		freeaddrinfo(res0);
	}
	else {
		struct sockaddr_in ssin;

		memset(&ssin, 0, sizeof ssin);
		if (inet_pton(AF_INET, buf, &ssin.sin_addr) != 1)
			return 0;
		ssin.sin_family = AF_INET;
		memcpy(ss, &ssin, sizeof(ssin));
		ss->ss_len = sizeof(struct sockaddr_in);
	}
	return 1;
}
","1. ss->ss_family = AF_LOCAL;
2. hints.ai_family = AF_INET6;
3. memcpy(ss, res0->ai_addr, res0->ai_addrlen);
4. if (inet_pton(AF_INET, buf, &ssin.sin_addr) != 1)
return 0;
5. ss->ss_len = sizeof(struct sockaddr_in);","5
14
18
26-27
30","CWE-74,CWE-189,CWE-787,CWE-121,CWE-287"
ldsem_cmpxchg-277498612814940,"static inline int ldsem_cmpxchg(long *old, long new, struct ld_semaphore *sem)
{
	long tmp = atomic_long_cmpxchg(&sem->count, *old, new);
	if (tmp == *old) {
		*old = new;
		return 1;
	} else {
		*old = tmp;
		return 0;
	}
}
","1. long tmp = atomic_long_cmpxchg(&sem->count, *old, new);
if (tmp == *old) {
*old = new;
2. *old = tmp;","3-5
8","CWE-668,CWE-125,CWE-287"
cil_build_ast-187713182306100,"int cil_build_ast(struct cil_db *db, struct cil_tree_node *parse_tree, struct cil_tree_node *ast)
{
	int rc = SEPOL_ERR;
	struct cil_args_build extra_args;

	if (db == NULL || parse_tree == NULL || ast == NULL) {
		goto exit;
	}

	extra_args.ast = ast;
	extra_args.db = db;
	extra_args.tunif = NULL;
	extra_args.in = NULL;
	extra_args.macro = NULL;
	extra_args.optional = NULL;
	extra_args.boolif = NULL;

	rc = cil_tree_walk(parse_tree, __cil_build_ast_node_helper, __cil_build_ast_first_child_helper, __cil_build_ast_last_child_helper, &extra_args);
	if (rc != SEPOL_OK) {
		goto exit;
	}

	return SEPOL_OK;

exit:
	return rc;
}
","1. goto exit;
2. extra_args.macro = NULL;
3. return rc;","7
14
26","CWE-416,CWE-200,CWE-125,CWE-119"
exif_data_load_data-87901407877889,"
#define ExifData

void
exif_data_load_data (ExifData *data, const unsigned char *d_orig,
		     unsigned int ds)
{
	unsigned int l;
	ExifLong offset;
	ExifShort n;
	const unsigned char *d = d_orig;
	unsigned int len, fullds;

	if (!data || !data->priv || !d || !ds)
		return;

	exif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, ""ExifData"",
		  ""Parsing %i byte(s) EXIF data...\n"", ds);

	
	if (ds < 6) {
		LOG_TOO_SMALL;
		return;
	}
	if (!memcmp (d, ExifHeader, 6)) {
		exif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, ""ExifData"",
			  ""Found EXIF header at start."");
	} else {
		while (ds >= 3) {
			while (ds && (d[0] == 0xff)) {
				d++;
				ds--;
			}

			
			if (ds && d[0] == JPEG_MARKER_SOI) {
				d++;
				ds--;
				continue;
			}

			
			if (ds && d[0] == JPEG_MARKER_APP1)
				break;

			
			if (ds >= 3 && d[0] >= 0xe0 && d[0] <= 0xef) {  
				d++;
				ds--;
				l = (d[0] << 8) | d[1];
				if (l > ds)
					return;
				d += l;
				ds -= l;
				continue;
			}

			
			exif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA,
				  ""ExifData"", _(""EXIF marker not found.""));
			return;
		}
		if (ds < 3) {
			LOG_TOO_SMALL;
			return;
		}
		d++;
		ds--;
		len = (d[0] << 8) | d[1];
		exif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, ""ExifData"",
			  ""We have to deal with %i byte(s) of EXIF data."",
			  len);
		d += 2;
		ds -= 2;
	}

	
	if (ds < 6) {
		LOG_TOO_SMALL;
		return;
	}
	if (memcmp (d, ExifHeader, 6)) {
		exif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA,
			  ""ExifData"", _(""EXIF header not found.""));
		return;
	}

	exif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, ""ExifData"",
		  ""Found EXIF header."");

	
	if (ds < 14)
		return;

	
	fullds = ds;
	if (ds > 0xfffe)
		ds = 0xfffe;

	
	if (!memcmp (d + 6, ""II"", 2))
		data->priv->order = EXIF_BYTE_ORDER_INTEL;
	else if (!memcmp (d + 6, ""MM"", 2))
		data->priv->order = EXIF_BYTE_ORDER_MOTOROLA;
	else {
		exif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA,
			  ""ExifData"", _(""Unknown encoding.""));
		return;
	}

	
	if (exif_get_short (d + 8, data->priv->order) != 0x002a)
		return;

	
	offset = exif_get_long (d + 10, data->priv->order);
	exif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, ""ExifData"", 
		  ""IFD 0 at %i."", (int) offset);

	
	if (offset > ds || offset + 6 + 2 > ds)
		return;

	
	exif_data_load_data_content (data, EXIF_IFD_0, d + 6, ds - 6, offset, 0);

	
	n = exif_get_short (d + 6 + offset, data->priv->order);
	
	if (offset + 6 + 2 + 12 * n + 4 > ds)
		return;

	offset = exif_get_long (d + 6 + offset + 2 + 12 * n, data->priv->order);
	if (offset) {
		exif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, ""ExifData"",
			  ""IFD 1 at %i."", (int) offset);

		
		if (offset > ds - 6) {
			exif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA,
				  ""ExifData"", ""Bogus offset of IFD1."");
		} else {
		   exif_data_load_data_content (data, EXIF_IFD_1, d + 6, ds - 6, offset, 0);
		}
	}

	
	interpret_maker_note(data, d, fullds);

	
	if (data->priv->options & EXIF_DATA_OPTION_FOLLOW_SPECIFICATION)
		exif_data_fix (data);
}
","1. unsigned int ds)
2. unsigned int l;
3. if (!data || !data->priv || !d || !ds)
4. ""Found EXIF header at start."");
5. if (ds && d[0] == JPEG_MARKER_SOI) {
d++;
6. if (ds && d[0] == JPEG_MARKER_APP1)
break;
7. l = (d[0] << 8) | d[1];
8. ds -= l;
9. return;
10. if (ds < 3) {
11. exif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, ""ExifData"",
12. return;
13. ""Found EXIF header."");
14. if (ds < 14)
15. if (ds > 0xfffe)
ds = 0xfffe;
16. else {
17. ""IFD 0 at %i."", (int) offset);
18. if (offset > ds || offset + 6 + 2 > ds)
19. return;","6
8
14
30
39-40
46-47
57
61
68
70
77
95
99
102
109-110
117
130
133
143","CWE-362,CWE-190,CWE-320"
WT_InterpolateNoLoop,"
#define S_WT_INT_FRAME
#define S_WT_VOICE

void WT_InterpolateNoLoop (S_WT_VOICE *pWTVoice, S_WT_INT_FRAME *pWTIntFrame)
{
    EAS_PCM *pOutputBuffer;
    EAS_I32 phaseInc;
    EAS_I32 phaseFrac;
    EAS_I32 acc0;
 const EAS_SAMPLE *pSamples;
    EAS_I32 samp1;
    EAS_I32 samp2;
    EAS_I32 numSamples;

 
     
     numSamples = pWTIntFrame->numSamples;
    if (numSamples <= 0) {
        ALOGE(""b/26366256"");
        return;
    }
     pOutputBuffer = pWTIntFrame->pAudioBuffer;
 
     phaseInc = pWTIntFrame->frame.phaseIncrement;
    pSamples = (const EAS_SAMPLE*) pWTVoice->phaseAccum;
    phaseFrac = (EAS_I32)pWTVoice->phaseFrac;

 
#if defined(_8_BIT_SAMPLES)
 
    samp1 = pSamples[0] << 8;
 
    samp2 = pSamples[1] << 8;
#else
    samp1 = pSamples[0];
    samp2 = pSamples[1];
#endif

 while (numSamples--) {


 
        acc0 = samp2 - samp1;
        acc0 = acc0 * phaseFrac;
 
        acc0 = samp1 + (acc0 >> NUM_PHASE_FRAC_BITS);

 
 
 *pOutputBuffer++ = (EAS_I16)(acc0 >> 2);

 
        phaseFrac += phaseInc;
 
        acc0 = phaseFrac >> NUM_PHASE_FRAC_BITS;

 
 if (acc0 > 0) {

 
            pSamples += acc0;
            phaseFrac = (EAS_I32)((EAS_U32)phaseFrac & PHASE_FRAC_MASK);

 
#if defined(_8_BIT_SAMPLES)
 
            samp1 = pSamples[0] << 8;
 
            samp2 = pSamples[1] << 8;
#else
            samp1 = pSamples[0];
            samp2 = pSamples[1];
#endif
 }
 }

 
    pWTVoice->phaseAccum = (EAS_U32) pSamples;
    pWTVoice->phaseFrac = (EAS_U32) phaseFrac;
}
","1. EAS_I32 numSamples;
2. samp1 = pSamples[0];
3. samp1 = pSamples[0];
samp2 = pSamples[1];","14
36
72-73","CWE-400,CWE-119"
kvmclock_reset-94026267182911,"static void kvmclock_reset(struct kvm_vcpu *vcpu)
{
	vcpu->arch.pv_time_enabled = false;
}
","1. static void kvmclock_reset(struct kvm_vcpu *vcpu)
2. vcpu->arch.pv_time_enabled = false;","1
3","CWE-310,CWE-190,CWE-200,CWE-119,CWE-399"
message_add_body_amqp_sequence-102573125383836,"
#define AMQP_VALUE
#define MESSAGE_HANDLE

int message_add_body_amqp_sequence(MESSAGE_HANDLE message, AMQP_VALUE sequence_list)
{
    int result;

    if ((message == NULL) ||
        (sequence_list == NULL))
    {
        
        LogError(""Bad arguments: message = %p, sequence_list = %p"",
            message, sequence_list);
        result = MU_FAILURE;
    }
    else
    {
        MESSAGE_BODY_TYPE body_type = internal_get_body_type(message);
        if ((body_type == MESSAGE_BODY_TYPE_DATA) ||
            (body_type == MESSAGE_BODY_TYPE_VALUE))
        {
            
            LogError(""Body is already set to another body type"");
            result = MU_FAILURE;
        }
        else
        {
            size_t realloc_size = safe_add_size_t(message->body_amqp_sequence_count, 1);
            realloc_size = safe_multiply_size_t(sizeof(AMQP_VALUE), realloc_size);

            if (realloc_size == SIZE_MAX)
            {
                LogError(""Invalid size for new_body_amqp_sequence_items"");
                result = MU_FAILURE;
            }
            else
            {
                AMQP_VALUE* new_body_amqp_sequence_items = (AMQP_VALUE*)realloc(message->body_amqp_sequence_items, realloc_size);

                if (new_body_amqp_sequence_items == NULL)
                {
                    
                    LogError(""Cannot allocate enough memory for sequence items"");
                    result = MU_FAILURE;
                }
                else
                {
                    message->body_amqp_sequence_items = new_body_amqp_sequence_items;

                    
                    
                    message->body_amqp_sequence_items[message->body_amqp_sequence_count] = amqpvalue_clone(sequence_list);
                    if (message->body_amqp_sequence_items[message->body_amqp_sequence_count] == NULL)
                    {
                        
                        LogError(""Cloning sequence failed"");
                        result = MU_FAILURE;
                    }
                    else
                    {
                        
                        message->body_amqp_sequence_count++;

                        
                        result = 0;
                    }
                }
            }
        }
    }

    return result;
}
","1. (sequence_list == NULL))
2. {
3. LogError(""Body is already set to another body type"");
4. AMQP_VALUE* new_body_amqp_sequence_items = (AMQP_VALUE*)realloc(message->body_amqp_sequence_items, realloc_size);
5. if (new_body_amqp_sequence_items == NULL)
6. LogError(""Cannot allocate enough memory for sequence items"");
7. result = MU_FAILURE;
8. {","10
18
24
39
41
44
58
61","CWE-358,CWE-190,CWE-400,CWE-119,CWE-125"
cf2_hintmap_build,"
#define CF2_ArrStack
#define CF2_Fixed
#define CF2_HintMap
#define CF2_HintMask
#define FT_Bool

  cf2_hintmap_build( CF2_HintMap   hintmap,
                     CF2_ArrStack  hStemHintArray,
                     CF2_ArrStack  vStemHintArray,
                     CF2_HintMask  hintMask,
                     CF2_Fixed     hintOrigin,
                     FT_Bool       initialMap )
  {
    FT_Byte*  maskPtr;

    CF2_Font         font = hintmap->font;
    CF2_HintMaskRec  tempHintMask;

    size_t   bitCount, i;
    FT_Byte  maskByte;


    
    if ( !initialMap && !cf2_hintmap_isValid( hintmap->initialHintMap ) )
    {
      
      
      cf2_hintmask_init( &tempHintMask, hintMask->error );
      cf2_hintmap_build( hintmap->initialHintMap,
                         hStemHintArray,
                         vStemHintArray,
                         &tempHintMask,
                         hintOrigin,
                         TRUE );
    }

    if ( !cf2_hintmask_isValid( hintMask ) )
    {
      
      cf2_hintmask_setAll( hintMask,
                           cf2_arrstack_size( hStemHintArray ) +
                             cf2_arrstack_size( vStemHintArray ) );
      if ( !cf2_hintmask_isValid( hintMask ) )
          return;                   
    }

    
    hintmap->count     = 0;
    hintmap->lastIndex = 0;

    
    tempHintMask = *hintMask;
     maskPtr      = cf2_hintmask_getMaskPtr( &tempHintMask );
 
     
     bitCount = cf2_arrstack_size( hStemHintArray );
 
    
    if ( bitCount > hintMask->bitCount )
        return;

     
     if ( font->blues.doEmBoxHints )
     {
      cf2_hint_initZero( &dummy );   

      
      cf2_hintmap_insertHint( hintmap,
                              &font->blues.emBoxBottomEdge,
                              &dummy );
      
      cf2_hintmap_insertHint( hintmap,
                              &dummy,
                              &font->blues.emBoxTopEdge );
    }

    
    
    for ( i = 0, maskByte = 0x80; i < bitCount; i++ )
    {
      if ( maskByte & *maskPtr )
      {
        
        CF2_HintRec  bottomHintEdge, topHintEdge;


        cf2_hint_init( &bottomHintEdge,
                       hStemHintArray,
                       i,
                       font,
                       hintOrigin,
                       hintmap->scale,
                       TRUE  );
        cf2_hint_init( &topHintEdge,
                       hStemHintArray,
                       i,
                       font,
                       hintOrigin,
                       hintmap->scale,
                       FALSE  );

        if ( cf2_hint_isLocked( &bottomHintEdge ) ||
             cf2_hint_isLocked( &topHintEdge )    ||
             cf2_blues_capture( &font->blues,
                                &bottomHintEdge,
                                &topHintEdge )   )
        {
          
          cf2_hintmap_insertHint( hintmap, &bottomHintEdge, &topHintEdge );

          *maskPtr &= ~maskByte;      
        }
      }

      if ( ( i & 7 ) == 7 )
      {
        
        maskPtr++;
        maskByte = 0x80;
      }
      else
        maskByte >>= 1;
    }

    

    

    if ( initialMap )
    {
      
      
      

      if ( hintmap->count == 0                           ||
           hintmap->edge[0].csCoord > 0                  ||
           hintmap->edge[hintmap->count - 1].csCoord < 0 )
      {
        
        

        CF2_HintRec  edge, invalid;


        cf2_hint_initZero( &edge );

        edge.flags = CF2_GhostBottom |
                     CF2_Locked      |
                     CF2_Synthetic;
        edge.scale = hintmap->scale;

        cf2_hint_initZero( &invalid );
        cf2_hintmap_insertHint( hintmap, &edge, &invalid );
      }
    }
    else
    {
      

      maskPtr = cf2_hintmask_getMaskPtr( &tempHintMask );

      for ( i = 0, maskByte = 0x80; i < bitCount; i++ )
      {
        if ( maskByte & *maskPtr )
        {
          CF2_HintRec  bottomHintEdge, topHintEdge;


          cf2_hint_init( &bottomHintEdge,
                         hStemHintArray,
                         i,
                         font,
                         hintOrigin,
                         hintmap->scale,
                         TRUE  );
          cf2_hint_init( &topHintEdge,
                         hStemHintArray,
                         i,
                         font,
                         hintOrigin,
                         hintmap->scale,
                         FALSE  );

          cf2_hintmap_insertHint( hintmap, &bottomHintEdge, &topHintEdge );
        }

        if ( ( i & 7 ) == 7 )
        {
          
          maskPtr++;
          maskByte = 0x80;
        }
        else
          maskByte >>= 1;
      }
    }

    

    
    cf2_hintmap_adjustHints( hintmap );

    
    
    if ( !initialMap )
    {
      for ( i = 0; i < hintmap->count; i++ )
      {
        if ( !cf2_hint_isSynthetic( &hintmap->edge[i] ) )
        {
          
          
          CF2_StemHint  stemhint = (CF2_StemHint)
                          cf2_arrstack_getPointer( hStemHintArray,
                                                   hintmap->edge[i].index );


          if ( cf2_hint_isTop( &hintmap->edge[i] ) )
            stemhint->maxDS = hintmap->edge[i].dsCoord;
          else
            stemhint->minDS = hintmap->edge[i].dsCoord;

          stemhint->used = TRUE;
        }
      }
    }

    
    hintmap->isValid = TRUE;

    
    cf2_hintmask_setNew( hintMask, FALSE );
  }
","1. TRUE );
2. cf2_hintmap_insertHint( hintmap, &bottomHintEdge, &topHintEdge );
3. CF2_HintRec  edge, invalid;
4. maskPtr = cf2_hintmask_getMaskPtr( &tempHintMask );","35
110
161
179","CWE-190,CWE-200,CWE-18,CWE-189"
adminchild-276092206446192,"void * adminchild(struct clientparam* param) {
 int i, res;
 char * buf;
 char username[256];
 char *sb;
 char *req = NULL;
 struct printparam pp;
 unsigned contentlen = 0;
 int isform = 0;

 pp.inbuf = 0;
 pp.cp = param;

 buf = myalloc(LINESIZE);
 if(!buf) {RETURN(555);}
 i = sockgetlinebuf(param, CLIENT, (unsigned char *)buf, LINESIZE - 1, '\n', conf.timeouts[STRING_S]);
 if(i<5 || ((buf[0]!='G' || buf[1]!='E' || buf[2]!='T' || buf[3]!=' ' || buf[4]!='/') && 
	   (buf[0]!='P' || buf[1]!='O' || buf[2]!='S' || buf[3]!='T' || buf[4]!=' ' || buf[5]!='/')))
 {
	RETURN(701);
 }
 buf[i] = 0;
 sb = strchr(buf+5, ' ');
 if(!sb){
	RETURN(702);
 }
 *sb = 0;
 req = mystrdup(buf + ((*buf == 'P')? 6 : 5));
 while((i = sockgetlinebuf(param, CLIENT, (unsigned char *)buf, LINESIZE - 1, '\n', conf.timeouts[STRING_S])) > 2){
	buf[i] = 0;
	if(i > 19 && (!strncasecmp(buf, ""authorization"", 13))){
		sb = strchr(buf, ':');
		if(!sb)continue;
		++sb;
		while(isspace(*sb))sb++;
		if(!*sb || strncasecmp(sb, ""basic"", 5)){
			continue;
		}
		sb+=5;
		while(isspace(*sb))sb++;
		i = de64((unsigned char *)sb, (unsigned char *)username, 255);
		if(i<=0)continue;
		username[i] = 0;
		sb = strchr((char *)username, ':');
		if(sb){
			*sb = 0;
			if(param->password)myfree(param->password);
			param->password = (unsigned char *)mystrdup(sb+1);
		}
		if(param->username) myfree(param->username);
		param->username = (unsigned char *)mystrdup(username);
		continue;
	}
	else if(i > 15 && (!strncasecmp(buf, ""content-length:"", 15))){
		sb = buf + 15;
		while(isspace(*sb))sb++;
		sscanf(sb, ""%u"", &contentlen);
		if(contentlen > LINESIZE*1024) contentlen = 0;
	}
	else if(i > 13 && (!strncasecmp(buf, ""content-type:"", 13))){
		sb = buf + 13;
		while(isspace(*sb))sb++;
		if(!strncasecmp(sb, ""x-www-form-urlencoded"", 21)) isform = 1;
	}
 }
 param->operation = ADMIN;
 if(isform && contentlen) {
	printstr(&pp, ""HTTP/1.0 100 Continue\r\n\r\n"");
	stdpr(&pp, NULL, 0);
 }
 res = (*param->srv->authfunc)(param);
 if(res && res != 10) {
	printstr(&pp, authreq);
	RETURN(res);
 }
 if(param->srv->singlepacket || param->redirected){
	if(*req == 'C') req[1] = 0;
	else *req = 0;
 }
 sprintf(buf, ok, conf.stringtable?(char *)conf.stringtable[2]:""3proxy"", conf.stringtable?(char *)conf.stringtable[2]:""3[APA3A] tiny proxy"", conf.stringtable?(char *)conf.stringtable[3]:"""");
 if(*req != 'S') printstr(&pp, buf);
 switch(*req){
	case 'C':
		printstr(&pp, counters);
		{
			struct trafcount *cp; 
			int num = 0;
			for(cp = conf.trafcounter; cp; cp = cp->next, num++){
			 int inbuf = 0;

			 if(cp->ace && (param->srv->singlepacket || param->redirected)){
				if(!ACLmatches(cp->ace, param))continue;
			 }
			 if(req[1] == 'S' && atoi(req+2) == num) cp->disabled=0;
			 if(req[1] == 'D' && atoi(req+2) == num) cp->disabled=1;
			 inbuf += sprintf(buf,	""<tr>""
						""<td>%s</td><td><A HREF=\'/C%c%d\'>%s</A></td><td>"",
						(cp->comment)?cp->comment:""&nbsp;"",
						(cp->disabled)?'S':'D',
						num,
						(cp->disabled)?""NO"":""YES""
					);
			 if(!cp->ace || !cp->ace->users){
				inbuf += sprintf(buf+inbuf, ""<center>ANY</center>"");
			 }
			 else {
				inbuf += printuserlist(buf+inbuf, LINESIZE-800, cp->ace->users, "",<br />\r\n"");
			 }
			 inbuf += sprintf(buf+inbuf, ""</td><td>"");
			 if(!cp->ace || !cp->ace->src){
				inbuf += sprintf(buf+inbuf, ""<center>ANY</center>"");
			 }
			 else {
				inbuf += printiplist(buf+inbuf, LINESIZE-512, cp->ace->src, "",<br />\r\n"");
			 }
			 inbuf += sprintf(buf+inbuf, ""</td><td>"");
			 if(!cp->ace || !cp->ace->dst){
				inbuf += sprintf(buf+inbuf, ""<center>ANY</center>"");
			 }
			 else {
				inbuf += printiplist(buf+inbuf, LINESIZE-512, cp->ace->dst, "",<br />\r\n"");
			 }
			 inbuf += sprintf(buf+inbuf, ""</td><td>"");
			 if(!cp->ace || !cp->ace->ports){
				inbuf += sprintf(buf+inbuf, ""<center>ANY</center>"");
			 }
			 else {
				inbuf += printportlist(buf+inbuf, LINESIZE-128, cp->ace->ports, "",<br />\r\n"");
			 }
			 if(cp->type == NONE) {
			  inbuf += sprintf(buf+inbuf,	
					""</td><td colspan=\'6\' align=\'center\'>exclude from limitation</td></tr>\r\n""
				 );
			 }
			 else {
			  inbuf += sprintf(buf+inbuf,	
					""</td><td>%""PRINTF_INT64_MODIFIER""u</td>""
					""<td>MB%s</td>""
					""<td>%""PRINTF_INT64_MODIFIER""u</td>""
					""<td>%s</td>"",
				 cp->traflim64 / (1024 * 1024),
				 rotations[cp->type],
				 cp->traf64,
				 cp->cleared?ctime(&cp->cleared):""never""
				);
			 inbuf += sprintf(buf + inbuf,
					""<td>%s</td>""
					""<td>%i</td>""
					""</tr>\r\n"",

				 cp->updated?ctime(&cp->updated):""never"",
				 cp->number
				);
			 }
			 printstr(&pp, buf);
			}

		}
		printstr(&pp, counterstail);
		break;
		
	case 'R':
		conf.needreload = 1;
		printstr(&pp, ""<h3>Reload scheduled</h3>"");
		break;
	case 'S':
		{
			if(req[1] == 'X'){
				printstr(&pp, style);
				break;
			}
			printstr(&pp, xml);
			printval(conf.services, TYPE_SERVER, 0, &pp);
			printstr(&pp, postxml);
		}
			break;
	case 'F':
		{
			FILE *fp;
			char buf[256];

			fp = confopen();
			if(!fp){
				printstr(&pp, ""<h3><font color=\""red\"">Failed to open config file</font></h3>"");
				break;
			}
				printstr(&pp, ""<h3>Please be careful editing config file remotely</h3>"");
				printstr(&pp, ""<form method=\""POST\"" action=\""/U\"" enctype=\""application/x-www-form-urlencoded\""><textarea cols=\""80\"" rows=\""30\"" name=\""conffile\"">"");
				while(fgets(buf, 256, fp)){
					printstr(&pp, buf);
				}
				if(!writable) fclose(fp);
				printstr(&pp, ""</textarea><br><input type=\""Submit\""></form>"");
			break;
		}
	case 'U':
		{
			unsigned l=0;
			int error = 0;

			if(!writable || !contentlen || fseek(writable, 0, 0)){
				error = 1;
			}
			while(l < contentlen && (i = sockgetlinebuf(param, CLIENT, (unsigned char *)buf, (contentlen - l) > LINESIZE - 1?LINESIZE - 1:contentlen - l, '+', conf.timeouts[STRING_S])) > 0){
				if(i > (contentlen - l)) i = (contentlen - l);
				if(!l){
					if(i<9 || strncasecmp(buf, ""conffile="", 9)) error = 1;
				}
				if(!error){
					buf[i] = 0;
					decodeurl((unsigned char *)buf, 1);
					fprintf(writable, ""%s"", l? buf : buf + 9);
				}
				l += i;
			}
			if(writable && !error){
				fflush(writable);
#ifndef _WINCE
				ftruncate(fileno(writable), ftell(writable));
#endif
			}
			printstr(&pp, error?    ""<h3><font color=\""red\"">Config file is not writable</font></h3>Make sure you have \""writable\"" command in configuration file"":
						""<h3>Configuration updated</h3>"");

		}
		break;
	default:
		printstr(&pp, (char *)conf.stringtable[WEBBANNERS]);
		break;
 }
 if(*req != 'S') printstr(&pp, tail);

CLEANRET:


 printstr(&pp, NULL);
 if(buf) myfree(buf);
 (*param->srv->logfunc)(param, (unsigned char *)req);
 if(req)myfree(req);
 freeparam(param);
 return (NULL);
}
","1. int i, res;
2. char username[256];
3. char *req = NULL;
4. unsigned contentlen = 0;
5. pp.inbuf = 0;
6. if(!buf) {RETURN(555);}
7. if(i<5 || ((buf[0]!='G' || buf[1]!='E' || buf[2]!='T' || buf[3]!=' ' || buf[4]!='/') &&
8. *sb = 0;
9. while(isspace(*sb))sb++;
10. sb = buf + 13;
11. if(res && res != 10) {
12. if(*req != 'S') printstr(&pp, buf);
13. case 'C':
14. inbuf += sprintf(buf,	""<tr>""
15. (cp->disabled)?""NO"":""YES""
16. if(!cp->ace || !cp->ace->src){
17. else {
18. inbuf += sprintf(buf + inbuf,
19. cp->number
20. conf.needreload = 1;
21. break;
22. printstr(&pp, xml);
printval(conf.services, TYPE_SERVER, 0, &pp);
23. FILE *fp;
24. break;
25. printstr(&pp, ""<form method=\""POST\"" action=\""/U\"" enctype=\""application/x-www-form-urlencoded\""><textarea cols=\""80\"" rows=\""30\"" name=\""conffile\"">"");
26. if(!writable || !contentlen || fseek(writable, 0, 0)){
error = 1;
27. if(writable && !error){
28. default:
29. freeparam(param);
return (NULL);","2
4
6
8
11
15
17
27
56
61
72
81
83
96
101
110
135
146
152
163
165
172-173
179
185
188
201-202
216
227
240-241","CWE-772,CWE-17,CWE-401"
update_write_cache_bitmap_v3_order-272608884597558,"
#define CACHE_BITMAP_V3_ORDER
#define UINT16

BOOL update_write_cache_bitmap_v3_order(wStream* s, CACHE_BITMAP_V3_ORDER* cache_bitmap_v3,
                                        UINT16* flags)
{
	BOOL rc;
	BYTE bitsPerPixelId;
	BITMAP_DATA_EX* bitmapData;

	if (!Stream_EnsureRemainingCapacity(
	        s, update_approximate_cache_bitmap_v3_order(cache_bitmap_v3, flags)))
		return FALSE;

	bitmapData = &cache_bitmap_v3->bitmapData;
	bitsPerPixelId = get_bpp_bmf(cache_bitmap_v3->bpp, &rc);
	if (!rc)
		return FALSE;
	*flags = (cache_bitmap_v3->cacheId & 0x00000003) |
	         ((cache_bitmap_v3->flags << 7) & 0x0000FF80) | ((bitsPerPixelId << 3) & 0x00000078);
	Stream_Write_UINT16(s, cache_bitmap_v3->cacheIndex); 
	Stream_Write_UINT32(s, cache_bitmap_v3->key1);       
	Stream_Write_UINT32(s, cache_bitmap_v3->key2);       
	Stream_Write_UINT8(s, bitmapData->bpp);
	Stream_Write_UINT8(s, 0);                   
	Stream_Write_UINT8(s, 0);                   
	Stream_Write_UINT8(s, bitmapData->codecID); 
	Stream_Write_UINT16(s, bitmapData->width);  
	Stream_Write_UINT16(s, bitmapData->height); 
	Stream_Write_UINT32(s, bitmapData->length); 
	Stream_Write(s, bitmapData->data, bitmapData->length);
	return TRUE;
}
","1. BOOL update_write_cache_bitmap_v3_order(wStream* s, CACHE_BITMAP_V3_ORDER* cache_bitmap_v3,
UINT16* flags)
2. BOOL rc;
BYTE bitsPerPixelId;
3. s, update_approximate_cache_bitmap_v3_order(cache_bitmap_v3, flags)))
4. bitsPerPixelId = get_bpp_bmf(cache_bitmap_v3->bpp, &rc);
if (!rc)
return FALSE;
*flags = (cache_bitmap_v3->cacheId & 0x00000003) |
5. Stream_Write_UINT32(s, cache_bitmap_v3->key1);
Stream_Write_UINT32(s, cache_bitmap_v3->key2);
Stream_Write_UINT8(s, bitmapData->bpp);
Stream_Write_UINT8(s, 0);
6. Stream_Write_UINT32(s, bitmapData->length);
Stream_Write(s, bitmapData->data, bitmapData->length);","5-6
8-9
13
17-20
23-26
31-32","CWE-125,CWE-787"
udp_recvmsg_1,"int udp_recvmsg_1(struct sock *sk, struct msghdr *msg, size_t len, int noblock,
		int flags, int *addr_len)
{
	struct inet_sock *inet = inet_sk(sk);
	DECLARE_SOCKADDR(struct sockaddr_in *, sin, msg->msg_name);
	struct sk_buff *skb;
	unsigned int ulen, copied;
	int peeked, off = 0;
	int err;
	int is_udplite = IS_UDPLITE(sk);
	bool slow;

	if (flags & MSG_ERRQUEUE)
		return ip_recv_error(sk, msg, len, addr_len);

try_again:
	skb = __skb_recv_datagram(sk, flags | (noblock ? MSG_DONTWAIT : 0),
				  &peeked, &off, &err);
	if (!skb)
		goto out;

	ulen = skb->len - sizeof(struct udphdr);
	copied = len;
	if (copied > ulen)
		copied = ulen;
	else if (copied < ulen)
		msg->msg_flags |= MSG_TRUNC;

	

	if (copied < ulen || UDP_SKB_CB(skb)->partial_cov) {
		if (udp_lib_checksum_complete(skb))
			goto csum_copy_err;
	}

	if (skb_csum_unnecessary(skb))
		err = skb_copy_datagram_msg(skb, sizeof(struct udphdr),
					    msg, copied);
	else {
		err = skb_copy_and_csum_datagram_msg(skb, sizeof(struct udphdr),
						     msg);

		if (err == -EINVAL)
			goto csum_copy_err;
	}

	if (unlikely(err)) {
		trace_kfree_skb(skb, udp_recvmsg_1);
		if (!peeked) {
			atomic_inc(&sk->sk_drops);
			UDP_INC_STATS_USER(sock_net(sk),
					   UDP_MIB_INERRORS, is_udplite);
		}
		goto out_free;
	}

	if (!peeked)
		UDP_INC_STATS_USER(sock_net(sk),
				UDP_MIB_INDATAGRAMS, is_udplite);

	sock_recv_ts_and_drops(msg, sk, skb);

	
	if (sin) {
		sin->sin_family = AF_INET;
		sin->sin_port = udp_hdr(skb)->source;
		sin->sin_addr.s_addr = ip_hdr(skb)->saddr;
		memset(sin->sin_zero, 0, sizeof(sin->sin_zero));
		*addr_len = sizeof(*sin);
	}
	if (inet->cmsg_flags)
		ip_cmsg_recv_offset(msg, skb, sizeof(struct udphdr));

	err = copied;
	if (flags & MSG_TRUNC)
		err = ulen;

out_free:
	skb_free_datagram_locked(sk, skb);
out:
	return err;

csum_copy_err:
	slow = lock_sock_fast(sk);
	if (!skb_kill_datagram(sk, skb, flags)) {
		UDP_INC_STATS_USER(sock_net(sk), UDP_MIB_CSUMERRORS, is_udplite);
		UDP_INC_STATS_USER(sock_net(sk), UDP_MIB_INERRORS, is_udplite);
 	}
 	unlock_sock_fast(sk, slow);
 
	
	cond_resched();
 	msg->msg_flags &= ~MSG_TRUNC;
 	goto try_again;
 }
","1. return ip_recv_error(sk, msg, len, addr_len);
2. try_again:
3. if (!skb)
goto out;
4. else {
5. if (err == -EINVAL)
6. goto out_free;
7. skb_free_datagram_locked(sk, skb);
8. slow = lock_sock_fast(sk);
if (!skb_kill_datagram(sk, skb, flags)) {
9. goto try_again;","14
16
19-20
43
47
58
83
88-89
98","CWE-358,CWE-399"
__detach_mounts-209887969950287,"void __detach_mounts(struct dentry *dentry)
{
	struct mountpoint *mp;
	struct mount *mnt;

	namespace_lock();
	mp = lookup_mountpoint(dentry);
	if (!mp)
		goto out_unlock;

	lock_mount_hash();
	while (!hlist_empty(&mp->m_list)) {
		mnt = hlist_entry(mp->m_list.first, struct mount, mnt_mp_list);
		if (mnt->mnt.mnt_flags & MNT_UMOUNT) {
			struct mount *p, *tmp;
			list_for_each_entry_safe(p, tmp, &mnt->mnt_mounts,  mnt_child) {
				hlist_add_head(&p->mnt_umount.s_list, &unmounted);
				umount_mnt(p);
			}
		}
		else umount_tree(mnt, 0);
	}
	unlock_mount_hash();
	put_mountpoint(mp);
out_unlock:
	namespace_unlock();
}
","1. namespace_lock();
2. struct mount *p, *tmp;
3. umount_mnt(p);
4. else umount_tree(mnt, 0);
5. put_mountpoint(mp);","6
15
18
21
24","CWE-787,CWE-200,CWE-284"
get_manuf_name_if_known-84830957454450,"const gchar *
get_manuf_name_if_known(const guint8 *addr, size_t size)
{
    hashmanuf_t *manuf_value;
    guint manuf_key;
    guint8 oct;

    ws_return_val_if(size != 6, NULL);

    
    manuf_key = addr[0];
    manuf_key = manuf_key<<8;
    oct = addr[1];
    manuf_key = manuf_key | oct;
    manuf_key = manuf_key<<8;
    oct = addr[2];
    manuf_key = manuf_key | oct;

    manuf_value = (hashmanuf_t *)wmem_map_lookup(manuf_hashtable, GUINT_TO_POINTER(manuf_key));
    if (manuf_value != NULL && manuf_value->status != HASHETHER_STATUS_UNRESOLVED) {
        return manuf_value->resolved_longname;
    }

    
    const char *short_name, *long_name;
    short_name = ws_manuf_lookup_str(addr, &long_name);
    if (short_name != NULL) {
        
        return long_name;
    }

    return NULL;

} 
","1. const gchar *
2. guint manuf_key;
3. manuf_key = addr[0];
4. oct = addr[1];
manuf_key = manuf_key | oct;
5. if (manuf_value != NULL && manuf_value->status != HASHETHER_STATUS_UNRESOLVED) {
return manuf_value->resolved_longname;
6. const char *short_name, *long_name;","1
5
11
13-14
20-21
25","CWE-476,CWE-190,CWE-20,CWE-125"
ip_ufo_append_data,"static inline int ip_ufo_append_data(struct sock *sk,
			struct sk_buff_head *queue,
			int getfrag(void *from, char *to, int offset, int len,
			       int odd, struct sk_buff *skb),
			void *from, int length, int hh_len, int fragheaderlen,
			int transhdrlen, int maxfraglen, unsigned int flags)
{
	struct sk_buff *skb;
	int err;

	
	if ((skb = skb_peek_tail(queue)) == NULL) {
		skb = sock_alloc_send_skb(sk,
			hh_len + fragheaderlen + transhdrlen + 20,
			(flags & MSG_DONTWAIT), &err);

		if (skb == NULL)
			return err;

		
		skb_reserve(skb, hh_len);

		
		skb_put(skb, fragheaderlen + transhdrlen);

		
		skb_reset_network_header(skb);

 		
 		skb->transport_header = skb->network_header + fragheaderlen;
 
 		skb->csum = 0;
 

 		__skb_queue_tail(queue, skb);
	} else if (skb_is_gso(skb)) {
		goto append;
 	}
 
	skb->ip_summed = CHECKSUM_PARTIAL;
	
	skb_shinfo(skb)->gso_size = maxfraglen - fragheaderlen;
	skb_shinfo(skb)->gso_type = SKB_GSO_UDP;

append:
 	return skb_append_datato_frags(sk, skb, getfrag, from,
 				       (length - transhdrlen));
 }
","1. static inline int ip_ufo_append_data(struct sock *sk,
struct sk_buff_head *queue,
2. void *from, int length, int hh_len, int fragheaderlen,
int transhdrlen, int maxfraglen, unsigned int flags)
3. struct sk_buff *skb;
int err;
4. if ((skb = skb_peek_tail(queue)) == NULL) {
skb = sock_alloc_send_skb(sk,
hh_len + fragheaderlen + transhdrlen + 20,
5. skb_put(skb, fragheaderlen + transhdrlen);
6. skb_reset_network_header(skb);
7. skb->csum = 0;
8. } else if (skb_is_gso(skb)) {
goto append;
9. skb->ip_summed = CHECKSUM_PARTIAL;
10. return skb_append_datato_frags(sk, skb, getfrag, from,
(length - transhdrlen));","1-2
5-6
8-9
15-17
27
30
35
39-40
43
49-50","CWE-264,CWE-787,CWE-119"
test_iterators-19717831148111,"static void test_iterators()
{
    int i;
    json_t *object, *foo, *bar, *baz;
    const char *iter_keys[3];
    int have_key[3] = { 0, 0, 0 };
    json_t *iter_values[3];
    void *iter;

    if(json_object_iter(NULL))
        fail(""able to iterate over NULL"");

    if(json_object_iter_next(NULL, NULL))
        fail(""able to increment an iterator on a NULL object"");

    object = json_object();
    foo = json_string(""foo"");
    bar = json_string(""bar"");
    baz = json_string(""baz"");
    if(!object || !foo || !bar || !bar)
        fail(""unable to create values"");

    if(json_object_iter_next(object, NULL))
        fail(""able to increment a NULL iterator"");

    if(json_object_set(object, ""a"", foo) ||
       json_object_set(object, ""b"", bar) ||
       json_object_set(object, ""c"", baz))
        fail(""unable to populate object"");

    iter = json_object_iter(object);
    if(!iter)
        fail(""unable to get iterator"");
    iter_keys[0] = json_object_iter_key(iter);
    iter_values[0] = json_object_iter_value(iter);

    iter = json_object_iter_next(object, iter);
    if(!iter)
        fail(""unable to increment iterator"");
    iter_keys[1] = json_object_iter_key(iter);
    iter_values[1] = json_object_iter_value(iter);

    iter = json_object_iter_next(object, iter);
    if(!iter)
        fail(""unable to increment iterator"");
    iter_keys[2] = json_object_iter_key(iter);
    iter_values[2] = json_object_iter_value(iter);

    if(json_object_iter_next(object, iter) != NULL)
        fail(""able to iterate over the end"");

    
    for (i = 0; i < 3; i++) {
        if (strcmp(iter_keys[i], ""a"") == 0) {
            if (iter_values[i] != foo)
                fail(""wrong value for iter key a"");
            else
                have_key[0] = 1;
        } else if (strcmp(iter_keys[i], ""b"") == 0) {
            if (iter_values[i] != bar)
                fail(""wrong value for iter key b"");
            else
                have_key[1] = 1;
        } else if (strcmp(iter_keys[i], ""c"") == 0) {
            if (iter_values[i] != baz)
                fail(""wrong value for iter key c"");
            else
                have_key[2] = 1;
        }
    }

    
    for(i = 0; i < 3; i++) {
        if(!have_key[i])
            fail(""a key wasn't iterated over"");
    }

    if(json_object_iter_at(object, ""foo""))
        fail(""json_object_iter_at() succeeds for non-existent key"");

    iter = json_object_iter_at(object, ""b"");
    if(!iter)
        fail(""json_object_iter_at() fails for an existing key"");

    if(strcmp(json_object_iter_key(iter), ""b""))
        fail(""iterating failed: wrong key"");
    if(json_object_iter_value(iter) != bar)
        fail(""iterating failed: wrong value"");

    if(json_object_iter_set(object, iter, baz))
        fail(""unable to set value at iterator"");

    if(strcmp(json_object_iter_key(iter), ""b""))
        fail(""json_object_iter_key() fails after json_object_iter_set()"");
    if(json_object_iter_value(iter) != baz)
        fail(""json_object_iter_value() fails after json_object_iter_set()"");
    if(json_object_get(object, ""b"") != baz)
        fail(""json_object_get() fails after json_object_iter_set()"");

    json_decref(object);
    json_decref(foo);
    json_decref(bar);
    json_decref(baz);
}
","1. int i;
json_t *object, *foo, *bar, *baz;
2. if(json_object_iter(NULL))
3. fail(""able to increment an iterator on a NULL object"");
4. object = json_object();
5. iter_values[0] = json_object_iter_value(iter);
6. fail(""unable to increment iterator"");
7. fail(""able to iterate over the end"");
8. if (iter_values[i] != foo)
9. have_key[1] = 1;
10. fail(""wrong value for iter key c"");
11. have_key[2] = 1;
12. if(!have_key[i])
fail(""a key wasn't iterated over"");
13. if(json_object_iter_at(object, ""foo""))
14. iter = json_object_iter_at(object, ""b"");
15. if(strcmp(json_object_iter_key(iter), ""b""))
fail(""iterating failed: wrong key"");
16. fail(""json_object_iter_key() fails after json_object_iter_set()"");
17. fail(""json_object_iter_value() fails after json_object_iter_set()"");
if(json_object_get(object, ""b"") != baz)","3-4
10
14
16
35
39
50
55
63
66
68
74-75
78
81
85-86
94
96-97","CWE-125,CWE-78,CWE-399,CWE-119"
xfs_attr_rmtval_get,"xfs_attr_rmtval_get(
	struct xfs_da_args	*args)
{
	struct xfs_bmbt_irec	map[ATTR_RMTVALUE_MAPSIZE];
	struct xfs_mount	*mp = args->dp->i_mount;
 	struct xfs_buf		*bp;
 	xfs_dablk_t		lblkno = args->rmtblkno;
 	__uint8_t		*dst = args->value;
	int			valuelen;
 	int			nmap;
 	int			error;
 	int			blkcnt = args->rmtblkcnt;
	int			i;
	int			offset = 0;

 	trace_xfs_attr_rmtval_get(args);
 
 	ASSERT(!(args->flags & ATTR_KERNOVAL));
	ASSERT(args->rmtvaluelen == args->valuelen);
 
	valuelen = args->rmtvaluelen;
 	while (valuelen > 0) {
 		nmap = ATTR_RMTVALUE_MAPSIZE;
 		error = xfs_bmapi_read(args->dp, (xfs_fileoff_t)lblkno,
				       blkcnt, map, &nmap,
				       XFS_BMAPI_ATTRFORK);
		if (error)
			return error;
		ASSERT(nmap >= 1);

		for (i = 0; (i < nmap) && (valuelen > 0); i++) {
			xfs_daddr_t	dblkno;
			int		dblkcnt;

			ASSERT((map[i].br_startblock != DELAYSTARTBLOCK) &&
			       (map[i].br_startblock != HOLESTARTBLOCK));
			dblkno = XFS_FSB_TO_DADDR(mp, map[i].br_startblock);
			dblkcnt = XFS_FSB_TO_BB(mp, map[i].br_blockcount);
			error = xfs_trans_read_buf(mp, NULL, mp->m_ddev_targp,
						   dblkno, dblkcnt, 0, &bp,
						   &xfs_attr3_rmt_buf_ops);
			if (error)
				return error;

			error = xfs_attr_rmtval_copyout(mp, bp, args->dp->i_ino,
							&offset, &valuelen,
							&dst);
			xfs_buf_relse(bp);
			if (error)
				return error;

			
			lblkno += map[i].br_blockcount;
			blkcnt -= map[i].br_blockcount;
		}
	}
	ASSERT(valuelen == 0);
	return 0;
}
","1. xfs_dablk_t		lblkno = args->rmtblkno;
2. ASSERT(!(args->flags & ATTR_KERNOVAL));
3. &dst);
xfs_buf_relse(bp);
4. return error;
5. blkcnt -= map[i].br_blockcount;
6. ASSERT(valuelen == 0);
return 0;","7
18
47-48
50
54
57-58","CWE-345,CWE-254,CWE-264,CWE-19,CWE-119"
isis_print_mt_port_cap_subtlv-179365134442633,"static int
isis_print_mt_port_cap_subtlv(netdissect_options *ndo,
                              const uint8_t *tptr, int len)
{
  int stlv_type, stlv_len;
  const struct isis_subtlv_spb_mcid *subtlv_spb_mcid;
  int i;

  while (len > 2)
  {
    ND_TCHECK2(*tptr, 2);
    stlv_type = *(tptr++);
    stlv_len  = *(tptr++);

    
    ND_PRINT((ndo, ""\n\t       %s subTLV #%u, length: %u"",
               tok2str(isis_mt_port_cap_subtlv_values, ""unknown"", stlv_type),
               stlv_type,
               stlv_len));

    
    len = len -2;

    
    if (len < stlv_len)
      goto trunc;
    
    ND_TCHECK2(*(tptr), stlv_len);

    switch (stlv_type)
    {
      case ISIS_SUBTLV_SPB_MCID:
      {
      	if (stlv_len < ISIS_SUBTLV_SPB_MCID_MIN_LEN)
      	  goto trunc;

        subtlv_spb_mcid = (const struct isis_subtlv_spb_mcid *)tptr;

        ND_PRINT((ndo,  ""\n\t         MCID: ""));
        isis_print_mcid(ndo, &(subtlv_spb_mcid->mcid));

          

        ND_PRINT((ndo,  ""\n\t         AUX-MCID: ""));
        isis_print_mcid(ndo, &(subtlv_spb_mcid->aux_mcid));

          
        tptr = tptr + ISIS_SUBTLV_SPB_MCID_MIN_LEN;
        len = len - ISIS_SUBTLV_SPB_MCID_MIN_LEN;
        stlv_len = stlv_len - ISIS_SUBTLV_SPB_MCID_MIN_LEN;

        break;
      }

      case ISIS_SUBTLV_SPB_DIGEST:
      {
        if (stlv_len < ISIS_SUBTLV_SPB_DIGEST_MIN_LEN)
          goto trunc;

        ND_PRINT((ndo, ""\n\t        RES: %d V: %d A: %d D: %d"",
                        (*(tptr) >> 5), (((*tptr)>> 4) & 0x01),
                        ((*(tptr) >> 2) & 0x03), ((*tptr) & 0x03)));

        tptr++;

        ND_PRINT((ndo,  ""\n\t         Digest: ""));

        for(i=1;i<=8; i++)
        {
            ND_PRINT((ndo, ""%08x "", EXTRACT_32BITS(tptr)));
            if (i%4 == 0 && i != 8)
              ND_PRINT((ndo, ""\n\t                 ""));
            tptr = tptr + 4;
        }

        len = len - ISIS_SUBTLV_SPB_DIGEST_MIN_LEN;
        stlv_len = stlv_len - ISIS_SUBTLV_SPB_DIGEST_MIN_LEN;

        break;
      }

      case ISIS_SUBTLV_SPB_BVID:
      {
        while (stlv_len >= ISIS_SUBTLV_SPB_BVID_MIN_LEN)
        {
          ND_PRINT((ndo, ""\n\t           ECT: %08x"",
                      EXTRACT_32BITS(tptr)));

          tptr = tptr+4;

          ND_PRINT((ndo, "" BVID: %d, U:%01x M:%01x "",
                     (EXTRACT_16BITS (tptr) >> 4) ,
                     (EXTRACT_16BITS (tptr) >> 3) & 0x01,
                     (EXTRACT_16BITS (tptr) >> 2) & 0x01));

          tptr = tptr + 2;
          len = len - ISIS_SUBTLV_SPB_BVID_MIN_LEN;
          stlv_len = stlv_len - ISIS_SUBTLV_SPB_BVID_MIN_LEN;
        }

        break;
      }

      default:
        break;
    }
    tptr += stlv_len;
    len -= stlv_len;
  }

  return 0;

  trunc:
    ND_PRINT((ndo, ""\n\t\t""));
    ND_PRINT((ndo, ""%s"", tstr));
    return(1);
}
","1. static int
isis_print_mt_port_cap_subtlv(netdissect_options *ndo,
2. int stlv_type, stlv_len;
const struct isis_subtlv_spb_mcid *subtlv_spb_mcid;
3. ND_TCHECK2(*tptr, 2);
4. stlv_len  = *(tptr++);
5. ND_PRINT((ndo, ""\n\t       %s subTLV #%u, length: %u"",
tok2str(isis_mt_port_cap_subtlv_values, ""unknown"", stlv_type),
stlv_type,
6. len = len -2;
7. if (len < stlv_len)
goto trunc;
8. case ISIS_SUBTLV_SPB_MCID:
9. goto trunc;
10. subtlv_spb_mcid = (const struct isis_subtlv_spb_mcid *)tptr;
11. isis_print_mcid(ndo, &(subtlv_spb_mcid->aux_mcid));
12. tptr = tptr + ISIS_SUBTLV_SPB_MCID_MIN_LEN;
len = len - ISIS_SUBTLV_SPB_MCID_MIN_LEN;
stlv_len = stlv_len - ISIS_SUBTLV_SPB_MCID_MIN_LEN;
13. break;
14. case ISIS_SUBTLV_SPB_DIGEST:
15. if (stlv_len < ISIS_SUBTLV_SPB_DIGEST_MIN_LEN)
goto trunc;
16. (*(tptr) >> 5), (((*tptr)>> 4) & 0x01),
((*(tptr) >> 2) & 0x03), ((*tptr) & 0x03)));
17. tptr++;
18. ND_PRINT((ndo, ""%08x "", EXTRACT_32BITS(tptr)));
if (i%4 == 0 && i != 8)
19. tptr = tptr + 4;
20. len = len - ISIS_SUBTLV_SPB_DIGEST_MIN_LEN;
stlv_len = stlv_len - ISIS_SUBTLV_SPB_DIGEST_MIN_LEN;
21. break;
22. while (stlv_len >= ISIS_SUBTLV_SPB_BVID_MIN_LEN)
23. EXTRACT_32BITS(tptr)));
24. tptr = tptr+4;
25. (EXTRACT_16BITS (tptr) >> 4) ,
(EXTRACT_16BITS (tptr) >> 3) & 0x01,
(EXTRACT_16BITS (tptr) >> 2) & 0x01));
26. len -= stlv_len;
27. return 0;
28. trunc:
ND_PRINT((ndo, ""\n\t\t""));
ND_PRINT((ndo, ""%s"", tstr));
return(1);","1-2
5-6
11
13
16-18
22
25-26
32
35
37
46
50-52
54
57
59-60
63-64
66
72-73
75
78-79
81
86
89
91
94-96
110
113
115-118","CWE-125,CWE-787"
radeon_atom_get_tv_timings,"bool radeon_atom_get_tv_timings(struct radeon_device *rdev, int index,
				struct drm_display_mode *mode)
{
	struct radeon_mode_info *mode_info = &rdev->mode_info;
	ATOM_ANALOG_TV_INFO *tv_info;
	ATOM_ANALOG_TV_INFO_V1_2 *tv_info_v1_2;
	ATOM_DTD_FORMAT *dtd_timings;
	int data_index = GetIndexIntoMasterTable(DATA, AnalogTV_Info);
	u8 frev, crev;
	u16 data_offset, misc;

	if (!atom_parse_data_header(mode_info->atom_context, data_index, NULL,
				    &frev, &crev, &data_offset))
		return false;

 	switch (crev) {
 	case 1:
 		tv_info = (ATOM_ANALOG_TV_INFO *)(mode_info->atom_context->bios + data_offset);
		if (index >= MAX_SUPPORTED_TV_TIMING)
 			return false;
 
 		mode->crtc_htotal = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_H_Total);
		mode->crtc_hdisplay = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_H_Disp);
		mode->crtc_hsync_start = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_H_SyncStart);
		mode->crtc_hsync_end = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_H_SyncStart) +
			le16_to_cpu(tv_info->aModeTimings[index].usCRTC_H_SyncWidth);

		mode->crtc_vtotal = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_V_Total);
		mode->crtc_vdisplay = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_V_Disp);
		mode->crtc_vsync_start = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_V_SyncStart);
		mode->crtc_vsync_end = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_V_SyncStart) +
			le16_to_cpu(tv_info->aModeTimings[index].usCRTC_V_SyncWidth);

		mode->flags = 0;
		misc = le16_to_cpu(tv_info->aModeTimings[index].susModeMiscInfo.usAccess);
		if (misc & ATOM_VSYNC_POLARITY)
			mode->flags |= DRM_MODE_FLAG_NVSYNC;
		if (misc & ATOM_HSYNC_POLARITY)
			mode->flags |= DRM_MODE_FLAG_NHSYNC;
		if (misc & ATOM_COMPOSITESYNC)
			mode->flags |= DRM_MODE_FLAG_CSYNC;
		if (misc & ATOM_INTERLACE)
			mode->flags |= DRM_MODE_FLAG_INTERLACE;
		if (misc & ATOM_DOUBLE_CLOCK_MODE)
			mode->flags |= DRM_MODE_FLAG_DBLSCAN;

		mode->clock = le16_to_cpu(tv_info->aModeTimings[index].usPixelClock) * 10;

		if (index == 1) {
			
			mode->crtc_htotal -= 1;
			mode->crtc_vtotal -= 1;
		}
 		break;
 	case 2:
 		tv_info_v1_2 = (ATOM_ANALOG_TV_INFO_V1_2 *)(mode_info->atom_context->bios + data_offset);
		if (index >= MAX_SUPPORTED_TV_TIMING_V1_2)
 			return false;
 
 		dtd_timings = &tv_info_v1_2->aModeTimings[index];
		mode->crtc_htotal = le16_to_cpu(dtd_timings->usHActive) +
			le16_to_cpu(dtd_timings->usHBlanking_Time);
		mode->crtc_hdisplay = le16_to_cpu(dtd_timings->usHActive);
		mode->crtc_hsync_start = le16_to_cpu(dtd_timings->usHActive) +
			le16_to_cpu(dtd_timings->usHSyncOffset);
		mode->crtc_hsync_end = mode->crtc_hsync_start +
			le16_to_cpu(dtd_timings->usHSyncWidth);

		mode->crtc_vtotal = le16_to_cpu(dtd_timings->usVActive) +
			le16_to_cpu(dtd_timings->usVBlanking_Time);
		mode->crtc_vdisplay = le16_to_cpu(dtd_timings->usVActive);
		mode->crtc_vsync_start = le16_to_cpu(dtd_timings->usVActive) +
			le16_to_cpu(dtd_timings->usVSyncOffset);
		mode->crtc_vsync_end = mode->crtc_vsync_start +
			le16_to_cpu(dtd_timings->usVSyncWidth);

		mode->flags = 0;
		misc = le16_to_cpu(dtd_timings->susModeMiscInfo.usAccess);
		if (misc & ATOM_VSYNC_POLARITY)
			mode->flags |= DRM_MODE_FLAG_NVSYNC;
		if (misc & ATOM_HSYNC_POLARITY)
			mode->flags |= DRM_MODE_FLAG_NHSYNC;
		if (misc & ATOM_COMPOSITESYNC)
			mode->flags |= DRM_MODE_FLAG_CSYNC;
		if (misc & ATOM_INTERLACE)
			mode->flags |= DRM_MODE_FLAG_INTERLACE;
		if (misc & ATOM_DOUBLE_CLOCK_MODE)
			mode->flags |= DRM_MODE_FLAG_DBLSCAN;

		mode->clock = le16_to_cpu(dtd_timings->usPixClk) * 10;
		break;
	}
	return true;
}
","1. struct drm_display_mode *mode)
2. struct radeon_mode_info *mode_info = &rdev->mode_info;
ATOM_ANALOG_TV_INFO *tv_info;
ATOM_ANALOG_TV_INFO_V1_2 *tv_info_v1_2;
ATOM_DTD_FORMAT *dtd_timings;
3. u8 frev, crev;
u16 data_offset, misc;
4. if (!atom_parse_data_header(mode_info->atom_context, data_index, NULL,
5. case 1:
tv_info = (ATOM_ANALOG_TV_INFO *)(mode_info->atom_context->bios + data_offset);
if (index >= MAX_SUPPORTED_TV_TIMING)
return false;
6. mode->crtc_htotal = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_H_Total);
mode->crtc_hdisplay = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_H_Disp);
7. mode->crtc_vdisplay = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_V_Disp);
mode->crtc_vsync_start = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_V_SyncStart);
mode->crtc_vsync_end = le16_to_cpu(tv_info->aModeTimings[index].usCRTC_V_SyncStart) +
le16_to_cpu(tv_info->aModeTimings[index].usCRTC_V_SyncWidth);
8. mode->flags = 0;
misc = le16_to_cpu(tv_info->aModeTimings[index].susModeMiscInfo.usAccess);
if (misc & ATOM_VSYNC_POLARITY)
mode->flags |= DRM_MODE_FLAG_NVSYNC;
if (misc & ATOM_HSYNC_POLARITY)
mode->flags |= DRM_MODE_FLAG_NHSYNC;
9. mode->flags |= DRM_MODE_FLAG_CSYNC;
if (misc & ATOM_INTERLACE)
10. if (misc & ATOM_DOUBLE_CLOCK_MODE)
11. if (index == 1) {
12. mode->crtc_htotal -= 1;
mode->crtc_vtotal -= 1;
13. tv_info_v1_2 = (ATOM_ANALOG_TV_INFO_V1_2 *)(mode_info->atom_context->bios + data_offset);
if (index >= MAX_SUPPORTED_TV_TIMING_V1_2)
14. dtd_timings = &tv_info_v1_2->aModeTimings[index];
mode->crtc_htotal = le16_to_cpu(dtd_timings->usHActive) +
15. mode->crtc_hdisplay = le16_to_cpu(dtd_timings->usHActive);
16. le16_to_cpu(dtd_timings->usHSyncOffset);
17. le16_to_cpu(dtd_timings->usHSyncWidth);
18. le16_to_cpu(dtd_timings->usVBlanking_Time);
19. mode->crtc_vsync_start = le16_to_cpu(dtd_timings->usVActive) +
20. mode->crtc_vsync_end = mode->crtc_vsync_start +
le16_to_cpu(dtd_timings->usVSyncWidth);
21. mode->flags = 0;
misc = le16_to_cpu(dtd_timings->susModeMiscInfo.usAccess);
22. mode->flags |= DRM_MODE_FLAG_NVSYNC;
if (misc & ATOM_HSYNC_POLARITY)
23. if (misc & ATOM_COMPOSITESYNC)
mode->flags |= DRM_MODE_FLAG_CSYNC;
if (misc & ATOM_INTERLACE)
24. if (misc & ATOM_DOUBLE_CLOCK_MODE)
mode->flags |= DRM_MODE_FLAG_DBLSCAN;
25. break;","2
4-7
9-10
12
17-20
22-23
29-32
34-39
41-42
44
49
51-52
56-57
60-61
63
65
67
70
72
74-75
77-78
80-81
83-85
87-88
91","CWE-190,CWE-193,CWE-125"
VP8LDecodeImage-45686945295690,"
#define VP8LDecoder

int VP8LDecodeImage(VP8LDecoder* const dec) {
  VP8Io* io = NULL;
  WebPDecParams* params = NULL;

  if (dec == NULL) return 0;

  assert(dec->hdr_.huffman_tables_.root.start != NULL);
  assert(dec->hdr_.htree_groups_ != NULL);
  assert(dec->hdr_.num_htree_groups_ > 0);

  io = dec->io_;
  assert(io != NULL);
  params = (WebPDecParams*)io->opaque;
  assert(params != NULL);

  
  if (dec->state_ != READ_DATA) {
    dec->output_ = params->output;
    assert(dec->output_ != NULL);

    if (!WebPIoInitFromOptions(params->options, io, MODE_BGRA)) {
      VP8LSetError(dec, VP8_STATUS_INVALID_PARAM);
      goto Err;
    }

    if (!AllocateInternalBuffers32b(dec, io->width)) goto Err;

#if !defined(WEBP_REDUCE_SIZE)
    if (io->use_scaling && !AllocateAndInitRescaler(dec, io)) goto Err;
#else
    if (io->use_scaling) {
      VP8LSetError(dec, VP8_STATUS_INVALID_PARAM);
      goto Err;
    }
#endif
    if (io->use_scaling || WebPIsPremultipliedMode(dec->output_->colorspace)) {
      
      WebPInitAlphaProcessing();
    }

    if (!WebPIsRGBMode(dec->output_->colorspace)) {
      WebPInitConvertARGBToYUV();
      if (dec->output_->u.YUVA.a != NULL) WebPInitAlphaProcessing();
    }
    if (dec->incremental_) {
      if (dec->hdr_.color_cache_size_ > 0 &&
          dec->hdr_.saved_color_cache_.colors_ == NULL) {
        if (!VP8LColorCacheInit(&dec->hdr_.saved_color_cache_,
                                dec->hdr_.color_cache_.hash_bits_)) {
          VP8LSetError(dec, VP8_STATUS_OUT_OF_MEMORY);
          goto Err;
        }
      }
    }
    dec->state_ = READ_DATA;
  }

  
  if (!DecodeImageData(dec, dec->pixels_, dec->width_, dec->height_,
                       io->crop_bottom, ProcessRows)) {
    goto Err;
  }

  params->last_y = dec->last_out_row_;
  return 1;

 Err:
  VP8LClear(dec);
  assert(dec->status_ != VP8_STATUS_OK);
  return 0;
}
","1. VP8Io* io = NULL;
2. assert(dec->output_ != NULL);
3. if (!AllocateInternalBuffers32b(dec, io->width)) goto Err;
4. if (io->use_scaling || WebPIsPremultipliedMode(dec->output_->colorspace)) {
5. if (!VP8LColorCacheInit(&dec->hdr_.saved_color_cache_,
6. VP8LSetError(dec, VP8_STATUS_OUT_OF_MEMORY);
7. dec->state_ = READ_DATA;
8. assert(dec->status_ != VP8_STATUS_OK);","5
22
29
39
51
53
58
72","CWE-200,CWE-20,CWE-119,CWE-78"
png_check_chunk_length,"png_check_chunk_length(png_const_structrp png_ptr, const png_uint_32 length)
{
   png_alloc_size_t limit = PNG_UINT_31_MAX;

# ifdef PNG_SET_USER_LIMITS_SUPPORTED
   if (png_ptr->user_chunk_malloc_max > 0 &&
       png_ptr->user_chunk_malloc_max < limit)
      limit = png_ptr->user_chunk_malloc_max;
# elif PNG_USER_CHUNK_MALLOC_MAX > 0
   if (PNG_USER_CHUNK_MALLOC_MAX < limit)
      limit = PNG_USER_CHUNK_MALLOC_MAX;
# endif
   if (png_ptr->chunk_name == png_IDAT)
    {
       png_alloc_size_t idat_limit = PNG_UINT_31_MAX;
       size_t row_factor =
         (size_t)png_ptr->width
         * (size_t)png_ptr->channels
         * (png_ptr->bit_depth > 8? 2: 1)
         + 1
         + (png_ptr->interlaced? 6: 0);
       if (png_ptr->height > PNG_UINT_32_MAX/row_factor)
         idat_limit = PNG_UINT_31_MAX;
       else
          idat_limit = png_ptr->height * row_factor;
       row_factor = row_factor > 32566? 32566 : row_factor;
      idat_limit += 6 + 5*(idat_limit/row_factor+1); 
      idat_limit=idat_limit < PNG_UINT_31_MAX? idat_limit : PNG_UINT_31_MAX;
      limit = limit < idat_limit? idat_limit : limit;
   }

   if (length > limit)
   {
      png_debug2(0,"" length = %lu, limit = %lu"",
         (unsigned long)length,(unsigned long)limit);
      png_chunk_error(png_ptr, ""chunk data is too large"");
   }
}
","1. size_t row_factor =
(size_t)png_ptr->width
* (size_t)png_ptr->channels
2. if (png_ptr->height > PNG_UINT_32_MAX/row_factor)
idat_limit = PNG_UINT_31_MAX;
3. row_factor = row_factor > 32566? 32566 : row_factor;
4. limit = limit < idat_limit? idat_limit : limit;
5. if (length > limit)
6. (unsigned long)length,(unsigned long)limit);","16-18
22-23
26
29
32
35","CWE-190,CWE-200,CWE-125"
kdc_process_s4u2proxy_req-249179667536439,"krb5_error_code
kdc_process_s4u2proxy_req(kdc_realm_t *kdc_active_realm,
                          krb5_kdc_req *request,
                          const krb5_enc_tkt_part *t2enc,
                          const krb5_db_entry *server,
                          krb5_const_principal server_princ,
                          krb5_const_principal proxy_princ,
                          const char **status)
{
    krb5_error_code errcode;

    
    if (request->kdc_options & (NON_TGT_OPTION | KDC_OPT_ENC_TKT_IN_SKEY)) {
        *status = ""INVALID_S4U2PROXY_OPTIONS"";
        return KRB5KDC_ERR_BADOPTION;
    }

    
    if (!krb5_principal_compare(kdc_context,
                                server->princ, 
                                server_princ)) {
        *status = ""EVIDENCE_TICKET_MISMATCH"";
        return KRB5KDC_ERR_SERVER_NOMATCH;
    }

    if (!isflagset(t2enc->flags, TKT_FLG_FORWARDABLE)) {
        *status = ""EVIDENCE_TKT_NOT_FORWARDABLE"";
        return KRB5_TKT_NOT_FORWARDABLE;
    }

    
    errcode = check_allowed_to_delegate_to(kdc_context,
                                           t2enc->client,
                                           server,
                                           proxy_princ);
    if (errcode) {
        *status = ""NOT_ALLOWED_TO_DELEGATE"";
        return errcode;
    }

    return 0;
}
","1. krb5_error_code
kdc_process_s4u2proxy_req(kdc_realm_t *kdc_active_realm,
2. const char **status)
3. server_princ)) {
*status = ""EVIDENCE_TICKET_MISMATCH"";
4. if (!isflagset(t2enc->flags, TKT_FLG_FORWARDABLE)) {
5. return KRB5_TKT_NOT_FORWARDABLE;","1-2
8
25-26
30
32","CWE-617,CWE-295,CWE-330,CWE-416"
add_bwrap_wrapper-86767131500877,"
#define FlatpakBwrap
#define GError

static gboolean
add_bwrap_wrapper (FlatpakBwrap *bwrap,
                   const char   *app_info_path,
                   GError      **error)
{
  glnx_autofd int app_info_fd = -1;
  g_auto(GLnxDirFdIterator) dir_iter = { 0 };
  struct dirent *dent;
  g_autofree char *user_runtime_dir = flatpak_get_real_xdg_runtime_dir ();
  g_autofree char *proxy_socket_dir = g_build_filename (user_runtime_dir, "".dbus-proxy/"", NULL);

  app_info_fd = open (app_info_path, O_RDONLY | O_CLOEXEC);
  if (app_info_fd == -1)
    return glnx_throw_errno_prefix (error, _(""Failed to open app info file""));

  if (!glnx_dirfd_iterator_init_at (AT_FDCWD, ""/"", FALSE, &dir_iter, error))
    return FALSE;

  flatpak_bwrap_add_arg (bwrap, flatpak_get_bwrap ());

  while (TRUE)
    {
      glnx_autofd int o_path_fd = -1;
      struct statfs stfs;

      if (!glnx_dirfd_iterator_next_dent_ensure_dtype (&dir_iter, &dent, NULL, error))
        return FALSE;

      if (dent == NULL)
        break;

      if (strcmp (dent->d_name, "".flatpak-info"") == 0)
        continue;

      
      o_path_fd = openat (dir_iter.fd, dent->d_name, O_PATH | O_NOFOLLOW | O_CLOEXEC);
      if (o_path_fd == -1 || fstatfs (o_path_fd, &stfs) != 0 || stfs.f_type == AUTOFS_SUPER_MAGIC)
        continue; 

      if (dent->d_type == DT_DIR)
        {
          if (strcmp (dent->d_name, ""tmp"") == 0 ||
              strcmp (dent->d_name, ""var"") == 0 ||
              strcmp (dent->d_name, ""run"") == 0)
            flatpak_bwrap_add_arg (bwrap, ""--bind"");
          else
            flatpak_bwrap_add_arg (bwrap, ""--ro-bind"");

          flatpak_bwrap_add_arg_printf (bwrap, ""/%s"", dent->d_name);
          flatpak_bwrap_add_arg_printf (bwrap, ""/%s"", dent->d_name);
        }
      else if (dent->d_type == DT_LNK)
        {
          g_autofree gchar *target = NULL;

          target = glnx_readlinkat_malloc (dir_iter.fd, dent->d_name,
                                           NULL, error);
          if (target == NULL)
            return FALSE;
          flatpak_bwrap_add_args (bwrap, ""--symlink"", target, NULL);
          flatpak_bwrap_add_arg_printf (bwrap, ""/%s"", dent->d_name);
        }
    }

  flatpak_bwrap_add_args (bwrap, ""--bind"", proxy_socket_dir, proxy_socket_dir, NULL);

  
  flatpak_bwrap_add_args (bwrap, ""--perms"", ""0600"", NULL);
  flatpak_bwrap_add_args_data_fd (bwrap, ""--file"", g_steal_fd (&app_info_fd), ""/.flatpak-info"");

  if (!flatpak_bwrap_bundle_args (bwrap, 1, -1, FALSE, error))
    return FALSE;

  
  flatpak_bwrap_add_arg (bwrap, ""--"");

  return TRUE;
}
","1. static gboolean
2. break;
3. flatpak_bwrap_add_arg (bwrap, ""--bind"");","5
34
49","CWE-264,CWE-787,CWE-399"
x25_recvmsg-120228788815363,"static int x25_recvmsg(struct kiocb *iocb, struct socket *sock,
		       struct msghdr *msg, size_t size,
		       int flags)
{
	struct sock *sk = sock->sk;
	struct x25_sock *x25 = x25_sk(sk);
	struct sockaddr_x25 *sx25 = (struct sockaddr_x25 *)msg->msg_name;
	size_t copied;
	int qbit, header_len;
	struct sk_buff *skb;
	unsigned char *asmptr;
	int rc = -ENOTCONN;

	lock_sock(sk);

	if (x25->neighbour == NULL)
		goto out;

	header_len = x25->neighbour->extended ?
		X25_EXT_MIN_LEN : X25_STD_MIN_LEN;

	
	if (sk->sk_state != TCP_ESTABLISHED)
		goto out;

	if (flags & MSG_OOB) {
		rc = -EINVAL;
		if (sock_flag(sk, SOCK_URGINLINE) ||
		    !skb_peek(&x25->interrupt_in_queue))
			goto out;

		skb = skb_dequeue(&x25->interrupt_in_queue);

		if (!pskb_may_pull(skb, X25_STD_MIN_LEN))
			goto out_free_dgram;

		skb_pull(skb, X25_STD_MIN_LEN);

		
		if (test_bit(X25_Q_BIT_FLAG, &x25->flags)) {
			asmptr  = skb_push(skb, 1);
			*asmptr = 0x00;
		}

		msg->msg_flags |= MSG_OOB;
	} else {
		
		release_sock(sk);
		skb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,
					flags & MSG_DONTWAIT, &rc);
		lock_sock(sk);
		if (!skb)
			goto out;

		if (!pskb_may_pull(skb, header_len))
			goto out_free_dgram;

		qbit = (skb->data[0] & X25_Q_BIT) == X25_Q_BIT;

		skb_pull(skb, header_len);

		if (test_bit(X25_Q_BIT_FLAG, &x25->flags)) {
			asmptr  = skb_push(skb, 1);
			*asmptr = qbit;
		}
	}

	skb_reset_transport_header(skb);
	copied = skb->len;

	if (copied > size) {
		copied = size;
		msg->msg_flags |= MSG_TRUNC;
	}

	
	msg->msg_flags |= MSG_EOR;

	rc = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);
	if (rc)
		goto out_free_dgram;

	if (sx25) {
		sx25->sx25_family = AF_X25;
		sx25->sx25_addr   = x25->dest_addr;
		msg->msg_namelen = sizeof(*sx25);
	}

	x25_check_rbuf(sk);
	rc = copied;
out_free_dgram:
	skb_free_datagram(sk, skb);
out:
	release_sock(sk);
	return rc;
}
","1. if (sk->sk_state != TCP_ESTABLISHED)
2. if (sock_flag(sk, SOCK_URGINLINE) ||
3. msg->msg_flags |= MSG_OOB;
4. copied = size;
5. rc = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);
6. out:","26
31
50
77
84
98","CWE-20,CWE-17"
parseNormalModeParameters-20082652406361,"
#define IsoPresentation

static int
parseNormalModeParameters(IsoPresentation* self, uint8_t* buffer, int totalLength, int bufPos)
{
    int endPos = bufPos + totalLength;

    self->calledPresentationSelector.size = 0;
    self->callingPresentationSelector.size = 0;

    bool hasUserData = false;

    while (bufPos < endPos) {
        uint8_t tag = buffer[bufPos++];
        int len;

        if (bufPos == endPos) {
            if (DEBUG_PRES)
                printf(""PRES: invalid message\n"");
            return -1;
        }

        bufPos = BerDecoder_decodeLength(buffer, &len, bufPos, endPos);

        if (bufPos < 0) {
            if (DEBUG_PRES)
                printf(""PRES: wrong parameter length\n"");
            return -1;
        }

        switch (tag) {
        case 0x81: 

            if (len > 16) {
                if (DEBUG_PRES)
                    printf(""PRES: calling-presentation-sel too large\n"");
            }
            else {
                self->callingPresentationSelector.size = len;
                int i;
                for (i = 0; i < len; i++)
                    self->callingPresentationSelector.value[i] = buffer[bufPos + i];
            }

            bufPos += len;
            break;

        case 0x82: 

            if (len > 16) {
                if (DEBUG_PRES)
                    printf(""PRES: called-presentation-sel too large\n"");
            }
            else {
                self->calledPresentationSelector.size = len;
                int i;
                for (i = 0; i < len; i++)
                    self->calledPresentationSelector.value[i] = buffer[bufPos + i];
            }

            bufPos += len;
            break;

        case 0x83: 

            if (len > 16) {
                if (DEBUG_PRES)
                    printf(""PRES: responding-presentation-sel too large\n"");
            }

            bufPos += len;
            break;

        case 0xa4: 
            if (DEBUG_PRES)
                printf(""PRES: pcd list\n"");
            bufPos = parsePresentationContextDefinitionList(self, buffer, len, bufPos);

            if (bufPos < 0)
                return -1;

            break;

        case 0xa5: 

            bufPos += len;
            break;

        case 0x61: 
            if (DEBUG_PRES)
                printf(""PRES: user-data\n"");

            bufPos = parseFullyEncodedData(self, buffer, len, bufPos);

            if (bufPos < 0)
                return -1;

            if (self->nextPayload.size > 0)
                hasUserData = true;

            break;

        case 0x00: 
            break;

        default:
            if (DEBUG_PRES)
                printf(""PRES: unknown tag in normal-mode\n"");
            bufPos += len;
            break;
        }
    }

    if (hasUserData == false) {
        if (DEBUG_PRES)
            printf(""PRES: user-data is missing\n"");

        return -1;
    }

    return bufPos;
}
","1. bufPos = parsePresentationContextDefinitionList(self, buffer, len, bufPos);
2. break;
3. break;
4. printf(""PRES: user-data is missing\n"");
5. return bufPos;","78
102
105
117
122","CWE-120,CWE-323,CWE-189,CWE-119,CWE-399"
find_high_bit-121747025803987,"static int find_high_bit(unsigned int x)
{
	int i;
	for(i=31;i>=0;i--) {
		if(x&(1U<<(unsigned int)i)) return i;
	}
	return 0;
}
","1. static int find_high_bit(unsigned int x)
2. int i;
3. if(x&(1U<<(unsigned int)i)) return i;","1
3
5","CWE-476,CWE-190,CWE-682"
CatalogueRescan,"
#define FontPathElementPtr

CatalogueRescan (FontPathElementPtr fpe)
{
    CataloguePtr	cat = fpe->private;
    char		link[MAXFONTFILENAMELEN];
    char		dest[MAXFONTFILENAMELEN];
    char		*attrib;
    FontPathElementPtr	subfpe;
    struct stat		statbuf;
    const char		*path;
    DIR			*dir;
    struct dirent	*entry;
    int			len;
    int			pathlen;

    path = fpe->name + strlen(CataloguePrefix);
    if (stat(path, &statbuf) < 0 || !S_ISDIR(statbuf.st_mode))
	return BadFontPath;

    if (statbuf.st_mtime <= cat->mtime)
	return Successful;

    dir = opendir(path);
    if (dir == NULL)
    {
	xfree(cat);
	return BadFontPath;
    }

    CatalogueUnrefFPEs (fpe);
     while (entry = readdir(dir), entry != NULL)
     {
 	snprintf(link, sizeof link, ""%s/%s"", path, entry->d_name);
	len = readlink(link, dest, sizeof dest - 1);
 	if (len < 0)
 	    continue;
	dest[len] = '\0';

	if (dest[0] != '/')
	{
	   pathlen = strlen(path);
	   memmove(dest + pathlen + 1, dest, sizeof dest - pathlen - 1);
	   memcpy(dest, path, pathlen);
	   memcpy(dest + pathlen, ""/"", 1);
	   len += pathlen + 1;
	}

	attrib = strchr(link, ':');
	if (attrib && len + strlen(attrib) < sizeof dest)
	{
	    memcpy(dest + len, attrib, strlen(attrib));
	    len += strlen(attrib);
	}

	subfpe = xalloc(sizeof *subfpe);
	if (subfpe == NULL)
	    continue;

	
	subfpe->type = fpe->type;
	subfpe->name_length = len;
	subfpe->name = xalloc (len + 1);
	if (subfpe == NULL)
	{
	    xfree(subfpe);
	    continue;
	}

	memcpy(subfpe->name, dest, len);
	subfpe->name[len] = '\0';

	
	subfpe->refcount = 1;

	if (FontFileInitFPE (subfpe) != Successful)
	{
	    xfree(subfpe->name);
	    xfree(subfpe);
	    continue;
	}

	if (CatalogueAddFPE(cat, subfpe) != Successful)
	{
	    FontFileFreeFPE (subfpe);
	    xfree(subfpe);
	    continue;
	}
    }

    closedir(dir);

    qsort(cat->fpeList,
	  cat->fpeCount, sizeof cat->fpeList[0], ComparePriority);

    cat->mtime = statbuf.st_mtime;

    return Successful;
}
","1. CatalogueRescan (FontPathElementPtr fpe)
2. char		link[MAXFONTFILENAMELEN];
3. len += strlen(attrib);
4. subfpe = xalloc(sizeof *subfpe);
if (subfpe == NULL)
continue;
5. subfpe->name_length = len;
6. cat->fpeCount, sizeof cat->fpeList[0], ComparePriority);","4
7
54
57-59
66
100","CWE-20,CWE-264,CWE-787,CWE-119"
WritePSDChannel_2,"
#define Image
#define ImageInfo
#define MagickBooleanType
#define MagickOffsetType
#define PSDInfo
#define QuantumType

static size_t WritePSDChannel_2(const PSDInfo *psd_info,
  const ImageInfo *image_info,Image *image,Image *next_image,
  const QuantumType quantum_type, unsigned char *compact_pixels,
  MagickOffsetType size_offset,const MagickBooleanType separate)
{
  int
    y;

  MagickBooleanType
    monochrome;

  QuantumInfo
    *quantum_info;

  register const PixelPacket
    *p;

  register ssize_t
    i;

  size_t
    count,
    length;

  unsigned char
    *pixels;

#ifdef MAGICKCORE_ZLIB_DELEGATE

#define CHUNK 16384

  int
    flush,
    level;

  unsigned char
    *compressed_pixels;

  z_stream
    stream;

  compressed_pixels=(unsigned char *) NULL;
  flush=Z_NO_FLUSH;
#endif
  count=0;
  if (separate != MagickFalse)
    {
      size_offset=TellBlob(image)+2;
      count+=WriteCompressionStart(psd_info,image,next_image,1);
    }
  if (next_image->depth > 8)
     next_image->depth=16;
   monochrome=IsMonochromeImage(image,&image->exception) && (image->depth == 1)
     ? MagickTrue : MagickFalse;
  quantum_info=AcquireQuantumInfo(image_info,next_image);
   if (quantum_info == (QuantumInfo *) NULL)
     return(0);
   pixels=GetQuantumPixels(quantum_info);
#ifdef MAGICKCORE_ZLIB_DELEGATE
  if (next_image->compression == ZipCompression)
    {
      compressed_pixels=(unsigned char *) AcquireQuantumMemory(CHUNK,
        sizeof(*compressed_pixels));
      if (compressed_pixels == (unsigned char *) NULL)
        {
          quantum_info=DestroyQuantumInfo(quantum_info);
          return(0);
        }
      ResetMagickMemory(&stream,0,sizeof(stream));
      stream.data_type=Z_BINARY;
      level=Z_DEFAULT_COMPRESSION;
      if ((image_info->quality > 0 && image_info->quality < 10))
        level=(int) image_info->quality;
      if (deflateInit(&stream,level) != Z_OK)
        {
          quantum_info=DestroyQuantumInfo(quantum_info);
          return(0);
        }
    }
#endif
  for (y=0; y < (ssize_t) next_image->rows; y++)
  {
    p=GetVirtualPixels(next_image,0,y,next_image->columns,1,&image->exception);
    if (p == (const PixelPacket *) NULL)
      break;
    length=ExportQuantumPixels(next_image,(CacheView *) NULL,quantum_info,
      quantum_type,pixels,&image->exception);
    if (monochrome != MagickFalse)
      for (i=0; i < (ssize_t) length; i++)
        pixels[i]=(~pixels[i]);
    if (next_image->compression == RLECompression)
      {
        length=PSDPackbitsEncodeImage(image,length,pixels,compact_pixels);
        count+=WriteBlob(image,length,compact_pixels);
        size_offset+=WritePSDOffset(psd_info,image,length,size_offset);
      }
#ifdef MAGICKCORE_ZLIB_DELEGATE
    else if (next_image->compression == ZipCompression)
      {
        stream.avail_in=(uInt) length;
        stream.next_in=(Bytef *) pixels;
        if (y == (ssize_t) next_image->rows-1)
          flush=Z_FINISH;
        do {
            stream.avail_out=(uInt) CHUNK;
            stream.next_out=(Bytef *) compressed_pixels;
            if (deflate(&stream,flush) == Z_STREAM_ERROR)
              break;
            length=(size_t) CHUNK-stream.avail_out;
            if (length > 0)
              count+=WriteBlob(image,length,compressed_pixels);
        } while (stream.avail_out == 0);
      }
#endif
    else
      count+=WriteBlob(image,length,pixels);
  }
#ifdef MAGICKCORE_ZLIB_DELEGATE
  if (next_image->compression == ZipCompression)
    {
      (void) deflateEnd(&stream);
      compressed_pixels=(unsigned char *) RelinquishMagickMemory(
        compressed_pixels);
    }
#endif
  quantum_info=DestroyQuantumInfo(quantum_info);
  return(count);
}
","1. const QuantumType quantum_type, unsigned char *compact_pixels,
2. monochrome;
3. *quantum_info;
4. *p;
5. count,
6. if (quantum_info == (QuantumInfo *) NULL)
7. if (p == (const PixelPacket *) NULL)
break;
8. if (next_image->compression == RLECompression)
9. count+=WriteBlob(image,length,compact_pixels);
10. return(count);","11
18
21
24
30
64
92-93
99
102
135","CWE-20,CWE-787,CWE-823"
is_link_trusted-205587796701261,"
#define NautilusFile

static gboolean
is_link_trusted (NautilusFile *file,
                 gboolean      is_launcher)
{
    GFile *location;
    gboolean res;
    g_autofree gchar* trusted = NULL;

    if (!is_launcher)
    {
        return TRUE;
    }

    trusted = nautilus_file_get_metadata (file,
                                          NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED,
                                          NULL);
    if (nautilus_file_can_execute (file) && trusted != NULL)
    {
        return TRUE;
    }

    res = FALSE;

    if (nautilus_file_is_local (file))
    {
        location = nautilus_file_get_location (file);
        res = nautilus_is_in_system_dir (location);
        g_object_unref (location);
    }

    return res;
}
","1. static gboolean
is_link_trusted (NautilusFile *file,
2. gboolean res;
g_autofree gchar* trusted = NULL;
3. return TRUE;
4. NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED,
NULL);
if (nautilus_file_can_execute (file) && trusted != NULL)
5. return TRUE;
6. location = nautilus_file_get_location (file);
res = nautilus_is_in_system_dir (location);
7. return res;","4-5
9-10
14
18-20
22
29-30
34","CWE-20,CWE-189,CWE-416,CWE-200,CWE-125"
PHP_METHOD_19,"
#define Phar

PHP_METHOD_19(Phar, offsetSet)
{
	char *fname, *cont_str = NULL;
	size_t fname_len, cont_len;
	zval *zresource;
	PHAR_ARCHIVE_OBJECT();

	if (PHAR_G(readonly) && !phar_obj->archive->is_data) {
		zend_throw_exception_ex(spl_ce_BadMethodCallException, 0, ""Write operations disabled by the php.ini setting phar.readonly"");
                return;
        }
 
       if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, ZEND_NUM_ARGS(), ""pr"", &fname, &fname_len, &zresource) == FAILURE
       && zend_parse_parameters(ZEND_NUM_ARGS(), ""ps"", &fname, &fname_len, &cont_str, &cont_len) == FAILURE) {
                return;
        }
 
	if (fname_len == sizeof("".phar/stub.php"")-1 && !memcmp(fname, "".phar/stub.php"", sizeof("".phar/stub.php"")-1)) {
		zend_throw_exception_ex(spl_ce_BadMethodCallException, 0, ""Cannot set stub \"".phar/stub.php\"" directly in phar \""%s\"", use setStub"", phar_obj->archive->fname);
		return;
	}

	if (fname_len == sizeof("".phar/alias.txt"")-1 && !memcmp(fname, "".phar/alias.txt"", sizeof("".phar/alias.txt"")-1)) {
		zend_throw_exception_ex(spl_ce_BadMethodCallException, 0, ""Cannot set alias \"".phar/alias.txt\"" directly in phar \""%s\"", use setAlias"", phar_obj->archive->fname);
		return;
	}

	if (fname_len >= sizeof("".phar"")-1 && !memcmp(fname, "".phar"", sizeof("".phar"")-1)) {
		zend_throw_exception_ex(spl_ce_BadMethodCallException, 0, ""Cannot set any files or directories in magic \"".phar\"" directory"", phar_obj->archive->fname);
		return;
	}

	phar_add_file(&(phar_obj->archive), fname, fname_len, cont_str, cont_len, zresource);
}
","1. char *fname, *cont_str = NULL;
2. zval *zresource;
3. if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, ZEND_NUM_ARGS(), ""pr"", &fname, &fname_len, &zresource) == FAILURE
&& zend_parse_parameters(ZEND_NUM_ARGS(), ""ps"", &fname, &fname_len, &cont_str, &cont_len) == FAILURE) {
4. if (fname_len == sizeof("".phar/stub.php"")-1 && !memcmp(fname, "".phar/stub.php"", sizeof("".phar/stub.php"")-1)) {
5. zend_throw_exception_ex(spl_ce_BadMethodCallException, 0, ""Cannot set any files or directories in magic \"".phar\"" directory"", phar_obj->archive->fname);
6. phar_add_file(&(phar_obj->archive), fname, fname_len, cont_str, cont_len, zresource);","6
8
16-17
21
32
36","CWE-20,CWE-264,CWE-416,CWE-400,CWE-399"
raptor_turtle_writer_set_option-176217820409042,"int
raptor_turtle_writer_set_option(raptor_turtle_writer *turtle_writer, 
                                 raptor_option option, int value)
{
  if(value < 0 ||
     !raptor_option_is_valid_for_area(option, RAPTOR_OPTION_AREA_TURTLE_WRITER))
    return 1;
  
  switch(option) {
    case RAPTOR_OPTION_WRITER_AUTO_INDENT:
      if(value)
        turtle_writer->flags |= TURTLE_WRITER_AUTO_INDENT;
      else
        turtle_writer->flags &= ~TURTLE_WRITER_AUTO_INDENT;        
      break;

    case RAPTOR_OPTION_WRITER_INDENT_WIDTH:
      turtle_writer->indent = value;
      break;
    
    case RAPTOR_OPTION_WRITER_AUTO_EMPTY:
    case RAPTOR_OPTION_WRITER_XML_VERSION:
    case RAPTOR_OPTION_WRITER_XML_DECLARATION:
      break;
        
    
    case RAPTOR_OPTION_SCANNING:
    case RAPTOR_OPTION_ALLOW_NON_NS_ATTRIBUTES:
    case RAPTOR_OPTION_ALLOW_OTHER_PARSETYPES:
    case RAPTOR_OPTION_ALLOW_BAGID:
    case RAPTOR_OPTION_ALLOW_RDF_TYPE_RDF_LIST:
    case RAPTOR_OPTION_NORMALIZE_LANGUAGE:
    case RAPTOR_OPTION_NON_NFC_FATAL:
    case RAPTOR_OPTION_WARN_OTHER_PARSETYPES:
    case RAPTOR_OPTION_CHECK_RDF_ID:
    case RAPTOR_OPTION_HTML_TAG_SOUP:
    case RAPTOR_OPTION_MICROFORMATS:
    case RAPTOR_OPTION_HTML_LINK:
    case RAPTOR_OPTION_WWW_TIMEOUT:
    case RAPTOR_OPTION_STRICT:
      
    
    case RAPTOR_OPTION_NO_NET:
    case RAPTOR_OPTION_NO_FILE:
    case RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES:

    
    case RAPTOR_OPTION_RELATIVE_URIS:

    
    case RAPTOR_OPTION_RESOURCE_BORDER:
    case RAPTOR_OPTION_LITERAL_BORDER:
    case RAPTOR_OPTION_BNODE_BORDER:
    case RAPTOR_OPTION_RESOURCE_FILL:
    case RAPTOR_OPTION_LITERAL_FILL:
    case RAPTOR_OPTION_BNODE_FILL:

    
    case RAPTOR_OPTION_JSON_CALLBACK:
    case RAPTOR_OPTION_JSON_EXTRA_DATA:
    case RAPTOR_OPTION_RSS_TRIPLES:
    case RAPTOR_OPTION_ATOM_ENTRY_URI:
    case RAPTOR_OPTION_PREFIX_ELEMENTS:
    
    
    case RAPTOR_OPTION_WRITE_BASE_URI:

    
    case RAPTOR_OPTION_WWW_HTTP_CACHE_CONTROL:
    case RAPTOR_OPTION_WWW_HTTP_USER_AGENT:
    case RAPTOR_OPTION_WWW_CERT_FILENAME:
    case RAPTOR_OPTION_WWW_CERT_TYPE:
    case RAPTOR_OPTION_WWW_CERT_PASSPHRASE:
    case RAPTOR_OPTION_WWW_SSL_VERIFY_PEER:
    case RAPTOR_OPTION_WWW_SSL_VERIFY_HOST:
      
    default:
      return -1;
      break;
  }

  return 0;
}
",1. if(value),11,"CWE-200,CWE-264,CWE-611"
ohci_bus_start," static int ohci_bus_start(OHCIState *ohci)
 {
     trace_usb_ohci_start(ohci->name);
 
     /* Delay the first SOF event by one frame time as

    if (ohci->eof_timer == NULL) {
        trace_usb_ohci_bus_eof_timer_failed(ohci->name);
        ohci_die(ohci);
        return 0;
    }

    trace_usb_ohci_start(ohci->name);

    /* Delay the first SOF event by one frame time as
 static void ohci_bus_stop(OHCIState *ohci)
 {
     trace_usb_ohci_stop(ohci->name);
    timer_del(ohci->eof_timer);
 }
 
 /* Sets a flag in a port status register but only set it if the port is
}
",1. static int ohci_bus_start(OHCIState *ohci),1,"CWE-20,CWE-400,CWE-399,CWE-416"
r_bin_mdmp_init_directory_entry,"static bool r_bin_mdmp_init_directory_entry(struct r_bin_mdmp_obj *obj, struct minidump_directory *entry) {
	int i;

	struct minidump_handle_operation_list *handle_operation_list;
	struct minidump_memory_list *memory_list;
	struct minidump_memory64_list *memory64_list;
	struct minidump_memory_info_list *memory_info_list;
	struct minidump_module_list *module_list;
	struct minidump_thread_list *thread_list;
	struct minidump_thread_ex_list *thread_ex_list;
	struct minidump_thread_info_list *thread_info_list;
	struct minidump_unloaded_module_list *unloaded_module_list;

	struct avrf_handle_operation *handle_operations;
	struct minidump_memory_descriptor *memories;
	struct minidump_memory_descriptor64 *memories64;
	struct minidump_memory_info *memory_infos;
	struct minidump_module *modules;
	struct minidump_thread *threads;
	struct minidump_thread_ex *ex_threads;
	struct minidump_thread_info *thread_infos;
	struct minidump_unloaded_module *unloaded_modules;

 	
 	if (entry->location.rva + entry->location.data_size > obj->b->length) {
		eprintf (""[ERROR] Size Mismatch - Stream data is larger than file size!\n"");
 		return false;
 	}
 
	switch (entry->stream_type) {
	case THREAD_LIST_STREAM:
		thread_list = (struct minidump_thread_list *)(obj->b->buf + entry->location.rva);

		sdb_set (obj->kv, ""mdmp_thread.format"", ""ddddq?? ""
			""ThreadId SuspendCount PriorityClass Priority ""
			""Teb (mdmp_memory_descriptor)Stack ""
			""(mdmp_location_descriptor)ThreadContext"", 0);
		sdb_num_set (obj->kv, ""mdmp_thread_list.offset"",
			entry->location.rva, 0);
		sdb_set (obj->kv, ""mdmp_thread_list.format"",
			sdb_fmt (""d[%i]? ""
				""NumberOfThreads (mdmp_thread)Threads"",
				thread_list->number_of_threads),
			0);

		
		for (i = 0; i < thread_list->number_of_threads; i++) {
			threads = (struct minidump_thread *)(&(thread_list->threads));
			r_list_append (obj->streams.threads, &(threads[i]));
		}
		break;
	case MODULE_LIST_STREAM:
		module_list = (struct minidump_module_list *)(obj->b->buf + entry->location.rva);

		sdb_set (obj->kv, ""mdmp_module.format"", ""qddtd???qq ""
			""BaseOfImage SizeOfImage CheckSum ""
			""TimeDateStamp ModuleNameRVA ""
			""(mdmp_vs_fixedfileinfo)VersionInfo ""
			""(mdmp_location_descriptor)CvRecord ""
			""(mdmp_location_descriptor)MiscRecord ""
			""Reserved0 Reserved1"", 0);
		sdb_num_set (obj->kv, ""mdmp_module_list.offset"",
			entry->location.rva, 0);
		sdb_set (obj->kv, ""mdmp_module_list.format"",
			sdb_fmt (""d[%i]? ""
				""NumberOfModule (mdmp_module)Modules"",
				module_list->number_of_modules,
				0),
			0);

		for (i = 0; i < module_list->number_of_modules; i++) {
			modules = (struct minidump_module *)(&(module_list->modules));
			r_list_append(obj->streams.modules, &(modules[i]));
		}
		break;
	case MEMORY_LIST_STREAM:
		memory_list = (struct minidump_memory_list *)(obj->b->buf + entry->location.rva);

		sdb_num_set (obj->kv, ""mdmp_memory_list.offset"",
			entry->location.rva, 0);
		sdb_set (obj->kv, ""mdmp_memory_list.format"",
			sdb_fmt (""d[%i]? ""
				""NumberOfMemoryRanges ""
				""(mdmp_memory_descriptor)MemoryRanges "",
				memory_list->number_of_memory_ranges,
				0),
			0);

		for (i = 0; i < memory_list->number_of_memory_ranges; i++) {
			memories = (struct minidump_memory_descriptor *)(&(memory_list->memory_ranges));
			r_list_append (obj->streams.memories, &(memories[i]));
		}
		break;
	case EXCEPTION_STREAM:
		
		obj->streams.exception = (struct minidump_exception_stream *)(obj->b->buf + entry->location.rva);

		sdb_set (obj->kv, ""mdmp_exception.format"", ""[4]E[4]Eqqdd[15]q ""
			""(mdmp_exception_code)ExceptionCode ""
			""(mdmp_exception_flags)ExceptionFlags ""
			""ExceptionRecord ExceptionAddress ""
			""NumberParameters __UnusedAlignment ""
			""ExceptionInformation"", 0);
		sdb_num_set (obj->kv, ""mdmp_exception_stream.offset"",
			entry->location.rva, 0);
		sdb_set (obj->kv, ""mdmp_exception_stream.format"", ""dd?? ""
			""ThreadId __Alignment ""
			""(mdmp_exception)ExceptionRecord ""
			""(mdmp_location_descriptor)ThreadContext"", 0);

		break;
	case SYSTEM_INFO_STREAM:
		obj->streams.system_info = (struct minidump_system_info *)(obj->b->buf + entry->location.rva);

		sdb_num_set (obj->kv, ""mdmp_system_info.offset"",
			entry->location.rva, 0);
		
		sdb_set (obj->kv, ""mdmp_system_info.format"", ""[2]EwwbBddd[4]Ed[2]Ew[2]q ""
			""(mdmp_processor_architecture)ProcessorArchitecture ""
			""ProcessorLevel ProcessorRevision NumberOfProcessors ""
			""(mdmp_product_type)ProductType ""
			""MajorVersion MinorVersion BuildNumber (mdmp_platform_id)PlatformId ""
			""CsdVersionRva (mdmp_suite_mask)SuiteMask Reserved2 ProcessorFeatures"", 0);

		break;
	case THREAD_EX_LIST_STREAM:
		
		thread_ex_list = (struct minidump_thread_ex_list *)(obj->b->buf + entry->location.rva);

		sdb_set (obj->kv, ""mdmp_thread_ex.format"", ""ddddq??? ""
			""ThreadId SuspendCount PriorityClass Priority ""
			""Teb (mdmp_memory_descriptor)Stack ""
			""(mdmp_location_descriptor)ThreadContext ""
			""(mdmp_memory_descriptor)BackingStore"", 0);
		sdb_num_set (obj->kv, ""mdmp_thread_ex_list.offset"",
			entry->location.rva, 0);
		sdb_set (obj->kv, ""mdmp_thread_ex_list.format"",
			sdb_fmt (""d[%i]? NumberOfThreads ""
				""(mdmp_thread_ex)Threads"",
				thread_ex_list->number_of_threads, 0),
			0);

		for (i = 0; i < thread_ex_list->number_of_threads; i++) {
			ex_threads = (struct minidump_thread_ex *)(&(thread_ex_list->threads));
			r_list_append (obj->streams.ex_threads, &(ex_threads[i]));
		}
		break;
	case MEMORY_64_LIST_STREAM:
		memory64_list = (struct minidump_memory64_list *)(obj->b->buf + entry->location.rva);

		sdb_num_set (obj->kv, ""mdmp_memory64_list.offset"",
			entry->location.rva, 0);
		sdb_set (obj->kv, ""mdmp_memory64_list.format"",
			sdb_fmt (""qq[%i]? NumberOfMemoryRanges ""
				""BaseRva ""
				""(mdmp_memory_descriptor64)MemoryRanges"",
				memory64_list->number_of_memory_ranges),
			0);

		obj->streams.memories64.base_rva = memory64_list->base_rva;
		for (i = 0; i < memory64_list->number_of_memory_ranges; i++) {
			memories64 = (struct minidump_memory_descriptor64 *)(&(memory64_list->memory_ranges));
			r_list_append (obj->streams.memories64.memories, &(memories64[i]));
		}
		break;
	case COMMENT_STREAM_A:
		
		obj->streams.comments_a = obj->b->buf + entry->location.rva;

		sdb_num_set (obj->kv, ""mdmp_comment_stream_a.offset"",
			entry->location.rva, 0);
		sdb_set (obj->kv, ""mdmp_comment_stream_a.format"",
			""s CommentA"", 0);

		break;
	case COMMENT_STREAM_W:
		
		obj->streams.comments_w = obj->b->buf + entry->location.rva;

		sdb_num_set (obj->kv, ""mdmp_comment_stream_w.offset"",
			entry->location.rva, 0);
		sdb_set (obj->kv, ""mdmp_comment_stream_w.format"",
				""s CommentW"", 0);

		break;
	case HANDLE_DATA_STREAM:
		
		obj->streams.handle_data = (struct minidump_handle_data_stream *)(obj->b->buf + entry->location.rva);

		sdb_num_set (obj->kv, ""mdmp_handle_data_stream.offset"",
				entry->location.rva, 0);
		sdb_set (obj->kv, ""mdmp_handle_data_stream.format"", ""dddd ""
				""SizeOfHeader SizeOfDescriptor ""
				""NumberOfDescriptors Reserved"", 0);
		break;
	case FUNCTION_TABLE_STREAM:
		
		obj->streams.function_table = (struct minidump_function_table_stream *)(obj->b->buf + entry->location.rva);

		sdb_num_set (obj->kv, ""mdmp_function_table_stream.offset"",
			entry->location.rva, 0);
		sdb_set (obj->kv, ""mdmp_function_table_stream.format"", ""dddddd ""
			""SizeOfHeader SizeOfDescriptor SizeOfNativeDescriptor ""
			""SizeOfFunctionEntry NumberOfDescriptors SizeOfAlignPad"",
			0);
		break;
	case UNLOADED_MODULE_LIST_STREAM:
		
		unloaded_module_list = (struct minidump_unloaded_module_list *)(obj->b->buf + entry->location.rva);

		sdb_set (obj->kv, ""mdmp_unloaded_module.format"", ""qddtd ""
			""BaseOfImage SizeOfImage CheckSum TimeDateStamp ""
			""ModuleNameRva"", 0);
		sdb_num_set (obj->kv, ""mdmp_unloaded_module_list.offset"",
			entry->location.rva, 0);
		sdb_set (obj->kv, ""mdmp_unloaded_module_list.format"", ""ddd ""
			""SizeOfHeader SizeOfEntry NumberOfEntries"", 0);

		for (i = 0; i < unloaded_module_list->number_of_entries; i++) {
			unloaded_modules = (struct minidump_unloaded_module *)((ut8 *)&unloaded_module_list + sizeof (struct minidump_unloaded_module_list));
			r_list_append (obj->streams.unloaded_modules, &(unloaded_modules[i]));
		}
		break;
	case MISC_INFO_STREAM:
		
		obj->streams.misc_info.misc_info_1 = (struct minidump_misc_info *)(obj->b->buf + entry->location.rva);

		
		sdb_num_set (obj->kv, ""mdmp_misc_info.offset"",
			entry->location.rva, 0);
		sdb_set (obj->kv, ""mdmp_misc_info.format"", ""d[4]Bdtttddddd ""
			""SizeOfInfo (mdmp_misc1_flags)Flags1 ProcessId ""
			""ProcessCreateTime ProcessUserTime ProcessKernelTime ""
			""ProcessorMaxMhz ProcessorCurrentMhz ""
			""ProcessorMhzLimit ProcessorMaxIdleState ""
			""ProcessorCurrentIdleState"", 0);

		break;
	case MEMORY_INFO_LIST_STREAM:
		memory_info_list = (struct minidump_memory_info_list *)(obj->b->buf + entry->location.rva);

		sdb_set (obj->kv, ""mdmp_memory_info.format"",
			""qq[4]Edq[4]E[4]E[4]Ed BaseAddress AllocationBase ""
			""(mdmp_page_protect)AllocationProtect __Alignment1 RegionSize ""
			""(mdmp_mem_state)State (mdmp_page_protect)Protect ""
			""(mdmp_mem_type)Type __Alignment2"", 0);
		sdb_num_set (obj->kv, ""mdmp_memory_info_list.offset"",
			entry->location.rva, 0);
		sdb_set (obj->kv, ""mdmp_memory_info_list.format"",
			sdb_fmt (""ddq[%i]? SizeOfHeader SizeOfEntry ""
				""NumberOfEntries (mdmp_memory_info)MemoryInfo"",
				memory_info_list->number_of_entries),
			0);

		for (i = 0; i < memory_info_list->number_of_entries; i++) {
			memory_infos = (struct minidump_memory_info *)((ut8 *)memory_info_list + sizeof (struct minidump_memory_info_list));
			r_list_append (obj->streams.memory_infos, &(memory_infos[i]));
		}
		break;
	case THREAD_INFO_LIST_STREAM:
		
		thread_info_list = (struct minidump_thread_info_list *)(obj->b->buf + entry->location.rva);

		sdb_set (obj->kv, ""mdmp_thread_info.format"", ""ddddttttqq ""
			""ThreadId DumpFlags DumpError ExitStatus CreateTime ""
			""ExitTime KernelTime UserTime StartAddress Affinity"",
			0);
		sdb_num_set (obj->kv, ""mdmp_thread_info_list.offset"",
				entry->location.rva, 0);
		sdb_set (obj->kv, ""mdmp_thread_info_list.format"", ""ddd ""
			""SizeOfHeader SizeOfEntry NumberOfEntries"", 0);

		for (i = 0; i < thread_info_list->number_of_entries; i++) {
			thread_infos = (struct minidump_thread_info *)((ut8 *)thread_info_list + sizeof (struct minidump_thread_info_list));
			r_list_append (obj->streams.thread_infos, &(thread_infos[i]));
		}
		break;
	case HANDLE_OPERATION_LIST_STREAM:
		
		handle_operation_list = (struct minidump_handle_operation_list *)(obj->b->buf + entry->location.rva);

		sdb_num_set (obj->kv, ""mdmp_handle_operation_list.offset"",
			entry->location.rva, 0);
		sdb_set (obj->kv, ""mdmp_handle_operation_list.format"", ""dddd ""
			""SizeOfHeader SizeOfEntry NumberOfEntries Reserved"", 0);

		for (i = 0; i < handle_operation_list->number_of_entries; i++) {
			handle_operations = (struct avrf_handle_operation *)((ut8 *)handle_operation_list + sizeof (struct minidump_handle_operation_list));
			r_list_append (obj->streams.operations, &(handle_operations[i]));
		}

		break;
	case LAST_RESERVED_STREAM:
		
		break;
	case UNUSED_STREAM:
	case RESERVED_STREAM_0:
	case RESERVED_STREAM_1:
		
		break;
	default:
		eprintf (""[WARN] Invalid or unsupported enumeration encountered %i\n"", entry->stream_type);
		return false;
	}
	return true;
}
","1. module_list = (struct minidump_module_list *)(obj->b->buf + entry->location.rva);
2. case HANDLE_DATA_STREAM:
3. memory_info_list->number_of_entries),
4. break;","54
187
253
260","CWE-125,CWE-59,CWE-119"
vrrp_print_stats-115282773106749,"void
vrrp_print_stats(void)
{
	FILE *file = fopen_safe(stats_file, ""w"");
	element e;
	vrrp_t *vrrp;

	if (!file) {
		log_message(LOG_INFO, ""Can't open %s (%d: %s)"",
			stats_file, errno, strerror(errno));
		return;
	}


	LIST_FOREACH(vrrp_data->vrrp, vrrp, e) {
		fprintf(file, ""VRRP Instance: %s\n"", vrrp->iname);
		fprintf(file, ""  Advertisements:\n"");
		fprintf(file, ""    Received: %"" PRIu64 ""\n"", vrrp->stats->advert_rcvd);
		fprintf(file, ""    Sent: %d\n"", vrrp->stats->advert_sent);
		fprintf(file, ""  Became master: %d\n"", vrrp->stats->become_master);
		fprintf(file, ""  Released master: %d\n"", vrrp->stats->release_master);
		fprintf(file, ""  Packet Errors:\n"");
		fprintf(file, ""    Length: %"" PRIu64 ""\n"", vrrp->stats->packet_len_err);
		fprintf(file, ""    TTL: %"" PRIu64 ""\n"", vrrp->stats->ip_ttl_err);
		fprintf(file, ""    Invalid Type: %"" PRIu64 ""\n"",
			vrrp->stats->invalid_type_rcvd);
		fprintf(file, ""    Advertisement Interval: %"" PRIu64 ""\n"",
			vrrp->stats->advert_interval_err);
		fprintf(file, ""    Address List: %"" PRIu64 ""\n"",
			vrrp->stats->addr_list_err);
		fprintf(file, ""  Authentication Errors:\n"");
		fprintf(file, ""    Invalid Type: %d\n"",
			vrrp->stats->invalid_authtype);
#ifdef _WITH_VRRP_AUTH_
		fprintf(file, ""    Type Mismatch: %d\n"",
			vrrp->stats->authtype_mismatch);
		fprintf(file, ""    Failure: %d\n"",
			vrrp->stats->auth_failure);
#endif
		fprintf(file, ""  Priority Zero:\n"");
		fprintf(file, ""    Received: %"" PRIu64 ""\n"", vrrp->stats->pri_zero_rcvd);
		fprintf(file, ""    Sent: %"" PRIu64 ""\n"", vrrp->stats->pri_zero_sent);
	}
	fclose(file);
}
","1. void
vrrp_print_stats(void)
2. FILE *file = fopen_safe(stats_file, ""w"");
element e;
vrrp_t *vrrp;
3. if (!file) {
log_message(LOG_INFO, ""Can't open %s (%d: %s)"",
stats_file, errno, strerror(errno));
return;
4. fprintf(file, ""  Advertisements:\n"");
5. fprintf(file, ""    Sent: %d\n"", vrrp->stats->advert_sent);
fprintf(file, ""  Became master: %d\n"", vrrp->stats->become_master);
6. fprintf(file, ""  Packet Errors:\n"");
7. fprintf(file, ""  Authentication Errors:\n"");
fprintf(file, ""    Invalid Type: %d\n"",
8. fprintf(file, ""  Priority Zero:\n"");","1-2
4-6
8-11
17
19-20
22
31-32
40","CWE-190,CWE-129,CWE-125,CWE-59"
gf_bifs_dec_sf_field-132329290846609,"
#define Bool
#define GF_BifsDecoder
#define GF_BitStream
#define GF_FieldInfo
#define GF_Node

GF_Err gf_bifs_dec_sf_field(GF_BifsDecoder * codec, GF_BitStream *bs, GF_Node *node, GF_FieldInfo *field, Bool is_mem_com)
{
	GF_Err e;
	GF_Node *new_node;
	u32 size, length, w, h, i;
	char *buffer;

	
	if (codec->ActiveQP && node) {
		e = gf_bifs_dec_unquant_field(codec, bs, node, field);
		if (e != GF_EOS) return e;
	}
	
	switch (field->fieldType) {
	case GF_SG_VRML_SFBOOL:
		* ((SFBool *) field->far_ptr) = (SFBool) gf_bs_read_int(bs, 1);
		break;
	case GF_SG_VRML_SFCOLOR:
		((SFColor *)field->far_ptr)->red = BD_ReadSFFloat(codec, bs);
		((SFColor *)field->far_ptr)->green = BD_ReadSFFloat(codec, bs);
		((SFColor *)field->far_ptr)->blue = BD_ReadSFFloat(codec, bs);
		break;
	case GF_SG_VRML_SFFLOAT:
		*((SFFloat *)field->far_ptr) = BD_ReadSFFloat(codec, bs);
		break;
	case GF_SG_VRML_SFINT32:
		*((SFInt32 *)field->far_ptr) = (s32) gf_bs_read_int(bs, 32);
		break;
	case GF_SG_VRML_SFTIME:
		*((SFTime *)field->far_ptr) = gf_bs_read_double(bs);
		if (node) BD_CheckSFTimeOffset(codec, node, field);
		break;
	case GF_SG_VRML_SFVEC2F:
		((SFVec2f *)field->far_ptr)->x = BD_ReadSFFloat(codec, bs);
		((SFVec2f *)field->far_ptr)->y = BD_ReadSFFloat(codec, bs);
		break;
	case GF_SG_VRML_SFVEC3F:
		((SFVec3f *)field->far_ptr)->x = BD_ReadSFFloat(codec, bs);
		((SFVec3f *)field->far_ptr)->y = BD_ReadSFFloat(codec, bs);
		((SFVec3f *)field->far_ptr)->z = BD_ReadSFFloat(codec, bs);
		break;
	case GF_SG_VRML_SFROTATION:
		((SFRotation *)field->far_ptr)->x = BD_ReadSFFloat(codec, bs);
		((SFRotation *)field->far_ptr)->y = BD_ReadSFFloat(codec, bs);
		((SFRotation *)field->far_ptr)->z = BD_ReadSFFloat(codec, bs);
		((SFRotation *)field->far_ptr)->q = BD_ReadSFFloat(codec, bs);
		break;
	case GF_SG_VRML_SFSTRING:
		size = gf_bs_read_int(bs, 5);
		length = gf_bs_read_int(bs, size);
		if (gf_bs_available(bs) < length) return GF_NON_COMPLIANT_BITSTREAM;

		if (node && (node->sgprivate->tag==TAG_MPEG4_CacheTexture) && (field->fieldIndex<=2)) {
			M_CacheTexture *ct = (M_CacheTexture *) node;
			ct->data_len = length;
			if (ct->data) gf_free(ct->data);
			ct->data = (u8*)gf_malloc(sizeof(char)*length);
			gf_bs_read_data(bs, (char*)ct->data, length);
		} else if (node && (node->sgprivate->tag==TAG_MPEG4_BitWrapper) ) {
			M_BitWrapper *bw = (M_BitWrapper*) node;
			if (bw->buffer.buffer) gf_free(bw->buffer.buffer);
			bw->buffer_len = length;
			bw->buffer.buffer = (char*)gf_malloc(sizeof(char)*length);
			gf_bs_read_data(bs, (char*)bw->buffer.buffer, length);
		} else {
			if ( ((SFString *)field->far_ptr)->buffer ) gf_free( ((SFString *)field->far_ptr)->buffer);
			((SFString *)field->far_ptr)->buffer = (char *)gf_malloc(sizeof(char)*(length+1));
			memset(((SFString *)field->far_ptr)->buffer , 0, length+1);
			for (i=0; i<length; i++) {
				((SFString *)field->far_ptr)->buffer[i] = gf_bs_read_int(bs, 8);
			}
		}
		break;
	case GF_SG_VRML_SFURL:
	{
		SFURL *url = (SFURL *) field->far_ptr;
		size = gf_bs_read_int(bs, 1);
		if (size) {
			if (url->url) gf_free(url->url );
			url->url = NULL;
			length = gf_bs_read_int(bs, 10);
			url->OD_ID = length;
		} else {
			if ( url->OD_ID ) url->OD_ID = (u32) -1;
			size = gf_bs_read_int(bs, 5);
			length = gf_bs_read_int(bs, size);
			if (gf_bs_available(bs) < length) return GF_NON_COMPLIANT_BITSTREAM;
			buffer = NULL;
			if (length) {
				buffer = (char *)gf_malloc(sizeof(char)*(length+1));
				memset(buffer, 0, length+1);
				for (i=0; i<length; i++) buffer[i] = gf_bs_read_int(bs, 8);
			}
			if (url->url) gf_free( url->url);
			
			if (buffer && strlen(buffer)) {
				url->url = buffer;
			} else {
				gf_free(buffer);
				url->url = NULL;
			}
		}
	}
	break;
	case GF_SG_VRML_SFIMAGE:
		if (((SFImage *)field->far_ptr)->pixels) {
			gf_free(((SFImage *)field->far_ptr)->pixels);
			((SFImage *)field->far_ptr)->pixels = NULL;
		}
		w = gf_bs_read_int(bs, 12);
		h = gf_bs_read_int(bs, 12);
		length = gf_bs_read_int(bs, 2);

		if (length > 3) length = 3;
		length += 1;
		size = w * h * length;
		if (gf_bs_available(bs) < size) return GF_NON_COMPLIANT_BITSTREAM;
		((SFImage *)field->far_ptr)->width = w;
		((SFImage *)field->far_ptr)->height = h;
		((SFImage *)field->far_ptr)->numComponents = length;
		((SFImage *)field->far_ptr)->pixels = (unsigned char *)gf_malloc(sizeof(char)*size);
		
		for (i=0; i<size; i++) {
			((SFImage *)field->far_ptr)->pixels[i] = gf_bs_read_int(bs, 8);
		}
		break;
	case GF_SG_VRML_SFCOMMANDBUFFER:
	{
		SFCommandBuffer *sfcb = (SFCommandBuffer *)field->far_ptr;
		if (!node) return GF_BAD_PARAM;
		if (sfcb->buffer) {
			gf_free(sfcb->buffer);
			sfcb->buffer = NULL;
			sfcb->bufferSize = 0;
		}
		while (gf_list_count(sfcb->commandList)) {
			GF_Command *com = (GF_Command*)gf_list_get(sfcb->commandList, 0);
			gf_list_rem(sfcb->commandList, 0);
			gf_sg_command_del(com);
		}

		size = gf_bs_read_int(bs, 5);
		length = gf_bs_read_int(bs, size);
		if (gf_bs_available(bs) < length) return GF_NON_COMPLIANT_BITSTREAM;

		sfcb->bufferSize = length;
		if (length) {
			sfcb->buffer = (unsigned char *)gf_malloc(sizeof(char)*(length));
			
			for (i=0; i<length; i++) {
				sfcb->buffer[i] = gf_bs_read_int(bs, 8);
			}
		}
		
		
		SFCommandBufferChanged(codec, node);

		
		if (codec->dec_memory_mode || (node->sgprivate->tag==TAG_MPEG4_InputSensor)) {
			CommandBufferItem *cbi = (CommandBufferItem *)gf_malloc(sizeof(CommandBufferItem));
			cbi->node = node;
			gf_node_register(cbi->node, NULL);
			cbi->cb = sfcb;
			gf_list_add(codec->command_buffers, cbi);
		}
	}
	break;
	case GF_SG_VRML_SFNODE:
		
		
		if (!is_mem_com) {
			GF_Node *old_node = *((GF_Node **) field->far_ptr);
			if (old_node != NULL) {
				u32 i, count = gf_list_count(codec->command_buffers);
				for (i=0; i<count; i++) {
					CommandBufferItem *cbi = (CommandBufferItem*) gf_list_get(codec->command_buffers, i);
					if (cbi->node == old_node) {
						gf_list_rem(codec->command_buffers, i);
						i--;
						count--;
						gf_node_unregister(cbi->node, NULL);
						gf_free(cbi);
					}
				}
				gf_node_unregister(old_node, node);
				 *((GF_Node **) field->far_ptr) = NULL;
			}
		}
		
		new_node = gf_bifs_dec_node(codec, bs, field->NDTtype);
		if (new_node) {
			e = gf_node_register(new_node, is_mem_com ? NULL : node);
			if (e) return e;
		}
		
		*((GF_Node **) field->far_ptr) = new_node;
		break;
	case GF_SG_VRML_SFSCRIPT:
#ifdef GPAC_HAS_QJS
		codec->LastError = node ? SFScript_Parse(codec, (SFScript*)field->far_ptr, bs, node) : GF_NON_COMPLIANT_BITSTREAM;
#else
		return GF_NOT_SUPPORTED;
#endif
		break;
	case GF_SG_VRML_SFATTRREF:
	{
		SFAttrRef *ar = (SFAttrRef *)field->far_ptr;
		u32 nodeID = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits);
		ar->node = gf_sg_find_node(codec->current_graph, nodeID);
		if (!ar->node) {

		} else {
			u32 nbBitsDEF = gf_get_bit_size(gf_node_get_num_fields_in_mode(ar->node, GF_SG_FIELD_CODING_DEF) - 1);
			u32 field_ref = gf_bs_read_int(bs, nbBitsDEF);
			codec->LastError = gf_bifs_get_field_index(ar->node, field_ref, GF_SG_FIELD_CODING_DEF, &ar->fieldIndex);
		}
	}
	break;
	default:
		return GF_NON_COMPLIANT_BITSTREAM;
	}
	return codec->LastError;
}
","1. u32 size, length, w, h, i;
2. case GF_SG_VRML_SFBOOL:
3. ((SFColor *)field->far_ptr)->red = BD_ReadSFFloat(codec, bs);
4. case GF_SG_VRML_SFVEC3F:
5. gf_bs_read_data(bs, (char*)ct->data, length);
} else if (node && (node->sgprivate->tag==TAG_MPEG4_BitWrapper) ) {
6. size = gf_bs_read_int(bs, 1);
if (size) {
7. if (gf_bs_available(bs) < length) return GF_NON_COMPLIANT_BITSTREAM;
8. if (((SFImage *)field->far_ptr)->pixels) {
9. ((SFImage *)field->far_ptr)->numComponents = length;
10. sfcb->buffer = NULL;
11. GF_Node *old_node = *((GF_Node **) field->far_ptr);
12. case GF_SG_VRML_SFSCRIPT:","12
22
26
44
65-66
84-85
94
113
127
140
182
208","CWE-125,CWE-19,CWE-119"
recvauth_common-280279505318393,"static krb5_error_code
recvauth_common(krb5_context context,
                krb5_auth_context * auth_context,
                
                krb5_pointer fd,
                char *appl_version,
                krb5_principal server,
                krb5_int32 flags,
                krb5_keytab keytab,
                
                krb5_ticket ** ticket,
                krb5_data *version)
{
    krb5_auth_context     new_auth_context;
    krb5_flags            ap_option = 0;
    krb5_error_code       retval, problem;
    krb5_data             inbuf;
    krb5_data             outbuf;
    krb5_rcache           rcache = 0;
    krb5_octet            response;
    krb5_data             null_server;
    krb5_data             d;
    int                   need_error_free = 0;
    int                   local_rcache = 0, local_authcon = 0;

    
    problem = 0;
    response = 0;

    if (!(flags & KRB5_RECVAUTH_SKIP_VERSION)) {
        
        if ((retval = krb5_read_message(context, fd, &inbuf)))
            return(retval);
        d = make_data((char *)sendauth_version, strlen(sendauth_version) + 1);
        if (!data_eq(inbuf, d)) {
            problem = KRB5_SENDAUTH_BADAUTHVERS;
            response = 1;
        }
        free(inbuf.data);
    }
    if (flags & KRB5_RECVAUTH_BADAUTHVERS) {
        problem = KRB5_SENDAUTH_BADAUTHVERS;
        response = 1;
    }

    
    if ((retval = krb5_read_message(context, fd, &inbuf)))
        return(retval);
    if (appl_version != NULL && !problem) {
        d = make_data(appl_version, strlen(appl_version) + 1);
        if (!data_eq(inbuf, d)) {
            problem = KRB5_SENDAUTH_BADAPPLVERS;
            response = 2;
        }
    }
    if (version && !problem)
        *version = inbuf;
    else
        free(inbuf.data);

    
    if ((krb5_net_write(context, *((int *)fd), (char *)&response, 1)) < 0) {
        return(problem); 
    }
    if (problem)
        return(problem);

    

    
    if ((retval = krb5_read_message(context, fd, &inbuf)))
        return retval;

    if (*auth_context == NULL) {
        problem = krb5_auth_con_init(context, &new_auth_context);
        *auth_context = new_auth_context;
        local_authcon = 1;
    }
    krb5_auth_con_getrcache(context, *auth_context, &rcache);
    if ((!problem) && rcache == NULL) {
        
        if (server != NULL && server->length > 0) {
            problem = krb5_get_server_rcache(context, &server->data[0],
                                             &rcache);
        } else {
            null_server.length = 7;
            null_server.data = ""default"";
            problem = krb5_get_server_rcache(context, &null_server, &rcache);
        }
        if (!problem)
            problem = krb5_auth_con_setrcache(context, *auth_context, rcache);
        local_rcache = 1;
    }
    if (!problem) {
        problem = krb5_rd_req(context, auth_context, &inbuf, server,
                              keytab, &ap_option, ticket);
        free(inbuf.data);
    }

    
    if (problem) {
        krb5_error      error;
        const   char *message;

        memset(&error, 0, sizeof(error));
        krb5_us_timeofday(context, &error.stime, &error.susec);
        if(server)
            error.server = server;
        else {
            
            (void) krb5_parse_name(context, ""????"", &error.server);
            need_error_free = 1;
        }

        error.error = problem - ERROR_TABLE_BASE_krb5;
        if (error.error > 127)
            error.error = KRB_ERR_GENERIC;
        message = error_message(problem);
        error.text.length  = strlen(message) + 1;
        error.text.data = strdup(message);
        if (!error.text.data) {
            retval = ENOMEM;
            goto cleanup;
        }
        if ((retval = krb5_mk_error(context, &error, &outbuf))) {
            free(error.text.data);
            goto cleanup;
        }
        free(error.text.data);
        if(need_error_free)
            krb5_free_principal(context, error.server);

    } else {
        outbuf.length = 0;
        outbuf.data = 0;
    }

    retval = krb5_write_message(context, fd, &outbuf);
    if (outbuf.data) {
        free(outbuf.data);
        
        retval = problem;
        goto cleanup;
    }
    if (retval)
        goto cleanup;

    
    if ((ap_option & AP_OPTS_MUTUAL_REQUIRED)) {
        if ((retval = krb5_mk_rep(context, *auth_context, &outbuf))) {
            return(retval);
        }
        retval = krb5_write_message(context, fd, &outbuf);
        free(outbuf.data);
    }

cleanup:;
    if (retval) {
        if (local_authcon) {
            krb5_auth_con_free(context, *auth_context);
        } else if (local_rcache && rcache != NULL) {
            krb5_rc_close(context, rcache);
            krb5_auth_con_setrcache(context, *auth_context, NULL);
        }
    }
    return retval;
}
","1. static krb5_error_code
recvauth_common(krb5_context context,
2. krb5_principal server,
krb5_int32 flags,
3. krb5_data *version)
4. krb5_auth_context     new_auth_context;
5. krb5_data             inbuf;
krb5_data             outbuf;
6. int                   need_error_free = 0;
7. if ((retval = krb5_read_message(context, fd, &inbuf)))
return(retval);
8. response = 1;
9. response = 2;
10. *version = inbuf;
11. free(inbuf.data);
12. if ((krb5_net_write(context, *((int *)fd), (char *)&response, 1)) < 0) {
return(problem);
13. if ((retval = krb5_read_message(context, fd, &inbuf)))
return retval;
14. } else {
15. keytab, &ap_option, ticket);
16. krb5_error      error;
17. krb5_us_timeofday(context, &error.stime, &error.susec);
18. error.server = server;
else {
19. error.text.data = strdup(message);
20. goto cleanup;
21. krb5_free_principal(context, error.server);
22. outbuf.data = 0;
23. retval = krb5_write_message(context, fd, &outbuf);
24. if (retval)
25. free(outbuf.data);
26. cleanup:;","1-2
7-8
12
14
17-18
23
39-40
44
62
66
68
74-75
85-86
101
112
122
126
128-129
141
144
152
156
159
166
175
178","CWE-20,CWE-362,CWE-770,CWE-416,CWE-200"
r_bin_ne_get_entrypoints-69288632292209,"RList *r_bin_ne_get_entrypoints(r_bin_ne_obj_t *bin) {
	RList *entries = r_list_newf (free);
	if (!entries) {
		return NULL;
	}
	RBinAddr *entry;
	RList *segments = r_bin_ne_get_segments (bin);
	if (!segments) {
		r_list_free (entries);
		return NULL;
	}
	if (bin->ne_header->csEntryPoint) {
		entry = R_NEW0 (RBinAddr);
		if (!entry) {
			r_list_free (entries);
			return NULL;
		}
		entry->bits = 16;
		RBinSection *s = r_list_get_n (segments, bin->ne_header->csEntryPoint - 1);
		entry->paddr = bin->ne_header->ipEntryPoint + (s? s->paddr: 0);
		r_list_append (entries, entry);
	}
	int off = 0;
	while (off < bin->ne_header->EntryTableLength) {
		if (bin->entry_table + off + 32 >= r_buf_size (bin->buf)) {
			break;
		}
		ut8 bundle_length = *(ut8 *)(bin->entry_table + off);
		if (!bundle_length) {
			break;
		}
		off++;
		ut8 bundle_type = *(ut8 *)(bin->entry_table + off);
		off++;
		int i;
		for (i = 0; i < bundle_length; i++) {
			entry = R_NEW0 (RBinAddr);
			if (!entry) {
				r_list_free (entries);
				return NULL;
			}
			off++;
			if (!bundle_type) { 
				off--;
				free (entry);
				break;
			} else if (bundle_type == 0xFF) { 
				off += 2;
				ut8 segnum = *(bin->entry_table + off);
				off++;
				ut16 segoff = *(ut16 *)(bin->entry_table + off);
				if (segnum > 0) {
					entry->paddr = (ut64)bin->segment_entries[segnum - 1].offset * bin->alignment + segoff;
				}
			} else { 
				entry->paddr = (ut64)bin->segment_entries[bundle_type - 1].offset * bin->alignment + *(ut16 *)(bin->entry_table + off);
			}
			off += 2;
			r_list_append (entries, entry);
		}
	}
	r_list_free (segments);
	bin->entries = entries;
	return entries;
}
","1. if (!entry) {
2. r_list_free (entries);","14
39","CWE-119,CWE-125,CWE-399,CWE-415"
r_cons_hud_string-145996415541468,"R_API char *r_cons_hud_string(const char *s) {
	if (!r_cons_is_interactive ()) {
		R_LOG_ERROR (""Hud mode requires scr.interactive=true"");
		return NULL;
	}
	char *os, *track, *ret, *o = strdup (s);
	if (!o) {
		return NULL;
	}
	r_str_ansi_strip (o);
	r_str_replace_ch (o, '\r', 0, true);
	r_str_replace_ch (o, '\t', 0, true);
	RList *fl = r_list_new ();
	int i;
	if (!fl) {
		free (o);
		return NULL;
	}
	fl->free = free;
	for (os = o, i = 0; o[i]; i++) {
		if (o[i] == '\n') {
			o[i] = 0;
			if (*os && *os != '#') {
				track = strdup (os);
				if (!r_list_append (fl, track)) {
					free (track);
					break;
				}
			}
			os = o + i + 1;
		}
	}
	ret = r_cons_hud (fl, NULL);
	free (o);
	r_list_free (fl);
	return ret;
}
","1. RList *fl = r_list_new ();
2. free (track);
break;
3. free (o);","13
26-27
34","CWE-119,CWE-772,CWE-22,CWE-400"
ras_validate-202438889914345,"int ras_validate(jas_stream_t *in)
{
	jas_uchar buf[RAS_MAGICLEN];
	int i;
	int n;
	uint_fast32_t magic;

	assert(JAS_STREAM_MAXPUTBACK >= RAS_MAGICLEN);

	
	if ((n = jas_stream_read(in, buf, RAS_MAGICLEN)) < 0) {
		return -1;
	}

	
	for (i = n - 1; i >= 0; --i) {
		if (jas_stream_ungetc(in, buf[i]) == EOF) {
			return -1;
		}
	}

	
	if (n < RAS_MAGICLEN) {
		return -1;
	}

	magic = (JAS_CAST(uint_fast32_t, buf[0]) << 24) |
	  (JAS_CAST(uint_fast32_t, buf[1]) << 16) |
	  (JAS_CAST(uint_fast32_t, buf[2]) << 8) |
	  buf[3];

	
	if (magic != RAS_MAGIC) {
		return -1;
	}
	return 0;
}
","1. jas_uchar buf[RAS_MAGICLEN];
2. int n;
3. return -1;
4. return -1;","3
5
20
36","CWE-190,CWE-20"
iwch_l2t_send,"static int iwch_l2t_send(struct t3cdev *tdev, struct sk_buff *skb, struct l2t_entry *l2e)
{
	int	error = 0;
	struct cxio_rdev *rdev;

	rdev = (struct cxio_rdev *)tdev->ulp;
	if (cxio_fatal_error(rdev)) {
		kfree_skb(skb);
		return -EIO;
	}
 	error = l2t_send(tdev, skb, l2e);
 	if (error < 0)
 		kfree_skb(skb);
	return error < 0 ? error : 0;
 }
","1. static int iwch_l2t_send(struct t3cdev *tdev, struct sk_buff *skb, struct l2t_entry *l2e)
2. int	error = 0;
3. rdev = (struct cxio_rdev *)tdev->ulp;
4. kfree_skb(skb);
5. return error < 0 ? error : 0;","1
3
6
8
14","CWE-119,CWE-264,CWE-399,CWE-189"
print_bpf_insn-219668604273828,"static void print_bpf_insn(const struct bpf_verifier_env *env,
			   const struct bpf_insn *insn)
{
	u8 class = BPF_CLASS(insn->code);

	if (class == BPF_ALU || class == BPF_ALU64) {
		if (BPF_SRC(insn->code) == BPF_X)
			verbose(""(%02x) %sr%d %s %sr%d\n"",
				insn->code, class == BPF_ALU ? ""(u32) "" : """",
				insn->dst_reg,
				bpf_alu_string[BPF_OP(insn->code) >> 4],
				class == BPF_ALU ? ""(u32) "" : """",
				insn->src_reg);
		else
			verbose(""(%02x) %sr%d %s %s%d\n"",
				insn->code, class == BPF_ALU ? ""(u32) "" : """",
				insn->dst_reg,
				bpf_alu_string[BPF_OP(insn->code) >> 4],
				class == BPF_ALU ? ""(u32) "" : """",
				insn->imm);
	} else if (class == BPF_STX) {
		if (BPF_MODE(insn->code) == BPF_MEM)
			verbose(""(%02x) *(%s *)(r%d %+d) = r%d\n"",
				insn->code,
				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
				insn->dst_reg,
				insn->off, insn->src_reg);
		else if (BPF_MODE(insn->code) == BPF_XADD)
			verbose(""(%02x) lock *(%s *)(r%d %+d) += r%d\n"",
				insn->code,
				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
				insn->dst_reg, insn->off,
				insn->src_reg);
		else
			verbose(""BUG_%02x\n"", insn->code);
	} else if (class == BPF_ST) {
		if (BPF_MODE(insn->code) != BPF_MEM) {
			verbose(""BUG_st_%02x\n"", insn->code);
			return;
		}
		verbose(""(%02x) *(%s *)(r%d %+d) = %d\n"",
			insn->code,
			bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
			insn->dst_reg,
			insn->off, insn->imm);
	} else if (class == BPF_LDX) {
		if (BPF_MODE(insn->code) != BPF_MEM) {
			verbose(""BUG_ldx_%02x\n"", insn->code);
			return;
		}
		verbose(""(%02x) r%d = *(%s *)(r%d %+d)\n"",
			insn->code, insn->dst_reg,
			bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
			insn->src_reg, insn->off);
	} else if (class == BPF_LD) {
		if (BPF_MODE(insn->code) == BPF_ABS) {
			verbose(""(%02x) r0 = *(%s *)skb[%d]\n"",
				insn->code,
				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
				insn->imm);
		} else if (BPF_MODE(insn->code) == BPF_IND) {
			verbose(""(%02x) r0 = *(%s *)skb[r%d + %d]\n"",
				insn->code,
				bpf_ldst_string[BPF_SIZE(insn->code) >> 3],
				insn->src_reg, insn->imm);
		} else if (BPF_MODE(insn->code) == BPF_IMM &&
			   BPF_SIZE(insn->code) == BPF_DW) {
			
			u64 imm = ((u64)(insn + 1)->imm << 32) | (u32)insn->imm;
			bool map_ptr = insn->src_reg == BPF_PSEUDO_MAP_FD;

			if (map_ptr && !env->allow_ptr_leaks)
				imm = 0;

			verbose(""(%02x) r%d = 0x%llx\n"", insn->code,
				insn->dst_reg, (unsigned long long)imm);
		} else {
			verbose(""BUG_ld_%02x\n"", insn->code);
			return;
		}
	} else if (class == BPF_JMP) {
		u8 opcode = BPF_OP(insn->code);

		if (opcode == BPF_CALL) {
			verbose(""(%02x) call %s#%d\n"", insn->code,
				func_id_name(insn->imm), insn->imm);
		} else if (insn->code == (BPF_JMP | BPF_JA)) {
			verbose(""(%02x) goto pc%+d\n"",
				insn->code, insn->off);
		} else if (insn->code == (BPF_JMP | BPF_EXIT)) {
			verbose(""(%02x) exit\n"", insn->code);
		} else if (BPF_SRC(insn->code) == BPF_X) {
			verbose(""(%02x) if r%d %s r%d goto pc%+d\n"",
				insn->code, insn->dst_reg,
				bpf_jmp_string[BPF_OP(insn->code) >> 4],
				insn->src_reg, insn->off);
		} else {
			verbose(""(%02x) if r%d %s 0x%x goto pc%+d\n"",
				insn->code, insn->dst_reg,
				bpf_jmp_string[BPF_OP(insn->code) >> 4],
				insn->imm, insn->off);
		}
	} else {
		verbose(""(%02x) %s\n"", insn->code, bpf_class_string[class]);
	}
}
","1. } else if (class == BPF_STX) {
2. verbose(""(%02x) r%d = *(%s *)(r%d %+d)\n"",
insn->code, insn->dst_reg,
3. insn->code, insn->dst_reg,","21
51-52
96","CWE-287,CWE-787,CWE-399,CWE-400"
njs_object_iterate_reverse-13954147737595,"njs_int_t
njs_object_iterate_reverse(njs_vm_t *vm, njs_iterator_args_t *args,
    njs_iterator_handler_t handler)
{
    double              idx;
    int64_t             i, from, to, length;
    njs_int_t           ret;
    njs_array_t         *array, *keys;
    njs_value_t         *entry, *value, prop, character, string_obj;
    const u_char        *p, *end, *pos;
    njs_string_prop_t   string_prop;
    njs_object_value_t  *object;

    value = args->value;
    from = args->from;
    to = args->to;

    if (njs_is_array(value)) {
        array = njs_array(value);

        from += 1;

        while (from-- > to) {
            if (njs_slow_path(!array->object.fast_array)) {
                goto process_object;
            }

            if (njs_fast_path(from < array->length
                              && njs_is_valid(&array->start[from])))
            {
                ret = handler(vm, args, &array->start[from], from);

            } else {
                entry = njs_value_arg(&njs_value_invalid);
                ret = njs_value_property_i64(vm, value, from, &prop);
                if (njs_slow_path(ret != NJS_DECLINED)) {
                    if (ret == NJS_ERROR) {
                        return NJS_ERROR;
                    }

                    entry = &prop;
                }

                ret = handler(vm, args, entry, from);
            }

            if (njs_slow_path(ret != NJS_OK)) {
                if (ret == NJS_DONE) {
                    return NJS_DONE;
                }

                return NJS_ERROR;
            }
        }

        return NJS_OK;
    }

    if (njs_is_string(value) || njs_is_object_string(value)) {

        if (njs_is_string(value)) {
            object = njs_object_value_alloc(vm, NJS_OBJ_TYPE_STRING, 0, value);
            if (njs_slow_path(object == NULL)) {
                return NJS_ERROR;
            }

            njs_set_object_value(&string_obj, object);

            args->value = &string_obj;
        }
        else {
            value = njs_object_value(value);
        }

        length = njs_string_prop(&string_prop, value);
        end = string_prop.start + string_prop.size;

        if ((size_t) length == string_prop.size) {
            

            p = string_prop.start + from;

            i = from + 1;

            while (i-- > to) {
                
                (void) njs_string_new(vm, &character, p, 1, 1);

                ret = handler(vm, args, &character, i);
                if (njs_slow_path(ret != NJS_OK)) {
                    if (ret == NJS_DONE) {
                        return NJS_DONE;
                    }

                    return NJS_ERROR;
                }

                p--;
            }

        } else {
            

            p = NULL;
            i = from + 1;

            if (i > to) {
                p = njs_string_offset(string_prop.start, end, from);
                p = njs_utf8_next(p, end);
            }

            while (i-- > to) {
                pos = njs_utf8_prev(p);

                
                (void) njs_string_new(vm, &character, pos, p - pos , 1);

                ret = handler(vm, args, &character, i);
                if (njs_slow_path(ret != NJS_OK)) {
                    if (ret == NJS_DONE) {
                        return NJS_DONE;
                    }

                    return NJS_ERROR;
                }

                p = pos;
            }
        }

        return NJS_OK;
    }

    if (!njs_is_object(value)) {
        return NJS_OK;
    }

process_object:

    if (!njs_fast_object(from - to)) {
        keys = njs_array_indices(vm, value);
        if (njs_slow_path(keys == NULL)) {
            return NJS_ERROR;
        }

        i = keys->length;

        while (i > 0) {
            idx = njs_string_to_index(&keys->start[--i]);

            if (idx < to || idx > from) {
                continue;
            }

            ret = njs_iterator_object_handler(vm, handler, args,
                                              &keys->start[i], idx);
            if (njs_slow_path(ret != NJS_OK)) {
                njs_array_destroy(vm, keys);
                return ret;
            }
        }

        njs_array_destroy(vm, keys);

        return NJS_OK;
    }

    i = from + 1;

    while (i-- > to) {
        ret = njs_iterator_object_handler(vm, handler, args, NULL, i);
        if (njs_slow_path(ret != NJS_OK)) {
            return ret;
        }
    }

    return NJS_OK;
}
","1. const u_char        *p, *end, *pos;
2. from += 1;
3. while (from-- > to) {
4. ret = handler(vm, args, &array->start[from], from);
5. if (ret == NJS_ERROR) {
6. ret = handler(vm, args, entry, from);
7. if (ret == NJS_DONE) {
8. if (njs_is_string(value) || njs_is_object_string(value)) {
9. return NJS_ERROR;
10. p--;
11. keys = njs_array_indices(vm, value);
12. return ret;","10
21
23
31
37
44
48
59
64
98
141
159","CWE-22,CWE-401,CWE-190,CWE-400,CWE-119"
ed_mul_slide-219629097024905,"void ed_mul_slide(ed_t r, const ed_t p, const bn_t k) {
	ed_t t[1 << (EP_WIDTH - 1)], q;
	uint8_t win[RLC_FP_BITS + 1];
	size_t l;

	ed_null(q);

	if (bn_is_zero(k) || ed_is_infty(p)) {
		ed_set_infty(r);
		return;
	}

	RLC_TRY {
		for (size_t i = 0; i < (1 << (EP_WIDTH - 1)); i ++) {
			ed_null(t[i]);
			ed_new(t[i]);
		}

		ed_new(q);

		ed_copy(t[0], p);
		ed_dbl(q, p);

#if defined(EP_MIXED)
		ed_norm(q, q);
#endif

		
		for (size_t i = 1; i < (1 << (EP_WIDTH - 1)); i++) {
			ed_add(t[i], t[i - 1], q);
		}

#if defined(EP_MIXED)
		ed_norm_sim(t + 1, (const ed_t *)t + 1, (1 << (EP_WIDTH - 1)) - 1);
#endif

		ed_set_infty(q);
		l = RLC_FP_BITS + 1;
		bn_rec_slw(win, &l, k, EP_WIDTH);
		for (size_t i = 0; i < l; i++) {
			if (win[i] == 0) {
				ed_dbl(q, q);
			} else {
				for (size_t j = 0; j < util_bits_dig(win[i]); j++) {
					ed_dbl(q, q);
				}
				ed_add(q, q, t[win[i] >> 1]);
			}
		}

		ed_norm(r, q);
		if (bn_sign(k) == RLC_NEG) {
			ed_neg(r, r);
		}
	}
	RLC_CATCH_ANY {
		RLC_THROW(ERR_CAUGHT);
	}
	RLC_FINALLY {
		for (size_t i = 0; i < (1 << (EP_WIDTH - 1)); i++) {
			ed_free(t[i]);
		}
		ed_free(q);
	}
}
","1. void ed_mul_slide(ed_t r, const ed_t p, const bn_t k) {
ed_t t[1 << (EP_WIDTH - 1)], q;
uint8_t win[RLC_FP_BITS + 1];
size_t l;
2. ed_null(q);
3. ed_set_infty(r);
return;
4. ed_new(t[i]);
5. ed_new(q);
6. ed_copy(t[0], p);
ed_dbl(q, p);
7. ed_add(t[i], t[i - 1], q);
8. ed_set_infty(q);
l = RLC_FP_BITS + 1;
bn_rec_slw(win, &l, k, EP_WIDTH);
for (size_t i = 0; i < l; i++) {
9. ed_dbl(q, q);
10. ed_add(q, q, t[win[i] >> 1]);
11. RLC_CATCH_ANY {","1-4
6
9-10
16
19
21-22
30
37-40
42
47
56",CWE-190
intuit_diff_type,"intuit_diff_type (bool need_header, mode_t *p_file_type)
{
    file_offset this_line = 0;
    file_offset first_command_line = -1;
    char first_ed_command_letter = 0;
    lin fcl_line = 0; 
    bool this_is_a_command = false;
    bool stars_this_line = false;
    bool extended_headers = false;
    enum nametype i;
    struct stat st[3];
    int stat_errno[3];
    int version_controlled[3];
    enum diff retval;
    mode_t file_type;
    size_t indent = 0;

    for (i = OLD;  i <= INDEX;  i++)
      if (p_name[i]) {
	  free (p_name[i]);
	  p_name[i] = 0;
        }
    for (i = 0; i < ARRAY_SIZE (invalid_names); i++)
	invalid_names[i] = NULL;
    for (i = OLD; i <= NEW; i++)
      if (p_timestr[i])
	{
	  free(p_timestr[i]);
	  p_timestr[i] = 0;
	}
    for (i = OLD; i <= NEW; i++)
      if (p_sha1[i])
	{
	  free (p_sha1[i]);
	  p_sha1[i] = 0;
	}
    p_git_diff = false;
    for (i = OLD; i <= NEW; i++)
      {
	p_mode[i] = 0;
	p_copy[i] = false;
	p_rename[i] = false;
      }

    
    if (diff_type == ED_DIFF || diff_type == NORMAL_DIFF)
      need_header = false;

    version_controlled[OLD] = -1;
    version_controlled[NEW] = -1;
    version_controlled[INDEX] = -1;
    p_rfc934_nesting = 0;
    p_timestamp[OLD].tv_sec = p_timestamp[NEW].tv_sec = -1;
    p_says_nonexistent[OLD] = p_says_nonexistent[NEW] = 0;
    Fseek (pfp, p_base, SEEK_SET);
    p_input_line = p_bline - 1;
    for (;;) {
	char *s;
	char *t;
	file_offset previous_line = this_line;
	bool last_line_was_command = this_is_a_command;
	bool stars_last_line = stars_this_line;
	size_t indent_last_line = indent;
	char ed_command_letter;
	bool strip_trailing_cr;
	size_t chars_read;

	indent = 0;
	this_line = file_tell (pfp);
	chars_read = pget_line (0, 0, false, false);
	if (chars_read == (size_t) -1)
	  xalloc_die ();
	if (! chars_read) {
	    if (first_ed_command_letter) {
					
		p_start = first_command_line;
		p_sline = fcl_line;
		retval = ED_DIFF;
		goto scan_exit;
	    }
	    else {
		p_start = this_line;
		p_sline = p_input_line;
		if (extended_headers)
		  {
		    
		    retval = UNI_DIFF;
		    goto scan_exit;
		  }
		return NO_DIFF;
	    }
	}
	strip_trailing_cr = 2 <= chars_read && buf[chars_read - 2] == '\r';
	for (s = buf; *s == ' ' || *s == '\t' || *s == 'X'; s++) {
	    if (*s == '\t')
		indent = (indent + 8) & ~7;
	    else
		indent++;
	}
	if (ISDIGIT (*s))
	  {
	    for (t = s + 1; ISDIGIT (*t) || *t == ',';  t++)
	       ;
	    if (*t == 'd' || *t == 'c' || *t == 'a')
	      {
		for (t++;  ISDIGIT (*t) || *t == ',';  t++)
		   ;
		for (; *t == ' ' || *t == '\t'; t++)
		   ;
		if (*t == '\r')
		  t++;
		this_is_a_command = (*t == '\n');
	      }
	  }
	if (! need_header
	    && first_command_line < 0
	    && ((ed_command_letter = get_ed_command_letter (s))
		|| this_is_a_command)) {
	    first_command_line = this_line;
	    first_ed_command_letter = ed_command_letter;
	    fcl_line = p_input_line;
	    p_indent = indent;		
	    p_strip_trailing_cr = strip_trailing_cr;
	}
	if (!stars_last_line && strnEQ(s, ""*** "", 4))
	  {
	    fetchname (s+4, strippath, &p_name[OLD], &p_timestr[OLD],
		       &p_timestamp[OLD]);
	    need_header = false;
	  }
	else if (strnEQ(s, ""+++ "", 4))
	  {
	    
	    fetchname (s+4, strippath, &p_name[OLD], &p_timestr[OLD],
		       &p_timestamp[OLD]);
	    need_header = false;
	    p_strip_trailing_cr = strip_trailing_cr;
	  }
	else if (strnEQ(s, ""Index:"", 6))
	  {
	    fetchname (s+6, strippath, &p_name[INDEX], (char **) 0, NULL);
	    need_header = false;
	    p_strip_trailing_cr = strip_trailing_cr;
	  }
	else if (strnEQ(s, ""Prereq:"", 7))
	  {
	    for (t = s + 7;  ISSPACE ((unsigned char) *t);  t++)
	       ;
	    revision = t;
	    for (t = revision;  *t;  t++)
	      if (ISSPACE ((unsigned char) *t))
		{
		  char const *u;
		  for (u = t + 1;  ISSPACE ((unsigned char) *u);  u++)
		     ;
		  if (*u)
		    {
		      char numbuf[LINENUM_LENGTH_BOUND + 1];
		      say (""Prereq: with multiple words at line %s of patch\n"",
			   format_linenum (numbuf, this_line));
		    }
		  break;
		}
	    if (t == revision)
		revision = 0;
	    else {
		char oldc = *t;
		*t = '\0';
		revision = xstrdup (revision);
		*t = oldc;
	    }
	  }
	else if (strnEQ (s, ""diff --git "", 11))
	  {
	    char const *u;

	    if (extended_headers)
	      {
		p_start = this_line;
		p_sline = p_input_line;
		
		retval = UNI_DIFF;
		goto scan_exit;
	      }

	    for (i = OLD; i <= NEW; i++)
	      {
		free (p_name[i]);
		p_name[i] = 0;
	      }
	    if (! ((p_name[OLD] = parse_name (s + 11, strippath, &u))
		   && ISSPACE ((unsigned char) *u)
		   && (p_name[NEW] = parse_name (u, strippath, &u))
		   && (u = skip_spaces (u), ! *u)))
	      for (i = OLD; i <= NEW; i++)
		{
		  free (p_name[i]);
		  p_name[i] = 0;
		}
	    p_git_diff = true;
	    need_header = false;
	  }
	else if (p_git_diff && strnEQ (s, ""index "", 6))
	  {
	    char const *u, *v;
	    if ((u = skip_hex_digits (s + 6))
		&& u[0] == '.' && u[1] == '.'
		&& (v = skip_hex_digits (u + 2))
		&& (! *v || ISSPACE ((unsigned char) *v)))
	      {
		get_sha1(&p_sha1[OLD], s + 6, u);
		get_sha1(&p_sha1[NEW], u + 2, v);
		p_says_nonexistent[OLD] = sha1_says_nonexistent (p_sha1[OLD]);
		p_says_nonexistent[NEW] = sha1_says_nonexistent (p_sha1[NEW]);
		if (*(v = skip_spaces (v)))
		  p_mode[OLD] = p_mode[NEW] = fetchmode (v);
		extended_headers = true;
	      }
	  }
	else if (p_git_diff && strnEQ (s, ""old mode "", 9))
	  {
	    p_mode[OLD] = fetchmode (s + 9);
	    extended_headers = true;
	  }
	else if (p_git_diff && strnEQ (s, ""new mode "", 9))
	  {
	    p_mode[NEW] = fetchmode (s + 9);
	    extended_headers = true;
	  }
	else if (p_git_diff && strnEQ (s, ""deleted file mode "", 18))
	  {
	    p_mode[OLD] = fetchmode (s + 18);
	    p_says_nonexistent[NEW] = 2;
	    extended_headers = true;
	  }
	else if (p_git_diff && strnEQ (s, ""new file mode "", 14))
	  {
	    p_mode[NEW] = fetchmode (s + 14);
	    p_says_nonexistent[OLD] = 2;
	    extended_headers = true;
	  }
	else if (p_git_diff && strnEQ (s, ""rename from "", 12))
	  {
	    
	    p_rename[OLD] = true;
	    extended_headers = true;
	  }
	else if (p_git_diff && strnEQ (s, ""rename to "", 10))
	  {
	    
	    p_rename[NEW] = true;
	    extended_headers = true;
	  }
	else if (p_git_diff && strnEQ (s, ""copy from "", 10))
	  {
	    
	    p_copy[OLD] = true;
	    extended_headers = true;
	  }
	else if (p_git_diff && strnEQ (s, ""copy to "", 8))
	  {
	    
	    p_copy[NEW] = true;
	    extended_headers = true;
	  }
	else if (p_git_diff && strnEQ (s, ""GIT binary patch"", 16))
	  {
	    p_start = this_line;
	    p_sline = p_input_line;
	    retval = GIT_BINARY_DIFF;
	    goto scan_exit;
	  }
	else
	  {
	    for (t = s;  t[0] == '-' && t[1] == ' ';  t += 2)
	       ;
	    if (strnEQ(t, ""--- "", 4))
	      {
		struct timespec timestamp;
		timestamp.tv_sec = -1;
		fetchname (t+4, strippath, &p_name[NEW], &p_timestr[NEW],
			   &timestamp);
		need_header = false;
		if (timestamp.tv_sec != -1)
		  {
		    p_timestamp[NEW] = timestamp;
		    p_rfc934_nesting = (t - s) >> 1;
		  }
		p_strip_trailing_cr = strip_trailing_cr;
	      }
	  }
	if (need_header)
	  continue;
	if ((diff_type == NO_DIFF || diff_type == ED_DIFF) &&
	  first_command_line >= 0 &&
	  strEQ(s, "".\n"") ) {
	    p_start = first_command_line;
	    p_sline = fcl_line;
	    retval = ED_DIFF;
	    goto scan_exit;
	}
	if ((diff_type == NO_DIFF || diff_type == UNI_DIFF)
	    && strnEQ(s, ""@@ -"", 4)) {

	    
	    struct timespec ti = p_timestamp[OLD];
	    p_timestamp[OLD] = p_timestamp[NEW];
	    p_timestamp[NEW] = ti;
	    t = p_name[OLD];
	    p_name[OLD] = p_name[NEW];
	    p_name[NEW] = t;
	    t = p_timestr[OLD];
	    p_timestr[OLD] = p_timestr[NEW];
	    p_timestr[NEW] = t;

	    s += 4;
	    if (s[0] == '0' && !ISDIGIT (s[1]))
	      p_says_nonexistent[OLD] = 1 + ! p_timestamp[OLD].tv_sec;
	    while (*s != ' ' && *s != '\n')
	      s++;
	    while (*s == ' ')
	      s++;
	    if (s[0] == '+' && s[1] == '0' && !ISDIGIT (s[2]))
	      p_says_nonexistent[NEW] = 1 + ! p_timestamp[NEW].tv_sec;
	    p_indent = indent;
	    p_start = this_line;
	    p_sline = p_input_line;
	    retval = UNI_DIFF;
	    if (! ((p_name[OLD] || ! p_timestamp[OLD].tv_sec)
		   && (p_name[NEW] || ! p_timestamp[NEW].tv_sec))
		&& ! p_name[INDEX] && need_header)
	      {
		char numbuf[LINENUM_LENGTH_BOUND + 1];
		say (""missing header for unified diff at line %s of patch\n"",
		     format_linenum (numbuf, p_sline));
	      }
	    goto scan_exit;
	}
	stars_this_line = strnEQ(s, ""********"", 8);
	if ((diff_type == NO_DIFF
	     || diff_type == CONTEXT_DIFF
	     || diff_type == NEW_CONTEXT_DIFF)
	    && stars_last_line && indent_last_line == indent
	    && strnEQ (s, ""*** "", 4)) {
	    s += 4;
	    if (s[0] == '0' && !ISDIGIT (s[1]))
	      p_says_nonexistent[OLD] = 1 + ! p_timestamp[OLD].tv_sec;
	    
	    
	    while (*s != '\n')
		s++;
	    p_indent = indent;
	    p_strip_trailing_cr = strip_trailing_cr;
	    p_start = previous_line;
	    p_sline = p_input_line - 1;
	    retval = (*(s-1) == '*' ? NEW_CONTEXT_DIFF : CONTEXT_DIFF);

	    {
	      
	      file_offset saved_p_base = p_base;
	      lin saved_p_bline = p_bline;
	      Fseek (pfp, previous_line, SEEK_SET);
	      p_input_line -= 2;
	      if (another_hunk (retval, false)
		  && ! p_repl_lines && p_newfirst == 1)
		p_says_nonexistent[NEW] = 1 + ! p_timestamp[NEW].tv_sec;
	      next_intuit_at (saved_p_base, saved_p_bline);
	    }

	    if (! ((p_name[OLD] || ! p_timestamp[OLD].tv_sec)
		   && (p_name[NEW] || ! p_timestamp[NEW].tv_sec))
		&& ! p_name[INDEX] && need_header)
	      {
		char numbuf[LINENUM_LENGTH_BOUND + 1];
		say (""missing header for context diff at line %s of patch\n"",
		     format_linenum (numbuf, p_sline));
	      }
	    goto scan_exit;
	}
	if ((diff_type == NO_DIFF || diff_type == NORMAL_DIFF) &&
	  last_line_was_command &&
	  (strnEQ(s, ""< "", 2) || strnEQ(s, ""> "", 2)) ) {
	    p_start = previous_line;
	    p_sline = p_input_line - 1;
	    p_indent = indent;
	    retval = NORMAL_DIFF;
	    goto scan_exit;
	}
    }

  scan_exit:

    
    file_type = p_mode[OLD] & S_IFMT;
    if (file_type)
      {
	mode_t new_file_type = p_mode[NEW] & S_IFMT;
	if (new_file_type && file_type != new_file_type)
	  file_type = 0;
      }
    else
      {
	file_type = p_mode[NEW] & S_IFMT;
	if (! file_type)
	  file_type = S_IFREG;
      }
    *p_file_type = file_type;

    

    i = NONE;

    if (!inname)
      {
	enum nametype i0 = NONE;

	if (! posixly_correct && (p_name[OLD] || p_name[NEW]) && p_name[INDEX])
	  {
	    free (p_name[INDEX]);
	    p_name[INDEX] = 0;
	  }

	for (i = OLD;  i <= INDEX;  i++)
	  if (p_name[i])
	    {
	      if (i0 != NONE && strcmp (p_name[i0], p_name[i]) == 0)
		{
		  
		  stat_errno[i] = stat_errno[i0];
		  if (! stat_errno[i])
		    st[i] = st[i0];
		}
	      else
		{
		  stat_errno[i] = stat_file (p_name[i], &st[i]);
		  if (! stat_errno[i])
		    {
		      if (lookup_file_id (&st[i]) == DELETE_LATER)
			stat_errno[i] = ENOENT;
		      else if (posixly_correct && name_is_valid (p_name[i]))
			break;
		    }
		}
	      i0 = i;
	    }

	if (! posixly_correct)
	  {
	    
	    i = best_name (p_name, stat_errno);

	    if (i == NONE && patch_get)
	      {
		enum nametype nope = NONE;

		for (i = OLD;  i <= INDEX;  i++)
		  if (p_name[i])
		    {
		      char const *cs;
		      char *getbuf;
		      char *diffbuf;
		      bool readonly = (outfile
				       && strcmp (outfile, p_name[i]) != 0);

		      if (nope == NONE || strcmp (p_name[nope], p_name[i]) != 0)
			{
			  cs = (version_controller
			        (p_name[i], readonly, (struct stat *) 0,
				 &getbuf, &diffbuf));
			  version_controlled[i] = !! cs;
			  if (cs)
			    {
			      if (version_get (p_name[i], cs, false, readonly,
					       getbuf, &st[i]))
				stat_errno[i] = 0;
			      else
				version_controlled[i] = 0;

			      free (getbuf);
			      free (diffbuf);

			      if (! stat_errno[i])
				break;
			    }
			}

		      nope = i;
		    }
	      }

	    if (i0 != NONE
		&& (i == NONE || (st[i].st_mode & S_IFMT) == file_type)
		&& maybe_reverse (p_name[i == NONE ? i0 : i], i == NONE,
				  i == NONE || st[i].st_size == 0)
		&& i == NONE)
	      i = i0;

	    if (i == NONE && p_says_nonexistent[reverse])
	      {
		int newdirs[3];
		int newdirs_min = INT_MAX;
		int distance_from_minimum[3];

		for (i = OLD;  i <= INDEX;  i++)
		  if (p_name[i])
		    {
		      newdirs[i] = (prefix_components (p_name[i], false)
				    - prefix_components (p_name[i], true));
		      if (newdirs[i] < newdirs_min)
			newdirs_min = newdirs[i];
		    }

		for (i = OLD;  i <= INDEX;  i++)
		  if (p_name[i])
		    distance_from_minimum[i] = newdirs[i] - newdirs_min;

		
		i = best_name (p_name, distance_from_minimum);
	      }
	  }
      }

     if ((pch_rename () || pch_copy ())
 	&& ! inname
 	&& ! ((i == OLD || i == NEW) &&
	      p_name[reverse] && p_name[! reverse] &&
	      name_is_valid (p_name[reverse]) &&
 	      name_is_valid (p_name[! reverse])))
       {
 	say (""Cannot %s file without two valid file names\n"", pch_rename () ? ""rename"" : ""copy"");
      }

    if (i == NONE)
      {
	if (inname)
	  {
	    inerrno = stat_file (inname, &instat);
	    if (inerrno || (instat.st_mode & S_IFMT) == file_type)
	      maybe_reverse (inname, inerrno, inerrno || instat.st_size == 0);
	  }
	else
          inerrno = -1;
      }
    else
      {
	inname = xstrdup (p_name[i]);
	inerrno = stat_errno[i];
	invc = version_controlled[i];
	instat = st[i];
      }

    return retval;
}
","1. p_sline = fcl_line;
2. this_is_a_command = (*t == '\n');
3. extended_headers = true;
4. p_sline = p_input_line;
5. s++;
6. && ! p_name[INDEX] && need_header)
7. scan_exit:
8. enum nametype i0 = NONE;
9. bool readonly = (outfile
10. if (newdirs[i] < newdirs_min)
11. inerrno = stat_errno[i];","77
112
247
273
325
336
397
442
489
536
574","CWE-116,CWE-125,CWE-399,CWE-119"
nfs4_open_revalidate,"nfs4_open_revalidate(struct inode *dir, struct dentry *dentry, int openflags, struct nameidata *nd)
{
	struct path path = {
		.mnt = nd->path.mnt,
		.dentry = dentry,
 	};
 	struct rpc_cred *cred;
 	struct nfs4_state *state;
	fmode_t fmode = openflags & (FMODE_READ | FMODE_WRITE);
 
 	cred = rpc_lookup_cred();
 	if (IS_ERR(cred))
 		return PTR_ERR(cred);
	state = nfs4_do_open(dir, &path, fmode, openflags, NULL, cred);
 	put_rpccred(cred);
 	if (IS_ERR(state)) {
 		switch (PTR_ERR(state)) {
			case -EPERM:
			case -EACCES:
			case -EDQUOT:
			case -ENOSPC:
			case -EROFS:
				lookup_instantiate_filp(nd, (struct dentry *)state, NULL);
				return 1;
			default:
				goto out_drop;
		}
 	}
 	if (state->inode == dentry->d_inode) {
 		nfs_set_verifier(dentry, nfs_save_change_attribute(dir));
		nfs4_intent_set_file(nd, &path, state, fmode);
 		return 1;
 	}
	nfs4_close_sync(&path, state, fmode);
 out_drop:
 	d_drop(dentry);
 	return 0;
}
","1. .dentry = dentry,
2. fmode_t fmode = openflags & (FMODE_READ | FMODE_WRITE);
3. cred = rpc_lookup_cred();
4. put_rpccred(cred);
if (IS_ERR(state)) {
5. case -EPERM:
case -EACCES:
case -EDQUOT:
6. lookup_instantiate_filp(nd, (struct dentry *)state, NULL);
7. default:
8. if (state->inode == dentry->d_inode) {
nfs_set_verifier(dentry, nfs_save_change_attribute(dir));
nfs4_intent_set_file(nd, &path, state, fmode);
9. out_drop:
10. return 0;","5
9
11
15-16
18-20
23
25
29-31
35
37","CWE-59,CWE-200,CWE-125,CWE-284"
jpc_dec_tileinit,"static int jpc_dec_tileinit(jpc_dec_t *dec, jpc_dec_tile_t *tile)
{
	jpc_dec_tcomp_t *tcomp;
	int compno;
	int rlvlno;
	jpc_dec_rlvl_t *rlvl;
	jpc_dec_band_t *band;
	jpc_dec_prc_t *prc;
	int bndno;
	jpc_tsfb_band_t *bnd;
	int bandno;
	jpc_dec_ccp_t *ccp;
	int prccnt;
	jpc_dec_cblk_t *cblk;
	int cblkcnt;
	uint_fast32_t tlprcxstart;
	uint_fast32_t tlprcystart;
	uint_fast32_t brprcxend;
	uint_fast32_t brprcyend;
	uint_fast32_t tlcbgxstart;
	uint_fast32_t tlcbgystart;
	uint_fast32_t brcbgxend;
	uint_fast32_t brcbgyend;
	uint_fast32_t cbgxstart;
	uint_fast32_t cbgystart;
	uint_fast32_t cbgxend;
	uint_fast32_t cbgyend;
	uint_fast32_t tlcblkxstart;
	uint_fast32_t tlcblkystart;
	uint_fast32_t brcblkxend;
	uint_fast32_t brcblkyend;
	uint_fast32_t cblkxstart;
	uint_fast32_t cblkystart;
	uint_fast32_t cblkxend;
	uint_fast32_t cblkyend;
	uint_fast32_t tmpxstart;
	uint_fast32_t tmpystart;
 	uint_fast32_t tmpxend;
 	uint_fast32_t tmpyend;
 	jpc_dec_cp_t *cp;
	jpc_tsfb_band_t bnds[JPC_MAXBANDS];
 	jpc_pchg_t *pchg;
 	int pchgno;
 	jpc_dec_cmpt_t *cmpt;

	cp = tile->cp;
	tile->realmode = 0;
	if (cp->mctid == JPC_MCT_ICT) {
		tile->realmode = 1;
	}

	for (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno <
	  dec->numcomps; ++compno, ++tcomp, ++cmpt) {
		ccp = &tile->cp->ccps[compno];
		if (ccp->qmfbid == JPC_COX_INS) {
			tile->realmode = 1;
		}
		tcomp->numrlvls = ccp->numrlvls;
		if (!(tcomp->rlvls = jas_alloc2(tcomp->numrlvls,
		  sizeof(jpc_dec_rlvl_t)))) {
			return -1;
		}
		if (!(tcomp->data = jas_seq2d_create(JPC_CEILDIV(tile->xstart,
		  cmpt->hstep), JPC_CEILDIV(tile->ystart, cmpt->vstep),
		  JPC_CEILDIV(tile->xend, cmpt->hstep), JPC_CEILDIV(tile->yend,
		  cmpt->vstep)))) {
			return -1;
		}
		if (!(tcomp->tsfb = jpc_cod_gettsfb(ccp->qmfbid,
		  tcomp->numrlvls - 1))) {
			return -1;
		}
		{
			jpc_tsfb_getbands(tcomp->tsfb, jas_seq2d_xstart(tcomp->data),
			  jas_seq2d_ystart(tcomp->data), jas_seq2d_xend(tcomp->data),
			  jas_seq2d_yend(tcomp->data), bnds);
		}
		for (rlvlno = 0, rlvl = tcomp->rlvls; rlvlno < tcomp->numrlvls;
		  ++rlvlno, ++rlvl) {
			rlvl->bands = 0;
			rlvl->xstart = JPC_CEILDIVPOW2(tcomp->xstart,
			  tcomp->numrlvls - 1 - rlvlno);
			rlvl->ystart = JPC_CEILDIVPOW2(tcomp->ystart,
			  tcomp->numrlvls - 1 - rlvlno);
			rlvl->xend = JPC_CEILDIVPOW2(tcomp->xend,
			  tcomp->numrlvls - 1 - rlvlno);
			rlvl->yend = JPC_CEILDIVPOW2(tcomp->yend,
			  tcomp->numrlvls - 1 - rlvlno);
			rlvl->prcwidthexpn = ccp->prcwidthexpns[rlvlno];
			rlvl->prcheightexpn = ccp->prcheightexpns[rlvlno];
			tlprcxstart = JPC_FLOORDIVPOW2(rlvl->xstart,
			  rlvl->prcwidthexpn) << rlvl->prcwidthexpn;
			tlprcystart = JPC_FLOORDIVPOW2(rlvl->ystart,
			  rlvl->prcheightexpn) << rlvl->prcheightexpn;
			brprcxend = JPC_CEILDIVPOW2(rlvl->xend,
			  rlvl->prcwidthexpn) << rlvl->prcwidthexpn;
			brprcyend = JPC_CEILDIVPOW2(rlvl->yend,
			  rlvl->prcheightexpn) << rlvl->prcheightexpn;
			rlvl->numhprcs = (brprcxend - tlprcxstart) >>
			  rlvl->prcwidthexpn;
			rlvl->numvprcs = (brprcyend - tlprcystart) >>
			  rlvl->prcheightexpn;
			rlvl->numprcs = rlvl->numhprcs * rlvl->numvprcs;

			if (rlvl->xstart >= rlvl->xend || rlvl->ystart >= rlvl->yend) {
				rlvl->bands = 0;
				rlvl->numprcs = 0;
				rlvl->numhprcs = 0;
				rlvl->numvprcs = 0;
				continue;
			}	
			if (!rlvlno) {
				tlcbgxstart = tlprcxstart;
				tlcbgystart = tlprcystart;
				brcbgxend = brprcxend;
				brcbgyend = brprcyend;
				rlvl->cbgwidthexpn = rlvl->prcwidthexpn;
				rlvl->cbgheightexpn = rlvl->prcheightexpn;
			} else {
				tlcbgxstart = JPC_CEILDIVPOW2(tlprcxstart, 1);
				tlcbgystart = JPC_CEILDIVPOW2(tlprcystart, 1);
				brcbgxend = JPC_CEILDIVPOW2(brprcxend, 1);
				brcbgyend = JPC_CEILDIVPOW2(brprcyend, 1);
				rlvl->cbgwidthexpn = rlvl->prcwidthexpn - 1;
				rlvl->cbgheightexpn = rlvl->prcheightexpn - 1;
			}
			rlvl->cblkwidthexpn = JAS_MIN(ccp->cblkwidthexpn,
			  rlvl->cbgwidthexpn);
			rlvl->cblkheightexpn = JAS_MIN(ccp->cblkheightexpn,
			  rlvl->cbgheightexpn);

			rlvl->numbands = (!rlvlno) ? 1 : 3;
			if (!(rlvl->bands = jas_alloc2(rlvl->numbands,
			  sizeof(jpc_dec_band_t)))) {
				return -1;
			}
			for (bandno = 0, band = rlvl->bands;
			  bandno < rlvl->numbands; ++bandno, ++band) {
				bndno = (!rlvlno) ? 0 : (3 * (rlvlno - 1) +
				  bandno + 1);
				bnd = &bnds[bndno];

				band->orient = bnd->orient;
				band->stepsize = ccp->stepsizes[bndno];
				band->analgain = JPC_NOMINALGAIN(ccp->qmfbid,
				  tcomp->numrlvls - 1, rlvlno, band->orient);
				band->absstepsize = jpc_calcabsstepsize(band->stepsize,
				  cmpt->prec + band->analgain);
				band->numbps = ccp->numguardbits +
				  JPC_QCX_GETEXPN(band->stepsize) - 1;
				band->roishift = (ccp->roishift + band->numbps >= JPC_PREC) ?
				  (JPC_PREC - 1 - band->numbps) : ccp->roishift;
				band->data = 0;
				band->prcs = 0;
				if (bnd->xstart == bnd->xend || bnd->ystart == bnd->yend) {
					continue;
				}
				if (!(band->data = jas_seq2d_create(0, 0, 0, 0))) {
					return -1;
				}
				jas_seq2d_bindsub(band->data, tcomp->data, bnd->locxstart,
				  bnd->locystart, bnd->locxend, bnd->locyend);
				jas_seq2d_setshift(band->data, bnd->xstart, bnd->ystart);

				assert(rlvl->numprcs);

				if (!(band->prcs = jas_alloc2(rlvl->numprcs,
				  sizeof(jpc_dec_prc_t)))) {
					return -1;
				}


				cbgxstart = tlcbgxstart;
				cbgystart = tlcbgystart;
				for (prccnt = rlvl->numprcs, prc = band->prcs;
				  prccnt > 0; --prccnt, ++prc) {
					cbgxend = cbgxstart + (1 << rlvl->cbgwidthexpn);
					cbgyend = cbgystart + (1 << rlvl->cbgheightexpn);
					prc->xstart = JAS_MAX(cbgxstart, JAS_CAST(uint_fast32_t,
					  jas_seq2d_xstart(band->data)));
					prc->ystart = JAS_MAX(cbgystart, JAS_CAST(uint_fast32_t,
					  jas_seq2d_ystart(band->data)));
					prc->xend = JAS_MIN(cbgxend, JAS_CAST(uint_fast32_t,
					  jas_seq2d_xend(band->data)));
					prc->yend = JAS_MIN(cbgyend, JAS_CAST(uint_fast32_t,
					  jas_seq2d_yend(band->data)));
					if (prc->xend > prc->xstart && prc->yend > prc->ystart) {
						tlcblkxstart = JPC_FLOORDIVPOW2(prc->xstart,
						  rlvl->cblkwidthexpn) << rlvl->cblkwidthexpn;
						tlcblkystart = JPC_FLOORDIVPOW2(prc->ystart,
						  rlvl->cblkheightexpn) << rlvl->cblkheightexpn;
						brcblkxend = JPC_CEILDIVPOW2(prc->xend,
						  rlvl->cblkwidthexpn) << rlvl->cblkwidthexpn;
						brcblkyend = JPC_CEILDIVPOW2(prc->yend,
						  rlvl->cblkheightexpn) << rlvl->cblkheightexpn;
						prc->numhcblks = (brcblkxend - tlcblkxstart) >>
						  rlvl->cblkwidthexpn;
						prc->numvcblks = (brcblkyend - tlcblkystart) >>
						  rlvl->cblkheightexpn;
						prc->numcblks = prc->numhcblks * prc->numvcblks;
						assert(prc->numcblks > 0);

						if (!(prc->incltagtree = jpc_tagtree_create(
						  prc->numhcblks, prc->numvcblks))) {
							return -1;
						}
						if (!(prc->numimsbstagtree = jpc_tagtree_create(
						  prc->numhcblks, prc->numvcblks))) {
							return -1;
						}
						if (!(prc->cblks = jas_alloc2(prc->numcblks,
						  sizeof(jpc_dec_cblk_t)))) {
							return -1;
						}

						cblkxstart = cbgxstart;
						cblkystart = cbgystart;
						for (cblkcnt = prc->numcblks, cblk = prc->cblks;
						  cblkcnt > 0;) {
							cblkxend = cblkxstart + (1 << rlvl->cblkwidthexpn);
							cblkyend = cblkystart + (1 << rlvl->cblkheightexpn);
							tmpxstart = JAS_MAX(cblkxstart, prc->xstart);
							tmpystart = JAS_MAX(cblkystart, prc->ystart);
							tmpxend = JAS_MIN(cblkxend, prc->xend);
							tmpyend = JAS_MIN(cblkyend, prc->yend);
							if (tmpxend > tmpxstart && tmpyend > tmpystart) {
								cblk->firstpassno = -1;
								cblk->mqdec = 0;
								cblk->nulldec = 0;
								cblk->flags = 0;
								cblk->numpasses = 0;
								cblk->segs.head = 0;
								cblk->segs.tail = 0;
								cblk->curseg = 0;
								cblk->numimsbs = 0;
								cblk->numlenbits = 3;
								cblk->flags = 0;
								if (!(cblk->data = jas_seq2d_create(0, 0, 0,
								  0))) {
									return -1;
								}
								jas_seq2d_bindsub(cblk->data, band->data,
								  tmpxstart, tmpystart, tmpxend, tmpyend);
								++cblk;
								--cblkcnt;
							}
							cblkxstart += 1 << rlvl->cblkwidthexpn;
							if (cblkxstart >= cbgxend) {
								cblkxstart = cbgxstart;
								cblkystart += 1 << rlvl->cblkheightexpn;
							}
						}

					} else {
						prc->cblks = 0;
						prc->incltagtree = 0;
						prc->numimsbstagtree = 0;
					}
					cbgxstart += 1 << rlvl->cbgwidthexpn;
					if (cbgxstart >= brcbgxend) {
						cbgxstart = tlcbgxstart;
						cbgystart += 1 << rlvl->cbgheightexpn;
					}

				}

			}
		}
	}

	if (!(tile->pi = jpc_dec_pi_create(dec, tile))) {
		return -1;
	}

	for (pchgno = 0; pchgno < jpc_pchglist_numpchgs(tile->cp->pchglist);
	  ++pchgno) {
		pchg = jpc_pchg_copy(jpc_pchglist_get(tile->cp->pchglist, pchgno));
		assert(pchg);
		jpc_pi_addpchg(tile->pi, pchg);
	}
	jpc_pi_init(tile->pi);

	return 0;
}
","1. uint_fast32_t tlcblkystart;
2. return -1;
3. jas_seq2d_ystart(tcomp->data), jas_seq2d_xend(tcomp->data),
4. rlvl->prcwidthexpn = ccp->prcwidthexpns[rlvlno];
5. rlvl->prcwidthexpn;
rlvl->numvprcs = (brprcyend - tlprcystart) >>
6. rlvl->numvprcs = 0;
7. rlvl->cbgwidthexpn = rlvl->prcwidthexpn;
8. brcbgyend = JPC_CEILDIVPOW2(brprcyend, 1);
9. rlvl->cbgwidthexpn);
10. return -1;
11. cbgxstart = tlcbgxstart;
12. rlvl->cblkwidthexpn) << rlvl->cblkwidthexpn;
13. rlvl->cblkheightexpn) << rlvl->cblkheightexpn;
14. rlvl->cblkwidthexpn;
15. prc->numcblks = prc->numhcblks * prc->numvcblks;
16. return -1;
17. sizeof(jpc_dec_cblk_t)))) {
18. cblkcnt > 0;) {
19. cblk->numlenbits = 3;
20. --cblkcnt;
21. cbgystart += 1 << rlvl->cbgheightexpn;
22. ++pchgno) {
23. return 0;","29
61
75
89
100-101
109
117
123
128
159
173
189
195
197
200
209
212
219
236
245
262
276
283","CWE-362,CWE-17,CWE-787"
ext4_invalidatepage," static void ext4_invalidatepage(struct page *page, unsigned long offset)
 {
 	journal_t *journal = EXT4_JOURNAL(page->mapping->host);
 
	
	if (ext4_should_dioread_nolock(page->mapping->host))
		ext4_invalidatepage_free_endio(page, offset);
 	
	if (offset == 0)
		ClearPageChecked(page);

	if (journal)
		jbd2_journal_invalidatepage(journal, page, offset);
	else
		block_invalidatepage(page, offset);
}
","1. if (ext4_should_dioread_nolock(page->mapping->host))
ext4_invalidatepage_free_endio(page, offset);
2. if (offset == 0)
3. jbd2_journal_invalidatepage(journal, page, offset);
4. block_invalidatepage(page, offset);","8-9
13
17
19","CWE-362,CWE-190,CWE-287,CWE-400"
pci_msix_table_init-269828223107342,"static int
pci_msix_table_init(struct pci_vdev *dev, int table_entries)
{
	int i, table_size;

	table_size = table_entries * MSIX_TABLE_ENTRY_SIZE;
	dev->msix.table = calloc(1, table_size);
	if (!dev->msix.table) {
		pr_err(""%s: Cannot alloc memory!\n"", __func__);
		return -1;
	}

	
	for (i = 0; i < table_entries; i++)
		dev->msix.table[i].vector_control |= PCIM_MSIX_VCTRL_MASK;

	return 0;
}
","1. int i, table_size;
2. dev->msix.table = calloc(1, table_size);
3. return -1;
4. dev->msix.table[i].vector_control |= PCIM_MSIX_VCTRL_MASK;","4
7
10
15","CWE-617,CWE-835,CWE-416,CWE-119"
nfc_unregister_device-117447946166223,"void nfc_unregister_device(struct nfc_dev *dev)
{
	int rc;

	pr_debug(""dev_name=%s\n"", dev_name(&dev->dev));

	rc = nfc_genl_device_removed(dev);
	if (rc)
		pr_debug(""The userspace won't be notified that the device %s ""
			 ""was removed\n"", dev_name(&dev->dev));

	device_lock(&dev->dev);
	if (dev->rfkill) {
		rfkill_unregister(dev->rfkill);
		rfkill_destroy(dev->rfkill);
	}
	dev->shutting_down = true;
	device_unlock(&dev->dev);

	if (dev->ops->check_presence) {
		del_timer_sync(&dev->check_pres_timer);
		cancel_work_sync(&dev->check_pres_work);
	}

	nfc_llcp_unregister_device(dev);

	mutex_lock(&nfc_devlist_mutex);
	nfc_devlist_generation++;
	device_del(&dev->dev);
	mutex_unlock(&nfc_devlist_mutex);
}
","1. void nfc_unregister_device(struct nfc_dev *dev)
2. int rc;
3. rc = nfc_genl_device_removed(dev);
if (rc)
4. ""was removed\n"", dev_name(&dev->dev));
5. device_lock(&dev->dev);
if (dev->rfkill) {
rfkill_unregister(dev->rfkill);
rfkill_destroy(dev->rfkill);
6. dev->shutting_down = true;
7. mutex_lock(&nfc_devlist_mutex);","1
3
7-8
10
12-15
17
27","CWE-367,CWE-20,CWE-399,CWE-400"
misaligned_fpu_load-102855084176352,"
#define __u32

static int misaligned_fpu_load(struct pt_regs *regs,
			   __u32 opcode,
			   int displacement_not_indexed,
			   int width_shift,
			   int do_paired_load)
{
	
	int error;
	int destreg;
	__u64 address;

	error = generate_and_check_address(regs, opcode,
			displacement_not_indexed, width_shift, &address);
	if (error < 0) {
		return error;
	}

	perf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, regs, address);

	destreg = (opcode >> 4) & 0x3f;
	if (user_mode(regs)) {
		__u64 buffer;
		__u32 buflo, bufhi;

		if (!access_ok(VERIFY_READ, (unsigned long) address, 1UL<<width_shift)) {
			return -1;
		}

		if (__copy_user(&buffer, (const void *)(int)address, (1 << width_shift)) > 0) {
			return -1; 
		}
		
		if (last_task_used_math == current) {
			enable_fpu();
			save_fpu(current);
			disable_fpu();
			last_task_used_math = NULL;
			regs->sr |= SR_FD;
		}

		buflo = *(__u32*) &buffer;
		bufhi = *(1 + (__u32*) &buffer);

		switch (width_shift) {
		case 2:
			current->thread.xstate->hardfpu.fp_regs[destreg] = buflo;
			break;
		case 3:
			if (do_paired_load) {
				current->thread.xstate->hardfpu.fp_regs[destreg] = buflo;
				current->thread.xstate->hardfpu.fp_regs[destreg+1] = bufhi;
			} else {
#if defined(CONFIG_CPU_LITTLE_ENDIAN)
				current->thread.xstate->hardfpu.fp_regs[destreg] = bufhi;
				current->thread.xstate->hardfpu.fp_regs[destreg+1] = buflo;
#else
				current->thread.xstate->hardfpu.fp_regs[destreg] = buflo;
				current->thread.xstate->hardfpu.fp_regs[destreg+1] = bufhi;
#endif
			}
			break;
		default:
			printk(""Unexpected width_shift %d in misaligned_fpu_load, PC=%08lx\n"",
				width_shift, (unsigned long) regs->pc);
			break;
		}
		return 0;
	} else {
		die (""Misaligned FPU load inside kernel"", regs, 0);
		return -1;
	}


}
","1. static int misaligned_fpu_load(struct pt_regs *regs,
2. int width_shift,
3. error = generate_and_check_address(regs, opcode,
4. current->thread.xstate->hardfpu.fp_regs[destreg] = buflo;
current->thread.xstate->hardfpu.fp_regs[destreg+1] = bufhi;
5. width_shift, (unsigned long) regs->pc);
break;
6. return 0;","4
7
15
55-56
69-70
72","CWE-399,CWE-400"
do_ip_getsockopt,"
#define __user

static int do_ip_getsockopt(struct sock *sk, int level, int optname,
			    char __user *optval, int __user *optlen)
{
	struct inet_sock *inet = inet_sk(sk);
	int val;
	int len;

	if (level != SOL_IP)
		return -EOPNOTSUPP;

	if (ip_mroute_opt(optname))
		return ip_mroute_getsockopt(sk, optname, optval, optlen);

	if (get_user(len, optlen))
		return -EFAULT;
	if (len < 0)
		return -EINVAL;

	lock_sock(sk);

	switch (optname) {
 	case IP_OPTIONS:
 	{
 		unsigned char optbuf[sizeof(struct ip_options)+40];
		struct ip_options *opt = (struct ip_options *)optbuf;
		struct ip_options_rcu *inet_opt;

		inet_opt = rcu_dereference_protected(inet->inet_opt,
						     sock_owned_by_user(sk));
 		opt->optlen = 0;
		if (inet_opt)
			memcpy(optbuf, &inet_opt->opt,
			       sizeof(struct ip_options) +
			       inet_opt->opt.optlen);
 		release_sock(sk);
 
 		if (opt->optlen == 0)
			return put_user(0, optlen);

		ip_options_undo(opt);

		len = min_t(unsigned int, len, opt->optlen);
		if (put_user(len, optlen))
			return -EFAULT;
		if (copy_to_user(optval, opt->__data, len))
			return -EFAULT;
		return 0;
	}
	case IP_PKTINFO:
		val = (inet->cmsg_flags & IP_CMSG_PKTINFO) != 0;
		break;
	case IP_RECVTTL:
		val = (inet->cmsg_flags & IP_CMSG_TTL) != 0;
		break;
	case IP_RECVTOS:
		val = (inet->cmsg_flags & IP_CMSG_TOS) != 0;
		break;
	case IP_RECVOPTS:
		val = (inet->cmsg_flags & IP_CMSG_RECVOPTS) != 0;
		break;
	case IP_RETOPTS:
		val = (inet->cmsg_flags & IP_CMSG_RETOPTS) != 0;
		break;
	case IP_PASSSEC:
		val = (inet->cmsg_flags & IP_CMSG_PASSSEC) != 0;
		break;
	case IP_RECVORIGDSTADDR:
		val = (inet->cmsg_flags & IP_CMSG_ORIGDSTADDR) != 0;
		break;
	case IP_TOS:
		val = inet->tos;
		break;
	case IP_TTL:
		val = (inet->uc_ttl == -1 ?
		       sysctl_ip_default_ttl :
		       inet->uc_ttl);
		break;
	case IP_HDRINCL:
		val = inet->hdrincl;
		break;
	case IP_NODEFRAG:
		val = inet->nodefrag;
		break;
	case IP_MTU_DISCOVER:
		val = inet->pmtudisc;
		break;
	case IP_MTU:
	{
		struct dst_entry *dst;
		val = 0;
		dst = sk_dst_get(sk);
		if (dst) {
			val = dst_mtu(dst);
			dst_release(dst);
		}
		if (!val) {
			release_sock(sk);
			return -ENOTCONN;
		}
		break;
	}
	case IP_RECVERR:
		val = inet->recverr;
		break;
	case IP_MULTICAST_TTL:
		val = inet->mc_ttl;
		break;
	case IP_MULTICAST_LOOP:
		val = inet->mc_loop;
		break;
	case IP_MULTICAST_IF:
	{
		struct in_addr addr;
		len = min_t(unsigned int, len, sizeof(struct in_addr));
		addr.s_addr = inet->mc_addr;
		release_sock(sk);

		if (put_user(len, optlen))
			return -EFAULT;
		if (copy_to_user(optval, &addr, len))
			return -EFAULT;
		return 0;
	}
	case IP_MSFILTER:
	{
		struct ip_msfilter msf;
		int err;

		if (len < IP_MSFILTER_SIZE(0)) {
			release_sock(sk);
			return -EINVAL;
		}
		if (copy_from_user(&msf, optval, IP_MSFILTER_SIZE(0))) {
			release_sock(sk);
			return -EFAULT;
		}
		err = ip_mc_msfget(sk, &msf,
				   (struct ip_msfilter __user *)optval, optlen);
		release_sock(sk);
		return err;
	}
	case MCAST_MSFILTER:
	{
		struct group_filter gsf;
		int err;

		if (len < GROUP_FILTER_SIZE(0)) {
			release_sock(sk);
			return -EINVAL;
		}
		if (copy_from_user(&gsf, optval, GROUP_FILTER_SIZE(0))) {
			release_sock(sk);
			return -EFAULT;
		}
		err = ip_mc_gsfget(sk, &gsf,
				   (struct group_filter __user *)optval,
				   optlen);
		release_sock(sk);
		return err;
	}
	case IP_MULTICAST_ALL:
		val = inet->mc_all;
		break;
	case IP_PKTOPTIONS:
	{
		struct msghdr msg;

		release_sock(sk);

		if (sk->sk_type != SOCK_STREAM)
			return -ENOPROTOOPT;

		msg.msg_control = optval;
		msg.msg_controllen = len;
		msg.msg_flags = 0;

		if (inet->cmsg_flags & IP_CMSG_PKTINFO) {
			struct in_pktinfo info;

			info.ipi_addr.s_addr = inet->inet_rcv_saddr;
			info.ipi_spec_dst.s_addr = inet->inet_rcv_saddr;
			info.ipi_ifindex = inet->mc_index;
			put_cmsg(&msg, SOL_IP, IP_PKTINFO, sizeof(info), &info);
		}
		if (inet->cmsg_flags & IP_CMSG_TTL) {
			int hlim = inet->mc_ttl;
			put_cmsg(&msg, SOL_IP, IP_TTL, sizeof(hlim), &hlim);
		}
		len -= msg.msg_controllen;
		return put_user(len, optlen);
	}
	case IP_FREEBIND:
		val = inet->freebind;
		break;
	case IP_TRANSPARENT:
		val = inet->transparent;
		break;
	case IP_MINTTL:
		val = inet->min_ttl;
		break;
	default:
		release_sock(sk);
		return -ENOPROTOOPT;
	}
	release_sock(sk);

	if (len < sizeof(int) && len > 0 && val >= 0 && val <= 255) {
		unsigned char ucval = (unsigned char)val;
		len = 1;
		if (put_user(len, optlen))
			return -EFAULT;
		if (copy_to_user(optval, &ucval, 1))
			return -EFAULT;
	} else {
		len = min_t(unsigned int, sizeof(int), len);
		if (put_user(len, optlen))
			return -EFAULT;
		if (copy_to_user(optval, &val, len))
			return -EFAULT;
	}
	return 0;
}
","1. char __user *optval, int __user *optlen)
2. if (len < 0)
3. if (copy_to_user(optval, opt->__data, len))
4. case IP_HDRINCL:
5. val = inet->pmtudisc;
6. if (dst) {
7. if (!val) {
8. val = inet->mc_loop;
break;
9. case IP_MSFILTER:
10. int err;
11. return -EFAULT;
12. release_sock(sk);
13. return put_user(len, optlen);
14. case IP_FREEBIND:
15. return -EFAULT;","5
19
48
81
88
95
99
112-113
127
130
138
155
193
195
214",CWE-362
userfaultfd_event_wait_completion_1,"static void userfaultfd_event_wait_completion_1(struct userfaultfd_ctx *ctx,
					      struct userfaultfd_wait_queue *ewq)
{
	struct userfaultfd_ctx *release_new_ctx;

	if (WARN_ON_ONCE(current->flags & PF_EXITING))
		goto out;

	ewq->ctx = ctx;
	init_waitqueue_entry(&ewq->wq, current);
	release_new_ctx = NULL;

	spin_lock(&ctx->event_wqh.lock);
	
	__add_wait_queue(&ctx->event_wqh, &ewq->wq);
	for (;;) {
		set_current_state(TASK_KILLABLE);
		if (ewq->msg.event == 0)
			break;
		if (READ_ONCE(ctx->released) ||
		    fatal_signal_pending(current)) {
			
			__remove_wait_queue(&ctx->event_wqh, &ewq->wq);
			if (ewq->msg.event == UFFD_EVENT_FORK) {
				struct userfaultfd_ctx *new;

				new = (struct userfaultfd_ctx *)
					(unsigned long)
					ewq->msg.arg.reserved.reserved1;
				release_new_ctx = new;
			}
			break;
		}

		spin_unlock(&ctx->event_wqh.lock);

		wake_up_poll(&ctx->fd_wqh, EPOLLIN);
		schedule();

		spin_lock(&ctx->event_wqh.lock);
	}
	__set_current_state(TASK_RUNNING);
	spin_unlock(&ctx->event_wqh.lock);

	if (release_new_ctx) {
		struct vm_area_struct *vma;
		struct mm_struct *mm = release_new_ctx->mm;
 
 		
 		down_write(&mm->mmap_sem);
		
		VM_WARN_ON(!mmget_still_valid(mm));
 		for (vma = mm->mmap; vma; vma = vma->vm_next)
 			if (vma->vm_userfaultfd_ctx.ctx == release_new_ctx) {
 				vma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;
				vma->vm_flags &= ~(VM_UFFD_WP | VM_UFFD_MISSING);
			}
		up_write(&mm->mmap_sem);

		userfaultfd_ctx_put(release_new_ctx);
	}

	
out:
	WRITE_ONCE(ctx->mmap_changing, false);
	userfaultfd_ctx_put(ctx);
}
","1. if (WARN_ON_ONCE(current->flags & PF_EXITING))
2. set_current_state(TASK_KILLABLE);
3. fatal_signal_pending(current)) {
4. spin_unlock(&ctx->event_wqh.lock);
5. struct vm_area_struct *vma;
6. vma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;
7. WRITE_ONCE(ctx->mmap_changing, false);","6
20
24
43
54
63
76","CWE-667,CWE-125,CWE-399,CWE-119"
dhcps_init-173392188470348,"void dhcps_init(struct netif * pnetif)
{	
	uint8_t *ip;

#ifdef CONFIG_DHCPS_KEPT_CLIENT_INFO
	memset(&ip_table, 0, sizeof(struct table));




#endif
	
	dhcps_netif = pnetif;

	if (dhcps_pcb != NULL) {
		udp_remove(dhcps_pcb);
		dhcps_pcb = NULL;	
	}

	dhcps_pcb = udp_new(); 
	if (dhcps_pcb == NULL) {
		printf(""\n\r Error!!!upd_new error \n\r"");
		return;
	}
#if LWIP_VERSION_MAJOR >= 2
	IP4_ADDR(ip_2_ip4(&dhcps_send_broadcast_address), 255, 255, 255, 255);
#else
	IP4_ADDR(&dhcps_send_broadcast_address, 255, 255, 255, 255);
#endif

	

	memcpy(&dhcps_local_address, &pnetif->ip_addr,
							sizeof(struct ip_addr));
	memcpy(&dhcps_local_mask, &pnetif->netmask,
						sizeof(struct ip_addr));

	memcpy(&dhcps_local_gateway, &pnetif->gw,
						sizeof(struct ip_addr));

	
#if LWIP_VERSION_MAJOR >= 2
	ip4_addr_set_u32(ip_2_ip4(&dhcps_network_id), (ip_addr_get_ip4_u32(netif_ip_addr4(pnetif))&(ip_addr_get_ip4_u32(netif_ip_netmask4(pnetif)))));
	ip4_addr_set_u32(ip_2_ip4(&dhcps_subnet_broadcast), (ip4_addr_get_u32(ip_2_ip4(&dhcps_network_id)) | ~(ip_addr_get_ip4_u32(netif_ip_netmask4(pnetif)))));
#if 1
	ip4_addr_set_u32(ip_2_ip4(&dhcps_owned_first_ip), htonl(ntohl(ip4_addr_get_u32(ip_2_ip4(&dhcps_network_id))) + 1));
	ip4_addr_set_u32(ip_2_ip4(&dhcps_owned_last_ip), htonl(ntohl(ip4_addr_get_u32(ip_2_ip4(&dhcps_subnet_broadcast))) - 1));	
	dhcps_num_of_available_ips = (ntohl(ip4_addr_get_u32(ip_2_ip4(&dhcps_owned_last_ip))) - ntohl(ip4_addr_get_u32(ip_2_ip4(&dhcps_owned_first_ip)))) + 1;
#endif
#else
	dhcps_network_id.addr = ((pnetif->ip_addr.addr) &
					(pnetif->netmask.addr));
	
	dhcps_subnet_broadcast.addr = ((dhcps_network_id.addr |
					~(pnetif->netmask.addr)));
#if 1
	dhcps_owned_first_ip.addr = htonl((ntohl(dhcps_network_id.addr) + 1));
	dhcps_owned_last_ip.addr = htonl(ntohl(dhcps_subnet_broadcast.addr) - 1);
	dhcps_num_of_available_ips = ((ntohl(dhcps_owned_last_ip.addr) 
				- ntohl(dhcps_owned_first_ip.addr)) + 1); 
#endif
#endif


#if CONFIG_EXAMPLE_UART_ATCMD || CONFIG_EXAMPLE_SPI_ATCMD 
#if IP_SOF_BROADCAST
  dhcps_pcb->so_options|=SOF_BROADCAST;
#endif 
#endif

#if IS_USE_FIXED_IP
#if LWIP_VERSION_MAJOR >= 2
	IP4_ADDR(ip_2_ip4(&dhcps_allocated_client_address), ip4_addr1(ip_2_ip4(&dhcps_local_address))
		, ip4_addr2(ip_2_ip4(&dhcps_local_address)), ip4_addr3(ip_2_ip4(&dhcps_local_address)),
					(ip4_addr4(ip_2_ip4(&dhcps_local_address))) + 1 );
#else
	IP4_ADDR(&dhcps_allocated_client_address, ip4_addr1(&dhcps_local_address)
		, ip4_addr2(&dhcps_local_address), ip4_addr3(&dhcps_local_address),
					(ip4_addr4(&dhcps_local_address)) + 1 );
#endif

#else
	if (dhcps_ip_table_semaphore != NULL) {	
		vSemaphoreDelete(dhcps_ip_table_semaphore);
		dhcps_ip_table_semaphore = NULL;
	}
	dhcps_ip_table_semaphore = xSemaphoreCreateMutex();

	
	memset(&ip_table, 0, sizeof(struct table));
#if LWIP_VERSION_MAJOR >= 2
	mark_ip_in_table((uint8_t)ip4_addr4(ip_2_ip4(&dhcps_local_address)));
	mark_ip_in_table((uint8_t)ip4_addr4(ip_2_ip4(&dhcps_local_gateway)));
#else
	mark_ip_in_table((uint8_t)ip4_addr4(&dhcps_local_address));
	mark_ip_in_table((uint8_t)ip4_addr4(&dhcps_local_gateway));
#endif

#if 0
	for (i = 1; i < ip4_addr4(&dhcps_local_address); i++) {
		mark_ip_in_table(i);
	}
#endif	
#endif
#if LWIP_VERSION_MAJOR >= 2
	if(ip4_addr_get_u32(ip_2_ip4(&dhcps_addr_pool_start)) == 0 && ip4_addr_get_u32(ip_2_ip4(&dhcps_addr_pool_end)) == 0)
#else
	if(dhcps_addr_pool_start.addr== 0 && dhcps_addr_pool_end.addr == 0)
#endif

	{		
		memcpy(&dhcps_pool_start,&dhcps_local_address,sizeof(struct ip_addr));
		ip = (uint8_t *)&dhcps_pool_start;
		ip[3] = DHCP_POOL_START;
		memcpy(&dhcps_pool_end,&dhcps_local_address,sizeof(struct ip_addr));
		ip = (uint8_t *)&dhcps_pool_end;
		ip[3] = DHCP_POOL_END;
		dhcps_set_addr_pool(1,&dhcps_pool_start,&dhcps_pool_end);
	}
	udp_bind(dhcps_pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
	udp_recv(dhcps_pcb, dhcps_receive_udp_packet_handler, NULL);

	
	dns_server_init(pnetif);

}
","1. sizeof(struct ip_addr));
2. sizeof(struct ip_addr));
3. memset(&ip_table, 0, sizeof(struct table));","36
39
90","CWE-264,CWE-416,CWE-125,CWE-404,CWE-399"
_gd2GetHeader_1,"_gd2GetHeader_1 (gdIOCtxPtr in, int *sx, int *sy,
               int *cs, int *vers, int *fmt, int *ncx, int *ncy,
               t_chunk_info ** chunkIdx)
{
	int i;
	int ch;
	char id[5];
	t_chunk_info *cidx;
	int sidx;
	int nc;

	GD2_DBG (printf (""Reading gd2 header info\n""));

	for (i = 0; i < 4; i++) {
		ch = gdGetC (in);
		if (ch == EOF) {
			goto fail1;
		};
		id[i] = ch;
	};
	id[4] = 0;

	GD2_DBG (printf (""Got file code: %s\n"", id));

	
	if (strcmp (id, GD2_ID) != 0) {
		GD2_DBG (printf (""Not a valid gd2 file\n""));
		goto fail1;
	};

	
	if (gdGetWord (vers, in) != 1) {
		goto fail1;
	};
	GD2_DBG (printf (""Version: %d\n"", *vers));

	if ((*vers != 1) && (*vers != 2)) {
		GD2_DBG (printf (""Bad version: %d\n"", *vers));
		goto fail1;
	};

	
	if (!gdGetWord (sx, in)) {
		GD2_DBG (printf (""Could not get x-size\n""));
		goto fail1;
	}
	if (!gdGetWord (sy, in)) {
		GD2_DBG (printf (""Could not get y-size\n""));
		goto fail1;
	}
	GD2_DBG (printf (""Image is %dx%d\n"", *sx, *sy));

	
	if (gdGetWord (cs, in) != 1) {
		goto fail1;
	};
	GD2_DBG (printf (""ChunkSize: %d\n"", *cs));

	if ((*cs < GD2_CHUNKSIZE_MIN) || (*cs > GD2_CHUNKSIZE_MAX)) {
		GD2_DBG (printf (""Bad chunk size: %d\n"", *cs));
		goto fail1;
	};

	
	if (gdGetWord (fmt, in) != 1) {
		goto fail1;
	};
	GD2_DBG (printf (""Format: %d\n"", *fmt));

	if ((*fmt != GD2_FMT_RAW) && (*fmt != GD2_FMT_COMPRESSED) &&
	        (*fmt != GD2_FMT_TRUECOLOR_RAW) &&
	        (*fmt != GD2_FMT_TRUECOLOR_COMPRESSED)) {
		GD2_DBG (printf (""Bad data format: %d\n"", *fmt));
		goto fail1;
	};


	
	if (gdGetWord (ncx, in) != 1) {
		goto fail1;
	};
	GD2_DBG (printf (""%d Chunks Wide\n"", *ncx));

	
	if (gdGetWord (ncy, in) != 1) {
		goto fail1;
	};
	GD2_DBG (printf (""%d Chunks vertically\n"", *ncy));

	if (gd2_compressed (*fmt)) {
		nc = (*ncx) * (*ncy);
		GD2_DBG (printf (""Reading %d chunk index entries\n"", nc));
		sidx = sizeof (t_chunk_info) * nc;
		cidx = gdCalloc (sidx, 1);
		if (!cidx) {
			goto fail1;
		}
		for (i = 0; i < nc; i++) {
			if (gdGetInt (&cidx[i].offset, in) != 1) {
				goto fail2;
			};
 			if (gdGetInt (&cidx[i].size, in) != 1) {
 				goto fail2;
 			};
			if (cidx[i].offset < 0 || cidx[i].size < 0)
				goto fail2;
 		};
 		*chunkIdx = cidx;
 	};

	GD2_DBG (printf (""gd2 header complete\n""));

	return 1;
fail2:
	gdFree(cidx);
fail1:
	return 0;
}
","1. if (strcmp (id, GD2_ID) != 0) {
2. GD2_DBG (printf (""Version: %d\n"", *vers));
3. GD2_DBG (printf (""ChunkSize: %d\n"", *cs));
4. goto fail1;","26
35
57
66","CWE-200,CWE-190,CWE-20,CWE-119"
_clean_slate_datagram-160775635931541,"static void _clean_slate_datagram(gnrc_sixlowpan_frag_fb_t *fbuf)
{
    clist_node_t new_queue = { .next = NULL };

    fbuf->sfr.arq_timeout_event.msg.content.ptr = NULL;
    
    evtimer_del((evtimer_t *)(&_arq_timer),
                &fbuf->sfr.arq_timeout_event.event);
    if (gnrc_sixlowpan_frag_sfr_congure_snd_has_inter_frame_gap()) {
        for (clist_node_t *node = clist_lpop(&_frame_queue);
             node != NULL; node = clist_lpop(&_frame_queue)) {
            _frame_queue_t *entry = (_frame_queue_t *)node;
            
            if (entry->datagram_tag == fbuf->tag) {
                gnrc_pktbuf_release(entry->frame);
                
                entry->frame = NULL;
                clist_rpush(&_frag_descs_free, node);
            }
            else {
                clist_rpush(&new_queue, node);
            }
        }
        
        _frame_queue = new_queue;
    }
    fbuf->offset = 0U;
    fbuf->sfr.cur_seq = 0U;
    fbuf->sfr.frags_sent = 0U;
    for (clist_node_t *node = clist_lpop(&fbuf->sfr.window);
         node != NULL; node = clist_lpop(&fbuf->sfr.window)) {
        clist_rpush(&_frag_descs_free, node);
    }
}
","1. evtimer_del((evtimer_t *)(&_arq_timer),
2. if (gnrc_sixlowpan_frag_sfr_congure_snd_has_inter_frame_gap()) {
for (clist_node_t *node = clist_lpop(&_frame_queue);
3. _frame_queue_t *entry = (_frame_queue_t *)node;","7
9-10
12","CWE-697,CWE-59,CWE-400"
nfs4_open_release,"static void nfs4_open_release(void *calldata)
{
	struct nfs4_opendata *data = calldata;
	struct nfs4_state *state = NULL;

	
	if (data->cancelled == 0)
		goto out_free;
	
	if (data->rpc_status != 0 || !data->rpc_done)
		goto out_free;
	
	if (data->o_res.rflags & NFS4_OPEN_RESULT_CONFIRM)
 		goto out_free;
 	state = nfs4_opendata_to_nfs4_state(data);
 	if (!IS_ERR(state))
		nfs4_close_state(&data->path, state, data->o_arg.fmode);
 out_free:
 	nfs4_opendata_put(data);
 }
","1. struct nfs4_state *state = NULL;
2. if (data->cancelled == 0)
3. if (data->rpc_status != 0 || !data->rpc_done)
4. if (!IS_ERR(state))
nfs4_close_state(&data->path, state, data->o_arg.fmode);","4
7
10
16-17","CWE-476,CWE-125,CWE-287,CWE-416"
br_multicast_add_group,"static int br_multicast_add_group(struct net_bridge *br,
				  struct net_bridge_port *port,
				  struct br_ip *group)
{
	struct net_bridge_mdb_entry *mp;
	struct net_bridge_port_group *p;
	struct net_bridge_port_group __rcu **pp;
	unsigned long now = jiffies;
	int err;

	spin_lock(&br->multicast_lock);
	if (!netif_running(br->dev) ||
	    (port && port->state == BR_STATE_DISABLED))
		goto out;

	mp = br_multicast_new_group(br, port, group);
	err = PTR_ERR(mp);
	if (IS_ERR(mp))
 		goto err;
 
 	if (!port) {
		if (hlist_unhashed(&mp->mglist))
			hlist_add_head(&mp->mglist, &br->mglist);
 		mod_timer(&mp->timer, now + br->multicast_membership_interval);
 		goto out;
 	}

	for (pp = &mp->ports;
	     (p = mlock_dereference(*pp, br)) != NULL;
	     pp = &p->next) {
		if (p->port == port)
			goto found;
		if ((unsigned long)p->port < (unsigned long)port)
			break;
	}

	p = kzalloc(sizeof(*p), GFP_ATOMIC);
	err = -ENOMEM;
	if (unlikely(!p))
		goto err;

	p->addr = *group;
	p->port = port;
	p->next = *pp;
	hlist_add_head(&p->mglist, &port->mglist);
	setup_timer(&p->timer, br_multicast_port_group_expired,
		    (unsigned long)p);
	setup_timer(&p->query_timer, br_multicast_port_group_query_expired,
		    (unsigned long)p);

	rcu_assign_pointer(*pp, p);

found:
	mod_timer(&p->timer, now + br->multicast_membership_interval);
out:
	err = 0;

err:
	spin_unlock(&br->multicast_lock);
	return err;
}
","1. struct net_bridge_port_group *p;
2. if (hlist_unhashed(&mp->mglist))
hlist_add_head(&mp->mglist, &br->mglist);
3. err = -ENOMEM;
4. err = 0;
5. spin_unlock(&br->multicast_lock);","6
22-23
38
56
59","CWE-399,CWE-287"
__xen_evtchn_do_upcall-185040365435236,"static void __xen_evtchn_do_upcall(void)
{
	struct vcpu_info *vcpu_info = __this_cpu_read(xen_vcpu);
	int cpu = smp_processor_id();

	read_lock(&evtchn_rwlock);

	do {
		vcpu_info->evtchn_upcall_pending = 0;

		xen_evtchn_handle_events(cpu);

		BUG_ON(!irqs_disabled());

		virt_rmb(); 

	} while (vcpu_info->evtchn_upcall_pending);

	read_unlock(&evtchn_rwlock);
}
","1. struct vcpu_info *vcpu_info = __this_cpu_read(xen_vcpu);
int cpu = smp_processor_id();
2. read_lock(&evtchn_rwlock);
3. vcpu_info->evtchn_upcall_pending = 0;
4. BUG_ON(!irqs_disabled());
5. virt_rmb();
6. } while (vcpu_info->evtchn_upcall_pending);","3-4
6
9
13
15
17","CWE-362,CWE-285,CWE-399"
rename_principal_2_svc," rename_principal_2_svc(rprinc_arg *arg, struct svc_req *rqstp)
 {
     static generic_ret          ret;
    char                        *prime_arg1 = NULL, *prime_arg2 = NULL;
    gss_buffer_desc             client_name = GSS_C_EMPTY_BUFFER;
    gss_buffer_desc             service_name = GSS_C_EMPTY_BUFFER;
     OM_uint32                   minor_stat;
     kadm5_server_handle_t       handle;
     restriction_t               *rp;
    const char                  *errmsg = NULL;
    size_t                      tlen1, tlen2, clen, slen;
    char                        *tdots1, *tdots2, *cdots, *sdots;

    xdr_free(xdr_generic_ret, &ret);

    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))
        goto exit_func;

    if ((ret.code = check_handle((void *)handle)))
        goto exit_func;

    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {
        ret.code = KADM5_FAILURE;
        goto exit_func;
    }
    if (krb5_unparse_name(handle->context, arg->src, &prime_arg1) ||
        krb5_unparse_name(handle->context, arg->dest, &prime_arg2)) {
        ret.code = KADM5_BAD_PRINCIPAL;
        goto exit_func;
    }
    tlen1 = strlen(prime_arg1);
    trunc_name(&tlen1, &tdots1);
    tlen2 = strlen(prime_arg2);
    trunc_name(&tlen2, &tdots2);
    clen = client_name.length;
    trunc_name(&clen, &cdots);
    slen = service_name.length;
    trunc_name(&slen, &sdots);

    ret.code = KADM5_OK;
    if (! CHANGEPW_SERVICE(rqstp)) {
        if (!kadm5int_acl_check(handle->context, rqst2name(rqstp),
                                ACL_DELETE, arg->src, NULL))
            ret.code = KADM5_AUTH_DELETE;
        
        if (!kadm5int_acl_check(handle->context, rqst2name(rqstp),
                                ACL_ADD, arg->dest, &rp) || rp) {
            if (ret.code == KADM5_AUTH_DELETE)
                ret.code = KADM5_AUTH_INSUFFICIENT;
            else
                ret.code = KADM5_AUTH_ADD;
        }
    } else
        ret.code = KADM5_AUTH_INSUFFICIENT;
    if (ret.code != KADM5_OK) {
        
        krb5_klog_syslog(LOG_NOTICE,
                         _(""Unauthorized request: kadm5_rename_principal, ""
                           ""%.*s%s to %.*s%s, ""
                           ""client=%.*s%s, service=%.*s%s, addr=%s""),
                         (int)tlen1, prime_arg1, tdots1,
                         (int)tlen2, prime_arg2, tdots2,
                         (int)clen, (char *)client_name.value, cdots,
                         (int)slen, (char *)service_name.value, sdots,
                         client_addr(rqstp->rq_xprt));
    } else {
        ret.code = kadm5_rename_principal((void *)handle, arg->src,
                                          arg->dest);
        if( ret.code != 0 )
            errmsg = krb5_get_error_message(handle->context, ret.code);

        
        krb5_klog_syslog(LOG_NOTICE,
                         _(""Request: kadm5_rename_principal, ""
                           ""%.*s%s to %.*s%s, %s, ""
                           ""client=%.*s%s, service=%.*s%s, addr=%s""),
                         (int)tlen1, prime_arg1, tdots1,
                         (int)tlen2, prime_arg2, tdots2,
                         errmsg ? errmsg : _(""success""),
                         (int)clen, (char *)client_name.value, cdots,
                         (int)slen, (char *)service_name.value, sdots,
                         client_addr(rqstp->rq_xprt));

        if (errmsg != NULL)
             krb5_free_error_message(handle->context, errmsg);
 
     }
exit_func:
     free(prime_arg1);
     free(prime_arg2);
     gss_release_buffer(&minor_stat, &client_name);
     gss_release_buffer(&minor_stat, &service_name);
     free_server_handle(handle);
     return &ret;
 }
","1. static generic_ret          ret;
2. gss_buffer_desc             client_name = GSS_C_EMPTY_BUFFER;
3. OM_uint32                   minor_stat;
4. xdr_free(xdr_generic_ret, &ret);
5. if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))
6. if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {
7. krb5_unparse_name(handle->context, arg->dest, &prime_arg2)) {
8. trunc_name(&tlen1, &tdots1);
9. trunc_name(&clen, &cdots);
10. trunc_name(&slen, &sdots);
11. ret.code = KADM5_OK;
12. ret.code = KADM5_AUTH_DELETE;
13. (int)tlen2, prime_arg2, tdots2,
14. arg->dest);
if( ret.code != 0 )
15. krb5_klog_syslog(LOG_NOTICE,
16. (int)tlen2, prime_arg2, tdots2,
errmsg ? errmsg : _(""success""),
17. if (errmsg != NULL)
18. free(prime_arg1);
19. free_server_handle(handle);
return &ret;","3
5
7
14
16
22
27
32
36
38
40
44
62
68-69
73
78-79
84
89
93-94","CWE-772,CWE-20,CWE-125"
nfs3svc_decode_symlinkargs-69199903195260,"
#define __be32

int
nfs3svc_decode_symlinkargs(struct svc_rqst *rqstp, __be32 *p,
					struct nfsd3_symlinkargs *args)
{
	unsigned int len, avail;
	char *old, *new;
	struct kvec *vec;

	if (!(p = decode_fh(p, &args->ffh)) ||
	    !(p = decode_filename(p, &args->fname, &args->flen))
		)
		return 0;
	p = decode_sattr3(p, &args->attrs);

	
	len = ntohl(*p++);
	if (len == 0 || len > NFS3_MAXPATHLEN || len >= PAGE_SIZE)
		return 0;
	args->tname = new = page_address(*(rqstp->rq_next_page++));
	args->tlen = len;
	
	old = (char*)p;
	vec = &rqstp->rq_arg.head[0];
	if ((void *)old > vec->iov_base + vec->iov_len)
		return 0;
	avail = vec->iov_len - (old - (char*)vec->iov_base);
	while (len && avail && *old) {
		*new++ = *old++;
		len--;
		avail--;
	}
	
	if (len && !avail && rqstp->rq_arg.page_len) {
		avail = min_t(unsigned int, rqstp->rq_arg.page_len, PAGE_SIZE);
		old = page_address(rqstp->rq_arg.pages[0]);
	}
	while (len && avail && *old) {
		*new++ = *old++;
		len--;
		avail--;
	}
	*new = '\0';
	if (len)
		return 0;

	return 1;
}
","1. nfs3svc_decode_symlinkargs(struct svc_rqst *rqstp, __be32 *p,
struct nfsd3_symlinkargs *args)
2. char *old, *new;
3. !(p = decode_filename(p, &args->fname, &args->flen))
4. if (len == 0 || len > NFS3_MAXPATHLEN || len >= PAGE_SIZE)
return 0;
args->tname = new = page_address(*(rqstp->rq_next_page++));
5. vec = &rqstp->rq_arg.head[0];
if ((void *)old > vec->iov_base + vec->iov_len)
6. avail--;
7. if (len && !avail && rqstp->rq_arg.page_len) {
8. old = page_address(rqstp->rq_arg.pages[0]);
9. *new = '\0';
10. return 1;","5-6
9
13
24-26
30-31
37
40
42
49
53","CWE-834,CWE-59,CWE-119"
session_new_2-206127486545548,"static int session_new_2(nghttp2_session **session_ptr,
                       const nghttp2_session_callbacks *callbacks,
                       void *user_data, int server,
                       const nghttp2_option *option, nghttp2_mem *mem) {
  int rv;
  size_t nbuffer;
  size_t max_deflate_dynamic_table_size =
      NGHTTP2_HD_DEFAULT_MAX_DEFLATE_BUFFER_SIZE;
  size_t i;

  if (mem == NULL) {
    mem = nghttp2_mem_default();
  }

  *session_ptr = nghttp2_mem_calloc(mem, 1, sizeof(nghttp2_session));
  if (*session_ptr == NULL) {
    rv = NGHTTP2_ERR_NOMEM;
    goto fail_session;
  }

  (*session_ptr)->mem = *mem;
  mem = &(*session_ptr)->mem;

  

  nghttp2_stream_init(&(*session_ptr)->root, 0, NGHTTP2_STREAM_FLAG_NONE,
                      NGHTTP2_STREAM_IDLE, NGHTTP2_DEFAULT_WEIGHT, 0, 0, NULL,
                      mem);

  (*session_ptr)->remote_window_size = NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE;
  (*session_ptr)->recv_window_size = 0;
  (*session_ptr)->consumed_size = 0;
  (*session_ptr)->recv_reduction = 0;
  (*session_ptr)->local_window_size = NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE;

  (*session_ptr)->goaway_flags = NGHTTP2_GOAWAY_NONE;
  (*session_ptr)->local_last_stream_id = (1u << 31) - 1;
  (*session_ptr)->remote_last_stream_id = (1u << 31) - 1;

  (*session_ptr)->pending_local_max_concurrent_stream =
      NGHTTP2_DEFAULT_MAX_CONCURRENT_STREAMS;
  (*session_ptr)->pending_enable_push = 1;
  (*session_ptr)->pending_no_rfc7540_priorities = UINT8_MAX;

  nghttp2_ratelim_init(&(*session_ptr)->stream_reset_ratelim,
                       NGHTTP2_DEFAULT_STREAM_RESET_BURST,
                       NGHTTP2_DEFAULT_STREAM_RESET_RATE);

  if (server) {
    (*session_ptr)->server = 1;
  }

  init_settings(&(*session_ptr)->remote_settings);
  init_settings(&(*session_ptr)->local_settings);

  (*session_ptr)->max_incoming_reserved_streams =
      NGHTTP2_MAX_INCOMING_RESERVED_STREAMS;

  
  (*session_ptr)->remote_settings.max_concurrent_streams = 100;

  (*session_ptr)->max_send_header_block_length = NGHTTP2_MAX_HEADERSLEN;
  (*session_ptr)->max_outbound_ack = NGHTTP2_DEFAULT_MAX_OBQ_FLOOD_ITEM;
  (*session_ptr)->max_settings = NGHTTP2_DEFAULT_MAX_SETTINGS;
  (*session_ptr)->max_continuations = NGHTTP2_DEFAULT_MAX_CONTINUATIONS;

  if (option) {
    if ((option->opt_set_mask & NGHTTP2_OPT_NO_AUTO_WINDOW_UPDATE) &&
        option->no_auto_window_update) {

      (*session_ptr)->opt_flags |= NGHTTP2_OPTMASK_NO_AUTO_WINDOW_UPDATE;
    }

    if (option->opt_set_mask & NGHTTP2_OPT_PEER_MAX_CONCURRENT_STREAMS) {

      (*session_ptr)->remote_settings.max_concurrent_streams =
          option->peer_max_concurrent_streams;
    }

    if (option->opt_set_mask & NGHTTP2_OPT_MAX_RESERVED_REMOTE_STREAMS) {

      (*session_ptr)->max_incoming_reserved_streams =
          option->max_reserved_remote_streams;
    }

    if ((option->opt_set_mask & NGHTTP2_OPT_NO_RECV_CLIENT_MAGIC) &&
        option->no_recv_client_magic) {

      (*session_ptr)->opt_flags |= NGHTTP2_OPTMASK_NO_RECV_CLIENT_MAGIC;
    }

    if ((option->opt_set_mask & NGHTTP2_OPT_NO_HTTP_MESSAGING) &&
        option->no_http_messaging) {

      (*session_ptr)->opt_flags |= NGHTTP2_OPTMASK_NO_HTTP_MESSAGING;
    }

    if (option->opt_set_mask & NGHTTP2_OPT_USER_RECV_EXT_TYPES) {
      memcpy((*session_ptr)->user_recv_ext_types, option->user_recv_ext_types,
             sizeof((*session_ptr)->user_recv_ext_types));
    }

    if (option->opt_set_mask & NGHTTP2_OPT_BUILTIN_RECV_EXT_TYPES) {
      (*session_ptr)->builtin_recv_ext_types = option->builtin_recv_ext_types;
    }

    if ((option->opt_set_mask & NGHTTP2_OPT_NO_AUTO_PING_ACK) &&
        option->no_auto_ping_ack) {
      (*session_ptr)->opt_flags |= NGHTTP2_OPTMASK_NO_AUTO_PING_ACK;
    }

    if (option->opt_set_mask & NGHTTP2_OPT_MAX_SEND_HEADER_BLOCK_LENGTH) {
      (*session_ptr)->max_send_header_block_length =
          option->max_send_header_block_length;
    }

    if (option->opt_set_mask & NGHTTP2_OPT_MAX_DEFLATE_DYNAMIC_TABLE_SIZE) {
      max_deflate_dynamic_table_size = option->max_deflate_dynamic_table_size;
    }

    if ((option->opt_set_mask & NGHTTP2_OPT_NO_CLOSED_STREAMS) &&
        option->no_closed_streams) {
      (*session_ptr)->opt_flags |= NGHTTP2_OPTMASK_NO_CLOSED_STREAMS;
    }

    if (option->opt_set_mask & NGHTTP2_OPT_MAX_OUTBOUND_ACK) {
      (*session_ptr)->max_outbound_ack = option->max_outbound_ack;
    }

    if ((option->opt_set_mask & NGHTTP2_OPT_MAX_SETTINGS) &&
        option->max_settings) {
      (*session_ptr)->max_settings = option->max_settings;
    }

    if ((option->opt_set_mask &
         NGHTTP2_OPT_SERVER_FALLBACK_RFC7540_PRIORITIES) &&
        option->server_fallback_rfc7540_priorities) {
      (*session_ptr)->opt_flags |=
          NGHTTP2_OPTMASK_SERVER_FALLBACK_RFC7540_PRIORITIES;
    }

    if ((option->opt_set_mask &
         NGHTTP2_OPT_NO_RFC9113_LEADING_AND_TRAILING_WS_VALIDATION) &&
        option->no_rfc9113_leading_and_trailing_ws_validation) {
      (*session_ptr)->opt_flags |=
          NGHTTP2_OPTMASK_NO_RFC9113_LEADING_AND_TRAILING_WS_VALIDATION;
    }

    if (option->opt_set_mask & NGHTTP2_OPT_STREAM_RESET_RATE_LIMIT) {
      nghttp2_ratelim_init(&(*session_ptr)->stream_reset_ratelim,
                           option->stream_reset_burst,
                           option->stream_reset_rate);
    }

    if (option->opt_set_mask & NGHTTP2_OPT_MAX_CONTINUATIONS) {
      (*session_ptr)->max_continuations = option->max_continuations;
    }
  }

  rv = nghttp2_hd_deflate_init2(&(*session_ptr)->hd_deflater,
                                max_deflate_dynamic_table_size, mem);
  if (rv != 0) {
    goto fail_hd_deflater;
  }
  rv = nghttp2_hd_inflate_init(&(*session_ptr)->hd_inflater, mem);
  if (rv != 0) {
    goto fail_hd_inflater;
  }

  nbuffer = ((*session_ptr)->max_send_header_block_length +
             NGHTTP2_FRAMEBUF_CHUNKLEN - 1) /
            NGHTTP2_FRAMEBUF_CHUNKLEN;

  if (nbuffer == 0) {
    nbuffer = 1;
  }

  
  rv = nghttp2_bufs_init3(&(*session_ptr)->aob.framebufs,
                          NGHTTP2_FRAMEBUF_CHUNKLEN, nbuffer, 1,
                          NGHTTP2_FRAME_HDLEN + 1, mem);
  if (rv != 0) {
    goto fail_aob_framebuf;
  }

  nghttp2_map_init(&(*session_ptr)->streams, mem);

  active_outbound_item_reset(&(*session_ptr)->aob, mem);

  (*session_ptr)->callbacks = *callbacks;
  (*session_ptr)->user_data = user_data;

  session_inbound_frame_reset(*session_ptr);

  if (nghttp2_enable_strict_preface) {
    nghttp2_inbound_frame *iframe = &(*session_ptr)->iframe;

    if (server && ((*session_ptr)->opt_flags &
                   NGHTTP2_OPTMASK_NO_RECV_CLIENT_MAGIC) == 0) {
      iframe->state = NGHTTP2_IB_READ_CLIENT_MAGIC;
      iframe->payloadleft = NGHTTP2_CLIENT_MAGIC_LEN;
    } else {
      iframe->state = NGHTTP2_IB_READ_FIRST_SETTINGS;
    }

    if (!server) {
      (*session_ptr)->aob.state = NGHTTP2_OB_SEND_CLIENT_MAGIC;
      nghttp2_bufs_add(&(*session_ptr)->aob.framebufs, NGHTTP2_CLIENT_MAGIC,
                       NGHTTP2_CLIENT_MAGIC_LEN);
    }
  }

  for (i = 0; i < NGHTTP2_EXTPRI_URGENCY_LEVELS; ++i) {
    nghttp2_pq_init(&(*session_ptr)->sched[i].ob_data, stream_less, mem);
  }

  return 0;

fail_aob_framebuf:
  nghttp2_hd_inflate_free(&(*session_ptr)->hd_inflater);
fail_hd_inflater:
  nghttp2_hd_deflate_free(&(*session_ptr)->hd_deflater);
fail_hd_deflater:
  nghttp2_mem_free(mem, *session_ptr);
fail_session:
  return rv;
}
","1. (*session_ptr)->server = 1;
2. NGHTTP2_MAX_INCOMING_RESERVED_STREAMS;
3. if (option->opt_set_mask & NGHTTP2_OPT_PEER_MAX_CONCURRENT_STREAMS) {
4. option->no_recv_client_magic) {
5. if (rv != 0) {
6. nghttp2_hd_deflate_free(&(*session_ptr)->hd_deflater);
7. return rv;","51
58
75
88
163
223
227","CWE-285,CWE-494,CWE-787,CWE-416"
RunAccuracyCheck,"   void RunAccuracyCheck() {
     ACMRandom rnd(ACMRandom::DeterministicSeed());
 uint32_t max_error = 0;

     int64_t total_error = 0;
     const int count_test_block = 10000;
     for (int i = 0; i < count_test_block; ++i) {
      DECLARE_ALIGNED(16, int16_t, test_input_block[kNumCoeffs]);
      DECLARE_ALIGNED(16, tran_low_t, test_temp_block[kNumCoeffs]);
      DECLARE_ALIGNED(16, uint8_t, dst[kNumCoeffs]);
      DECLARE_ALIGNED(16, uint8_t, src[kNumCoeffs]);
#if CONFIG_VP9_HIGHBITDEPTH
      DECLARE_ALIGNED(16, uint16_t, dst16[kNumCoeffs]);
      DECLARE_ALIGNED(16, uint16_t, src16[kNumCoeffs]);
#endif
 
      
       for (int j = 0; j < kNumCoeffs; ++j) {
        if (bit_depth_ == VPX_BITS_8) {
          src[j] = rnd.Rand8();
          dst[j] = rnd.Rand8();
          test_input_block[j] = src[j] - dst[j];
#if CONFIG_VP9_HIGHBITDEPTH
        } else {
          src16[j] = rnd.Rand16() & mask_;
          dst16[j] = rnd.Rand16() & mask_;
          test_input_block[j] = src16[j] - dst16[j];
#endif
        }
       }
 
      ASM_REGISTER_STATE_CHECK(RunFwdTxfm(test_input_block,
                                          test_temp_block, pitch_));
      if (bit_depth_ == VPX_BITS_8) {
        ASM_REGISTER_STATE_CHECK(
            RunInvTxfm(test_temp_block, dst, pitch_));
#if CONFIG_VP9_HIGHBITDEPTH
      } else {
        ASM_REGISTER_STATE_CHECK(
            RunInvTxfm(test_temp_block, CONVERT_TO_BYTEPTR(dst16), pitch_));
#endif
      }
 
       for (int j = 0; j < kNumCoeffs; ++j) {
#if CONFIG_VP9_HIGHBITDEPTH
        const uint32_t diff =
            bit_depth_ == VPX_BITS_8 ?  dst[j] - src[j] : dst16[j] - src16[j];
#else
         const uint32_t diff = dst[j] - src[j];
#endif
         const uint32_t error = diff * diff;
         if (max_error < error)
           max_error = error;
        total_error += error;

       }
     }
 
    EXPECT_GE(1u  << 2 * (bit_depth_ - 8), max_error)
         << ""Error: 16x16 FHT/IHT has an individual round trip error > 1"";
 
    EXPECT_GE(count_test_block << 2 * (bit_depth_ - 8), total_error)
         << ""Error: 16x16 FHT/IHT has average round trip error > 1 per block"";
   }
","1. ACMRandom rnd(ACMRandom::DeterministicSeed());
uint32_t max_error = 0;
2. const int count_test_block = 10000;
for (int i = 0; i < count_test_block; ++i) {
DECLARE_ALIGNED(16, int16_t, test_input_block[kNumCoeffs]);
3. DECLARE_ALIGNED(16, uint8_t, src[kNumCoeffs]);
4. for (int j = 0; j < kNumCoeffs; ++j) {
if (bit_depth_ == VPX_BITS_8) {
src[j] = rnd.Rand8();
dst[j] = rnd.Rand8();
5. ASM_REGISTER_STATE_CHECK(RunFwdTxfm(test_input_block,
6. if (bit_depth_ == VPX_BITS_8) {
ASM_REGISTER_STATE_CHECK(
7. for (int j = 0; j < kNumCoeffs; ++j) {
8. const uint32_t diff = dst[j] - src[j];
9. const uint32_t error = diff * diff;
if (max_error < error)
max_error = error;
10. EXPECT_GE(1u  << 2 * (bit_depth_ - 8), max_error)
11. EXPECT_GE(count_test_block << 2 * (bit_depth_ - 8), total_error)
<< ""Error: 16x16 FHT/IHT has average round trip error > 1 per block"";","2-3
6-8
11
18-21
32
34-35
44
49
51-53
59
62-63",CWE-119
EnableHighDPISupport," void EnableHighDPISupport() {
   if (IsHighDPIEnabled() &&
      !SetProcessDpiAwarenessWrapper(PROCESS_SYSTEM_DPI_AWARE)) {
    SetProcessDPIAwareWrapper();
   }
 }
",1. SetProcessDPIAwareWrapper();,4,"CWE-310,CWE-264,CWE-189,CWE-125,CWE-399"
trak_box_size-207778018025317,"
#define GF_Box

GF_Err trak_box_size(GF_Box *s)
{
	u32 pos=0;
	GF_TrackBox *ptr = (GF_TrackBox *)s;

	if (ptr->sample_encryption && ptr->sample_encryption->load_needed) {
		if (!ptr->moov || !!ptr->moov->mov || !ptr->moov->mov->movieFileMap)
			return GF_ISOM_INVALID_FILE;
		GF_Err e = senc_Parse(ptr->moov->mov->movieFileMap->bs, ptr, NULL, ptr->sample_encryption);
		if (e) return e;
	}

	gf_isom_check_position(s, (GF_Box *)ptr->Header, &pos);
	gf_isom_check_position(s, (GF_Box *)ptr->Aperture, &pos);
	gf_isom_check_position(s, (GF_Box *)ptr->References, &pos);
	gf_isom_check_position(s, (GF_Box *)ptr->editBox, &pos);
	gf_isom_check_position(s, (GF_Box *)ptr->Media, &pos);
	gf_isom_check_position(s, (GF_Box *)ptr->meta, &pos);
	gf_isom_check_position(s, (GF_Box *)ptr->groups, &pos);
	gf_isom_check_position(s, (GF_Box *)ptr->udta, &pos);
	return GF_OK;
}
","1. u32 pos=0;
2. if (ptr->sample_encryption && ptr->sample_encryption->load_needed) {
if (!ptr->moov || !!ptr->moov->mov || !ptr->moov->mov->movieFileMap)
return GF_ISOM_INVALID_FILE;
3. if (e) return e;
4. return GF_OK;","6
9-11
13
24","CWE-284,CWE-189,CWE-787,CWE-125,CWE-17"
vc4_get_bcl_1,"vc4_get_bcl_1(struct drm_device *dev, struct vc4_exec_info *exec)
{
	struct drm_vc4_submit_cl *args = exec->args;
	void *temp = NULL;
	void *bin;
	int ret = 0;
	uint32_t bin_offset = 0;
	uint32_t shader_rec_offset = roundup(bin_offset + args->bin_cl_size,
					     16);
	uint32_t uniforms_offset = shader_rec_offset + args->shader_rec_size;
	uint32_t exec_size = uniforms_offset + args->uniforms_size;
	uint32_t temp_size = exec_size + (sizeof(struct vc4_shader_state) *
					  args->shader_rec_count);
	struct vc4_bo *bo;

	if (shader_rec_offset < args->bin_cl_size ||
	    uniforms_offset < shader_rec_offset ||
	    exec_size < uniforms_offset ||
	    args->shader_rec_count >= (UINT_MAX /
 					  sizeof(struct vc4_shader_state)) ||
 	    temp_size < exec_size) {
 		DRM_ERROR(""overflow in exec arguments\n"");
		ret = -EINVAL;
 		goto fail;
 	}
 
	
	temp = drm_malloc_ab(temp_size, 1);
	if (!temp) {
		DRM_ERROR(""Failed to allocate storage for copying ""
			  ""in bin/render CLs.\n"");
		ret = -ENOMEM;
		goto fail;
	}
	bin = temp + bin_offset;
	exec->shader_rec_u = temp + shader_rec_offset;
	exec->uniforms_u = temp + uniforms_offset;
	exec->shader_state = temp + exec_size;
	exec->shader_state_size = args->shader_rec_count;

	if (copy_from_user(bin,
			   (void __user *)(uintptr_t)args->bin_cl,
			   args->bin_cl_size)) {
		ret = -EFAULT;
		goto fail;
	}

	if (copy_from_user(exec->shader_rec_u,
			   (void __user *)(uintptr_t)args->shader_rec,
			   args->shader_rec_size)) {
		ret = -EFAULT;
		goto fail;
	}

	if (copy_from_user(exec->uniforms_u,
			   (void __user *)(uintptr_t)args->uniforms,
			   args->uniforms_size)) {
		ret = -EFAULT;
		goto fail;
	}

	bo = vc4_bo_create(dev, exec_size, true);
	if (IS_ERR(bo)) {
		DRM_ERROR(""Couldn't allocate BO for binning\n"");
		ret = PTR_ERR(bo);
		goto fail;
	}
	exec->exec_bo = &bo->base;

	list_add_tail(&to_vc4_bo(&exec->exec_bo->base)->unref_head,
		      &exec->unref_list);

	exec->ct0ca = exec->exec_bo->paddr + bin_offset;

	exec->bin_u = bin;

	exec->shader_rec_v = exec->exec_bo->vaddr + shader_rec_offset;
	exec->shader_rec_p = exec->exec_bo->paddr + shader_rec_offset;
	exec->shader_rec_size = args->shader_rec_size;

	exec->uniforms_v = exec->exec_bo->vaddr + uniforms_offset;
	exec->uniforms_p = exec->exec_bo->paddr + uniforms_offset;
	exec->uniforms_size = args->uniforms_size;

	ret = vc4_validate_bin_cl(dev,
				  exec->exec_bo->vaddr + bin_offset,
				  bin,
				  exec);
	if (ret)
		goto fail;

	ret = vc4_validate_shader_recs(dev, exec);
	if (ret)
		goto fail;

	
	ret = vc4_wait_for_seqno(dev, exec->bin_dep_seqno, ~0ull, true);

fail:
	drm_free_large(temp);
	return ret;
}
","1. void *temp = NULL;
void *bin;
int ret = 0;
2. DRM_ERROR(""overflow in exec arguments\n"");
3. goto fail;
4. if (copy_from_user(bin,
5. ret = -EFAULT;
6. if (copy_from_user(exec->shader_rec_u,
7. ret = -EFAULT;
goto fail;
8. goto fail;
9. bo = vc4_bo_create(dev, exec_size, true);
if (IS_ERR(bo)) {
10. exec->exec_bo = &bo->base;
11. exec->shader_rec_p = exec->exec_bo->paddr + shader_rec_offset;
12. exec->uniforms_v = exec->exec_bo->vaddr + uniforms_offset;
exec->uniforms_p = exec->exec_bo->paddr + uniforms_offset;
exec->uniforms_size = args->uniforms_size;
13. ret = vc4_validate_bin_cl(dev,
exec->exec_bo->vaddr + bin_offset,
14. goto fail;","4-6
22
39
47
50
54
57-58
65
68-69
74
84
87-89
91-92
96","CWE-476,CWE-190,CWE-125,CWE-119"
dns_resolver_describe," static void dns_resolver_describe(const struct key *key, struct seq_file *m)
 {
 	seq_puts(m, key->description);
	if (key_is_positive(key)) {
 		int err = PTR_ERR(key->payload.data[dns_key_error]);
 
 		if (err)
			seq_printf(m, "": %d"", err);
		else
			seq_printf(m, "": %u"", key->datalen);
	}
}
","1. static void dns_resolver_describe(const struct key *key, struct seq_file *m)
2. seq_puts(m, key->description);
if (key_is_positive(key)) {
int err = PTR_ERR(key->payload.data[dns_key_error]);
3. if (err)
4. seq_printf(m, "": %u"", key->datalen);","1
3-5
7
10","CWE-190,CWE-20"
OVS_REQUIRES,"    OVS_REQUIRES(ofproto_mutex)
{
     const struct rule_actions *actions = rule_get_actions(rule);
 
     
    ovs_assert(rule->state != RULE_INSERTED);
 
     if (rule->hard_timeout || rule->idle_timeout) {
         ovs_list_insert(&ofproto->expirable, &rule->expirable);
    }
    cookies_insert(ofproto, rule);
    eviction_group_add_rule(rule);
    if (actions->has_meter) {
        meter_insert_rule(rule);
    }
    if (actions->has_groups) {
        const struct ofpact_group *a;
        OFPACT_FOR_EACH_TYPE_FLATTENED (a, GROUP, actions->ofpacts,
                                        actions->ofpacts_len) {
            struct ofgroup *group;

            group = ofproto_group_lookup(ofproto, a->group_id, OVS_VERSION_MAX,
                                         false);
            ovs_assert(group != NULL);
            group_add_rule(group, rule);
        }
    }

    rule->state = RULE_INSERTED;
}
","1. OVS_REQUIRES(ofproto_mutex)
2. if (rule->hard_timeout || rule->idle_timeout) {
3. const struct ofpact_group *a;
OFPACT_FOR_EACH_TYPE_FLATTENED (a, GROUP, actions->ofpacts,
4. struct ofgroup *group;
5. group = ofproto_group_lookup(ofproto, a->group_id, OVS_VERSION_MAX,","1
8
17-18
20
22","CWE-119,CWE-190,CWE-200,CWE-189"
parse,"parse(struct magic_set *ms, struct magic_entry *me, const char *line,
    size_t lineno, int action)
{
#ifdef ENABLE_CONDITIONALS
	static uint32_t last_cont_level = 0;
#endif
	size_t i;
	struct magic *m;
	const char *l = line;
	char *t;
	int op;
	uint32_t cont_level;
	int32_t diff;

	cont_level = 0;

	
	while (*l == '>') {
		++l;		
		cont_level++; 
	}
#ifdef ENABLE_CONDITIONALS
	if (cont_level == 0 || cont_level > last_cont_level)
		if (file_check_mem(ms, cont_level) == -1)
			return -1;
	last_cont_level = cont_level;
#endif
	if (cont_level != 0) {
		if (me->mp == NULL) {
			file_magerror(ms, ""No current entry for continuation"");
			return -1;
		}
		if (me->cont_count == 0) {
			file_magerror(ms, ""Continuations present with 0 count"");
			return -1;
		}
		m = &me->mp[me->cont_count - 1];
		diff = (int32_t)cont_level - (int32_t)m->cont_level;
		if (diff > 1)
			file_magwarn(ms, ""New continuation level %u is more ""
			    ""than one larger than current level %u"", cont_level,
			    m->cont_level);
		if (me->cont_count == me->max_count) {
			struct magic *nm;
			size_t cnt = me->max_count + ALLOC_CHUNK;
			if ((nm = CAST(struct magic *, realloc(me->mp,
			    sizeof(*nm) * cnt))) == NULL) {
				file_oomem(ms, sizeof(*nm) * cnt);
				return -1;
			}
			me->mp = m = nm;
			me->max_count = CAST(uint32_t, cnt);
		}
		m = &me->mp[me->cont_count++];
		(void)memset(m, 0, sizeof(*m));
		m->cont_level = cont_level;
	} else {
		static const size_t len = sizeof(*m) * ALLOC_CHUNK;
		if (me->mp != NULL)
			return 1;
		if ((m = CAST(struct magic *, malloc(len))) == NULL) {
			file_oomem(ms, len);
			return -1;
		}
		me->mp = m;
		me->max_count = ALLOC_CHUNK;
		(void)memset(m, 0, sizeof(*m));
		m->factor_op = FILE_FACTOR_OP_NONE;
		m->cont_level = 0;
		me->cont_count = 1;
	}
	m->lineno = CAST(uint32_t, lineno);

	if (*l == '&') {  
                ++l;            
                m->flag |= OFFADD;
        }
	if (*l == '(') {
		++l;		
		m->flag |= INDIR;
		if (m->flag & OFFADD)
			m->flag = (m->flag & ~OFFADD) | INDIROFFADD;

		if (*l == '&') {  
			++l;            
			m->flag |= OFFADD;
		}
	}
	
	if (m->cont_level == 0 && (m->flag & (OFFADD | INDIROFFADD)))
		if (ms->flags & MAGIC_CHECK)
			file_magwarn(ms, ""relative offset at level 0"");

	
	m->offset = (uint32_t)strtoul(l, &t, 0);
        if (l == t)
		if (ms->flags & MAGIC_CHECK)
			file_magwarn(ms, ""offset `%s' invalid"", l);
        l = t;

	if (m->flag & INDIR) {
		m->in_type = FILE_LONG;
		m->in_offset = 0;
		
		if (*l == '.') {
			l++;
			switch (*l) {
			case 'l':
				m->in_type = FILE_LELONG;
				break;
			case 'L':
				m->in_type = FILE_BELONG;
				break;
			case 'm':
				m->in_type = FILE_MELONG;
				break;
			case 'h':
			case 's':
				m->in_type = FILE_LESHORT;
				break;
			case 'H':
			case 'S':
				m->in_type = FILE_BESHORT;
				break;
			case 'c':
			case 'b':
			case 'C':
			case 'B':
				m->in_type = FILE_BYTE;
				break;
			case 'e':
			case 'f':
			case 'g':
				m->in_type = FILE_LEDOUBLE;
				break;
			case 'E':
			case 'F':
			case 'G':
				m->in_type = FILE_BEDOUBLE;
				break;
			case 'i':
				m->in_type = FILE_LEID3;
				break;
			case 'I':
				m->in_type = FILE_BEID3;
				break;
			default:
				if (ms->flags & MAGIC_CHECK)
					file_magwarn(ms,
					    ""indirect offset type `%c' invalid"",
					    *l);
				break;
			}
			l++;
		}

		m->in_op = 0;
		if (*l == '~') {
			m->in_op |= FILE_OPINVERSE;
			l++;
		}
		if ((op = get_op(*l)) != -1) {
			m->in_op |= op;
			l++;
		}
		if (*l == '(') {
			m->in_op |= FILE_OPINDIRECT;
			l++;
		}
		if (isdigit((unsigned char)*l) || *l == '-') {
			m->in_offset = (int32_t)strtol(l, &t, 0);
			if (l == t)
				if (ms->flags & MAGIC_CHECK)
					file_magwarn(ms,
					    ""in_offset `%s' invalid"", l);
			l = t;
		}
		if (*l++ != ')' || 
		    ((m->in_op & FILE_OPINDIRECT) && *l++ != ')'))
			if (ms->flags & MAGIC_CHECK)
				file_magwarn(ms,
				    ""missing ')' in indirect offset"");
	}
	EATAB;

#ifdef ENABLE_CONDITIONALS
	m->cond = get_cond(l, &l);
	if (check_cond(ms, m->cond, cont_level) == -1)
		return -1;

	EATAB;
#endif

	
	if (*l == 'u') {
		
		m->type = get_type(type_tbl, l + 1, &l);
		if (m->type == FILE_INVALID) {
			
			m->type = get_standard_integer_type(l, &l);
		}
		
		if (m->type != FILE_INVALID)
			m->flag |= UNSIGNED;
	} else {
		
		m->type = get_type(type_tbl, l, &l);
		if (m->type == FILE_INVALID) {
			
			if (*l == 'd')
				m->type = get_standard_integer_type(l, &l);
			else if (*l == 's' && !isalpha((unsigned char)l[1])) {
				m->type = FILE_STRING;
				++l;
			}
		}
	}

	if (m->type == FILE_INVALID) {
		
		m->type = get_type(special_tbl, l, &l);
	}
			
	if (m->type == FILE_INVALID) {
		if (ms->flags & MAGIC_CHECK)
			file_magwarn(ms, ""type `%s' invalid"", l);
		return -1;
	}

	
	

	m->mask_op = 0;
	if (*l == '~') {
		if (!IS_STRING(m->type))
			m->mask_op |= FILE_OPINVERSE;
		else if (ms->flags & MAGIC_CHECK)
			file_magwarn(ms, ""'~' invalid for string types"");
		++l;
	}
	m->str_range = 0;
	m->str_flags = m->type == FILE_PSTRING ? PSTRING_1_LE : 0;
	if ((op = get_op(*l)) != -1) {
		if (!IS_STRING(m->type)) {
			uint64_t val;
			++l;
			m->mask_op |= op;
			val = (uint64_t)strtoull(l, &t, 0);
			l = t;
			m->num_mask = file_signextend(ms, m, val);
			eatsize(&l);
		}
		else if (op == FILE_OPDIVIDE) {
			int have_range = 0;
			while (!isspace((unsigned char)*++l)) {
				switch (*l) {
				case '0':  case '1':  case '2':
				case '3':  case '4':  case '5':
				case '6':  case '7':  case '8':
				case '9':
					if (have_range &&
					    (ms->flags & MAGIC_CHECK))
						file_magwarn(ms,
						    ""multiple ranges"");
					have_range = 1;
					m->str_range = CAST(uint32_t,
					    strtoul(l, &t, 0));
					if (m->str_range == 0)
						file_magwarn(ms,
						    ""zero range"");
					l = t - 1;
					break;
				case CHAR_COMPACT_WHITESPACE:
					m->str_flags |=
					    STRING_COMPACT_WHITESPACE;
					break;
				case CHAR_COMPACT_OPTIONAL_WHITESPACE:
					m->str_flags |=
					    STRING_COMPACT_OPTIONAL_WHITESPACE;
					break;
				case CHAR_IGNORE_LOWERCASE:
					m->str_flags |= STRING_IGNORE_LOWERCASE;
					break;
				case CHAR_IGNORE_UPPERCASE:
					m->str_flags |= STRING_IGNORE_UPPERCASE;
					break;
				case CHAR_REGEX_OFFSET_START:
					m->str_flags |= REGEX_OFFSET_START;
					break;
				case CHAR_BINTEST:
					m->str_flags |= STRING_BINTEST;
					break;
				case CHAR_TEXTTEST:
					m->str_flags |= STRING_TEXTTEST;
					break;
				case CHAR_TRIM:
					m->str_flags |= STRING_TRIM;
					break;
				case CHAR_PSTRING_1_LE:
					if (m->type != FILE_PSTRING)
						goto bad;
					m->str_flags = (m->str_flags & ~PSTRING_LEN) | PSTRING_1_LE;
					break;
				case CHAR_PSTRING_2_BE:
					if (m->type != FILE_PSTRING)
						goto bad;
					m->str_flags = (m->str_flags & ~PSTRING_LEN) | PSTRING_2_BE;
					break;
				case CHAR_PSTRING_2_LE:
					if (m->type != FILE_PSTRING)
						goto bad;
					m->str_flags = (m->str_flags & ~PSTRING_LEN) | PSTRING_2_LE;
					break;
				case CHAR_PSTRING_4_BE:
					if (m->type != FILE_PSTRING)
						goto bad;
 					m->str_flags = (m->str_flags & ~PSTRING_LEN) | PSTRING_4_BE;
 					break;
 				case CHAR_PSTRING_4_LE:
					switch (m->type) {
					case FILE_PSTRING:
					case FILE_REGEX:
						break;
					default:
 						goto bad;
					}
 					m->str_flags = (m->str_flags & ~PSTRING_LEN) | PSTRING_4_LE;
 					break;
 				case CHAR_PSTRING_LENGTH_INCLUDES_ITSELF:
					if (m->type != FILE_PSTRING)
						goto bad;
					m->str_flags |= PSTRING_LENGTH_INCLUDES_ITSELF;
					break;
				default:
				bad:
					if (ms->flags & MAGIC_CHECK)
						file_magwarn(ms,
						    ""string extension `%c' ""
						    ""invalid"", *l);
					return -1;
				}
				
				if (l[1] == '/' &&
				    !isspace((unsigned char)l[2]))
					l++;
			}
			if (string_modifier_check(ms, m) == -1)
				return -1;
		}
		else {
			if (ms->flags & MAGIC_CHECK)
				file_magwarn(ms, ""invalid string op: %c"", *t);
			return -1;
		}
	}
	
	EATAB;
  
	switch (*l) {
	case '>':
	case '<':
  		m->reln = *l;
  		++l;
		if (*l == '=') {
			if (ms->flags & MAGIC_CHECK) {
				file_magwarn(ms, ""%c= not supported"",
				    m->reln);
				return -1;
			}
		   ++l;
		}
		break;
	
	case '&':
	case '^':
	case '=':
  		m->reln = *l;
  		++l;
		if (*l == '=') {
		   
		   ++l;
		}
		break;
	case '!':
		m->reln = *l;
		++l;
		break;
	default:
  		m->reln = '=';	
		if (*l == 'x' && ((isascii((unsigned char)l[1]) && 
		    isspace((unsigned char)l[1])) || !l[1])) {
			m->reln = *l;
			++l;
		}
		break;
	}
	
	if (m->reln != 'x' && getvalue(ms, m, &l, action))
		return -1;

	

	
	EATAB;
	if (l[0] == '\b') {
		++l;
		m->flag |= NOSPACE;
	} else if ((l[0] == '\\') && (l[1] == 'b')) {
		++l;
		++l;
		m->flag |= NOSPACE;
	}
	for (i = 0; (m->desc[i++] = *l++) != '\0' && i < sizeof(m->desc); )
		continue;
	if (i == sizeof(m->desc)) {
		m->desc[sizeof(m->desc) - 1] = '\0';
		if (ms->flags & MAGIC_CHECK)
			file_magwarn(ms, ""description `%s' truncated"", m->desc);
	}

        
        if (ms->flags & MAGIC_CHECK) {
		if (check_format(ms, m) == -1)
			return -1;
	}
#ifndef COMPILE_ONLY
	if (action == FILE_CHECK) {
		file_mdump(m);
	}
#endif
	m->mimetype[0] = '\0';		
	return 0;
}
","1. char *t;
2. return -1;
3. if (me->cont_count == me->max_count) {
4. if ((nm = CAST(struct magic *, realloc(me->mp,
5. return 1;
6. (void)memset(m, 0, sizeof(*m));
7. if (m->flag & OFFADD)
8. if (*l == '&') {
9. if (ms->flags & MAGIC_CHECK)
10. case 'm':
11. m->in_type = FILE_LEDOUBLE;
12. case 'I':
13. default:
if (ms->flags & MAGIC_CHECK)
14. m->in_op |= FILE_OPINVERSE;
15. l++;
16. l = t;
17. if (ms->flags & MAGIC_CHECK)
18. EATAB;
19. m->type = get_standard_integer_type(l, &l);
20. m->type = get_type(type_tbl, l, &l);
21. if (m->type == FILE_INVALID) {
22. file_magwarn(ms, ""type `%s' invalid"", l);
23. m->str_range = 0;
24. ++l;
25. switch (*l) {
26. (ms->flags & MAGIC_CHECK))
27. if (m->str_range == 0)
28. break;
29. break;
30. case CHAR_PSTRING_1_LE:
31. goto bad;
32. case CHAR_PSTRING_2_BE:
33. m->str_flags = (m->str_flags & ~PSTRING_LEN) | PSTRING_2_BE;
34. goto bad;
35. case CHAR_PSTRING_4_BE:
36. m->str_flags = (m->str_flags & ~PSTRING_LEN) | PSTRING_4_BE;
break;
37. switch (m->type) {
38. if (m->type != FILE_PSTRING)
goto bad;
39. file_magwarn(ms,
40. EATAB;
41. m->reln = *l;
42. m->reln = *l;
43. default:
44. ++l;
45. break;
46. m->flag |= NOSPACE;
} else if ((l[0] == '\\') && (l[1] == 'b')) {
47. return -1;","10
37
45
48
62
69
83
86
93
118
138
148
151-152
163
168
180
184
188
213
225
246
248
263
268
278
284
290
294
314
321
323
326
329
333
336
339-340
342
352-353
359
382
402
410
413
418
420
440-441
460","CWE-284,CWE-78,CWE-400,CWE-119,CWE-399"
mrb_proc_s_new-137564315991286,"static mrb_value
mrb_proc_s_new(mrb_state *mrb, mrb_value proc_class)
{
  mrb_value blk;
  mrb_value proc;
  struct RProc *p;

  
  mrb_get_args(mrb, ""&!"", &blk);
  p = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, mrb_class_ptr(proc_class));
  mrb_proc_copy(mrb, p, mrb_proc_ptr(blk));
  proc = mrb_obj_value(p);
  mrb_funcall_with_block(mrb, proc, MRB_SYM(initialize), 0, NULL, proc);
  if (!MRB_PROC_STRICT_P(p) &&
      mrb->c->ci > mrb->c->cibase && MRB_PROC_ENV(p) == mrb->c->ci[-1].u.env) {
    p->flags |= MRB_PROC_ORPHAN;
  }
  return proc;
}
","1. mrb_value proc;
struct RProc *p;
2. p = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, mrb_class_ptr(proc_class));
mrb_proc_copy(mrb, p, mrb_proc_ptr(blk));
proc = mrb_obj_value(p);
3. if (!MRB_PROC_STRICT_P(p) &&
mrb->c->ci > mrb->c->cibase && MRB_PROC_ENV(p) == mrb->c->ci[-1].u.env) {
4. return proc;","5-6
10-12
14-15
18","CWE-476,CWE-190,CWE-20"
imap_auth_cram_md5-72129395102168,"
#define IMAP_DATA

imap_auth_res_t imap_auth_cram_md5 (IMAP_DATA* idata, const char* method)
{
  char ibuf[LONG_STRING*2], obuf[LONG_STRING];
  unsigned char hmac_response[MD5_DIGEST_LEN];
  int len;
  int rc;

  if (!mutt_bit_isset (idata->capabilities, ACRAM_MD5))
    return IMAP_AUTH_UNAVAIL;

  mutt_message _(""Authenticating (CRAM-MD5)..."");

  
  if (mutt_account_getlogin (&idata->conn->account))
    return IMAP_AUTH_FAILURE;
  if (mutt_account_getpass (&idata->conn->account))
    return IMAP_AUTH_FAILURE;

  imap_cmd_start (idata, ""AUTHENTICATE CRAM-MD5"");

  
  do
    rc = imap_cmd_step (idata);
  while (rc == IMAP_CMD_CONTINUE);
  
  if (rc != IMAP_CMD_RESPOND)
  {
    dprint (1, (debugfile, ""Invalid response from server: %s\n"", ibuf));
    goto bail;
  }

  if ((len = mutt_from_base64 (obuf, idata->buf + 2, sizeof(obuf) - 1)) == -1)
  {
    dprint (1, (debugfile, ""Error decoding base64 response.\n""));
    goto bail;
  }

  obuf[len] = '\0';
  dprint (2, (debugfile, ""CRAM challenge: %s\n"", obuf));

  
  hmac_md5 (idata->conn->account.pass, obuf, hmac_response);
  
  snprintf (obuf, sizeof (obuf),
    ""%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"",
    idata->conn->account.user,
    hmac_response[0], hmac_response[1], hmac_response[2], hmac_response[3],
    hmac_response[4], hmac_response[5], hmac_response[6], hmac_response[7],
    hmac_response[8], hmac_response[9], hmac_response[10], hmac_response[11],
    hmac_response[12], hmac_response[13], hmac_response[14], hmac_response[15]);
  dprint(2, (debugfile, ""CRAM response: %s\n"", obuf));

  
  
  mutt_to_base64 ((unsigned char*) ibuf, (unsigned char*) obuf, strlen (obuf),
		  sizeof (ibuf) - 2);
  safe_strcat (ibuf, sizeof (ibuf), ""\r\n"");
  mutt_socket_write (idata->conn, ibuf);

  do
    rc = imap_cmd_step (idata);
  while (rc == IMAP_CMD_CONTINUE);

  if (rc != IMAP_CMD_OK)
  {
    dprint (1, (debugfile, ""Error receiving server response.\n""));
    goto bail;
  }

  if (imap_code (idata->buf))
    return IMAP_AUTH_SUCCESS;

 bail:
  mutt_error _(""CRAM-MD5 authentication failed."");
  mutt_sleep (2);
  return IMAP_AUTH_FAILURE;
}
","1. mutt_message _(""Authenticating (CRAM-MD5)..."");
2. rc = imap_cmd_step (idata);
3. goto bail;
4. return IMAP_AUTH_SUCCESS;","14
81
87
91","CWE-362,CWE-125,CWE-119,CWE-189"
xsltCompileLocationPathPattern,"xsltCompileLocationPathPattern(xsltParserContextPtr ctxt, int novar) {
    SKIP_BLANKS;
    if ((CUR == '/') && (NXT(1) == '/')) {
	
	NEXT;
	NEXT;
	ctxt->comp->priority = 0.5;	
	xsltCompileRelativePathPattern(ctxt, NULL, novar);
    } else if (CUR == '/') {
	
	NEXT;
	SKIP_BLANKS;
	PUSH(XSLT_OP_ROOT, NULL, NULL, novar);
	if ((CUR != 0) && (CUR != '|')) {
	    PUSH(XSLT_OP_PARENT, NULL, NULL, novar);
	    xsltCompileRelativePathPattern(ctxt, NULL, novar);
	}
    } else if (CUR == '*') {
	xsltCompileRelativePathPattern(ctxt, NULL, novar);
    } else if (CUR == '@') {
	xsltCompileRelativePathPattern(ctxt, NULL, novar);
    } else {
	xmlChar *name;
	name = xsltScanNCName(ctxt);
	if (name == NULL) {
	    xsltTransformError(NULL, NULL, NULL,
		    ""xsltCompileLocationPathPattern : Name expected\n"");
	    ctxt->error = 1;
	    return;
	}
 	SKIP_BLANKS;
 	if ((CUR == '(') && !xmlXPathIsNodeType(name)) {
 	    xsltCompileIdKeyPattern(ctxt, name, 1, novar, 0);
	    if (ctxt->error)
		return;
 	    if ((CUR == '/') && (NXT(1) == '/')) {
 		PUSH(XSLT_OP_ANCESTOR, NULL, NULL, novar);
 		NEXT;
		NEXT;
		SKIP_BLANKS;
		xsltCompileRelativePathPattern(ctxt, NULL, novar);
	    } else if (CUR == '/') {
		PUSH(XSLT_OP_PARENT, NULL, NULL, novar);
		NEXT;
		SKIP_BLANKS;
		xsltCompileRelativePathPattern(ctxt, NULL, novar);
	    }
	    return;
	}
	xsltCompileRelativePathPattern(ctxt, name, novar);
    }
error:
    return;
}
","1. ""xsltCompileLocationPathPattern : Name expected\n"");
2. xsltCompileIdKeyPattern(ctxt, name, 1, novar, 0);
3. PUSH(XSLT_OP_ANCESTOR, NULL, NULL, novar);
4. return;
5. return;","32
38
42
53
58",CWE-119
tcp_v6_syn_recv_sock_2,"static struct sock *tcp_v6_syn_recv_sock_2(const struct sock *sk, struct sk_buff *skb,
					 struct request_sock *req,
					 struct dst_entry *dst,
					 struct request_sock *req_unhash,
					 bool *own_req)
{
	struct inet_request_sock *ireq;
	struct ipv6_pinfo *newnp;
	const struct ipv6_pinfo *np = inet6_sk(sk);
	struct ipv6_txoptions *opt;
	struct tcp6_sock *newtcp6sk;
	struct inet_sock *newinet;
	struct tcp_sock *newtp;
	struct sock *newsk;
#ifdef CONFIG_TCP_MD5SIG
	struct tcp_md5sig_key *key;
#endif
	struct flowi6 fl6;

	if (skb->protocol == htons(ETH_P_IP)) {
		

		newsk = tcp_v4_syn_recv_sock(sk, skb, req, dst,
					     req_unhash, own_req);

		if (!newsk)
			return NULL;

		newtcp6sk = (struct tcp6_sock *)newsk;
		inet_sk(newsk)->pinet6 = &newtcp6sk->inet6;

		newinet = inet_sk(newsk);
		newnp = inet6_sk(newsk);
		newtp = tcp_sk(newsk);

		memcpy(newnp, np, sizeof(struct ipv6_pinfo));

		newnp->saddr = newsk->sk_v6_rcv_saddr;

		inet_csk(newsk)->icsk_af_ops = &ipv6_mapped;
		newsk->sk_backlog_rcv = tcp_v4_do_rcv;
#ifdef CONFIG_TCP_MD5SIG
 		newtp->af_specific = &tcp_sock_ipv6_mapped_specific;
 #endif
 
		newnp->ipv6_mc_list = NULL;
 		newnp->ipv6_ac_list = NULL;
 		newnp->ipv6_fl_list = NULL;
 		newnp->pktoptions  = NULL;
		newnp->opt	   = NULL;
		newnp->mcast_oif   = tcp_v6_iif(skb);
		newnp->mcast_hops  = ipv6_hdr(skb)->hop_limit;
		newnp->rcv_flowinfo = ip6_flowinfo(ipv6_hdr(skb));
		if (np->repflow)
			newnp->flow_label = ip6_flowlabel(ipv6_hdr(skb));

		

		
		tcp_sync_mss(newsk, inet_csk(newsk)->icsk_pmtu_cookie);

		return newsk;
	}

	ireq = inet_rsk(req);

	if (sk_acceptq_is_full(sk))
		goto out_overflow;

	if (!dst) {
		dst = inet6_csk_route_req(sk, &fl6, req, IPPROTO_TCP);
		if (!dst)
			goto out;
	}

	newsk = tcp_create_openreq_child(sk, req, skb);
	if (!newsk)
		goto out_nonewsk;

	

	newsk->sk_gso_type = SKB_GSO_TCPV6;
	ip6_dst_store(newsk, dst, NULL, NULL);
	inet6_sk_rx_dst_set(newsk, skb);

	newtcp6sk = (struct tcp6_sock *)newsk;
	inet_sk(newsk)->pinet6 = &newtcp6sk->inet6;

	newtp = tcp_sk(newsk);
	newinet = inet_sk(newsk);
	newnp = inet6_sk(newsk);

	memcpy(newnp, np, sizeof(struct ipv6_pinfo));

	newsk->sk_v6_daddr = ireq->ir_v6_rmt_addr;
	newnp->saddr = ireq->ir_v6_loc_addr;
	newsk->sk_v6_rcv_saddr = ireq->ir_v6_loc_addr;
	newsk->sk_bound_dev_if = ireq->ir_iif;

	
 	newinet->inet_opt = NULL;
	newnp->ipv6_mc_list = NULL;
 	newnp->ipv6_ac_list = NULL;
 	newnp->ipv6_fl_list = NULL;
 
	
	newnp->rxopt.all = np->rxopt.all;

	newnp->pktoptions = NULL;
	newnp->opt	  = NULL;
	newnp->mcast_oif  = tcp_v6_iif(skb);
	newnp->mcast_hops = ipv6_hdr(skb)->hop_limit;
	newnp->rcv_flowinfo = ip6_flowinfo(ipv6_hdr(skb));
	if (np->repflow)
		newnp->flow_label = ip6_flowlabel(ipv6_hdr(skb));

	
	opt = ireq->ipv6_opt;
	if (!opt)
		opt = rcu_dereference(np->opt);
	if (opt) {
		opt = ipv6_dup_options(newsk, opt);
		RCU_INIT_POINTER(newnp->opt, opt);
	}
	inet_csk(newsk)->icsk_ext_hdr_len = 0;
	if (opt)
		inet_csk(newsk)->icsk_ext_hdr_len = opt->opt_nflen +
						    opt->opt_flen;

	tcp_ca_openreq_child(newsk, dst);

	tcp_sync_mss(newsk, dst_mtu(dst));
	newtp->advmss = tcp_mss_clamp(tcp_sk(sk), dst_metric_advmss(dst));

	tcp_initialize_rcv_mss(newsk);

	newinet->inet_daddr = newinet->inet_saddr = LOOPBACK4_IPV6;
	newinet->inet_rcv_saddr = LOOPBACK4_IPV6;

#ifdef CONFIG_TCP_MD5SIG
	
	key = tcp_v6_md5_do_lookup(sk, &newsk->sk_v6_daddr);
	if (key) {
		
		tcp_md5_do_add(newsk, (union tcp_md5_addr *)&newsk->sk_v6_daddr,
			       AF_INET6, key->key, key->keylen,
			       sk_gfp_mask(sk, GFP_ATOMIC));
	}
#endif

	if (__inet_inherit_port(sk, newsk) < 0) {
		inet_csk_prepare_forced_close(newsk);
		tcp_done(newsk);
		goto out;
	}
	*own_req = inet_ehash_nolisten(newsk, req_to_sk(req_unhash));
	if (*own_req) {
		tcp_move_syn(newtp, req);

		
		if (ireq->pktopts) {
			newnp->pktoptions = skb_clone(ireq->pktopts,
						      sk_gfp_mask(sk, GFP_ATOMIC));
			consume_skb(ireq->pktopts);
			ireq->pktopts = NULL;
			if (newnp->pktoptions) {
				tcp_v6_restore_cb(newnp->pktoptions);
				skb_set_owner_r(newnp->pktoptions, newsk);
			}
		}
	}

	return newsk;

out_overflow:
	__NET_INC_STATS(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);
out_nonewsk:
	dst_release(dst);
out:
	tcp_listendrop(sk);
	return NULL;
}
","1. struct request_sock *req_unhash,
bool *own_req)
2. struct inet_request_sock *ireq;
3. if (!newsk)
4. newnp->opt	   = NULL;
5. if (!newsk)
6. inet6_sk_rx_dst_set(newsk, skb);
7. newnp->pktoptions = NULL;
8. if (np->repflow)
9. RCU_INIT_POINTER(newnp->opt, opt);
10. opt->opt_flen;
11. newinet->inet_rcv_saddr = LOOPBACK4_IPV6;
12. if (__inet_inherit_port(sk, newsk) < 0) {
13. dst_release(dst);
14. tcp_listendrop(sk);
return NULL;","4-5
7
28
52
86
97
125
130
144
149
159
176
203
205-206","CWE-362,CWE-264,CWE-416"
perform_gamma_composition_tests,"perform_gamma_composition_tests(png_modifier *pm, int do_background,
 int expand_16)
{
   png_byte colour_type = 0;
   png_byte bit_depth = 0;
 unsigned int palette_number = 0;

 
    
   while (next_format(&colour_type, &bit_depth, &palette_number,
                      pm->test_lbg_gamma_composition, pm->test_tRNS))
      if ((colour_type & PNG_COLOR_MASK_ALPHA) != 0
#if 0 
          
          || colour_type == 3
#endif
          || (colour_type != 3 && palette_number != 0))
    {
       unsigned int i, j;
 
 
 for (i=0; i<pm->ngamma_tests; ++i) for (j=0; j<pm->ngamma_tests; ++j)
 {
         gamma_composition_test(pm, colour_type, bit_depth, palette_number,
            pm->interlace_type, 1/pm->gammas[i], pm->gammas[j],
            pm->use_input_precision, do_background, expand_16);

 if (fail(pm))
 return;
 }
 }
}
","1. png_byte colour_type = 0;
png_byte bit_depth = 0;
unsigned int palette_number = 0;
2. pm->test_lbg_gamma_composition, pm->test_tRNS))
if ((colour_type & PNG_COLOR_MASK_ALPHA) != 0
3. || (colour_type != 3 && palette_number != 0))
4. unsigned int i, j;
5. for (i=0; i<pm->ngamma_tests; ++i) for (j=0; j<pm->ngamma_tests; ++j)
6. gamma_composition_test(pm, colour_type, bit_depth, palette_number,
7. pm->use_input_precision, do_background, expand_16);
8. if (fail(pm))","4-6
16-17
22
24
27
29
31
33","CWE-200,CWE-17,CWE-189,CWE-323"
ovl_setattr-42751625686669,"int ovl_setattr(struct dentry *dentry, struct iattr *attr)
{
	int err;
	struct dentry *upperdentry;

	err = ovl_want_write(dentry);
	if (err)
		goto out;

	err = ovl_copy_up(dentry);
	if (!err) {
		upperdentry = ovl_dentry_upper(dentry);

		mutex_lock(&upperdentry->d_inode->i_mutex);
		err = notify_change(upperdentry, attr, NULL);
		mutex_unlock(&upperdentry->d_inode->i_mutex);
	}
	ovl_drop_write(dentry);
out:
	return err;
}
",1. err = ovl_copy_up(dentry);,10,"CWE-416,CWE-190,CWE-200,CWE-400,CWE-119"
vmx_set_constant_host_state,"static void vmx_set_constant_host_state(struct vcpu_vmx *vmx)
{
 	u32 low32, high32;
 	unsigned long tmpl;
 	struct desc_ptr dt;
	unsigned long cr4;
 
 	vmcs_writel(HOST_CR0, read_cr0() & ~X86_CR0_TS);  
 	vmcs_writel(HOST_CR3, read_cr3());  
 
	
	cr4 = read_cr4();
	vmcs_writel(HOST_CR4, cr4);			
	vmx->host_state.vmcs_host_cr4 = cr4;

 	vmcs_write16(HOST_CS_SELECTOR, __KERNEL_CS);  
 #ifdef CONFIG_X86_64
 	
	vmcs_write16(HOST_DS_SELECTOR, 0);
	vmcs_write16(HOST_ES_SELECTOR, 0);
#else
	vmcs_write16(HOST_DS_SELECTOR, __KERNEL_DS);  
	vmcs_write16(HOST_ES_SELECTOR, __KERNEL_DS);  
#endif
	vmcs_write16(HOST_SS_SELECTOR, __KERNEL_DS);  
	vmcs_write16(HOST_TR_SELECTOR, GDT_ENTRY_TSS*8);  

	native_store_idt(&dt);
	vmcs_writel(HOST_IDTR_BASE, dt.address);   
	vmx->host_idt_base = dt.address;

	vmcs_writel(HOST_RIP, vmx_return); 

	rdmsr(MSR_IA32_SYSENTER_CS, low32, high32);
	vmcs_write32(HOST_IA32_SYSENTER_CS, low32);
	rdmsrl(MSR_IA32_SYSENTER_EIP, tmpl);
	vmcs_writel(HOST_IA32_SYSENTER_EIP, tmpl);   

	if (vmcs_config.vmexit_ctrl & VM_EXIT_LOAD_IA32_PAT) {
		rdmsr(MSR_IA32_CR_PAT, low32, high32);
		vmcs_write64(HOST_IA32_PAT, low32 | ((u64) high32 << 32));
	}
}
","1. vmx->host_state.vmcs_host_cr4 = cr4;
2. vmcs_writel(HOST_IDTR_BASE, dt.address);
vmx->host_idt_base = dt.address;
3. vmcs_writel(HOST_RIP, vmx_return);
4. rdmsr(MSR_IA32_SYSENTER_CS, low32, high32);
5. rdmsrl(MSR_IA32_SYSENTER_EIP, tmpl);
vmcs_writel(HOST_IA32_SYSENTER_EIP, tmpl);
6. rdmsr(MSR_IA32_CR_PAT, low32, high32);","14
33-34
36
38
40-41
44","CWE-552,CWE-200,CWE-787,CWE-400,CWE-125"
check_multi_info-62813826543308,"static void check_multi_info(ogs_sbi_client_t *client)
{
    CURLM *multi = NULL;
    CURLMsg *resource;
    int pending;
    CURL *easy = NULL;
    CURLcode res;
    connection_t *conn = NULL;
    ogs_sbi_response_t *response = NULL;

    ogs_assert(client);
    multi = client->multi;
    ogs_assert(multi);

    while ((resource = curl_multi_info_read(multi, &pending))) {
        char *url;
        char *content_type = NULL;
        long res_status;
        ogs_assert(resource);

        switch (resource->msg) {
        case CURLMSG_DONE:
            easy = resource->easy_handle;
            ogs_assert(easy);

            curl_easy_getinfo(easy, CURLINFO_PRIVATE, &conn);
            ogs_assert(conn);

            curl_easy_getinfo(easy, CURLINFO_EFFECTIVE_URL, &url);
            curl_easy_getinfo(easy, CURLINFO_RESPONSE_CODE, &res_status);
            curl_easy_getinfo(easy, CURLINFO_CONTENT_TYPE, &content_type);

            res = resource->data.result;
            if (res == CURLE_OK) {
                ogs_log_level_e level = OGS_LOG_DEBUG;

                response = ogs_sbi_response_new();
                ogs_assert(response);

                response->status = res_status;

                ogs_assert(conn->method);
                response->h.method = ogs_strdup(conn->method);
                ogs_assert(response->h.method);

                
                response->h.uri = ogs_strdup(url);
                ogs_assert(response->h.uri);

                if (content_type)
                    ogs_sbi_header_set(response->http.headers,
                            OGS_SBI_CONTENT_TYPE, content_type);
                if (conn->location)
                    ogs_sbi_header_set(response->http.headers,
                            OGS_SBI_LOCATION, conn->location);

                if (conn->memory_overflow == true)
                    level = OGS_LOG_ERROR;

                ogs_log_message(level, 0, ""[%d:%s] %s"",
                        response->status, response->h.method, response->h.uri);

                if (conn->memory) {
                    response->http.content =
                        ogs_memdup(conn->memory, conn->size + 1);
                    ogs_assert(response->http.content);
                    response->http.content_length = conn->size;
                    ogs_assert(response->http.content_length);
                }

                ogs_log_message(level, 0, ""RECEIVED[%d]"",
                        (int)response->http.content_length);
                if (response->http.content_length && response->http.content)
                    ogs_log_message(level, 0, ""%s"", response->http.content);

                if (conn->memory_overflow == true) {
                    ogs_sbi_response_free(response);
                    connection_remove(conn);
                    break;
                }

            } else
                ogs_warn(""[%d] %s"", res, conn->error);

            ogs_assert(conn->client_cb);
            conn->client_cb(res == CURLE_OK ? OGS_OK : OGS_ERROR,
                            response, conn->data);
            connection_remove(conn);
            break;
        default:
            ogs_error(""Unknown CURL resource[%d]"", resource->msg);
            break;
        }
    }
}
","1. static void check_multi_info(ogs_sbi_client_t *client)
2. int pending;
3. ogs_assert(easy);
4. ogs_sbi_response_free(response);
5. ogs_warn(""[%d] %s"", res, conn->error);
6. response, conn->data);","1
5
24
77
83
87","CWE-200,CWE-399,CWE-400"
do_local_notify-95543749168596,"static void
do_local_notify(xmlNode * notify_src, const char *client_id,
                gboolean sync_reply, gboolean from_peer)
{
    
    cib_client_t *client_obj = NULL;
    int local_rc = pcmk_ok;

    if (client_id != NULL) {
        client_obj = g_hash_table_lookup(client_list, client_id);
    } else {
        crm_trace(""No client to sent the response to. F_CIB_CLIENTID not set."");
    }

    if (client_obj == NULL) {
        local_rc = -ECONNRESET;

    } else {
        int rid = 0;

        if(sync_reply) {
            if (client_obj->ipc) {
                CRM_LOG_ASSERT(client_obj->request_id);

                rid = client_obj->request_id;
                client_obj->request_id = 0;

                crm_trace(""Sending response %d to %s %s"",
                      rid, client_obj->name, from_peer?""(originator of delegated request)"":"""");
            } else {
                crm_trace(""Sending response to %s %s"",
                      client_obj->name, from_peer?""(originator of delegated request)"":"""");
            }

        } else {
            crm_trace(""Sending an event to %s %s"",
                      client_obj->name, from_peer?""(originator of delegated request)"":"""");
        }

        if (client_obj->ipc && crm_ipcs_send(client_obj->ipc, rid, notify_src, !sync_reply) < 0) {
            local_rc = -ENOMSG;

#ifdef HAVE_GNUTLS_GNUTLS_H
        } else if (client_obj->session) {
            crm_send_remote_msg(client_obj->session, notify_src, client_obj->encrypted);
#endif
        } else if(client_obj->ipc == NULL) {
            crm_err(""Unknown transport for %s"", client_obj->name);
        }
    }

    if (local_rc != pcmk_ok && client_obj != NULL) {
        crm_warn(""%sSync reply to %s failed: %s"",
                 sync_reply ? """" : ""A-"",
                 client_obj ? client_obj->name : ""<unknown>"", pcmk_strerror(local_rc));
    }
}
","1. static void
do_local_notify(xmlNode * notify_src, const char *client_id,
gboolean sync_reply, gboolean from_peer)
2. cib_client_t *client_obj = NULL;
3. } else {
4. if(sync_reply) {
if (client_obj->ipc) {
5. rid = client_obj->request_id;
client_obj->request_id = 0;
6. rid, client_obj->name, from_peer?""(originator of delegated request)"":"""");
} else {
crm_trace(""Sending response to %s %s"",
client_obj->name, from_peer?""(originator of delegated request)"":"""");
7. } else {
crm_trace(""Sending an event to %s %s"",
client_obj->name, from_peer?""(originator of delegated request)"":"""");
8. if (local_rc != pcmk_ok && client_obj != NULL) {
crm_warn(""%sSync reply to %s failed: %s"",
9. client_obj ? client_obj->name : ""<unknown>"", pcmk_strerror(local_rc));","1-3
6
18
21-22
25-26
29-32
35-37
52-53
55","CWE-862,CWE-200,CWE-59,CWE-399"
amd_gpio_remove,"static int amd_gpio_remove(struct platform_device *pdev)
{
	struct amd_gpio *gpio_dev;

 	gpio_dev = platform_get_drvdata(pdev);
 
 	gpiochip_remove(&gpio_dev->gc);
 
 	return 0;
 }
","1. static int amd_gpio_remove(struct platform_device *pdev)
2. struct amd_gpio *gpio_dev;
3. gpiochip_remove(&gpio_dev->gc);
4. return 0;","1
3
7
9","CWE-416,CWE-399,CWE-415"
ip6_print,"ip6_print(netdissect_options *ndo, const u_char *bp, u_int length)
{
	register const struct ip6_hdr *ip6;
	register int advance;
	u_int len;
	const u_char *ipend;
	register const u_char *cp;
	register u_int payload_len;
	int nh;
	int fragmented = 0;
	u_int flow;

	ip6 = (const struct ip6_hdr *)bp;

	ND_TCHECK(*ip6);
	if (length < sizeof (struct ip6_hdr)) {
		ND_PRINT((ndo, ""truncated-ip6 %u"", length));
		return;
	}

        if (!ndo->ndo_eflag)
            ND_PRINT((ndo, ""IP6 ""));

	if (IP6_VERSION(ip6) != 6) {
          ND_PRINT((ndo,""version error: %u != 6"", IP6_VERSION(ip6)));
          return;
	}

	payload_len = EXTRACT_16BITS(&ip6->ip6_plen);
	len = payload_len + sizeof(struct ip6_hdr);
	if (length < len)
		ND_PRINT((ndo, ""truncated-ip6 - %u bytes missing!"",
			len - length));

        if (ndo->ndo_vflag) {
            flow = EXTRACT_32BITS(&ip6->ip6_flow);
            ND_PRINT((ndo, ""(""));
#if 0
            
            if (flow & 0x0f000000)
		ND_PRINT((ndo, ""pri 0x%02x, "", (flow & 0x0f000000) >> 24));
            if (flow & 0x00ffffff)
		ND_PRINT((ndo, ""flowlabel 0x%06x, "", flow & 0x00ffffff));
#else
            
            if (flow & 0x0ff00000)
		ND_PRINT((ndo, ""class 0x%02x, "", (flow & 0x0ff00000) >> 20));
            if (flow & 0x000fffff)
		ND_PRINT((ndo, ""flowlabel 0x%05x, "", flow & 0x000fffff));
#endif

            ND_PRINT((ndo, ""hlim %u, next-header %s (%u) payload length: %u) "",
                         ip6->ip6_hlim,
                         tok2str(ipproto_values,""unknown"",ip6->ip6_nxt),
                         ip6->ip6_nxt,
                         payload_len));
        }

	
	ipend = bp + len;
	if (ipend < ndo->ndo_snapend)
		ndo->ndo_snapend = ipend;

	cp = (const u_char *)ip6;
 	advance = sizeof(struct ip6_hdr);
 	nh = ip6->ip6_nxt;
 	while (cp < ndo->ndo_snapend && advance > 0) {
		if (len < (u_int)advance)
			goto trunc;
 		cp += advance;
 		len -= advance;
 
		if (cp == (const u_char *)(ip6 + 1) &&
		    nh != IPPROTO_TCP && nh != IPPROTO_UDP &&
		    nh != IPPROTO_DCCP && nh != IPPROTO_SCTP) {
			ND_PRINT((ndo, ""%s > %s: "", ip6addr_string(ndo, &ip6->ip6_src),
				     ip6addr_string(ndo, &ip6->ip6_dst)));
		}

		switch (nh) {
		case IPPROTO_HOPOPTS:
			advance = hbhopt_print(ndo, cp);
			if (advance < 0)
				return;
			nh = *cp;
			break;
		case IPPROTO_DSTOPTS:
			advance = dstopt_print(ndo, cp);
			if (advance < 0)
				return;
			nh = *cp;
			break;
		case IPPROTO_FRAGMENT:
			advance = frag6_print(ndo, cp, (const u_char *)ip6);
			if (advance < 0 || ndo->ndo_snapend <= cp + advance)
				return;
			nh = *cp;
			fragmented = 1;
			break;

		case IPPROTO_MOBILITY_OLD:
		case IPPROTO_MOBILITY:
			
 			advance = mobility_print(ndo, cp, (const u_char *)ip6);
			if (advance < 0)
				return;
 			nh = *cp;
 			return;
 		case IPPROTO_ROUTING:
			ND_TCHECK(*cp);
 			advance = rt6_print(ndo, cp, (const u_char *)ip6);
			if (advance < 0)
				return;
 			nh = *cp;
 			break;
 		case IPPROTO_SCTP:
			sctp_print(ndo, cp, (const u_char *)ip6, len);
			return;
		case IPPROTO_DCCP:
			dccp_print(ndo, cp, (const u_char *)ip6, len);
			return;
		case IPPROTO_TCP:
			tcp_print(ndo, cp, len, (const u_char *)ip6, fragmented);
			return;
		case IPPROTO_UDP:
			udp_print(ndo, cp, len, (const u_char *)ip6, fragmented);
			return;
		case IPPROTO_ICMPV6:
			icmp6_print(ndo, cp, len, (const u_char *)ip6, fragmented);
 			return;
 		case IPPROTO_AH:
 			advance = ah_print(ndo, cp);
			if (advance < 0)
				return;
 			nh = *cp;
 			break;
 		case IPPROTO_ESP:
 		    {
 			int enh, padlen;
 			advance = esp_print(ndo, cp, len, (const u_char *)ip6, &enh, &padlen);
			if (advance < 0)
				return;
 			nh = enh & 0xff;
 			len -= padlen;
 			break;
		    }
		case IPPROTO_IPCOMP:
		    {
			ipcomp_print(ndo, cp);
			
			advance = -1;
			break;
		    }

		case IPPROTO_PIM:
			pim_print(ndo, cp, len, (const u_char *)ip6);
			return;

		case IPPROTO_OSPF:
			ospf6_print(ndo, cp, len);
			return;

		case IPPROTO_IPV6:
			ip6_print(ndo, cp, len);
			return;

		case IPPROTO_IPV4:
		        ip_print(ndo, cp, len);
			return;

                case IPPROTO_PGM:
                        pgm_print(ndo, cp, len, (const u_char *)ip6);
                        return;

		case IPPROTO_GRE:
			gre_print(ndo, cp, len);
			return;

		case IPPROTO_RSVP:
			rsvp_print(ndo, cp, len);
			return;

		case IPPROTO_NONE:
			ND_PRINT((ndo, ""no next header""));
			return;

		default:
			ND_PRINT((ndo, ""ip-proto-%d %d"", nh, len));
			return;
		}
	}

	return;
trunc:
	ND_PRINT((ndo, ""[|ip6]""));
}
","1. register const struct ip6_hdr *ip6;
register int advance;
2. const u_char *ipend;
3. register u_int payload_len;
int nh;
int fragmented = 0;
u_int flow;
4. ip6 = (const struct ip6_hdr *)bp;
5. ND_TCHECK(*ip6);
if (length < sizeof (struct ip6_hdr)) {
6. return;
7. if (!ndo->ndo_eflag)
ND_PRINT((ndo, ""IP6 ""));
8. if (IP6_VERSION(ip6) != 6) {
ND_PRINT((ndo,""version error: %u != 6"", IP6_VERSION(ip6)));
9. len = payload_len + sizeof(struct ip6_hdr);
if (length < len)
10. len - length));
11. flow = EXTRACT_32BITS(&ip6->ip6_flow);
ND_PRINT((ndo, ""(""));
12. ND_PRINT((ndo, ""class 0x%02x, "", (flow & 0x0ff00000) >> 20));
if (flow & 0x000fffff)
13. ip6->ip6_nxt,
payload_len));
14. ndo->ndo_snapend = ipend;
15. advance = sizeof(struct ip6_hdr);
16. if (len < (u_int)advance)
17. cp += advance;
18. nh != IPPROTO_DCCP && nh != IPPROTO_SCTP) {
19. ip6addr_string(ndo, &ip6->ip6_dst)));
20. advance = hbhopt_print(ndo, cp);
21. return;
nh = *cp;
22. advance = dstopt_print(ndo, cp);
23. break;
24. advance = frag6_print(ndo, cp, (const u_char *)ip6);
25. advance = mobility_print(ndo, cp, (const u_char *)ip6);
26. ND_TCHECK(*cp);
advance = rt6_print(ndo, cp, (const u_char *)ip6);
27. case IPPROTO_SCTP:
28. return;
29. tcp_print(ndo, cp, len, (const u_char *)ip6, fragmented);
30. case IPPROTO_ICMPV6:
31. return;
32. if (advance < 0)
return;
33. advance = esp_print(ndo, cp, len, (const u_char *)ip6, &enh, &padlen);
34. case IPPROTO_IPCOMP:
35. ipcomp_print(ndo, cp);
36. case IPPROTO_PIM:
37. return;
38. return;
39. case IPPROTO_IPV6:
40. return;
41. case IPPROTO_RSVP:
rsvp_print(ndo, cp, len);
42. return;
43. return;
44. return;","3-4
6
8-11
13
15-16
18
21-22
24-25
30-31
33
36-37
47-48
55-56
64
67
70
72
77
79
84
86-87
90
94
96
113
119-120
125
130
132
137
139
142-143
149
156
158
169
171
175
177
191
193-194
199
203
207","CWE-264,CWE-125"
hb_set_symmetric_difference-140051460020944,"void
hb_set_symmetric_difference (hb_set_t       *set,
			     const hb_set_t *other)
{
  
  set->symmetric_difference (*other);
}
","1. void
hb_set_symmetric_difference (hb_set_t       *set,
const hb_set_t *other)",1-3,"CWE-125,CWE-787"
object_common1,"
#define UNSERIALIZE_PARAMETER

static inline long object_common1(UNSERIALIZE_PARAMETER, zend_class_entry *ce)
 {
 	long elements;
 
	if( *p >= max - 2) {
		zend_error(E_WARNING, ""Bad unserialize data"");
		return -1;
	}

 	elements = parse_iv2((*p) + 2, p);
 
 	(*p) += 2;

	if (ce->serialize == NULL) {
		object_init_ex(*rval, ce);
	} else {
 		
 		zend_error(E_WARNING, ""Erroneous data format for unserializing '%s'"", ce->name);
		return -1;
 	}
 
 	return elements;
}
","1. static inline long object_common1(UNSERIALIZE_PARAMETER, zend_class_entry *ce)
2. if( *p >= max - 2) {
zend_error(E_WARNING, ""Bad unserialize data"");
3. elements = parse_iv2((*p) + 2, p);
4. if (ce->serialize == NULL) {
object_init_ex(*rval, ce);
} else {
5. return -1;
6. return elements;","4
8-9
13
17-19
23
26","CWE-476,CWE-125,CWE-119"
bgp_capability_orf-165367285886243,"static int
bgp_capability_orf (struct peer *peer, struct capability_header *hdr)
{
  struct stream *s = BGP_INPUT (peer);
  size_t end = stream_get_getp (s) + hdr->length;
  
  assert (stream_get_getp(s) + sizeof(struct capability_orf_entry) <= end);
  
  
  do
    {
      if (bgp_capability_orf_entry (peer, hdr) == -1)
        return -1;
    } 
  while (stream_get_getp(s) + sizeof(struct capability_orf_entry) < end);
  
  return 0;
}
","1. struct stream *s = BGP_INPUT (peer);
size_t end = stream_get_getp (s) + hdr->length;
2. assert (stream_get_getp(s) + sizeof(struct capability_orf_entry) <= end);
3. do
4. if (bgp_capability_orf_entry (peer, hdr) == -1)
return -1;
5. while (stream_get_getp(s) + sizeof(struct capability_orf_entry) < end);","4-5
7
13
15-16
18","CWE-119,CWE-200,CWE-189"
hostap_setup_dev,"void hostap_setup_dev(struct net_device *dev, local_info_t *local,
		      int type)
{
	struct hostap_interface *iface;
 
 	iface = netdev_priv(dev);
 	ether_setup(dev);
	dev->priv_flags &= ~IFF_TX_SKB_SHARING;
 
 	
 	if (iface) {
		
		iface->wireless_data.spy_data = &iface->spy_data;
		dev->wireless_data = &iface->wireless_data;
	}
	dev->wireless_handlers = &hostap_iw_handler_def;
	dev->watchdog_timeo = TX_TIMEOUT;

	switch(type) {
	case HOSTAP_INTERFACE_AP:
		dev->tx_queue_len = 0;	
		dev->netdev_ops = &hostap_mgmt_netdev_ops;
		dev->type = ARPHRD_IEEE80211;
		dev->header_ops = &hostap_80211_ops;
		break;
	case HOSTAP_INTERFACE_MASTER:
		dev->netdev_ops = &hostap_master_ops;
		break;
	default:
		dev->tx_queue_len = 0;	
		dev->netdev_ops = &hostap_netdev_ops;
	}

	dev->mtu = local->mtu;


	SET_ETHTOOL_OPS(dev, &prism2_ethtool_ops);

}
","1. void hostap_setup_dev(struct net_device *dev, local_info_t *local,
2. iface->wireless_data.spy_data = &iface->spy_data;
3. switch(type) {
4. dev->netdev_ops = &hostap_netdev_ops;
5. SET_ETHTOOL_OPS(dev, &prism2_ethtool_ops);","1
14
20
32
38","CWE-362,CWE-264"
qedi_dbg_warn,"qedi_dbg_warn(struct qedi_dbg_ctx *qedi, const char *func, u32 line,
	      const char *fmt, ...)
 {
 	va_list va;
 	struct va_format vaf;
 
 	va_start(va, fmt);
 
	vaf.fmt = fmt;
	vaf.va = &va;

	if (!(qedi_dbg_log & QEDI_LOG_WARN))
		goto ret;
 
 	if (likely(qedi) && likely(qedi->pdev))
 		pr_warn(""[%s]:[%s:%d]:%d: %pV"", dev_name(&qedi->pdev->dev),
			func, line, qedi->host_no, &vaf);
 	else
		pr_warn(""[0000:00:00.0]:[%s:%d]: %pV"", func, line, &vaf);
 
 ret:
 	va_end(va);
}
","1. qedi_dbg_warn(struct qedi_dbg_ctx *qedi, const char *func, u32 line,
const char *fmt, ...)
2. va_list va;
3. vaf.fmt = fmt;
4. if (!(qedi_dbg_log & QEDI_LOG_WARN))
5. pr_warn(""[%s]:[%s:%d]:%d: %pV"", dev_name(&qedi->pdev->dev),
func, line, qedi->host_no, &vaf);
6. pr_warn(""[0000:00:00.0]:[%s:%d]: %pV"", func, line, &vaf);
7. ret:","1-2
4
9
12
16-17
19
21",CWE-125
asn1_read_BOOLEAN_context," bool asn1_read_BOOLEAN_context(struct asn1_data *data, bool *v, int context)
 {
        uint8_t tmp = 0;
       if (!asn1_start_tag(data, ASN1_CONTEXT_SIMPLE(context))) return false;
       *v = false;
       if (!asn1_read_uint8(data, &tmp)) return false;
        if (tmp == 0xFF) {
                *v = true;
        }
       return asn1_end_tag(data);
 }
","1. bool asn1_read_BOOLEAN_context(struct asn1_data *data, bool *v, int context)
2. uint8_t tmp = 0;
if (!asn1_start_tag(data, ASN1_CONTEXT_SIMPLE(context))) return false;
*v = false;
if (!asn1_read_uint8(data, &tmp)) return false;
if (tmp == 0xFF) {
*v = true;
3. return asn1_end_tag(data);","1
3-8
10","CWE-189,CWE-347,CWE-200,CWE-125,CWE-399"
mpls_dev_sysctl_register-4356707973503,"static int mpls_dev_sysctl_register(struct net_device *dev,
				    struct mpls_dev *mdev)
{
	char path[sizeof(""net/mpls/conf/"") + IFNAMSIZ];
	struct net *net = dev_net(dev);
	struct ctl_table *table;
	int i;

	table = kmemdup(&mpls_dev_table, sizeof(mpls_dev_table), GFP_KERNEL);
	if (!table)
		goto out;

	
	for (i = 0; i < ARRAY_SIZE(mpls_dev_table); i++) {
		table[i].data = (char *)mdev + (uintptr_t)table[i].data;
		table[i].extra1 = mdev;
		table[i].extra2 = net;
	}

	snprintf(path, sizeof(path), ""net/mpls/conf/%s"", dev->name);

	mdev->sysctl = register_net_sysctl(net, path, table);
	if (!mdev->sysctl)
		goto free;

	mpls_netconf_notify_devconf(net, RTM_NEWNETCONF, NETCONFA_ALL, mdev);
	return 0;

free:
	kfree(table);
out:
	mdev->sysctl = NULL;
	return -ENOBUFS;
}
","1. struct ctl_table *table;
2. return 0;
3. free:
4. mdev->sysctl = NULL;
return -ENOBUFS;","6
29
31
34-35","CWE-20,CWE-476,CWE-200,CWE-119,CWE-415"
listen_fn_,"
#define UNUSED_ATTR

static void *listen_fn_(UNUSED_ATTR void *context) {

  prctl(PR_SET_NAME, (unsigned long)LISTEN_THREAD_NAME_, 0, 0, 0);

  listen_socket_ = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
 if (listen_socket_ == -1) {
    LOG_ERROR(""%s socket creation failed: %s"", __func__, strerror(errno));
 goto cleanup;
 }

 int enable = 1;
 if (setsockopt(listen_socket_, SOL_SOCKET, SO_REUSEADDR, &enable, sizeof(enable)) == -1) {
    LOG_ERROR(""%s unable to set SO_REUSEADDR: %s"", __func__, strerror(errno));
 goto cleanup;
 }

 struct sockaddr_in addr;
  addr.sin_family = AF_INET;
  addr.sin_addr.s_addr = htonl(LOCALHOST_);
  addr.sin_port = htons(LISTEN_PORT_);
 if (bind(listen_socket_, (struct sockaddr *)&addr, sizeof(addr)) == -1) {
    LOG_ERROR(""%s unable to bind listen socket: %s"", __func__, strerror(errno));
 goto cleanup;
 }

 if (listen(listen_socket_, 10) == -1) {
    LOG_ERROR(""%s unable to listen: %s"", __func__, strerror(errno));
 goto cleanup;

   }
 
   for (;;) {
    int client_socket = TEMP_FAILURE_RETRY(accept(listen_socket_, NULL, NULL));
     if (client_socket == -1) {
       if (errno == EINVAL || errno == EBADF) {
         break;
 }
      LOG_WARN(""%s error accepting socket: %s"", __func__, strerror(errno));
 continue;
 }

 

     pthread_mutex_lock(&client_socket_lock_);
     safe_close_(&client_socket_);
     client_socket_ = client_socket;
    TEMP_FAILURE_RETRY(send(client_socket_, ""btsnoop\0\0\0\0\1\0\0\x3\xea"", 16, 0));
     pthread_mutex_unlock(&client_socket_lock_);
   }
 
cleanup:
  safe_close_(&listen_socket_);
 return NULL;
}
","1. listen_socket_ = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
2. if (bind(listen_socket_, (struct sockaddr *)&addr, sizeof(addr)) == -1) {
3. if (listen(listen_socket_, 10) == -1) {
4. goto cleanup;
5. LOG_WARN(""%s error accepting socket: %s"", __func__, strerror(errno));
6. pthread_mutex_lock(&client_socket_lock_);
safe_close_(&client_socket_);
7. cleanup:
safe_close_(&listen_socket_);","8
24
29
31
41
48-49
55-56","CWE-200,CWE-415,CWE-284,CWE-119"
parseDragons-21465712585074,"
#define RBinFile
#define RBuffer
#define R_OWN

static RCoreSymCacheElement *parseDragons(RBinFile *bf, RBuffer *buf, int off, int bits, R_OWN char *file_name) {
	D eprintf (""Dragons at 0x%x\n"", off);
	st64 size = r_buf_size (buf);
	if (off >= size) {
		return NULL;
	}
	size -= off;
	if (!size) {
		return NULL;
	}
	if (size < 32) {
		return NULL;
	}
	ut8 *b = malloc (size);
	if (!b) {
		return NULL;
	}
	int available = r_buf_read_at (buf, off, b, size);
	if (available != size) {
		eprintf (""Warning: r_buf_read_at failed\n"");
		return NULL;
	}
#if 0
	
	
	
	0x00000138 |1a2b b2a1 0300 0000 1a2b b2a1 e055 0000| .+.......+...U..
                         n_segments ----.          .--- how many sections ?
	0x00000148 |0100 0000 ca55 0000 0400 0000 1800 0000| .....U..........
	             .---- how many symbols? 0xc7
	0x00000158 |c700 0000 0000 0000 0000 0000 0104 0000| ................
	0x00000168 |250b e803 0000 0100 0000 0000 bd55 0000| %............U..
	0x00000178 |91bb e903 e35a b42c 93a4 340a 8746 9489| .....Z.,..4..F..
	0x00000188 |0cea 4c40 0c00 0000 0900 0000 0000 0000| ..L@............
	0x00000198 |0000 0000 0000 0000 0000 0000 0000 0000| ................
	0x000001a8 |0080 0000 0000 0000 5f5f 5445 5854 0000| ........__TEXT..
	0x000001b8 |0000 0000 0000 0000 0080 0000 0000 0000| ................
	0x000001c8 |0040 0000 0000 0000 5f5f 4441 5441 0000| .@......__DATA..
	0x000001d8 |0000 0000 0000 0000 00c0 0000 0000 0000| ................
	0x000001e8 |0000 0100 0000 0000 5f5f 4c4c 564d 0000| ........__LLVM..
	0x000001f8 |0000 0000 0000 0000 00c0 0100 0000 0000| ................
	0x00000208 |00c0 0000 0000 0000 5f5f 4c49 4e4b 4544| ........__LINKED
	0x00000218 |4954 0000 0000 0000 0000 0000 d069 0000| IT...........i..
#endif
	
	int magicCombo = 0;
	if (!memcmp (""\x1a\x2b\xb2\xa1"", b, 4)) { 
		magicCombo++;
	}
	if (!memcmp (""\x1a\x2b\xb2\xa1"", b + 8, 4)) {
		magicCombo++;
	}
	if (magicCombo != 2) {
		
		available = r_buf_read_at (buf, off - 8, b, size);
		if (available != size) {
			eprintf (""Warning: r_buf_read_at failed\n"");
			return NULL;
		}
		if (!memcmp (""\x1a\x2b\xb2\xa1"", b, 4)) { 
			off -= 8;
		} else {
			eprintf (""0x%08x  parsing error: invalid magic retry\n"", off);
		}
	}
	D eprintf (""0x%08x  magic  OK\n"", off);
	D {
		const int e0ss = r_read_le32 (b + 12);
		eprintf (""0x%08x  eoss   0x%x\n"", off + 12, e0ss);
	}
	free (b);
	return r_coresym_cache_element_new (bf, buf, off + 16, bits, file_name);
}
","1. size -= off;
if (!size) {
return NULL;
2. return NULL;
3. return NULL;
4. if (available != size) {
5. return NULL;
6. int magicCombo = 0;
if (!memcmp (""\x1a\x2b\xb2\xa1"", b, 4)) {
magicCombo++;
7. eprintf (""Warning: r_buf_read_at failed\n"");
return NULL;
8. D eprintf (""0x%08x  magic  OK\n"", off);
D {
const int e0ss = r_read_le32 (b + 12);
eprintf (""0x%08x  eoss   0x%x\n"", off + 12, e0ss);
9. free (b);
return r_coresym_cache_element_new (bf, buf, off + 16, bits, file_name);","12-14
17
21
24
26
51-53
62-63
71-74
76-77","CWE-416,CWE-125,CWE-189"
consume_one_event-96121985099877,"static void consume_one_event(unsigned cpu, struct evtchn_loop_ctrl *ctrl,
			      struct evtchn_fifo_control_block *control_block,
			      unsigned priority, unsigned long *ready)
{
	struct evtchn_fifo_queue *q = &per_cpu(cpu_queue, cpu);
	uint32_t head;
	evtchn_port_t port;
	event_word_t *word;

	head = q->head[priority];

	
	if (head == 0) {
		virt_rmb(); 
		head = control_block->head[priority];
	}

	port = head;
	word = event_word_from_port(port);
	head = clear_linked(word);

	
	if (head == 0)
		clear_bit(priority, ready);

	if (evtchn_fifo_is_pending(port) && !evtchn_fifo_is_masked(port)) {
		if (unlikely(!ctrl))
			pr_warn(""Dropping pending event for port %u\n"", port);
		else
			handle_irq_for_port(port, ctrl);
	}

	q->head[priority] = head;
}
","1. struct evtchn_fifo_queue *q = &per_cpu(cpu_queue, cpu);
uint32_t head;
2. word = event_word_from_port(port);
3. if (unlikely(!ctrl))
4. q->head[priority] = head;","5-6
22
36
42","CWE-362,CWE-284,CWE-400"
fr_print,"fr_print(netdissect_options *ndo,
         register const u_char *p, u_int length)
{
	int ret;
	uint16_t extracted_ethertype;
	u_int dlci;
	u_int addr_len;
	uint16_t nlpid;
	u_int hdr_len;
	uint8_t flags[4];

	ret = parse_q922_addr(ndo, p, &dlci, &addr_len, flags, length);
	if (ret == -1)
		goto trunc;
	if (ret == 0) {
		ND_PRINT((ndo, ""Q.922, invalid address""));
		return 0;
	}

	ND_TCHECK(p[addr_len]);
	if (length < addr_len + 1)
		goto trunc;

	if (p[addr_len] != LLC_UI && dlci != 0) {
                
		if (!ND_TTEST2(p[addr_len], 2) || length < addr_len + 2) {
                        
                        ND_PRINT((ndo, ""UI %02x! "", p[addr_len]));
                } else {
                        extracted_ethertype = EXTRACT_16BITS(p+addr_len);

                        if (ndo->ndo_eflag)
                                fr_hdr_print(ndo, length, addr_len, dlci,
                                    flags, extracted_ethertype);

                        if (ethertype_print(ndo, extracted_ethertype,
                                            p+addr_len+ETHERTYPE_LEN,
                                            length-addr_len-ETHERTYPE_LEN,
                                            ndo->ndo_snapend-p-addr_len-ETHERTYPE_LEN,
                                            NULL, NULL) == 0)
                                
                                ND_PRINT((ndo, ""UI %02x! "", p[addr_len]));
                        else
                                return addr_len + 2;
                }
        }

	ND_TCHECK(p[addr_len+1]);
	if (length < addr_len + 2)
		goto trunc;

	if (p[addr_len + 1] == 0) {
		
		if (addr_len != 3)
			ND_PRINT((ndo, ""Pad! ""));
		hdr_len = addr_len + 1  + 1  + 1 ;
	} else {
		
		if (addr_len == 3)
			ND_PRINT((ndo, ""No pad! ""));
		hdr_len = addr_len + 1  + 1 ;
	}

        ND_TCHECK(p[hdr_len - 1]);
	if (length < hdr_len)
		goto trunc;
	nlpid = p[hdr_len - 1];

	if (ndo->ndo_eflag)
		fr_hdr_print(ndo, length, addr_len, dlci, flags, nlpid);
	p += hdr_len;
	length -= hdr_len;

	switch (nlpid) {
	case NLPID_IP:
	        ip_print(ndo, p, length);
		break;

	case NLPID_IP6:
		ip6_print(ndo, p, length);
		break;

 	case NLPID_CLNP:
 	case NLPID_ESIS:
 	case NLPID_ISIS:
		isoclns_print(ndo, p - 1, length + 1); 
 		break;
 
 	case NLPID_SNAP:
		if (snap_print(ndo, p, length, ndo->ndo_snapend - p, NULL, NULL, 0) == 0) {
			
                        if (!ndo->ndo_eflag)
                            fr_hdr_print(ndo, length + hdr_len, hdr_len,
                                         dlci, flags, nlpid);
			if (!ndo->ndo_suppress_default_print)
				ND_DEFAULTPRINT(p - hdr_len, length + hdr_len);
		}
		break;

        case NLPID_Q933:
		q933_print(ndo, p, length);
		break;

        case NLPID_MFR:
                frf15_print(ndo, p, length);
                break;

        case NLPID_PPP:
                ppp_print(ndo, p, length);
                break;

	default:
		if (!ndo->ndo_eflag)
                    fr_hdr_print(ndo, length + hdr_len, addr_len,
				     dlci, flags, nlpid);
		if (!ndo->ndo_xflag)
			ND_DEFAULTPRINT(p, length);
	}

	return hdr_len;

 trunc:
        ND_PRINT((ndo, ""[|fr]""));
        return 0;

}
","1. goto trunc;
if (ret == 0) {
ND_PRINT((ndo, ""Q.922, invalid address""));
2. ND_TCHECK(p[addr_len]);
3. p+addr_len+ETHERTYPE_LEN,
4. return addr_len + 2;
5. ND_TCHECK(p[addr_len+1]);
6. } else {
7. if (addr_len == 3)
ND_PRINT((ndo, ""No pad! ""));
8. nlpid = p[hdr_len - 1];
9. fr_hdr_print(ndo, length, addr_len, dlci, flags, nlpid);
10. ip6_print(ndo, p, length);
11. if (!ndo->ndo_eflag)
12. default:
13. ND_DEFAULTPRINT(p, length);
14. ND_PRINT((ndo, ""[|fr]""));","14-16
20
41
48
52
64
69-70
77
80
90
102
122
127
133","CWE-362,CWE-125,CWE-787"
ed_map-53658967674604,"void ed_map(ed_t p, const uint8_t *msg, size_t len) {
	ed_map_dst(p, msg, len, (const uint8_t *)""RELIC"", 5);
}
","1. void ed_map(ed_t p, const uint8_t *msg, size_t len) {",1,"CWE-190,CWE-264,CWE-284,CWE-416"
_moddeinit," void _moddeinit(module_unload_intent_t intent)
 {
 	service_named_unbind_command(""chanserv"", &cs_flags);

	hook_del_nick_can_register(check_registration_keywords);

	hook_del_user_can_register(check_registration_keywords);

	del_conf_item(""ANOPE_FLAGS_COMPAT"", &chansvs.me->conf_table);
 }
","1. void _moddeinit(module_unload_intent_t intent)
2. service_named_unbind_command(""chanserv"", &cs_flags);
3. hook_del_nick_can_register(check_registration_keywords);
4. hook_del_user_can_register(check_registration_keywords);
5. del_conf_item(""ANOPE_FLAGS_COMPAT"", &chansvs.me->conf_table);","1
3
5
7
9","CWE-200,CWE-20,CWE-284"
bn_set_bit-250742957016678,"void bn_set_bit(bn_t a, size_t bit, int value) {
	int d;

	if (bit < 0) {
		RLC_THROW(ERR_NO_VALID);
		return;
	}

	RLC_RIP(bit, d, bit);

	bn_grow(a, d);

	if (value == 1) {
		a->dp[d] |= ((dig_t)1 << bit);
		if ((d + 1) > a->used) {
			a->used = d + 1;
		}
	} else {
		a->dp[d] &= ~((dig_t)1 << bit);
		bn_trim(a);
	}
}
","1. void bn_set_bit(bn_t a, size_t bit, int value) {
int d;
2. RLC_THROW(ERR_NO_VALID);
3. RLC_RIP(bit, d, bit);
4. bn_grow(a, d);
5. a->dp[d] |= ((dig_t)1 << bit);
6. } else {
a->dp[d] &= ~((dig_t)1 << bit);
bn_trim(a);","1-2
5
9
11
14
18-20",CWE-190
path_name,"char *path_name(const struct name_path *path, const char *name)
{
	const struct name_path *p;
	char *n, *m;
	int nlen = strlen(name);
	int len = nlen + 1;

	for (p = path; p; p = p->up) {
		if (p->elem_len)
			len += p->elem_len + 1;
 	}
 	n = xmalloc(len);
 	m = n + len - (nlen + 1);
	memcpy(m, name, nlen + 1);
 	for (p = path; p; p = p->up) {
 		if (p->elem_len) {
 			m -= p->elem_len + 1;
			memcpy(m, p->elem, p->elem_len);
			m[p->elem_len] = '/';
		}
	}
	return n;
}
","1. char *n, *m;
int nlen = strlen(name);
int len = nlen + 1;
2. n = xmalloc(len);
m = n + len - (nlen + 1);
3. m[p->elem_len] = '/';","4-6
12-13
19","CWE-1284,CWE-190,CWE-125,CWE-119"
gss_get_mic_iov,"
#define OM_uint32

gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
		gss_qop_t qop_req, gss_iov_buffer_desc *iov, int iov_count)
{
    OM_uint32 status;
    gss_union_ctx_id_t ctx;
    gss_mechanism mech;

    status = val_wrap_iov_args(minor_status, context_handle, 0, qop_req, NULL,
			       iov, iov_count);
    if (status != GSS_S_COMPLETE)
	return status;
 
     
     ctx = (gss_union_ctx_id_t)context_handle;
    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)
	return GSS_S_NO_CONTEXT;
     mech = gssint_get_mechanism(ctx->mech_type);
     if (mech == NULL)
 	return GSS_S_BAD_MECH;
    if (mech->gss_get_mic_iov == NULL)
	return GSS_S_UNAVAILABLE;
    status = mech->gss_get_mic_iov(minor_status, ctx->internal_ctx_id, qop_req,
				   iov, iov_count);
    if (status != GSS_S_COMPLETE)
	map_error(minor_status, mech);
    return status;
}
","1. gss_qop_t qop_req, gss_iov_buffer_desc *iov, int iov_count)
2. gss_union_ctx_id_t ctx;
gss_mechanism mech;
3. status = val_wrap_iov_args(minor_status, context_handle, 0, qop_req, NULL,
4. if (mech == NULL)
5. if (mech->gss_get_mic_iov == NULL)
return GSS_S_UNAVAILABLE;
6. iov, iov_count);
7. map_error(minor_status, mech);","5
8-9
11
21
23-24
26
28","CWE-18,CWE-415"
mono_gc_cleanup-24139485918900,"void
mono_gc_cleanup (void)
{
#ifdef DEBUG
	g_message (""%s: cleaning up finalizer"", __func__);
#endif

	if (!gc_disabled) {
		ResetEvent (shutdown_event);
		finished = TRUE;
		if (mono_thread_internal_current () != gc_thread) {
			mono_gc_finalize_notify ();
			
			
			if (WaitForSingleObjectEx (shutdown_event, 2000, FALSE) == WAIT_TIMEOUT) {
				int ret;

				
				suspend_finalizers = TRUE;

				
				mono_thread_internal_stop (gc_thread);

				
				ret = WaitForSingleObjectEx (gc_thread->handle, 100, TRUE);

				if (ret == WAIT_TIMEOUT) {
					
					g_warning (""Shutting down finalizer thread timed out."");
				} else {
					
					Sleep (100);
				}

			}
		}
		gc_thread = NULL;
#ifdef HAVE_BOEHM_GC
		GC_finalizer_notifier = NULL;
#endif
	}

	DeleteCriticalSection (&handle_section);
	DeleteCriticalSection (&allocator_section);
	DeleteCriticalSection (&finalizer_mutex);
	DeleteCriticalSection (&reference_queue_mutex);
}
","1. void
2. if (mono_thread_internal_current () != gc_thread) {
3. int ret;
4. mono_thread_internal_stop (gc_thread);
5. ret = WaitForSingleObjectEx (gc_thread->handle, 100, TRUE);
6. if (ret == WAIT_TIMEOUT) {","1
11
16
22
25
27","CWE-284,CWE-787,CWE-399,CWE-354"
header_seek-186027106079490,"
#define SF_PRIVATE

static void
header_seek (SF_PRIVATE *psf, sf_count_t position, int whence)
{
	switch (whence)
	{	case SEEK_SET :
			if (psf->header.indx + position >= psf->header.len)
				psf_bump_header_allocation (psf, position) ;
			if (position > psf->header.len)
			{	
				psf_fseek (psf, position, whence) ;
				return ;
				} ;
			if (position > psf->header.end)
				psf->header.end += psf_fread (psf->header.ptr + psf->header.end, 1, position - psf->header.end, psf) ;
			psf->header.indx = position ;
			break ;

		case SEEK_CUR :
			if (psf->header.indx + position >= psf->header.len)
				psf_bump_header_allocation (psf, position) ;

			if (psf->header.indx + position < 0)
				break ;

			if (psf->header.indx >= psf->header.len)
			{	psf_fseek (psf, position, whence) ;
				return ;
				} ;

			if (psf->header.indx + position <= psf->header.end)
			{	psf->header.indx += position ;
				break ;
				} ;

			if (psf->header.indx + position > psf->header.len)
			{	
				psf->header.indx = psf->header.end ;
				psf_fseek (psf, position, SEEK_CUR) ;
				break ;
				} ;

			psf->header.end += psf_fread (psf->header.ptr + psf->header.end, 1, position - (psf->header.end - psf->header.indx), psf) ;
			psf->header.indx = psf->header.end ;
			break ;

		case SEEK_END :
		default :
			psf_log_printf (psf, ""Bad whence param in header_seek().\n"") ;
			break ;
		} ;

	return ;
} 
","1. static void
2. if (position > psf->header.len)
3. psf_fseek (psf, position, whence) ;
4. if (position > psf->header.end)
psf->header.end += psf_fread (psf->header.ptr + psf->header.end, 1, position - psf->header.end, psf) ;
psf->header.indx = position ;
5. case SEEK_CUR :
if (psf->header.indx + position >= psf->header.len)
psf_bump_header_allocation (psf, position) ;
6. if (psf->header.indx >= psf->header.len)
{	psf_fseek (psf, position, whence) ;
return ;
7. if (psf->header.indx + position <= psf->header.end)
8. if (psf->header.indx + position > psf->header.len)
9. psf->header.indx = psf->header.end ;
psf_fseek (psf, position, SEEK_CUR) ;
break ;
10. psf->header.end += psf_fread (psf->header.ptr + psf->header.end, 1, position - (psf->header.end - psf->header.indx), psf) ;
psf->header.indx = psf->header.end ;
break ;
11. case SEEK_END :
default :
psf_log_printf (psf, ""Bad whence param in header_seek().\n"") ;
break ;
12. return ;","4
11
13
16-18
21-23
28-30
33
38
40-42
45-47
49-52
55","CWE-369,CWE-125,CWE-119"
nfsd4_encode_fattr,"nfsd4_encode_fattr(struct xdr_stream *xdr, struct svc_fh *fhp,
		struct svc_export *exp,
		struct dentry *dentry, u32 *bmval,
		struct svc_rqst *rqstp, int ignore_crossmnt)
{
	u32 bmval0 = bmval[0];
	u32 bmval1 = bmval[1];
	u32 bmval2 = bmval[2];
	struct kstat stat;
	struct svc_fh *tempfh = NULL;
	struct kstatfs statfs;
	__be32 *p;
	int starting_len = xdr->buf->len;
	int attrlen_offset;
	__be32 attrlen;
	u32 dummy;
	u64 dummy64;
	u32 rdattr_err = 0;
	__be32 status;
	int err;
	struct nfs4_acl *acl = NULL;
	void *context = NULL;
	int contextlen;
	bool contextsupport = false;
	struct nfsd4_compoundres *resp = rqstp->rq_resp;
	u32 minorversion = resp->cstate.minorversion;
	struct path path = {
		.mnt	= exp->ex_path.mnt,
		.dentry	= dentry,
	};
	struct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);

	BUG_ON(bmval1 & NFSD_WRITEONLY_ATTRS_WORD1);
	BUG_ON(!nfsd_attrs_supported(minorversion, bmval));

	if (exp->ex_fslocs.migrated) {
		status = fattr_handle_absent_fs(&bmval0, &bmval1, &bmval2, &rdattr_err);
		if (status)
			goto out;
	}

	err = vfs_getattr(&path, &stat, STATX_BASIC_STATS, AT_STATX_SYNC_AS_STAT);
	if (err)
		goto out_nfserr;
	if ((bmval0 & (FATTR4_WORD0_FILES_AVAIL | FATTR4_WORD0_FILES_FREE |
			FATTR4_WORD0_FILES_TOTAL | FATTR4_WORD0_MAXNAME)) ||
	    (bmval1 & (FATTR4_WORD1_SPACE_AVAIL | FATTR4_WORD1_SPACE_FREE |
		       FATTR4_WORD1_SPACE_TOTAL))) {
		err = vfs_statfs(&path, &statfs);
		if (err)
			goto out_nfserr;
	}
	if ((bmval0 & (FATTR4_WORD0_FILEHANDLE | FATTR4_WORD0_FSID)) && !fhp) {
		tempfh = kmalloc(sizeof(struct svc_fh), GFP_KERNEL);
		status = nfserr_jukebox;
		if (!tempfh)
			goto out;
		fh_init(tempfh, NFS4_FHSIZE);
		status = fh_compose(tempfh, exp, dentry, NULL);
		if (status)
			goto out;
		fhp = tempfh;
	}
	if (bmval0 & FATTR4_WORD0_ACL) {
		err = nfsd4_get_nfs4_acl(rqstp, dentry, &acl);
		if (err == -EOPNOTSUPP)
			bmval0 &= ~FATTR4_WORD0_ACL;
		else if (err == -EINVAL) {
			status = nfserr_attrnotsupp;
			goto out;
		} else if (err != 0)
			goto out_nfserr;
	}

#ifdef CONFIG_NFSD_V4_SECURITY_LABEL
	if ((bmval2 & FATTR4_WORD2_SECURITY_LABEL) ||
	     bmval0 & FATTR4_WORD0_SUPPORTED_ATTRS) {
		if (exp->ex_flags & NFSEXP_SECURITY_LABEL)
			err = security_inode_getsecctx(d_inode(dentry),
						&context, &contextlen);
		else
			err = -EOPNOTSUPP;
		contextsupport = (err == 0);
		if (bmval2 & FATTR4_WORD2_SECURITY_LABEL) {
			if (err == -EOPNOTSUPP)
				bmval2 &= ~FATTR4_WORD2_SECURITY_LABEL;
			else if (err)
				goto out_nfserr;
		}
	}
#endif 

	status = nfsd4_encode_bitmap(xdr, bmval0, bmval1, bmval2);
	if (status)
		goto out;

	attrlen_offset = xdr->buf->len;
	p = xdr_reserve_space(xdr, 4);
	if (!p)
		goto out_resource;
	p++;                

	if (bmval0 & FATTR4_WORD0_SUPPORTED_ATTRS) {
		u32 supp[3];

		memcpy(supp, nfsd_suppattrs[minorversion], sizeof(supp));

		if (!IS_POSIXACL(dentry->d_inode))
			supp[0] &= ~FATTR4_WORD0_ACL;
		if (!contextsupport)
			supp[2] &= ~FATTR4_WORD2_SECURITY_LABEL;
		if (!supp[2]) {
			p = xdr_reserve_space(xdr, 12);
			if (!p)
				goto out_resource;
			*p++ = cpu_to_be32(2);
			*p++ = cpu_to_be32(supp[0]);
			*p++ = cpu_to_be32(supp[1]);
		} else {
			p = xdr_reserve_space(xdr, 16);
			if (!p)
				goto out_resource;
			*p++ = cpu_to_be32(3);
			*p++ = cpu_to_be32(supp[0]);
			*p++ = cpu_to_be32(supp[1]);
			*p++ = cpu_to_be32(supp[2]);
		}
	}
	if (bmval0 & FATTR4_WORD0_TYPE) {
		p = xdr_reserve_space(xdr, 4);
		if (!p)
			goto out_resource;
		dummy = nfs4_file_type(stat.mode);
		if (dummy == NF4BAD) {
			status = nfserr_serverfault;
			goto out;
		}
		*p++ = cpu_to_be32(dummy);
	}
	if (bmval0 & FATTR4_WORD0_FH_EXPIRE_TYPE) {
		p = xdr_reserve_space(xdr, 4);
		if (!p)
			goto out_resource;
		if (exp->ex_flags & NFSEXP_NOSUBTREECHECK)
			*p++ = cpu_to_be32(NFS4_FH_PERSISTENT);
		else
			*p++ = cpu_to_be32(NFS4_FH_PERSISTENT|
						NFS4_FH_VOL_RENAME);
	}
	if (bmval0 & FATTR4_WORD0_CHANGE) {
		p = xdr_reserve_space(xdr, 8);
		if (!p)
			goto out_resource;
		p = encode_change(p, &stat, d_inode(dentry), exp);
	}
	if (bmval0 & FATTR4_WORD0_SIZE) {
		p = xdr_reserve_space(xdr, 8);
		if (!p)
			goto out_resource;
		p = xdr_encode_hyper(p, stat.size);
	}
	if (bmval0 & FATTR4_WORD0_LINK_SUPPORT) {
		p = xdr_reserve_space(xdr, 4);
		if (!p)
			goto out_resource;
		*p++ = cpu_to_be32(1);
	}
	if (bmval0 & FATTR4_WORD0_SYMLINK_SUPPORT) {
		p = xdr_reserve_space(xdr, 4);
		if (!p)
			goto out_resource;
		*p++ = cpu_to_be32(1);
	}
	if (bmval0 & FATTR4_WORD0_NAMED_ATTR) {
		p = xdr_reserve_space(xdr, 4);
		if (!p)
			goto out_resource;
		*p++ = cpu_to_be32(0);
	}
	if (bmval0 & FATTR4_WORD0_FSID) {
		p = xdr_reserve_space(xdr, 16);
		if (!p)
			goto out_resource;
		if (exp->ex_fslocs.migrated) {
			p = xdr_encode_hyper(p, NFS4_REFERRAL_FSID_MAJOR);
			p = xdr_encode_hyper(p, NFS4_REFERRAL_FSID_MINOR);
		} else switch(fsid_source(fhp)) {
		case FSIDSOURCE_FSID:
			p = xdr_encode_hyper(p, (u64)exp->ex_fsid);
			p = xdr_encode_hyper(p, (u64)0);
			break;
		case FSIDSOURCE_DEV:
			*p++ = cpu_to_be32(0);
			*p++ = cpu_to_be32(MAJOR(stat.dev));
			*p++ = cpu_to_be32(0);
			*p++ = cpu_to_be32(MINOR(stat.dev));
			break;
		case FSIDSOURCE_UUID:
			p = xdr_encode_opaque_fixed(p, exp->ex_uuid,
								EX_UUID_LEN);
			break;
		}
	}
	if (bmval0 & FATTR4_WORD0_UNIQUE_HANDLES) {
		p = xdr_reserve_space(xdr, 4);
		if (!p)
			goto out_resource;
		*p++ = cpu_to_be32(0);
	}
	if (bmval0 & FATTR4_WORD0_LEASE_TIME) {
		p = xdr_reserve_space(xdr, 4);
		if (!p)
			goto out_resource;
		*p++ = cpu_to_be32(nn->nfsd4_lease);
	}
	if (bmval0 & FATTR4_WORD0_RDATTR_ERROR) {
		p = xdr_reserve_space(xdr, 4);
		if (!p)
			goto out_resource;
		*p++ = cpu_to_be32(rdattr_err);
	}
	if (bmval0 & FATTR4_WORD0_ACL) {
		struct nfs4_ace *ace;

		if (acl == NULL) {
			p = xdr_reserve_space(xdr, 4);
			if (!p)
				goto out_resource;

			*p++ = cpu_to_be32(0);
			goto out_acl;
		}
		p = xdr_reserve_space(xdr, 4);
		if (!p)
			goto out_resource;
		*p++ = cpu_to_be32(acl->naces);

		for (ace = acl->aces; ace < acl->aces + acl->naces; ace++) {
			p = xdr_reserve_space(xdr, 4*3);
			if (!p)
				goto out_resource;
			*p++ = cpu_to_be32(ace->type);
			*p++ = cpu_to_be32(ace->flag);
			*p++ = cpu_to_be32(ace->access_mask &
							NFS4_ACE_MASK_ALL);
			status = nfsd4_encode_aclname(xdr, rqstp, ace);
			if (status)
				goto out;
		}
	}
out_acl:
	if (bmval0 & FATTR4_WORD0_ACLSUPPORT) {
		p = xdr_reserve_space(xdr, 4);
		if (!p)
			goto out_resource;
		*p++ = cpu_to_be32(IS_POSIXACL(dentry->d_inode) ?
			ACL4_SUPPORT_ALLOW_ACL|ACL4_SUPPORT_DENY_ACL : 0);
	}
	if (bmval0 & FATTR4_WORD0_CANSETTIME) {
		p = xdr_reserve_space(xdr, 4);
		if (!p)
			goto out_resource;
		*p++ = cpu_to_be32(1);
	}
	if (bmval0 & FATTR4_WORD0_CASE_INSENSITIVE) {
		p = xdr_reserve_space(xdr, 4);
		if (!p)
			goto out_resource;
		*p++ = cpu_to_be32(0);
	}
	if (bmval0 & FATTR4_WORD0_CASE_PRESERVING) {
		p = xdr_reserve_space(xdr, 4);
		if (!p)
			goto out_resource;
		*p++ = cpu_to_be32(1);
	}
	if (bmval0 & FATTR4_WORD0_CHOWN_RESTRICTED) {
		p = xdr_reserve_space(xdr, 4);
		if (!p)
			goto out_resource;
		*p++ = cpu_to_be32(1);
	}
	if (bmval0 & FATTR4_WORD0_FILEHANDLE) {
		p = xdr_reserve_space(xdr, fhp->fh_handle.fh_size + 4);
		if (!p)
			goto out_resource;
		p = xdr_encode_opaque(p, &fhp->fh_handle.fh_base,
					fhp->fh_handle.fh_size);
	}
	if (bmval0 & FATTR4_WORD0_FILEID) {
		p = xdr_reserve_space(xdr, 8);
		if (!p)
			goto out_resource;
		p = xdr_encode_hyper(p, stat.ino);
	}
	if (bmval0 & FATTR4_WORD0_FILES_AVAIL) {
		p = xdr_reserve_space(xdr, 8);
		if (!p)
			goto out_resource;
		p = xdr_encode_hyper(p, (u64) statfs.f_ffree);
	}
	if (bmval0 & FATTR4_WORD0_FILES_FREE) {
		p = xdr_reserve_space(xdr, 8);
		if (!p)
			goto out_resource;
		p = xdr_encode_hyper(p, (u64) statfs.f_ffree);
	}
	if (bmval0 & FATTR4_WORD0_FILES_TOTAL) {
		p = xdr_reserve_space(xdr, 8);
		if (!p)
			goto out_resource;
		p = xdr_encode_hyper(p, (u64) statfs.f_files);
	}
	if (bmval0 & FATTR4_WORD0_FS_LOCATIONS) {
		status = nfsd4_encode_fs_locations(xdr, rqstp, exp);
		if (status)
			goto out;
	}
	if (bmval0 & FATTR4_WORD0_HOMOGENEOUS) {
		p = xdr_reserve_space(xdr, 4);
		if (!p)
			goto out_resource;
		*p++ = cpu_to_be32(1);
	}
	if (bmval0 & FATTR4_WORD0_MAXFILESIZE) {
		p = xdr_reserve_space(xdr, 8);
		if (!p)
			goto out_resource;
		p = xdr_encode_hyper(p, exp->ex_path.mnt->mnt_sb->s_maxbytes);
	}
	if (bmval0 & FATTR4_WORD0_MAXLINK) {
		p = xdr_reserve_space(xdr, 4);
		if (!p)
			goto out_resource;
		*p++ = cpu_to_be32(255);
	}
	if (bmval0 & FATTR4_WORD0_MAXNAME) {
		p = xdr_reserve_space(xdr, 4);
		if (!p)
			goto out_resource;
		*p++ = cpu_to_be32(statfs.f_namelen);
	}
	if (bmval0 & FATTR4_WORD0_MAXREAD) {
		p = xdr_reserve_space(xdr, 8);
		if (!p)
			goto out_resource;
		p = xdr_encode_hyper(p, (u64) svc_max_payload(rqstp));
	}
	if (bmval0 & FATTR4_WORD0_MAXWRITE) {
		p = xdr_reserve_space(xdr, 8);
		if (!p)
			goto out_resource;
		p = xdr_encode_hyper(p, (u64) svc_max_payload(rqstp));
	}
	if (bmval1 & FATTR4_WORD1_MODE) {
		p = xdr_reserve_space(xdr, 4);
		if (!p)
			goto out_resource;
		*p++ = cpu_to_be32(stat.mode & S_IALLUGO);
	}
	if (bmval1 & FATTR4_WORD1_NO_TRUNC) {
		p = xdr_reserve_space(xdr, 4);
		if (!p)
			goto out_resource;
		*p++ = cpu_to_be32(1);
	}
	if (bmval1 & FATTR4_WORD1_NUMLINKS) {
		p = xdr_reserve_space(xdr, 4);
		if (!p)
			goto out_resource;
		*p++ = cpu_to_be32(stat.nlink);
	}
	if (bmval1 & FATTR4_WORD1_OWNER) {
		status = nfsd4_encode_user(xdr, rqstp, stat.uid);
		if (status)
			goto out;
	}
	if (bmval1 & FATTR4_WORD1_OWNER_GROUP) {
		status = nfsd4_encode_group(xdr, rqstp, stat.gid);
		if (status)
			goto out;
	}
	if (bmval1 & FATTR4_WORD1_RAWDEV) {
		p = xdr_reserve_space(xdr, 8);
		if (!p)
			goto out_resource;
		*p++ = cpu_to_be32((u32) MAJOR(stat.rdev));
		*p++ = cpu_to_be32((u32) MINOR(stat.rdev));
	}
	if (bmval1 & FATTR4_WORD1_SPACE_AVAIL) {
		p = xdr_reserve_space(xdr, 8);
		if (!p)
			goto out_resource;
		dummy64 = (u64)statfs.f_bavail * (u64)statfs.f_bsize;
		p = xdr_encode_hyper(p, dummy64);
	}
	if (bmval1 & FATTR4_WORD1_SPACE_FREE) {
		p = xdr_reserve_space(xdr, 8);
		if (!p)
			goto out_resource;
		dummy64 = (u64)statfs.f_bfree * (u64)statfs.f_bsize;
		p = xdr_encode_hyper(p, dummy64);
	}
	if (bmval1 & FATTR4_WORD1_SPACE_TOTAL) {
		p = xdr_reserve_space(xdr, 8);
		if (!p)
			goto out_resource;
		dummy64 = (u64)statfs.f_blocks * (u64)statfs.f_bsize;
		p = xdr_encode_hyper(p, dummy64);
	}
	if (bmval1 & FATTR4_WORD1_SPACE_USED) {
		p = xdr_reserve_space(xdr, 8);
		if (!p)
			goto out_resource;
		dummy64 = (u64)stat.blocks << 9;
		p = xdr_encode_hyper(p, dummy64);
	}
	if (bmval1 & FATTR4_WORD1_TIME_ACCESS) {
		p = xdr_reserve_space(xdr, 12);
		if (!p)
			goto out_resource;
		p = xdr_encode_hyper(p, (s64)stat.atime.tv_sec);
		*p++ = cpu_to_be32(stat.atime.tv_nsec);
	}
	if (bmval1 & FATTR4_WORD1_TIME_DELTA) {
		p = xdr_reserve_space(xdr, 12);
		if (!p)
			goto out_resource;
		*p++ = cpu_to_be32(0);
		*p++ = cpu_to_be32(1);
		*p++ = cpu_to_be32(0);
	}
	if (bmval1 & FATTR4_WORD1_TIME_METADATA) {
		p = xdr_reserve_space(xdr, 12);
		if (!p)
			goto out_resource;
		p = xdr_encode_hyper(p, (s64)stat.ctime.tv_sec);
		*p++ = cpu_to_be32(stat.ctime.tv_nsec);
	}
	if (bmval1 & FATTR4_WORD1_TIME_MODIFY) {
		p = xdr_reserve_space(xdr, 12);
		if (!p)
			goto out_resource;
		p = xdr_encode_hyper(p, (s64)stat.mtime.tv_sec);
		*p++ = cpu_to_be32(stat.mtime.tv_nsec);
	}
	if (bmval1 & FATTR4_WORD1_MOUNTED_ON_FILEID) {
		struct kstat parent_stat;
		u64 ino = stat.ino;

		p = xdr_reserve_space(xdr, 8);
		if (!p)
                	goto out_resource;
		
		if (ignore_crossmnt == 0 &&
		    dentry == exp->ex_path.mnt->mnt_root) {
			err = get_parent_attributes(exp, &parent_stat);
			if (err)
				goto out_nfserr;
			ino = parent_stat.ino;
		}
		p = xdr_encode_hyper(p, ino);
	}
#ifdef CONFIG_NFSD_PNFS
	if (bmval1 & FATTR4_WORD1_FS_LAYOUT_TYPES) {
		status = nfsd4_encode_layout_types(xdr, exp->ex_layout_types);
		if (status)
			goto out;
	}

	if (bmval2 & FATTR4_WORD2_LAYOUT_TYPES) {
		status = nfsd4_encode_layout_types(xdr, exp->ex_layout_types);
		if (status)
			goto out;
	}

	if (bmval2 & FATTR4_WORD2_LAYOUT_BLKSIZE) {
		p = xdr_reserve_space(xdr, 4);
		if (!p)
			goto out_resource;
		*p++ = cpu_to_be32(stat.blksize);
 	}
 #endif 
 	if (bmval2 & FATTR4_WORD2_SUPPATTR_EXCLCREAT) {
		u32 supp[3];

		memcpy(supp, nfsd_suppattrs[minorversion], sizeof(supp));
		supp[0] &= NFSD_SUPPATTR_EXCLCREAT_WORD0;
		supp[1] &= NFSD_SUPPATTR_EXCLCREAT_WORD1;
		supp[2] &= NFSD_SUPPATTR_EXCLCREAT_WORD2;

		status = nfsd4_encode_bitmap(xdr, supp[0], supp[1], supp[2]);
 		if (status)
 			goto out;
 	}

	if (bmval2 & FATTR4_WORD2_SECURITY_LABEL) {
		status = nfsd4_encode_security_label(xdr, rqstp, context,
								contextlen);
		if (status)
			goto out;
	}

	attrlen = htonl(xdr->buf->len - attrlen_offset - 4);
	write_bytes_to_xdr_buf(xdr->buf, attrlen_offset, &attrlen, 4);
	status = nfs_ok;

out:
#ifdef CONFIG_NFSD_V4_SECURITY_LABEL
	if (context)
		security_release_secctx(context, contextlen);
#endif 
	kfree(acl);
	if (tempfh) {
		fh_put(tempfh);
		kfree(tempfh);
	}
	if (status)
		xdr_truncate_encode(xdr, starting_len);
	return status;
out_nfserr:
	status = nfserrno(err);
	goto out;
out_resource:
	status = nfserr_resource;
	goto out;
}
","1. nfsd4_encode_fattr(struct xdr_stream *xdr, struct svc_fh *fhp,
2. struct kstat stat;
3. int starting_len = xdr->buf->len;
4. __be32 attrlen;
5. u64 dummy64;
6. status = fattr_handle_absent_fs(&bmval0, &bmval1, &bmval2, &rdattr_err);
7. err = vfs_getattr(&path, &stat, STATX_BASIC_STATS, AT_STATX_SYNC_AS_STAT);
8. FATTR4_WORD1_SPACE_TOTAL))) {
9. if (err)
10. if ((bmval0 & (FATTR4_WORD0_FILEHANDLE | FATTR4_WORD0_FSID)) && !fhp) {
11. if (!tempfh)
12. fh_init(tempfh, NFS4_FHSIZE);
13. goto out;
14. else if (err == -EINVAL) {
status = nfserr_attrnotsupp;
15. status = nfsd4_encode_bitmap(xdr, bmval0, bmval1, bmval2);
16. } else {
17. goto out_resource;
18. if (!p)
19. if (bmval0 & FATTR4_WORD0_SIZE) {
20. if (!p)
goto out_resource;
p = xdr_encode_hyper(p, stat.size);
21. p = xdr_reserve_space(xdr, 4);
if (!p)
22. p = xdr_reserve_space(xdr, 4);
23. if (bmval0 & FATTR4_WORD0_NAMED_ATTR) {
24. if (!p)
goto out_resource;
*p++ = cpu_to_be32(0);
25. if (!p)
26. case FSIDSOURCE_UUID:
27. *p++ = cpu_to_be32(0);
28. goto out_resource;
*p++ = cpu_to_be32(nn->nfsd4_lease);
29. goto out_resource;
30. if (!p)
31. p = xdr_reserve_space(xdr, 4*3);
32. *p++ = cpu_to_be32(ace->access_mask &
33. status = nfsd4_encode_aclname(xdr, rqstp, ace);
34. if (!p)
goto out_resource;
*p++ = cpu_to_be32(IS_POSIXACL(dentry->d_inode) ?
ACL4_SUPPORT_ALLOW_ACL|ACL4_SUPPORT_DENY_ACL : 0);
35. if (bmval0 & FATTR4_WORD0_CASE_PRESERVING) {
p = xdr_reserve_space(xdr, 4);
36. goto out_resource;
37. *p++ = cpu_to_be32(1);
38. if (!p)
39. if (bmval0 & FATTR4_WORD0_FILEID) {
p = xdr_reserve_space(xdr, 8);
40. p = xdr_encode_hyper(p, stat.ino);
41. p = xdr_reserve_space(xdr, 8);
42. if (!p)
43. if (status)
44. p = xdr_reserve_space(xdr, 4);
45. if (!p)
46. *p++ = cpu_to_be32(statfs.f_namelen);
47. goto out_resource;
48. if (bmval1 & FATTR4_WORD1_MODE) {
p = xdr_reserve_space(xdr, 4);
if (!p)
49. if (bmval1 & FATTR4_WORD1_NO_TRUNC) {
50. goto out_resource;
51. if (bmval1 & FATTR4_WORD1_NUMLINKS) {
52. if (bmval1 & FATTR4_WORD1_SPACE_AVAIL) {
53. goto out_resource;
54. if (bmval1 & FATTR4_WORD1_TIME_DELTA) {
55. *p++ = cpu_to_be32(0);
56. u64 ino = stat.ino;
57. goto out_resource;
58. if (err)
59. p = xdr_encode_hyper(p, ino);
60. supp[2] &= NFSD_SUPPATTR_EXCLCREAT_WORD2;
61. attrlen = htonl(xdr->buf->len - attrlen_offset - 4);
62. out:
63. fh_put(tempfh);
kfree(tempfh);
64. if (status)
65. out_nfserr:","1
9
13
15
17
37
42
48
50
53
56
58
61
68-69
93
119
143
152
156
158-160
163-164
169
174
176-178
182
198
208
213-214
228
234
239
244
246
254-257
271-272
274
281
285
290-291
294
297
310
316
332
339
341
352
355-357
361
364
367
390
400
425
431
449
453
461
465
493
507
511
518-519
521
524","CWE-190,CWE-200,CWE-20"
bmp_read_info_header,"
#define FILE
#define IN
#define OPJ_BITMAPINFOHEADER

static OPJ_BOOL bmp_read_info_header(FILE* IN, OPJ_BITMAPINFOHEADER* header)
{
    memset(header, 0, sizeof(*header));
    
    
    header->biSize  = (OPJ_UINT32)getc(IN);
    header->biSize |= (OPJ_UINT32)getc(IN) << 8;
    header->biSize |= (OPJ_UINT32)getc(IN) << 16;
    header->biSize |= (OPJ_UINT32)getc(IN) << 24;

    switch (header->biSize) {
    case 12U:  
    case 40U:  
    case 52U:  
    case 56U:  
    case 108U: 
    case 124U: 
        break;
    default:
        fprintf(stderr, ""Error, unknown BMP header size %d\n"", header->biSize);
        return OPJ_FALSE;
    }

    header->biWidth  = (OPJ_UINT32)getc(IN);
    header->biWidth |= (OPJ_UINT32)getc(IN) << 8;
    header->biWidth |= (OPJ_UINT32)getc(IN) << 16;
    header->biWidth |= (OPJ_UINT32)getc(IN) << 24;

    header->biHeight  = (OPJ_UINT32)getc(IN);
    header->biHeight |= (OPJ_UINT32)getc(IN) << 8;
    header->biHeight |= (OPJ_UINT32)getc(IN) << 16;
    header->biHeight |= (OPJ_UINT32)getc(IN) << 24;

    header->biPlanes  = (OPJ_UINT16)getc(IN);
    header->biPlanes |= (OPJ_UINT16)((OPJ_UINT32)getc(IN) << 8);
 
     header->biBitCount  = (OPJ_UINT16)getc(IN);
     header->biBitCount |= (OPJ_UINT16)((OPJ_UINT32)getc(IN) << 8);
    if (header->biBitCount == 0) {
        fprintf(stderr, ""Error, invalid biBitCount %d\n"", 0);
        return OPJ_FALSE;
    }
 
     if (header->biSize >= 40U) {
         header->biCompression  = (OPJ_UINT32)getc(IN);
        header->biCompression |= (OPJ_UINT32)getc(IN) << 8;
        header->biCompression |= (OPJ_UINT32)getc(IN) << 16;
        header->biCompression |= (OPJ_UINT32)getc(IN) << 24;

        header->biSizeImage  = (OPJ_UINT32)getc(IN);
        header->biSizeImage |= (OPJ_UINT32)getc(IN) << 8;
        header->biSizeImage |= (OPJ_UINT32)getc(IN) << 16;
        header->biSizeImage |= (OPJ_UINT32)getc(IN) << 24;

        header->biXpelsPerMeter  = (OPJ_UINT32)getc(IN);
        header->biXpelsPerMeter |= (OPJ_UINT32)getc(IN) << 8;
        header->biXpelsPerMeter |= (OPJ_UINT32)getc(IN) << 16;
        header->biXpelsPerMeter |= (OPJ_UINT32)getc(IN) << 24;

        header->biYpelsPerMeter  = (OPJ_UINT32)getc(IN);
        header->biYpelsPerMeter |= (OPJ_UINT32)getc(IN) << 8;
        header->biYpelsPerMeter |= (OPJ_UINT32)getc(IN) << 16;
        header->biYpelsPerMeter |= (OPJ_UINT32)getc(IN) << 24;

        header->biClrUsed  = (OPJ_UINT32)getc(IN);
        header->biClrUsed |= (OPJ_UINT32)getc(IN) << 8;
        header->biClrUsed |= (OPJ_UINT32)getc(IN) << 16;
        header->biClrUsed |= (OPJ_UINT32)getc(IN) << 24;

        header->biClrImportant  = (OPJ_UINT32)getc(IN);
        header->biClrImportant |= (OPJ_UINT32)getc(IN) << 8;
        header->biClrImportant |= (OPJ_UINT32)getc(IN) << 16;
        header->biClrImportant |= (OPJ_UINT32)getc(IN) << 24;
    }

    if (header->biSize >= 56U) {
        header->biRedMask  = (OPJ_UINT32)getc(IN);
        header->biRedMask |= (OPJ_UINT32)getc(IN) << 8;
        header->biRedMask |= (OPJ_UINT32)getc(IN) << 16;
        header->biRedMask |= (OPJ_UINT32)getc(IN) << 24;

        header->biGreenMask  = (OPJ_UINT32)getc(IN);
        header->biGreenMask |= (OPJ_UINT32)getc(IN) << 8;
        header->biGreenMask |= (OPJ_UINT32)getc(IN) << 16;
        header->biGreenMask |= (OPJ_UINT32)getc(IN) << 24;

        header->biBlueMask  = (OPJ_UINT32)getc(IN);
        header->biBlueMask |= (OPJ_UINT32)getc(IN) << 8;
        header->biBlueMask |= (OPJ_UINT32)getc(IN) << 16;
        header->biBlueMask |= (OPJ_UINT32)getc(IN) << 24;

        header->biAlphaMask  = (OPJ_UINT32)getc(IN);
        header->biAlphaMask |= (OPJ_UINT32)getc(IN) << 8;
        header->biAlphaMask |= (OPJ_UINT32)getc(IN) << 16;
        header->biAlphaMask |= (OPJ_UINT32)getc(IN) << 24;
    }

    if (header->biSize >= 108U) {
        header->biColorSpaceType  = (OPJ_UINT32)getc(IN);
        header->biColorSpaceType |= (OPJ_UINT32)getc(IN) << 8;
        header->biColorSpaceType |= (OPJ_UINT32)getc(IN) << 16;
        header->biColorSpaceType |= (OPJ_UINT32)getc(IN) << 24;

        if (fread(&(header->biColorSpaceEP), 1U, sizeof(header->biColorSpaceEP),
                  IN) != sizeof(header->biColorSpaceEP)) {
            fprintf(stderr, ""Error, can't  read BMP header\n"");
            return OPJ_FALSE;
        }

        header->biRedGamma  = (OPJ_UINT32)getc(IN);
        header->biRedGamma |= (OPJ_UINT32)getc(IN) << 8;
        header->biRedGamma |= (OPJ_UINT32)getc(IN) << 16;
        header->biRedGamma |= (OPJ_UINT32)getc(IN) << 24;

        header->biGreenGamma  = (OPJ_UINT32)getc(IN);
        header->biGreenGamma |= (OPJ_UINT32)getc(IN) << 8;
        header->biGreenGamma |= (OPJ_UINT32)getc(IN) << 16;
        header->biGreenGamma |= (OPJ_UINT32)getc(IN) << 24;

        header->biBlueGamma  = (OPJ_UINT32)getc(IN);
        header->biBlueGamma |= (OPJ_UINT32)getc(IN) << 8;
        header->biBlueGamma |= (OPJ_UINT32)getc(IN) << 16;
        header->biBlueGamma |= (OPJ_UINT32)getc(IN) << 24;
    }

    if (header->biSize >= 124U) {
        header->biIntent  = (OPJ_UINT32)getc(IN);
        header->biIntent |= (OPJ_UINT32)getc(IN) << 8;
        header->biIntent |= (OPJ_UINT32)getc(IN) << 16;
        header->biIntent |= (OPJ_UINT32)getc(IN) << 24;

        header->biIccProfileData  = (OPJ_UINT32)getc(IN);
        header->biIccProfileData |= (OPJ_UINT32)getc(IN) << 8;
        header->biIccProfileData |= (OPJ_UINT32)getc(IN) << 16;
        header->biIccProfileData |= (OPJ_UINT32)getc(IN) << 24;

        header->biIccProfileSize  = (OPJ_UINT32)getc(IN);
        header->biIccProfileSize |= (OPJ_UINT32)getc(IN) << 8;
        header->biIccProfileSize |= (OPJ_UINT32)getc(IN) << 16;
        header->biIccProfileSize |= (OPJ_UINT32)getc(IN) << 24;

        header->biReserved  = (OPJ_UINT32)getc(IN);
        header->biReserved |= (OPJ_UINT32)getc(IN) << 8;
        header->biReserved |= (OPJ_UINT32)getc(IN) << 16;
        header->biReserved |= (OPJ_UINT32)getc(IN) << 24;
    }
    return OPJ_TRUE;
}
","1. fprintf(stderr, ""Error, unknown BMP header size %d\n"", header->biSize);
2. header->biHeight |= (OPJ_UINT32)getc(IN) << 8;
3. header->biPlanes |= (OPJ_UINT16)((OPJ_UINT32)getc(IN) << 8);
4. header->biRedMask |= (OPJ_UINT32)getc(IN) << 24;
5. header->biGreenGamma  = (OPJ_UINT32)getc(IN);
6. header->biIccProfileData |= (OPJ_UINT32)getc(IN) << 16;
7. header->biReserved |= (OPJ_UINT32)getc(IN) << 8;","25
35
40
85
120
139
148","CWE-476,CWE-20,CWE-787,CWE-119"
path_openat-210673271919392,"static struct file *path_openat(int dfd, struct filename *pathname,
		struct nameidata *nd, const struct open_flags *op, int flags)
{
	struct file *file;
	struct path path;
	int opened = 0;
	int error;

	file = get_empty_filp();
	if (IS_ERR(file))
		return file;

	file->f_flags = op->open_flag;

	if (unlikely(file->f_flags & __O_TMPFILE)) {
		error = do_tmpfile(dfd, pathname, nd, flags, op, file, &opened);
		goto out2;
	}

	error = path_init(dfd, pathname, flags, nd);
	if (unlikely(error))
		goto out;

	error = do_last(nd, &path, file, op, &opened, pathname);
	while (unlikely(error > 0)) { 
		struct path link = path;
		void *cookie;
		if (!(nd->flags & LOOKUP_FOLLOW)) {
			path_put_conditional(&path, nd);
			path_put(&nd->path);
			error = -ELOOP;
			break;
		}
		error = may_follow_link(&link, nd);
		if (unlikely(error))
			break;
		nd->flags |= LOOKUP_PARENT;
		nd->flags &= ~(LOOKUP_OPEN|LOOKUP_CREATE|LOOKUP_EXCL);
		error = follow_link(&link, nd, &cookie);
		if (unlikely(error))
			break;
		error = do_last(nd, &path, file, op, &opened, pathname);
		put_link(nd, &link, cookie);
	}
out:
	path_cleanup(nd);
out2:
	if (!(opened & FILE_OPENED)) {
		BUG_ON(!error);
		put_filp(file);
	}
	if (unlikely(error)) {
		if (error == -EOPENSTALE) {
			if (flags & LOOKUP_RCU)
				error = -ECHILD;
			else
				error = -ESTALE;
		}
		file = ERR_PTR(error);
	}
	return file;
}
","1. error = path_init(dfd, pathname, flags, nd);
2. goto out;
3. while (unlikely(error > 0)) {
4. if (unlikely(error))
break;
5. nd->flags &= ~(LOOKUP_OPEN|LOOKUP_CREATE|LOOKUP_EXCL);
6. break;
7. if (!(opened & FILE_OPENED)) {
8. error = -ESTALE;","20
22
25
35-36
38
41
48
57","CWE-119,CWE-416,CWE-284,CWE-78"
PyParser_ParseFileObject-271233030957905,"
#define FILE
#define PyObject

node *
PyParser_ParseFileObject(FILE *fp, PyObject *filename,
                         const char *enc, grammar *g, int start,
                         const char *ps1, const char *ps2,
                         perrdetail *err_ret, int *flags)
{
    struct tok_state *tok;

    if (initerr(err_ret, filename) < 0)
        return NULL;

    if ((tok = PyTokenizer_FromFile(fp, enc, ps1, ps2)) == NULL) {
        err_ret->error = E_NOMEM;
        return NULL;
    }
    if (*flags & PyPARSE_TYPE_COMMENTS) {
        tok->type_comments = 1;
    }
#ifndef PGEN
    Py_INCREF(err_ret->filename);
    tok->filename = err_ret->filename;
#endif
    return parsetok(tok, g, start, err_ret, flags);
}
","1. const char *enc, grammar *g, int start,
2. struct tok_state *tok;
3. return NULL;
4. if ((tok = PyTokenizer_FromFile(fp, enc, ps1, ps2)) == NULL) {
5. if (*flags & PyPARSE_TYPE_COMMENTS) {
tok->type_comments = 1;","7
11
14
16
20-21","CWE-200,CWE-787,CWE-119,CWE-125,CWE-59"
_TIFFmalloc_1-32801725953381,"tdata_t
_TIFFmalloc_1(tsize_t s)
{
        if (s == 0)
                return ((void *) NULL);

	return (malloc((size_t) s));
}
","1. tdata_t
2. if (s == 0)
return ((void *) NULL);
3. return (malloc((size_t) s));","1
4-5
7","CWE-476,CWE-369"
nf_tables_deactivate_set-222031977809239,"void nf_tables_deactivate_set(const struct nft_ctx *ctx, struct nft_set *set,
			      struct nft_set_binding *binding,
			      enum nft_trans_phase phase)
{
	switch (phase) {
	case NFT_TRANS_PREPARE:
		if (nft_set_is_anonymous(set))
			nft_deactivate_next(ctx->net, set);

		set->use--;
		return;
	case NFT_TRANS_ABORT:
	case NFT_TRANS_RELEASE:
		set->use--;
		fallthrough;
	default:
		nf_tables_unbind_set(ctx, set, binding,
				     phase == NFT_TRANS_COMMIT);
	}
}
","1. struct nft_set_binding *binding,
enum nft_trans_phase phase)
2. switch (phase) {
3. case NFT_TRANS_ABORT:
4. set->use--;
5. nf_tables_unbind_set(ctx, set, binding,","2-3
5
12
14
17","CWE-190,CWE-120,CWE-125"
png_set_text_2,"png_set_text_2(png_structp png_ptr, png_infop info_ptr, png_textp text_ptr,
               int num_text)
{
   int i;

   png_debug1(1, ""in %s storage function"", ((png_ptr == NULL ||
      png_ptr->chunk_name[0] == '\0') ?
      ""text"" : (png_const_charp)png_ptr->chunk_name));

   if (png_ptr == NULL || info_ptr == NULL || num_text == 0)
      return(0);

   
   if (info_ptr->num_text + num_text > info_ptr->max_text)
   {
      int old_max_text = info_ptr->max_text;
      int old_num_text = info_ptr->num_text;

      if (info_ptr->text != NULL)
      {
         png_textp old_text;

         info_ptr->max_text = info_ptr->num_text + num_text + 8;
         old_text = info_ptr->text;

         info_ptr->text = (png_textp)png_malloc_warn(png_ptr,
            (png_uint_32)(info_ptr->max_text * png_sizeof(png_text)));
         if (info_ptr->text == NULL)
         {
            
            info_ptr->max_text = old_max_text;
            info_ptr->text = old_text;
            return(1);
         }
         png_memcpy(info_ptr->text, old_text, (png_size_t)(old_max_text *
            png_sizeof(png_text)));
         png_free(png_ptr, old_text);
      }
      else
      {
         info_ptr->max_text = num_text + 8;
         info_ptr->num_text = 0;
         info_ptr->text = (png_textp)png_malloc_warn(png_ptr,
            (png_uint_32)(info_ptr->max_text * png_sizeof(png_text)));
         if (info_ptr->text == NULL)
         {
            
            info_ptr->num_text = old_num_text;
            info_ptr->max_text = old_max_text;
            return(1);
         }
#ifdef PNG_FREE_ME_SUPPORTED
         info_ptr->free_me |= PNG_FREE_TEXT;
#endif
      }
      png_debug1(3, ""allocated %d entries for info_ptr->text"",
         info_ptr->max_text);
   }

   for (i = 0; i < num_text; i++)
   {
      png_size_t text_length, key_len;
      png_size_t lang_len, lang_key_len;
      png_textp textp = &(info_ptr->text[info_ptr->num_text]);

      if (text_ptr[i].key == NULL)
          continue;

      key_len = png_strlen(text_ptr[i].key);

      if (text_ptr[i].compression <= 0)
      {
         lang_len = 0;
         lang_key_len = 0;
      }

      else
#ifdef PNG_iTXt_SUPPORTED
      {
         

         if (text_ptr[i].lang != NULL)
            lang_len = png_strlen(text_ptr[i].lang);
         else
            lang_len = 0;
         if (text_ptr[i].lang_key != NULL)
            lang_key_len = png_strlen(text_ptr[i].lang_key);
         else
            lang_key_len = 0;
      }
#else 
      {
         png_warning(png_ptr, ""iTXt chunk not supported."");
         continue;
      }
#endif

      if (text_ptr[i].text == NULL || text_ptr[i].text[0] == '\0')
      {
         text_length = 0;
#ifdef PNG_iTXt_SUPPORTED
         if (text_ptr[i].compression > 0)
            textp->compression = PNG_ITXT_COMPRESSION_NONE;
         else
#endif
            textp->compression = PNG_TEXT_COMPRESSION_NONE;
      }

      else
      {
         text_length = png_strlen(text_ptr[i].text);
         textp->compression = text_ptr[i].compression;
      }

      textp->key = (png_charp)png_malloc_warn(png_ptr,
         (png_uint_32)
          (key_len + text_length + lang_len + lang_key_len + 4));
       if (textp->key == NULL)
          return(1);
      png_debug2(2, ""Allocated %lu bytes at %p in png_set_text"",
                  (png_uint_32)
                  (key_len + lang_len + lang_key_len + text_length + 4),
                 textp->key);
 
       png_memcpy(textp->key, text_ptr[i].key,(png_size_t)(key_len));
       *(textp->key + key_len) = '\0';
#ifdef PNG_iTXt_SUPPORTED
      if (text_ptr[i].compression > 0)
      {
         textp->lang = textp->key + key_len + 1;
         png_memcpy(textp->lang, text_ptr[i].lang, lang_len);
         *(textp->lang + lang_len) = '\0';
         textp->lang_key = textp->lang + lang_len + 1;
         png_memcpy(textp->lang_key, text_ptr[i].lang_key, lang_key_len);
         *(textp->lang_key + lang_key_len) = '\0';
         textp->text = textp->lang_key + lang_key_len + 1;
      }
      else
#endif
      {
#ifdef PNG_iTXt_SUPPORTED
         textp->lang=NULL;
         textp->lang_key=NULL;
#endif
         textp->text = textp->key + key_len + 1;
      }
      if (text_length)
         png_memcpy(textp->text, text_ptr[i].text,
            (png_size_t)(text_length));
      *(textp->text + text_length) = '\0';

#ifdef PNG_iTXt_SUPPORTED
      if (textp->compression > 0)
      {
         textp->text_length = 0;
         textp->itxt_length = text_length;
      }
      else
#endif

      {
         textp->text_length = text_length;
#ifdef PNG_iTXt_SUPPORTED
         textp->itxt_length = 0;
#endif
      }
      info_ptr->num_text++;
      png_debug1(3, ""transferred text chunk %d"", info_ptr->num_text);
   }
   return(0);
}
","1. int i;
2. if (info_ptr->num_text + num_text > info_ptr->max_text)
3. int old_max_text = info_ptr->max_text;
4. old_text = info_ptr->text;
5. info_ptr->text = (png_textp)png_malloc_warn(png_ptr,
6. info_ptr->max_text = old_max_text;
7. return(1);
8. if (info_ptr->text == NULL)
9. key_len = png_strlen(text_ptr[i].key);
10. if (text_ptr[i].compression <= 0)
11. png_memcpy(textp->key, text_ptr[i].key,(png_size_t)(key_len));
12. textp->text = textp->key + key_len + 1;
13. (png_size_t)(text_length));
*(textp->text + text_length) = '\0';","4
16
18
26
28
33
35
47
71
73
127
147
151-152","CWE-358,CWE-399,CWE-400"
avc_parse_slice_1-80803889058933,"
#define AVCSliceInfo
#define AVCState
#define Bool
#define GF_BitStream

static s32 avc_parse_slice_1(GF_BitStream *bs, AVCState *avc, Bool svc_idr_flag, AVCSliceInfo *si)
{
	s32 pps_id, num_ref_idx_l0_active_minus1 = 0, num_ref_idx_l1_active_minus1 = 0;

	
	gf_bs_read_ue_log(bs, ""first_mb_in_slice"");
	si->slice_type = gf_bs_read_ue_log(bs, ""slice_type"");
	if (si->slice_type > 9) return -1;

	pps_id = gf_bs_read_ue_log(bs, ""pps_id"");
	if ((pps_id<0) || (pps_id >= 255)) return -1;
	si->pps = &avc->pps[pps_id];
	if (!si->pps->slice_group_count) return -2;
	if (si->pps->sps_id>=32) return -1;
	si->sps = &avc->sps[si->pps->sps_id];
	if (!si->sps->log2_max_frame_num) return -2;
	avc->sps_active_idx = si->pps->sps_id;
	avc->pps_active_idx = pps_id;

	si->frame_num = gf_bs_read_int_log(bs, si->sps->log2_max_frame_num, ""frame_num"");

	si->field_pic_flag = 0;
	si->bottom_field_flag = 0;
	if (!si->sps->frame_mbs_only_flag) {
		si->field_pic_flag = gf_bs_read_int_log(bs, 1, ""field_pic_flag"");
		if (si->field_pic_flag)
			si->bottom_field_flag = gf_bs_read_int_log(bs, 1, ""bottom_field_flag"");
	}

	if ((si->nal_unit_type == GF_AVC_NALU_IDR_SLICE) || svc_idr_flag)
		si->idr_pic_id = gf_bs_read_ue_log(bs, ""idr_pic_id"");

	if (si->sps->poc_type == 0) {
		si->poc_lsb = gf_bs_read_int_log(bs, si->sps->log2_max_poc_lsb, ""poc_lsb"");
		if (si->pps->pic_order_present && !si->field_pic_flag) {
			si->delta_poc_bottom = gf_bs_read_se_log(bs, ""poc_lsb"");
		}
	}
	else if ((si->sps->poc_type == 1) && !si->sps->delta_pic_order_always_zero_flag) {
		si->delta_poc[0] = gf_bs_read_se_log(bs, ""delta_poc0"");
		if ((si->pps->pic_order_present == 1) && !si->field_pic_flag)
			si->delta_poc[1] = gf_bs_read_se_log(bs, ""delta_poc1"");
	}

	if (si->pps->redundant_pic_cnt_present) {
		si->redundant_pic_cnt = gf_bs_read_ue_log(bs, ""redundant_pic_cnt"");
	}

	if (si->slice_type % 5 == GF_AVC_TYPE_B) {
		gf_bs_read_int_log(bs, 1, ""direct_spatial_mv_pred_flag"");
	}

	num_ref_idx_l0_active_minus1 = si->pps->num_ref_idx_l0_default_active_minus1;
	num_ref_idx_l1_active_minus1 = si->pps->num_ref_idx_l1_default_active_minus1;

	if (si->slice_type % 5 == GF_AVC_TYPE_P || si->slice_type % 5 == GF_AVC_TYPE_SP || si->slice_type % 5 == GF_AVC_TYPE_B) {
		Bool num_ref_idx_active_override_flag = gf_bs_read_int_log(bs, 1, ""num_ref_idx_active_override_flag"");
		if (num_ref_idx_active_override_flag) {
			num_ref_idx_l0_active_minus1 = gf_bs_read_ue_log(bs, ""num_ref_idx_l0_active_minus1"");
			if (si->slice_type % 5 == GF_AVC_TYPE_B) {
				num_ref_idx_l1_active_minus1 = gf_bs_read_ue_log(bs, ""num_ref_idx_l1_active_minus1"");
			}
		}
	}

	if (si->nal_unit_type == 20 || si->nal_unit_type == 21) {
		
		GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[avc-h264] unimplemented ref_pic_list_mvc_modification() in slide header\n""));
		assert(0);
		return -1;
	}
	else {
		ref_pic_list_modification(bs, si->slice_type);
	}

	if ((si->pps->weighted_pred_flag && (si->slice_type % 5 == GF_AVC_TYPE_P || si->slice_type % 5 == GF_AVC_TYPE_SP))
		|| (si->pps->weighted_bipred_idc == 1 && si->slice_type % 5 == GF_AVC_TYPE_B)) {
		avc_pred_weight_table(bs, si->slice_type, si->sps->ChromaArrayType, num_ref_idx_l0_active_minus1, num_ref_idx_l1_active_minus1);
	}

	if (si->nal_ref_idc != 0) {
		dec_ref_pic_marking(bs, (si->nal_unit_type == GF_AVC_NALU_IDR_SLICE));
	}

	if (si->pps->entropy_coding_mode_flag && si->slice_type % 5 != GF_AVC_TYPE_I && si->slice_type % 5 != GF_AVC_TYPE_SI) {
		gf_bs_read_ue_log(bs, ""cabac_init_idc"");
	}

	gf_bs_read_se(bs);
	if (si->slice_type % 5 == GF_AVC_TYPE_SP || si->slice_type % 5 == GF_AVC_TYPE_SI) {
		if (si->slice_type % 5 == GF_AVC_TYPE_SP) {
			gf_bs_read_int_log(bs, 1, ""sp_for_switch_flag"");
		}
		gf_bs_read_se_log(bs, ""slice_qs_delta"");
	}

	if (si->pps->deblocking_filter_control_present_flag) {
		if (gf_bs_read_ue_log(bs, ""disable_deblocking_filter_idc"") != 1) {
			gf_bs_read_se_log(bs, ""slice_alpha_c0_offset_div2"");
			gf_bs_read_se_log(bs, ""slice_beta_offset_div2"");
		}
	}

	if (si->pps->slice_group_count > 1 && si->pps->mb_slice_group_map_type >= 3 && si->pps->mb_slice_group_map_type <= 5) {
		gf_bs_read_int_log(bs, (u32)ceil(log1p((si->pps->pic_size_in_map_units_minus1 + 1) / (si->pps->slice_group_change_rate_minus1 + 1) ) / log(2)), ""slice_group_change_cycle"");
	}
	return 0;
}
","1. if (!si->pps->slice_group_count) return -2;
if (si->pps->sps_id>=32) return -1;
2. si->bottom_field_flag = gf_bs_read_int_log(bs, 1, ""bottom_field_flag"");
3. si->delta_poc[0] = gf_bs_read_se_log(bs, ""delta_poc0"");
4. si->delta_poc[1] = gf_bs_read_se_log(bs, ""delta_poc1"");
5. if (si->pps->redundant_pic_cnt_present) {
6. num_ref_idx_l0_active_minus1 = gf_bs_read_ue_log(bs, ""num_ref_idx_l0_active_minus1"");","19-20
33
46
48
51
65","CWE-476,CWE-347,CWE-120"
isis_print_mt_capability_subtlv,"isis_print_mt_capability_subtlv(netdissect_options *ndo,
                                const uint8_t *tptr, int len)
{
  int stlv_type, stlv_len, tmp;
 
   while (len > 2)
   {
    ND_TCHECK2(*tptr, 2);
     stlv_type = *(tptr++);
     stlv_len  = *(tptr++);
 
    
    ND_PRINT((ndo, ""\n\t      %s subTLV #%u, length: %u"",
               tok2str(isis_mt_capability_subtlv_values, ""unknown"", stlv_type),
               stlv_type,
               stlv_len));
 
     len = len - 2;
 
    
    if (len < stlv_len)
      goto trunc;
    
    ND_TCHECK2(*(tptr), stlv_len);

     switch (stlv_type)
     {
       case ISIS_SUBTLV_SPB_INSTANCE:
          if (stlv_len < ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN)
            goto trunc;
 
           ND_PRINT((ndo, ""\n\t        CIST Root-ID: %08x"", EXTRACT_32BITS(tptr)));
           tptr = tptr+4;
          ND_PRINT((ndo, "" %08x"", EXTRACT_32BITS(tptr)));
          tptr = tptr+4;
          ND_PRINT((ndo, "", Path Cost: %08x"", EXTRACT_32BITS(tptr)));
          tptr = tptr+4;
          ND_PRINT((ndo, "", Prio: %d"", EXTRACT_16BITS(tptr)));
          tptr = tptr + 2;
          ND_PRINT((ndo, ""\n\t        RES: %d"",
                    EXTRACT_16BITS(tptr) >> 5));
          ND_PRINT((ndo, "", V: %d"",
                    (EXTRACT_16BITS(tptr) >> 4) & 0x0001));
          ND_PRINT((ndo, "", SPSource-ID: %d"",
                    (EXTRACT_32BITS(tptr) & 0x000fffff)));
          tptr = tptr+4;
          ND_PRINT((ndo, "", No of Trees: %x"", *(tptr)));

           tmp = *(tptr++);
 
           len = len - ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN;
          stlv_len = stlv_len - ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN;
 
           while (tmp)
           {
            if (stlv_len < ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN)
              goto trunc;
 
             ND_PRINT((ndo, ""\n\t         U:%d, M:%d, A:%d, RES:%d"",
                       *(tptr) >> 7, (*(tptr) >> 6) & 0x01,
                      (*(tptr) >> 5) & 0x01, (*(tptr) & 0x1f)));

            tptr++;

            ND_PRINT((ndo, "", ECT: %08x"", EXTRACT_32BITS(tptr)));

            tptr = tptr + 4;

            ND_PRINT((ndo, "", BVID: %d, SPVID: %d"",
                      (EXTRACT_24BITS(tptr) >> 12) & 0x000fff,
                      EXTRACT_24BITS(tptr) & 0x000fff));
 
             tptr = tptr + 3;
             len = len - ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN;
            stlv_len = stlv_len - ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN;
             tmp--;
           }
 
           break;
 
       case ISIS_SUBTLV_SPBM_SI:
          if (stlv_len < 8)
            goto trunc;
 
           ND_PRINT((ndo, ""\n\t        BMAC: %08x"", EXTRACT_32BITS(tptr)));
           tptr = tptr+4;
          ND_PRINT((ndo, ""%04x"", EXTRACT_16BITS(tptr)));
          tptr = tptr+2;

          ND_PRINT((ndo, "", RES: %d, VID: %d"", EXTRACT_16BITS(tptr) >> 12,
                    (EXTRACT_16BITS(tptr)) & 0x0fff));

          tptr = tptr+2;
          len = len - 8;
          stlv_len = stlv_len - 8;

          while (stlv_len >= 4) {
            ND_TCHECK2(*tptr, 4);
            ND_PRINT((ndo, ""\n\t        T: %d, R: %d, RES: %d, ISID: %d"",
                    (EXTRACT_32BITS(tptr) >> 31),
                    (EXTRACT_32BITS(tptr) >> 30) & 0x01,
                    (EXTRACT_32BITS(tptr) >> 24) & 0x03f,
                    (EXTRACT_32BITS(tptr)) & 0x0ffffff));

            tptr = tptr + 4;
            len = len - 4;
            stlv_len = stlv_len - 4;
          }

        break;

       default:
         break;
     }
    tptr += stlv_len;
    len -= stlv_len;
   }
   return 0;
 
  trunc:
    ND_PRINT((ndo, ""\n\t\t""));
    ND_PRINT((ndo, ""%s"", tstr));
    return(1);
}
","1. isis_print_mt_capability_subtlv(netdissect_options *ndo,
const uint8_t *tptr, int len)
2. int stlv_type, stlv_len, tmp;
3. while (len > 2)
4. ND_TCHECK2(*tptr, 2);
stlv_type = *(tptr++);
stlv_len  = *(tptr++);
5. ND_PRINT((ndo, ""\n\t      %s subTLV #%u, length: %u"",
tok2str(isis_mt_capability_subtlv_values, ""unknown"", stlv_type),
6. stlv_len));
7. len = len - 2;
8. if (len < stlv_len)
9. ND_TCHECK2(*(tptr), stlv_len);
10. switch (stlv_type)
11. goto trunc;
12. ND_PRINT((ndo, ""\n\t        CIST Root-ID: %08x"", EXTRACT_32BITS(tptr)));
tptr = tptr+4;
13. ND_PRINT((ndo, "", Path Cost: %08x"", EXTRACT_32BITS(tptr)));
14. ND_PRINT((ndo, "", Prio: %d"", EXTRACT_16BITS(tptr)));
tptr = tptr + 2;
ND_PRINT((ndo, ""\n\t        RES: %d"",
15. ND_PRINT((ndo, "", V: %d"",
16. (EXTRACT_32BITS(tptr) & 0x000fffff)));
tptr = tptr+4;
17. tmp = *(tptr++);
18. len = len - ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN;
stlv_len = stlv_len - ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN;
19. if (stlv_len < ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN)
20. ND_PRINT((ndo, ""\n\t         U:%d, M:%d, A:%d, RES:%d"",
*(tptr) >> 7, (*(tptr) >> 6) & 0x01,
(*(tptr) >> 5) & 0x01, (*(tptr) & 0x1f)));
21. tptr++;
22. ND_PRINT((ndo, "", ECT: %08x"", EXTRACT_32BITS(tptr)));
23. tptr = tptr + 4;
24. ND_PRINT((ndo, "", BVID: %d, SPVID: %d"",
(EXTRACT_24BITS(tptr) >> 12) & 0x000fff,
EXTRACT_24BITS(tptr) & 0x000fff));
25. tptr = tptr + 3;
len = len - ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN;
stlv_len = stlv_len - ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN;
tmp--;
26. break;
27. case ISIS_SUBTLV_SPBM_SI:
if (stlv_len < 8)
goto trunc;
28. ND_PRINT((ndo, ""\n\t        BMAC: %08x"", EXTRACT_32BITS(tptr)));
tptr = tptr+4;
ND_PRINT((ndo, ""%04x"", EXTRACT_16BITS(tptr)));
tptr = tptr+2;
29. ND_PRINT((ndo, "", RES: %d, VID: %d"", EXTRACT_16BITS(tptr) >> 12,
30. tptr = tptr+2;
len = len - 8;
stlv_len = stlv_len - 8;
31. while (stlv_len >= 4) {
ND_TCHECK2(*tptr, 4);
ND_PRINT((ndo, ""\n\t        T: %d, R: %d, RES: %d, ISID: %d"",
32. (EXTRACT_32BITS(tptr) >> 30) & 0x01,
(EXTRACT_32BITS(tptr) >> 24) & 0x03f,
(EXTRACT_32BITS(tptr)) & 0x0ffffff));
33. tptr = tptr + 4;
len = len - 4;
stlv_len = stlv_len - 4;
34. break;
35. default:
36. tptr += stlv_len;
len -= stlv_len;
37. ND_PRINT((ndo, ""\n\t\t""));
38. return(1);","1-2
4
6
8-10
13-14
16
18
21
24
26
30
32-33
36
38-40
42
45-46
49
51-52
56
59-61
63
65
67
69-71
73-76
79
81-83
85-88
90
93-95
97-99
101-103
105-107
110
112
115-116
121
123","CWE-125,CWE-787"
gf_isom_box_parse_ex_2-212068774588761,"
#define Bool
#define GF_BitStream
#define GF_Box

GF_Err gf_isom_box_parse_ex_2(GF_Box **outBox, GF_BitStream *bs, u32 parent_type, Bool is_root_box, u64 parent_size)
{
	u32 type, uuid_type, hdr_size, restore_type;
	u64 size, start, comp_start, end;
	char uuid[16];
	GF_Err e;
	GF_BitStream *uncomp_bs = NULL;
	u8 *uncomp_data = NULL;
	u32 compressed_size=0;
	GF_Box *newBox;
	Bool skip_logs = (gf_bs_get_cookie(bs) & GF_ISOM_BS_COOKIE_NO_LOGS ) ? GF_TRUE : GF_FALSE;
	Bool is_special = GF_TRUE;
	
	if ((bs == NULL) || (outBox == NULL) ) return GF_BAD_PARAM;
	*outBox = NULL;
	if (gf_bs_available(bs) < 8) {
		return GF_ISOM_INCOMPLETE_FILE;
	}

	comp_start = start = gf_bs_get_position(bs);

	uuid_type = 0;
	size = (u64) gf_bs_read_u32(bs);
	hdr_size = 4;
	
	if ((size >= 2) && (size <= 4)) {
		size = 4;
		type = GF_ISOM_BOX_TYPE_VOID;
	} else {
		type = gf_bs_read_u32(bs);
		hdr_size += 4;
		
		if (type == GF_ISOM_BOX_TYPE_TOTL)
			size = 12;
		if (!size) {
			if (is_root_box) {
				if (!skip_logs) {
					GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[iso file] Warning Read Box type %s (0x%08X) size 0 reading till the end of file\n"", gf_4cc_to_str(type), type));
				}
				size = gf_bs_available(bs) + 8;
			} else {
				if (!skip_logs) {
					GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Read Box type %s (0x%08X) at position ""LLU"" has size 0 but is not at root/file level. Forbidden, skipping end of parent box !\n"", gf_4cc_to_str(type), type, start));
					return GF_SKIP_BOX;
				}
				return GF_OK;
			}
		}
		if (is_root_box && (size>=8)) {
			Bool do_uncompress = GF_FALSE;
			u8 *compb = NULL;
			u32 osize = 0;
			u32 otype = type;
			if (type==GF_4CC('!', 'm', 'o', 'f')) {
				do_uncompress = GF_TRUE;
				type = GF_ISOM_BOX_TYPE_MOOF;
			}
			else if (type==GF_4CC('!', 'm', 'o', 'v')) {
				do_uncompress = GF_TRUE;
				type = GF_ISOM_BOX_TYPE_MOOV;
			}
			else if (type==GF_4CC('!', 's', 'i', 'x')) {
				do_uncompress = GF_TRUE;
				type = GF_ISOM_BOX_TYPE_SIDX;
			}
			else if (type==GF_4CC('!', 's', 's', 'x')) {
				do_uncompress = GF_TRUE;
				type = GF_ISOM_BOX_TYPE_SSIX;
			}

			if (do_uncompress) {
				compb = gf_malloc((u32) (size-8));

				compressed_size = (u32) (size - 8);
				gf_bs_read_data(bs, compb, compressed_size);
				e = gf_gz_decompress_payload(compb, compressed_size, &uncomp_data, &osize);
				if (e) {
					GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Failed to uncompress payload for box type %s (0x%08X)\n"", gf_4cc_to_str(otype), otype));
					return e;
				}

				
				size = osize + 8;
				uncomp_bs = gf_bs_new(uncomp_data, osize, GF_BITSTREAM_READ);
				bs = uncomp_bs;
				start = 0;
				gf_free(compb);
			}
		}
	}
	
	memset(uuid, 0, 16);
	if (type == GF_ISOM_BOX_TYPE_UUID ) {
		if (gf_bs_available(bs) < 16) {
			return GF_ISOM_INCOMPLETE_FILE;
		}
		gf_bs_read_data(bs, uuid, 16);
		hdr_size += 16;
		uuid_type = gf_isom_solve_uuid_box(uuid);
	}

	
	if (size == 1) {
		if (gf_bs_available(bs) < 8) {
			return GF_ISOM_INCOMPLETE_FILE;
		}
		size = gf_bs_read_u64(bs);
		hdr_size += 8;
	}
	if (!skip_logs)
		GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[iso file] Read Box type %s size ""LLD"" start ""LLD""\n"", gf_4cc_to_str(type), size,  start));

	if ( size < hdr_size ) {
		GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Box %s size ""LLD"" less than box header size %d\n"", gf_4cc_to_str(type), size, hdr_size));
		return GF_ISOM_INVALID_FILE;
	}
	
	if (parent_size && (parent_size<size)) {
		GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Box %s size ""LLU"" is larger than remaining parent size ""LLU""\n"", gf_4cc_to_str(type), size, parent_size ));
		return GF_ISOM_INVALID_FILE;
	}
	restore_type = 0;
	if ((parent_type==GF_ISOM_BOX_TYPE_STSD) && (type==GF_QT_SUBTYPE_RAW) ) {
		u64 cookie = gf_bs_get_cookie(bs);
		restore_type = type;
		if (cookie & GF_ISOM_BS_COOKIE_VISUAL_TRACK)
			type = GF_QT_SUBTYPE_RAW_VID;
		else
			type = GF_QT_SUBTYPE_RAW_AUD;

	}

	
	if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TREF)) {
		newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFT);
		if (!newBox) return GF_OUT_OF_MEM;
		((GF_TrackReferenceTypeBox*)newBox)->reference_type = type;
	} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_IREF)) {
		newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFI);
		if (!newBox) return GF_OUT_OF_MEM;
		((GF_ItemReferenceTypeBox*)newBox)->reference_type = type;
	} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TRGR)) {
		newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_TRGT);
		if (!newBox) return GF_OUT_OF_MEM;
		((GF_TrackGroupTypeBox*)newBox)->group_type = type;
	} else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_GRPL)) {
		newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_GRPT);
		if (!newBox) return GF_OUT_OF_MEM;
		((GF_EntityToGroupTypeBox*)newBox)->grouping_type = type;
	} else {
		
		is_special = GF_FALSE;
		newBox = gf_isom_box_new_ex(uuid_type ? uuid_type : type, parent_type, skip_logs, is_root_box);
		if (!newBox) return GF_OUT_OF_MEM;
	}

	
	if (type==GF_ISOM_BOX_TYPE_UUID && !is_special) {
		memcpy(((GF_UUIDBox *)newBox)->uuid, uuid, 16);
		((GF_UUIDBox *)newBox)->internal_4cc = uuid_type;
	}

	if (!newBox->type) newBox->type = type;
	if (restore_type)
		newBox->type = restore_type;

	end = gf_bs_available(bs);
	if (size - hdr_size > end ) {
		newBox->size = size - hdr_size - end;
		*outBox = newBox;
		return GF_ISOM_INCOMPLETE_FILE;
	}

	newBox->size = size - hdr_size;

	e = gf_isom_full_box_read(newBox, bs);
	if (!e) e = gf_isom_box_read(newBox, bs);
	if (e) {
		if (gf_opts_get_bool(""core"", ""no-check""))
			e = GF_OK;
	}
	newBox->size = size;
	end = gf_bs_get_position(bs);

	if (uncomp_bs) {
		gf_free(uncomp_data);
		gf_bs_del(uncomp_bs);
		if (e) {
			gf_isom_box_del(newBox);
			*outBox = NULL;
			return e;
		}
		
		size -= 8;
		
		if (type==GF_ISOM_BOX_TYPE_MOOF) {
			((GF_MovieFragmentBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;
		}
		
		else if (type==GF_ISOM_BOX_TYPE_MOOV) {
			((GF_MovieBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;
			((GF_MovieBox *)newBox)->file_offset = comp_start;
		}
		
		else if (type==GF_ISOM_BOX_TYPE_SIDX) {
			((GF_SegmentIndexBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;
		}
		
		else if (type==GF_ISOM_BOX_TYPE_SSIX) {
			((GF_SubsegmentIndexBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;
		}
		newBox->internal_flags = GF_ISOM_BOX_COMPRESSED;
	}


	if (e && (e != GF_ISOM_INCOMPLETE_FILE)) {
		gf_isom_box_del(newBox);
		*outBox = NULL;
		if (is_root_box && (e==GF_SKIP_BOX))
			e = GF_ISOM_INVALID_FILE;

		if (!skip_logs && (e!=GF_SKIP_BOX)) {
			GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Read Box \""%s\"" (start ""LLU"") failed (%s) - skipping\n"", gf_4cc_to_str(type), start, gf_error_to_string(e)));
		}
		
		return e;
	}

	if (end-start > size) {
		if (!skip_logs) {
			GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] Box \""%s\"" size ""LLU"" (start ""LLU"") invalid (read ""LLU"")\n"", gf_4cc_to_str(type), size, start, (end-start) ));
		}
		
		gf_bs_seek(bs, start+size);
	} else if (end-start < size) {
		u32 to_skip = (u32) (size-(end-start));
		if (!skip_logs) {
			if ((to_skip!=4) || gf_bs_peek_bits(bs, 32, 0)) {
				GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] Box \""%s\"" (start ""LLU"") has %u extra bytes\n"", gf_4cc_to_str(type), start, to_skip));
				unused_bytes += to_skip;
			}
		}
		gf_bs_skip_bytes(bs, to_skip);
	}
	*outBox = newBox;

	return e;
}
","1. Bool skip_logs = (gf_bs_get_cookie(bs) & GF_ISOM_BS_COOKIE_NO_LOGS ) ? GF_TRUE : GF_FALSE;
2. if (gf_bs_available(bs) < 8) {
return GF_ISOM_INCOMPLETE_FILE;
3. comp_start = start = gf_bs_get_position(bs);
4. type = GF_ISOM_BOX_TYPE_VOID;
5. size = gf_bs_available(bs) + 8;
6. do_uncompress = GF_TRUE;
7. else if (type==GF_4CC('!', 'm', 'o', 'v')) {
8. gf_bs_read_data(bs, compb, compressed_size);
9. if (gf_bs_available(bs) < 16) {
10. hdr_size += 16;
11. if (gf_bs_available(bs) < 8) {
12. if (parent_size && (parent_size<size)) {
13. u64 cookie = gf_bs_get_cookie(bs);
14. newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFT);
15. } else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TRGR)) {
16. newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_GRPT);
17. ((GF_EntityToGroupTypeBox*)newBox)->grouping_type = type;
18. if (!newBox) return GF_OUT_OF_MEM;
19. if (!newBox->type) newBox->type = type;
20. newBox->size = size - hdr_size - end;
21. if (!e) e = gf_isom_box_read(newBox, bs);
22. if (uncomp_bs) {
23. gf_bs_del(uncomp_bs);
24. *outBox = NULL;
25. ((GF_MovieFragmentBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size;
26. if (e && (e != GF_ISOM_INCOMPLETE_FILE)) {
27. return e;
28. u32 to_skip = (u32) (size-(end-start));
29. return e;","16
21-22
25
33
45
60
63
80
99
103
109
123
129
140
147
152
154
159
168
174
182
190
192
195
202
221
231
241
252","CWE-476,CWE-362,CWE-310,CWE-399"
Create_Surface_Solid-137322310400848,"
#define SDL_Color
#define Uint32

static SDL_Surface* Create_Surface_Solid(int width, int height, SDL_Color fg, Uint32 *color)
{
    const int alignment = Get_Alignement() - 1;
    SDL_Surface *textbuf;
    Sint64 size;

    
    void *pixels, *ptr;
    
    Sint64 pitch = (Sint64)width + (Sint64)alignment;
    pitch += alignment;
    pitch &= ~alignment;
    size = height * pitch + sizeof (void *) + alignment;
    if (size < 0 || size > SDL_MAX_SINT32) {
        
        return NULL;
    }

    ptr = SDL_malloc((size_t)size);
    if (ptr == NULL) {
        return NULL;
    }

    
    pixels = (void *)(((uintptr_t)ptr + sizeof(void *) + alignment) & ~alignment);
    ((void **)pixels)[-1] = ptr;

    textbuf = SDL_CreateRGBSurfaceWithFormatFrom(pixels, width, height, 0, pitch, SDL_PIXELFORMAT_INDEX8);
    if (textbuf == NULL) {
        SDL_free(ptr);
        return NULL;
    }

    
    textbuf->flags &= ~SDL_PREALLOC;
    textbuf->flags |= SDL_SIMD_ALIGNED;

    
    SDL_memset(pixels, 0, height * pitch);

    
    *color = 1;

    
    {
        SDL_Palette *palette = textbuf->format->palette;
        palette->colors[0].r = 255 - fg.r;
        palette->colors[0].g = 255 - fg.g;
        palette->colors[0].b = 255 - fg.b;
        palette->colors[1].r = fg.r;
        palette->colors[1].g = fg.g;
        palette->colors[1].b = fg.b;
        palette->colors[1].a = fg.a;
    }

    SDL_SetColorKey(textbuf, SDL_TRUE, 0);

    return textbuf;
}
","1. void *pixels, *ptr;
2. pitch &= ~alignment;
3. if (size < 0 || size > SDL_MAX_SINT32) {
4. ((void **)pixels)[-1] = ptr;
5. if (textbuf == NULL) {
SDL_free(ptr);
return NULL;
6. *color = 1;
7. palette->colors[0].g = 255 - fg.g;
8. palette->colors[1].r = fg.r;
9. SDL_SetColorKey(textbuf, SDL_TRUE, 0);","15
19
21
33
36-38
49
55
57
63","CWE-476,CWE-190,CWE-400,CWE-189"
adjust_branches,"static void adjust_branches(struct bpf_prog *prog, int pos, int delta)
{
	struct bpf_insn *insn = prog->insnsi;
	int insn_cnt = prog->len;
	int i;

	for (i = 0; i < insn_cnt; i++, insn++) {
		if (BPF_CLASS(insn->code) != BPF_JMP ||
		    BPF_OP(insn->code) == BPF_CALL ||
		    BPF_OP(insn->code) == BPF_EXIT)
			continue;

 		
 		if (i < pos && i + insn->off + 1 > pos)
 			insn->off += delta;
		else if (i > pos + delta && i + insn->off + 1 <= pos + delta)
 			insn->off -= delta;
 	}
 }
","1. struct bpf_insn *insn = prog->insnsi;
int insn_cnt = prog->len;
int i;
2. for (i = 0; i < insn_cnt; i++, insn++) {
3. if (i < pos && i + insn->off + 1 > pos)
insn->off += delta;
else if (i > pos + delta && i + insn->off + 1 <= pos + delta)","3-5
7
14-16","CWE-264,CWE-416,CWE-400,CWE-193,CWE-399"
rawv6_sendmsg," static int rawv6_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)
 {
	struct ipv6_txoptions *opt_to_free = NULL;
 	struct ipv6_txoptions opt_space;
 	DECLARE_SOCKADDR(struct sockaddr_in6 *, sin6, msg->msg_name);
 	struct in6_addr *daddr, *final_p, final;
	struct inet_sock *inet = inet_sk(sk);
	struct ipv6_pinfo *np = inet6_sk(sk);
	struct raw6_sock *rp = raw6_sk(sk);
	struct ipv6_txoptions *opt = NULL;
	struct ip6_flowlabel *flowlabel = NULL;
	struct dst_entry *dst = NULL;
	struct raw6_frag_vec rfv;
	struct flowi6 fl6;
	int addr_len = msg->msg_namelen;
	int hlimit = -1;
	int tclass = -1;
	int dontfrag = -1;
	u16 proto;
	int err;

	
	if (len > INT_MAX)
		return -EMSGSIZE;

	
	if (msg->msg_flags & MSG_OOB)
		return -EOPNOTSUPP;

	
	memset(&fl6, 0, sizeof(fl6));

	fl6.flowi6_mark = sk->sk_mark;

	if (sin6) {
		if (addr_len < SIN6_LEN_RFC2133)
			return -EINVAL;

		if (sin6->sin6_family && sin6->sin6_family != AF_INET6)
			return -EAFNOSUPPORT;

		
		proto = ntohs(sin6->sin6_port);

		if (!proto)
			proto = inet->inet_num;
		else if (proto != inet->inet_num)
			return -EINVAL;

		if (proto > 255)
			return -EINVAL;

		daddr = &sin6->sin6_addr;
		if (np->sndflow) {
			fl6.flowlabel = sin6->sin6_flowinfo&IPV6_FLOWINFO_MASK;
			if (fl6.flowlabel&IPV6_FLOWLABEL_MASK) {
				flowlabel = fl6_sock_lookup(sk, fl6.flowlabel);
				if (!flowlabel)
					return -EINVAL;
			}
		}

		
		if (sk->sk_state == TCP_ESTABLISHED &&
		    ipv6_addr_equal(daddr, &sk->sk_v6_daddr))
			daddr = &sk->sk_v6_daddr;

		if (addr_len >= sizeof(struct sockaddr_in6) &&
		    sin6->sin6_scope_id &&
		    __ipv6_addr_needs_scope_id(__ipv6_addr_type(daddr)))
			fl6.flowi6_oif = sin6->sin6_scope_id;
	} else {
		if (sk->sk_state != TCP_ESTABLISHED)
			return -EDESTADDRREQ;

		proto = inet->inet_num;
		daddr = &sk->sk_v6_daddr;
		fl6.flowlabel = np->flow_label;
	}

	if (fl6.flowi6_oif == 0)
		fl6.flowi6_oif = sk->sk_bound_dev_if;

	if (msg->msg_controllen) {
		opt = &opt_space;
		memset(opt, 0, sizeof(struct ipv6_txoptions));
		opt->tot_len = sizeof(struct ipv6_txoptions);

		err = ip6_datagram_send_ctl(sock_net(sk), sk, msg, &fl6, opt,
					    &hlimit, &tclass, &dontfrag);
		if (err < 0) {
			fl6_sock_release(flowlabel);
			return err;
		}
		if ((fl6.flowlabel&IPV6_FLOWLABEL_MASK) && !flowlabel) {
			flowlabel = fl6_sock_lookup(sk, fl6.flowlabel);
			if (!flowlabel)
				return -EINVAL;
		}
 		if (!(opt->opt_nflen|opt->opt_flen))
 			opt = NULL;
 	}
	if (!opt) {
		opt = txopt_get(np);
		opt_to_free = opt;
		}
 	if (flowlabel)
 		opt = fl6_merge_options(&opt_space, flowlabel, opt);
 	opt = ipv6_fixup_options(&opt_space, opt);

	fl6.flowi6_proto = proto;
	rfv.msg = msg;
	rfv.hlen = 0;
	err = rawv6_probe_proto_opt(&rfv, &fl6);
	if (err)
		goto out;

	if (!ipv6_addr_any(daddr))
		fl6.daddr = *daddr;
	else
		fl6.daddr.s6_addr[15] = 0x1; 
	if (ipv6_addr_any(&fl6.saddr) && !ipv6_addr_any(&np->saddr))
		fl6.saddr = np->saddr;

	final_p = fl6_update_dst(&fl6, opt, &final);

	if (!fl6.flowi6_oif && ipv6_addr_is_multicast(&fl6.daddr))
		fl6.flowi6_oif = np->mcast_oif;
	else if (!fl6.flowi6_oif)
		fl6.flowi6_oif = np->ucast_oif;
	security_sk_classify_flow(sk, flowi6_to_flowi(&fl6));

	if (inet->hdrincl)
		fl6.flowi6_flags |= FLOWI_FLAG_KNOWN_NH;

	dst = ip6_dst_lookup_flow(sk, &fl6, final_p);
	if (IS_ERR(dst)) {
		err = PTR_ERR(dst);
		goto out;
	}
	if (hlimit < 0)
		hlimit = ip6_sk_dst_hoplimit(np, &fl6, dst);

	if (tclass < 0)
		tclass = np->tclass;

	if (dontfrag < 0)
		dontfrag = np->dontfrag;

	if (msg->msg_flags&MSG_CONFIRM)
		goto do_confirm;

back_from_confirm:
	if (inet->hdrincl)
		err = rawv6_send_hdrinc(sk, msg, len, &fl6, &dst, msg->msg_flags);
	else {
		lock_sock(sk);
		err = ip6_append_data(sk, raw6_getfrag, &rfv,
			len, 0, hlimit, tclass, opt, &fl6, (struct rt6_info *)dst,
			msg->msg_flags, dontfrag);

		if (err)
			ip6_flush_pending_frames(sk);
		else if (!(msg->msg_flags & MSG_MORE))
			err = rawv6_push_pending_frames(sk, &fl6, rp);
		release_sock(sk);
	}
done:
 	dst_release(dst);
 out:
 	fl6_sock_release(flowlabel);
	txopt_put(opt_to_free);
 	return err < 0 ? err : len;
 do_confirm:
 	dst_confirm(dst);
	if (!(msg->msg_flags & MSG_PROBE) || len)
		goto back_from_confirm;
	err = 0;
	goto done;
}
","1. static int rawv6_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)
2. struct ipv6_txoptions *opt = NULL;
3. int addr_len = msg->msg_namelen;
int hlimit = -1;
4. int dontfrag = -1;
5. int err;
6. if (len > INT_MAX)
7. return -EOPNOTSUPP;
8. if (sin6) {
9. if (sin6->sin6_family && sin6->sin6_family != AF_INET6)
10. return -EINVAL;
11. daddr = &sin6->sin6_addr;
12. flowlabel = fl6_sock_lookup(sk, fl6.flowlabel);
13. ipv6_addr_equal(daddr, &sk->sk_v6_daddr))
14. __ipv6_addr_needs_scope_id(__ipv6_addr_type(daddr)))
15. } else {
16. fl6.flowlabel = np->flow_label;
17. if (msg->msg_controllen) {
18. err = ip6_datagram_send_ctl(sock_net(sk), sk, msg, &fl6, opt,
19. if ((fl6.flowlabel&IPV6_FLOWLABEL_MASK) && !flowlabel) {
flowlabel = fl6_sock_lookup(sk, fl6.flowlabel);
20. return -EINVAL;
21. if (!opt) {
opt = txopt_get(np);
22. if (!fl6.flowi6_oif && ipv6_addr_is_multicast(&fl6.daddr))
fl6.flowi6_oif = np->mcast_oif;
else if (!fl6.flowi6_oif)
23. security_sk_classify_flow(sk, flowi6_to_flowi(&fl6));
24. err = PTR_ERR(dst);
25. hlimit = ip6_sk_dst_hoplimit(np, &fl6, dst);
26. if (msg->msg_flags&MSG_CONFIRM)
27. err = rawv6_send_hdrinc(sk, msg, len, &fl6, &dst, msg->msg_flags);
28. lock_sock(sk);
29. if (err)
ip6_flush_pending_frames(sk);
30. fl6_sock_release(flowlabel);
31. goto back_from_confirm;","1
10
15-16
18
20
25
30
39
43
52
57
61
72
77
79
85
91
96
102-103
105
110-111
134-136
138
145
149
157
162
164
169-170
178
184","CWE-362,CWE-264,CWE-416"
xfs_attr_shortform_list,"xfs_attr_shortform_list(xfs_attr_list_context_t *context)
{
	attrlist_cursor_kern_t *cursor;
	xfs_attr_sf_sort_t *sbuf, *sbp;
	xfs_attr_shortform_t *sf;
	xfs_attr_sf_entry_t *sfe;
	xfs_inode_t *dp;
	int sbsize, nsbuf, count, i;
	int error;

	ASSERT(context != NULL);
	dp = context->dp;
	ASSERT(dp != NULL);
	ASSERT(dp->i_afp != NULL);
	sf = (xfs_attr_shortform_t *)dp->i_afp->if_u1.if_data;
	ASSERT(sf != NULL);
	if (!sf->hdr.count)
		return 0;
	cursor = context->cursor;
	ASSERT(cursor != NULL);

	trace_xfs_attr_list_sf(context);

	
	if (context->bufsize == 0 ||
	    (XFS_ISRESET_CURSOR(cursor) &&
             (dp->i_afp->if_bytes + sf->hdr.count * 16) < context->bufsize)) {
		for (i = 0, sfe = &sf->list[0]; i < sf->hdr.count; i++) {
			error = context->put_listent(context,
					   sfe->flags,
					   sfe->nameval,
					   (int)sfe->namelen,
					   (int)sfe->valuelen,
					   &sfe->nameval[sfe->namelen]);

			
			if (context->seen_enough)
				break;

			if (error)
				return error;
			sfe = XFS_ATTR_SF_NEXTENTRY(sfe);
		}
		trace_xfs_attr_list_sf_all(context);
		return 0;
	}

	
	if (context->bufsize == 0)
		return 0;

	
	sbsize = sf->hdr.count * sizeof(*sbuf);
	sbp = sbuf = kmem_alloc(sbsize, KM_SLEEP | KM_NOFS);

	
	nsbuf = 0;
	for (i = 0, sfe = &sf->list[0]; i < sf->hdr.count; i++) {
		if (unlikely(
		    ((char *)sfe < (char *)sf) ||
		    ((char *)sfe >= ((char *)sf + dp->i_afp->if_bytes)))) {
			XFS_CORRUPTION_ERROR(""xfs_attr_shortform_list"",
					     XFS_ERRLEVEL_LOW,
					     context->dp->i_mount, sfe);
			kmem_free(sbuf);
			return -EFSCORRUPTED;
		}

		sbp->entno = i;
		sbp->hash = xfs_da_hashname(sfe->nameval, sfe->namelen);
		sbp->name = sfe->nameval;
		sbp->namelen = sfe->namelen;
		
		sbp->valuelen = sfe->valuelen;
		sbp->flags = sfe->flags;
		sfe = XFS_ATTR_SF_NEXTENTRY(sfe);
		sbp++;
		nsbuf++;
	}

	
	xfs_sort(sbuf, nsbuf, sizeof(*sbuf), xfs_attr_shortform_compare);

	
	count = 0;
	cursor->initted = 1;
	cursor->blkno = 0;
	for (sbp = sbuf, i = 0; i < nsbuf; i++, sbp++) {
		if (sbp->hash == cursor->hashval) {
			if (cursor->offset == count) {
				break;
			}
			count++;
		} else if (sbp->hash > cursor->hashval) {
			break;
		}
	}
	if (i == nsbuf) {
		kmem_free(sbuf);
		return 0;
	}

	
	for ( ; i < nsbuf; i++, sbp++) {
		if (cursor->hashval != sbp->hash) {
			cursor->hashval = sbp->hash;
			cursor->offset = 0;
		}
		error = context->put_listent(context,
					sbp->flags,
					sbp->name,
 					sbp->namelen,
 					sbp->valuelen,
 					&sbp->name[sbp->namelen]);
		if (error) {
			kmem_free(sbuf);
 			return error;
		}
 		if (context->seen_enough)
 			break;
 		cursor->offset++;
	}

	kmem_free(sbuf);
	return 0;
}
","1. xfs_attr_shortform_list(xfs_attr_list_context_t *context)
2. attrlist_cursor_kern_t *cursor;
3. int sbsize, nsbuf, count, i;
4. ASSERT(dp->i_afp != NULL);
5. if (!sf->hdr.count)
6. (int)sfe->valuelen,
&sfe->nameval[sfe->namelen]);
7. if (error)
8. for (i = 0, sfe = &sf->list[0]; i < sf->hdr.count; i++) {
9. context->dp->i_mount, sfe);
10. sbp->flags = sfe->flags;
11. sbp++;
12. for (sbp = sbuf, i = 0; i < nsbuf; i++, sbp++) {
13. count++;
} else if (sbp->hash > cursor->hashval) {
14. kmem_free(sbuf);
15. for ( ; i < nsbuf; i++, sbp++) {
16. error = context->put_listent(context,
17. sbp->name,
18. cursor->offset++;","1
3
8
14
17
41-42
51
74
80
91
93
108
113-114
119
126
131
133
143","CWE-476,CWE-190,CWE-59,CWE-119"
parse_ext_option-1721364605043,"static int8_t parse_ext_option(uint16_t *dst, uint8_t **packet_data_pptr, uint8_t *packet_data_start_ptr, uint16_t packet_len, uint16_t *message_left)
{
    uint16_t option_number = *dst;

    if (option_number == 13) {
        uint8_t option_ext;
        int8_t read_result = sn_coap_parser_read_packet_u8(&option_ext,
                                                            *packet_data_pptr,
                                                            packet_data_start_ptr,
                                                            packet_len);
        if (read_result != 0) {
            
            tr_error(""sn_coap_parser_options_parse - **packet_data_pptr overflow !"");
            return -1;
        }
        else {
            if(sn_coap_parser_add_u16_limit(option_number, option_ext, &option_number) != 0)
            {
                return -1;
            }

            *message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr,
                                                            packet_data_start_ptr,
                                                            packet_len,
                                                            1);
        }
    } else if (option_number == 14) {
            int8_t read_result = sn_coap_parser_read_packet_u16(&option_number,
                                                                *packet_data_pptr,
                                                                packet_data_start_ptr,
                                                                packet_len);
            if (read_result != 0) {
                
                tr_error(""sn_coap_parser_options_parse - **packet_data_pptr overflow !"");
                return -1;
            }
            else {
                if(sn_coap_parser_add_u16_limit(option_number, 269, &option_number) != 0)
                {
                    return -1;
                }

                *message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr,
                                                            packet_data_start_ptr,
                                                            packet_len,
                                                            2);
            }
    }
    
    else if (option_number == 15) {
        tr_error(""sn_coap_parser_options_parse - invalid option number(15)!"");
        return -1;
    }

    *dst = option_number;
    return 0;
}
","1. if (option_number == 13) {
2. packet_data_start_ptr,
packet_len);
3. return -1;
4. *message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr,
packet_data_start_ptr,
packet_len,
5. *packet_data_pptr,
packet_data_start_ptr,
6. else {
7. return -1;
8. *message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr,
9. *dst = option_number;","5
9-10
19
22-24
29-30
37
40
43
55","CWE-310,CWE-264,CWE-119"
load_1,"
#define ImlibImage
#define ImlibProgressFunction

load_1(ImlibImage * im, ImlibProgressFunction progress, char progress_granularity,
     char immediate_load)
{
   static const int    intoffset[] = { 0, 4, 2, 1 };
   static const int    intjump[] = { 8, 8, 4, 2 };
   int                 rc;
   DATA32             *ptr;
   GifFileType        *gif;
   GifRowType         *rows;
   GifRecordType       rec;
   ColorMapObject     *cmap;
   int                 i, j, done, bg, r, g, b, w = 0, h = 0;
   float               per = 0.0, per_inc;
   int                 last_per = 0, last_y = 0;
   int                 transp;
   int                 fd;

   done = 0;
   rows = NULL;
   transp = -1;

   
   
   if (im->data)
      return 0;

   fd = open(im->real_file, O_RDONLY);
   if (fd < 0)
      return 0;

#if GIFLIB_MAJOR >= 5
   gif = DGifOpenFileHandle(fd, NULL);
#else
   gif = DGifOpenFileHandle(fd);
#endif
   if (!gif)
     {
        close(fd);
        return 0;
     }

   rc = 0;                      

   do
     {
        if (DGifGetRecordType(gif, &rec) == GIF_ERROR)
          {
             
             rec = TERMINATE_RECORD_TYPE;
          }
        if ((rec == IMAGE_DESC_RECORD_TYPE) && (!done))
          {
             if (DGifGetImageDesc(gif) == GIF_ERROR)
               {
                  
                  rec = TERMINATE_RECORD_TYPE;
                  break;
               }
             w = gif->Image.Width;
             h = gif->Image.Height;
             if (!IMAGE_DIMENSIONS_OK(w, h))
                goto quit2;

             rows = calloc(h, sizeof(GifRowType *));
             if (!rows)
                goto quit2;

             for (i = 0; i < h; i++)
               {
                  rows[i] = calloc(w, sizeof(GifPixelType));
                  if (!rows[i])
                     goto quit;
               }

             if (gif->Image.Interlace)
               {
                  for (i = 0; i < 4; i++)
                    {
                       for (j = intoffset[i]; j < h; j += intjump[i])
                         {
                            DGifGetLine(gif, rows[j], w);
                         }
                    }
               }
             else
               {
                  for (i = 0; i < h; i++)
                    {
                       DGifGetLine(gif, rows[i], w);
                    }
               }
             done = 1;
          }
        else if (rec == EXTENSION_RECORD_TYPE)
          {
             int                 ext_code;
             GifByteType        *ext;

             ext = NULL;
             DGifGetExtension(gif, &ext_code, &ext);
             while (ext)
               {
                  if ((ext_code == 0xf9) && (ext[1] & 1) && (transp < 0))
                    {
                       transp = (int)ext[4];
                    }
                  ext = NULL;
                  DGifGetExtensionNext(gif, &ext);
               }
          }
     }
   while (rec != TERMINATE_RECORD_TYPE);

   if (transp >= 0)
     {
        SET_FLAG(im->flags, F_HAS_ALPHA);
     }
   else
     {
        UNSET_FLAG(im->flags, F_HAS_ALPHA);
     }
   if (!rows)
     {
        goto quit2;
     }

   
   
   
   im->w = w;
   im->h = h;
   if (!im->format)
      im->format = strdup(""gif"");
 
    if (im->loader || immediate_load || progress)
      {
        DATA32 colormap[256];

         bg = gif->SBackGroundColor;
         cmap = (gif->Image.ColorMap ? gif->Image.ColorMap : gif->SColorMap);
        memset (colormap, 0, sizeof(colormap));
        if (cmap != NULL)
           {
              for (i = cmap->ColorCount > 256 ? 256 : cmap->ColorCount; i-- > 0;)
                 {
                    r = cmap->Colors[i].Red;
                    g = cmap->Colors[i].Green;
                    b = cmap->Colors[i].Blue;
                    colormap[i] = (0xff << 24) | (r << 16) | (g << 8) | b;
                 }
              
              if (transp >= 0 && transp < 256)
                 colormap[transp] = bg >= 0 && bg < 256 ? colormap[bg] & 0x00ffffff : 0x00000000;
           }
         im->data = (DATA32 *) malloc(sizeof(DATA32) * w * h);
         if (!im->data)
            goto quit;
                    {
                       r = cmap->Colors[bg].Red;
                       g = cmap->Colors[bg].Green;
                       b = cmap->Colors[bg].Blue;
                       *ptr++ = 0x00ffffff & ((r << 16) | (g << 8) | b);
                    }
                  else
                    {
                       r = cmap->Colors[rows[i][j]].Red;
                       g = cmap->Colors[rows[i][j]].Green;
                       b = cmap->Colors[rows[i][j]].Blue;
                       *ptr++ = (0xff << 24) | (r << 16) | (g << 8) | b;
           {
              for (j = 0; j < w; j++)
                {
                  *ptr++ = colormap[rows[i][j]];
                   per += per_inc;
                   if (progress && (((int)per) != last_per)
                       && (((int)per) % progress_granularity == 0))
                         {
                            rc = 2;
                            goto quit;
                         }
                       last_y = i;
                    }
               }
          }

      finish:
        if (progress)
           progress(im, 100, 0, last_y, w, h);
     }

   rc = 1;                      

 quit:
   for (i = 0; i < h; i++)
      free(rows[i]);
   free(rows);

 quit2:
#if GIFLIB_MAJOR > 5 || (GIFLIB_MAJOR == 5 && GIFLIB_MINOR >= 1)
   DGifCloseFile(gif, NULL);
#else
   DGifCloseFile(gif);
#endif

   return rc;
}
","1. rec = TERMINATE_RECORD_TYPE;
2. goto quit2;
3. int                 ext_code;
4. goto quit;
5. rc = 1;","53
70
100
161
195","CWE-362,CWE-254,CWE-59,CWE-823"
set_modifier_for_read," set_modifier_for_read(png_modifier *pm, png_infopp ppi, png_uint_32 id,
    const char *name)
 {
    
   pm->state = modifier_start;
   pm->bit_depth = 0;
   pm->colour_type = 255;

   pm->pending_len = 0;
   pm->pending_chunk = 0;
   pm->flush = 0;
   pm->buffer_count = 0;
   pm->buffer_position = 0;

 return set_store_for_read(&pm->this, ppi, id, name);
}
",1. pm->colour_type = 255;,10,"CWE-476,CWE-835,CWE-369,CWE-119"
pvc_getname-122454932289265,"static int pvc_getname(struct socket *sock, struct sockaddr *sockaddr,
		       int *sockaddr_len, int peer)
{
	struct sockaddr_atmpvc *addr;
	struct atm_vcc *vcc = ATM_SD(sock);

	if (!vcc->dev || !test_bit(ATM_VF_ADDR, &vcc->flags))
		return -ENOTCONN;
	*sockaddr_len = sizeof(struct sockaddr_atmpvc);
	addr = (struct sockaddr_atmpvc *)sockaddr;
	memset(addr, 0, sizeof(*addr));
	addr->sap_family = AF_ATMPVC;
	addr->sap_addr.itf = vcc->dev->number;
	addr->sap_addr.vpi = vcc->vpi;
	addr->sap_addr.vci = vcc->vci;
	return 0;
}
","1. static int pvc_getname(struct socket *sock, struct sockaddr *sockaddr,
2. return -ENOTCONN;
3. addr->sap_family = AF_ATMPVC;
4. return 0;","1
8
12
16","CWE-772,CWE-200,CWE-125,CWE-254"
handle_exception_1,"static int handle_exception_1(struct kvm_vcpu *vcpu)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	struct kvm_run *kvm_run = vcpu->run;
	u32 intr_info, ex_no, error_code;
	unsigned long cr2, rip, dr6;
	u32 vect_info;
	enum emulation_result er;

	vect_info = vmx->idt_vectoring_info;
	intr_info = vmx->exit_intr_info;

 	if (is_machine_check(intr_info))
 		return handle_machine_check(vcpu);
 
	if (is_nmi(intr_info))
 		return 1;  
 
 	if (is_no_device(intr_info)) {
		vmx_fpu_activate(vcpu);
		return 1;
	}

	if (is_invalid_opcode(intr_info)) {
		if (is_guest_mode(vcpu)) {
			kvm_queue_exception(vcpu, UD_VECTOR);
			return 1;
		}
		er = emulate_instruction(vcpu, EMULTYPE_TRAP_UD);
		if (er != EMULATE_DONE)
			kvm_queue_exception(vcpu, UD_VECTOR);
		return 1;
	}

	error_code = 0;
	if (intr_info & INTR_INFO_DELIVER_CODE_MASK)
		error_code = vmcs_read32(VM_EXIT_INTR_ERROR_CODE);

	
	if ((vect_info & VECTORING_INFO_VALID_MASK) &&
	    !(is_page_fault(intr_info) && !(error_code & PFERR_RSVD_MASK))) {
		vcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;
		vcpu->run->internal.suberror = KVM_INTERNAL_ERROR_SIMUL_EX;
		vcpu->run->internal.ndata = 3;
		vcpu->run->internal.data[0] = vect_info;
		vcpu->run->internal.data[1] = intr_info;
		vcpu->run->internal.data[2] = error_code;
		return 0;
	}

	if (is_page_fault(intr_info)) {
		
		BUG_ON(enable_ept);
		cr2 = vmcs_readl(EXIT_QUALIFICATION);
		trace_kvm_page_fault(cr2, error_code);

		if (kvm_event_needs_reinjection(vcpu))
			kvm_mmu_unprotect_page_virt(vcpu, cr2);
		return kvm_mmu_page_fault(vcpu, cr2, error_code, NULL, 0);
	}

	ex_no = intr_info & INTR_INFO_VECTOR_MASK;

	if (vmx->rmode.vm86_active && rmode_exception(vcpu, ex_no))
		return handle_rmode_exception(vcpu, ex_no, error_code);

	switch (ex_no) {
	case AC_VECTOR:
		kvm_queue_exception_e(vcpu, AC_VECTOR, error_code);
		return 1;
	case DB_VECTOR:
		dr6 = vmcs_readl(EXIT_QUALIFICATION);
		if (!(vcpu->guest_debug &
		      (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP))) {
			vcpu->arch.dr6 &= ~15;
			vcpu->arch.dr6 |= dr6 | DR6_RTM;
			if (!(dr6 & ~DR6_RESERVED)) 
				skip_emulated_instruction(vcpu);

			kvm_queue_exception(vcpu, DB_VECTOR);
			return 1;
		}
		kvm_run->debug.arch.dr6 = dr6 | DR6_FIXED_1;
		kvm_run->debug.arch.dr7 = vmcs_readl(GUEST_DR7);
		
	case BP_VECTOR:
		
		vmx->vcpu.arch.event_exit_inst_len =
			vmcs_read32(VM_EXIT_INSTRUCTION_LEN);
		kvm_run->exit_reason = KVM_EXIT_DEBUG;
		rip = kvm_rip_read(vcpu);
		kvm_run->debug.arch.pc = vmcs_readl(GUEST_CS_BASE) + rip;
		kvm_run->debug.arch.exception = ex_no;
		break;
	default:
		kvm_run->exit_reason = KVM_EXIT_EXCEPTION;
		kvm_run->ex.exception = ex_no;
		kvm_run->ex.error_code = error_code;
		break;
	}
	return 0;
}
","1. struct kvm_run *kvm_run = vcpu->run;
2. unsigned long cr2, rip, dr6;
3. enum emulation_result er;
4. return 1;
5. if (intr_info & INTR_INFO_DELIVER_CODE_MASK)
6. if ((vect_info & VECTORING_INFO_VALID_MASK) &&
7. vcpu->run->internal.data[1] = intr_info;
8. switch (ex_no) {
9. vcpu->arch.dr6 |= dr6 | DR6_RTM;
10. break;","4
6
8
32
36
44
50
71
80
102","CWE-362,CWE-617,CWE-125,CWE-416"
vvc_parse_picture_header-99219411018956,"
#define GF_BitStream
#define VVCSliceInfo
#define VVCState

static
s32 vvc_parse_picture_header(GF_BitStream *bs, VVCState *vvc, VVCSliceInfo *si)
{
	u32 pps_id;

	si->irap_or_gdr_pic = gf_bs_read_int_log(bs, 1, ""irap_or_gdr_pic"");
	si->non_ref_pic = gf_bs_read_int_log(bs, 1, ""non_ref_pic"");
	if (si->irap_or_gdr_pic)
		si->gdr_pic = gf_bs_read_int_log(bs, 1, ""gdr_pic"");
	if ((si->inter_slice_allowed_flag = gf_bs_read_int_log(bs, 1, ""inter_slice_allowed_flag"")))
		si->intra_slice_allowed_flag = gf_bs_read_int_log(bs, 1, ""intra_slice_allowed_flag"");

	pps_id = gf_bs_read_ue_log(bs, ""pps_id"");
	if ((pps_id<0) || (pps_id >= 64))
		return -1;
	si->pps = &vvc->pps[pps_id];
	si->sps = &vvc->sps[si->pps->sps_id];
	si->poc_lsb = gf_bs_read_int_log(bs, si->sps->log2_max_poc_lsb, ""poc_lsb"");

	si->recovery_point_valid = 0;
	si->gdr_recovery_count = 0;
	if (si->gdr_pic) {
		si->recovery_point_valid = 1;
		si->gdr_recovery_count = gf_bs_read_ue_log(bs, ""gdr_recovery_count"");
	}
	gf_bs_read_int_log(bs, si->sps->ph_num_extra_bits, ""ph_extra_bits"");

	if (si->sps->poc_msb_cycle_flag) {
		if ( (si->poc_msb_cycle_present_flag = gf_bs_read_int_log(bs, 1, ""poc_msb_cycle_present_flag""))) {
			si->poc_msb_cycle = gf_bs_read_int_log(bs, si->sps->poc_msb_cycle_len, ""poc_msb_cycle"");
		}
	}

	return 0;
}
","1. u32 pps_id;
2. si->irap_or_gdr_pic = gf_bs_read_int_log(bs, 1, ""irap_or_gdr_pic"");
3. si->gdr_pic = gf_bs_read_int_log(bs, 1, ""gdr_pic"");
4. si->intra_slice_allowed_flag = gf_bs_read_int_log(bs, 1, ""intra_slice_allowed_flag"");
5. pps_id = gf_bs_read_ue_log(bs, ""pps_id"");
6. si->pps = &vvc->pps[pps_id];
si->sps = &vvc->sps[si->pps->sps_id];
7. si->recovery_point_valid = 0;
8. gf_bs_read_int_log(bs, si->sps->ph_num_extra_bits, ""ph_extra_bits"");
9. if (si->sps->poc_msb_cycle_flag) {
if ( (si->poc_msb_cycle_present_flag = gf_bs_read_int_log(bs, 1, ""poc_msb_cycle_present_flag""))) {
si->poc_msb_cycle = gf_bs_read_int_log(bs, si->sps->poc_msb_cycle_len, ""poc_msb_cycle"");
10. return 0;","9
11
14
16
18
21-22
25
31
33-35
39","CWE-190,CWE-119"
isor_reader_get_sample_2-96647622077716,"
#define ISOMChannel

void isor_reader_get_sample_2(ISOMChannel *ch)
{
	GF_Err e;
	Bool skip_sample=GF_FALSE;
	u32 sample_desc_index;
	if (ch->sample) return;

	if (ch->next_track) {
		ch->track = ch->next_track;
		if (!ch->owner->nodata)
			gf_isom_set_sample_alloc(ch->owner->mov, ch->track, isor_sample_alloc, ch);
		ch->next_track = 0;
	}

	if (ch->to_init) {
		if (!ch->owner->nodata)
			gf_isom_set_sample_alloc(ch->owner->mov, ch->track, isor_sample_alloc, ch);
		init_reader(ch);
		sample_desc_index = ch->last_sample_desc_index;
	} else if (ch->speed < 0) {
		if (ch->last_state == GF_EOS) {
			ch->sample = NULL;
			return;
		}

		if (ch->static_sample->IsRAP) {
			ch->last_rap_sample_time = ch->sample_time;
		}

		e = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->sample_time + 1, &sample_desc_index, GF_ISOM_SEARCH_FORWARD, &ch->static_sample, &ch->sample_num, NULL);
		ch->static_sample->alloc_size = 0;

		if ((e==GF_EOS) || (ch->static_sample->IsRAP)) {
			if (!ch->last_rap_sample_time) {
				e = GF_EOS;
			} else {
				e = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->last_rap_sample_time - 1, &sample_desc_index, GF_ISOM_SEARCH_SYNC_BACKWARD, &ch->static_sample, &ch->sample_num, NULL);
				ch->static_sample->alloc_size = 0;
			}
		}

		if (e) {
			if ((e==GF_EOS) && !ch->owner->frag_type) {
				ch->last_state = GF_EOS;
			}
			ch->sample = NULL;
			return;
		}
		ch->sample = ch->static_sample;

		if (ch->sample->DTS == ch->sample_time) {
			if (!ch->owner->frag_type) {
				ch->last_state = GF_EOS;
			}
		}
		if (ch->sample) {
			ch->sample_time = ch->sample->DTS;
		}

	} else if (ch->has_edit_list) {
		u32 prev_sample = ch->sample_num;
		e = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->sample_time + 1, &sample_desc_index, GF_ISOM_SEARCH_FORWARD, &ch->static_sample, &ch->sample_num, &ch->sample_data_offset);
		ch->static_sample->alloc_size = 0;

		if (e == GF_OK) {
			ch->sample = ch->static_sample;

			
			if (ch->edit_sync_frame) {
				ch->edit_sync_frame++;
				if (ch->edit_sync_frame < ch->sample_num) {
					ch->static_sample->alloc_size = 0;
					ch->static_sample->dataLength = 0;
					ch->sample = gf_isom_get_sample_ex(ch->owner->mov, ch->track, ch->edit_sync_frame, &sample_desc_index, ch->static_sample, &ch->sample_data_offset);
					if (ch->sample) {
						ch->sample->DTS = ch->sample_time;
						ch->sample->CTS_Offset = 0;
					}
				} else {
					ch->edit_sync_frame = 0;
					if (ch->sample) ch->sample_time = ch->sample->DTS;
				}
			} else {
				
				if (prev_sample == ch->sample_num) {
					if (ch->owner->frag_type && (ch->sample_num==gf_isom_get_sample_count(ch->owner->mov, ch->track))) {
						ch->sample = NULL;
					} else {
						u32 sample_num = ch->sample_num ? ch->sample_num : 1;

						if (sample_num >= gf_isom_get_sample_count(ch->owner->mov, ch->track) ) {
							
						} else {
							u32 time_diff = gf_isom_get_sample_duration(ch->owner->mov, ch->track, sample_num);

							ch->static_sample->alloc_size = 0;
							ch->static_sample->dataLength = 0;

							e = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->sample_time + time_diff, &sample_desc_index, GF_ISOM_SEARCH_FORWARD, &ch->static_sample, &ch->sample_num, &ch->sample_data_offset);
							ch->static_sample->alloc_size = 0;
							if (e==GF_OK) {
								if (ch->sample_num == prev_sample) {
									ch->sample_time += time_diff;
									ch->sample = NULL;
									if (ch->pck) {
										gf_filter_pck_discard(ch->pck);
										ch->pck = NULL;
									}
									return;
								} else {
									ch->sample = ch->static_sample;
								}
							}
						}
					}
				}

				
				if (ch->sample && !ch->sample->IsRAP && ch->has_rap && (ch->sample_num != prev_sample+1)) {
					GF_ISOSample *found = ch->static_sample;
					u32 samp_num = ch->sample_num;
					ch->sample = NULL;
					ch->static_sample->alloc_size = 0;
					ch->static_sample->dataLength = 0;
					e = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->sample_time + 1, &sample_desc_index, GF_ISOM_SEARCH_SYNC_BACKWARD, &ch->static_sample, &ch->sample_num, &ch->sample_data_offset);

					ch->static_sample->alloc_size = 0;
					ch->sample = (e == GF_OK) ? ch->static_sample : NULL;

					
					if (!ch->sample || !ch->sample->data) {
						ch->sample = ch->static_sample = found;
						ch->sample_time = ch->sample->DTS;
						ch->sample_num = samp_num;
					} else {
						ch->sample = ch->static_sample;
						ch->edit_sync_frame = ch->sample_num;
						ch->sample->DTS = ch->sample_time;
						ch->sample->CTS_Offset = 0;
					}
				} else {
					if (ch->sample) ch->sample_time = ch->sample->DTS;
				}
			}
		}
	} else {
		Bool do_fetch = GF_TRUE;
		ch->sample_num++;
		if (ch->sample_last && (ch->sample_last<ch->sample_num)) {
			ch->sample = NULL;
			ch->last_state = GF_EOS;
			ch->playing = 2;
			return;
		}

		if (ch->sap_only) {
			Bool is_rap = gf_isom_get_sample_sync(ch->owner->mov, ch->track, ch->sample_num);
			if (!is_rap) {
				GF_ISOSampleRollType roll_type;
				gf_isom_get_sample_rap_roll_info(ch->owner->mov, ch->track, ch->sample_num, &is_rap, &roll_type, NULL);
				if (roll_type) is_rap = GF_TRUE;
			}

			if (!is_rap) {
				do_fetch = GF_FALSE;
			} else if (ch->sap_only==2) {
				ch->sap_only = 0;
			}
		}
		if (do_fetch) {
			if (ch->owner->nodata) {
				ch->sample = gf_isom_get_sample_info_ex(ch->owner->mov, ch->track, ch->sample_num, &sample_desc_index, &ch->sample_data_offset, ch->static_sample);
			} else {
				ch->sample = gf_isom_get_sample_ex(ch->owner->mov, ch->track, ch->sample_num, &sample_desc_index, ch->static_sample, &ch->sample_data_offset);
			}
			
			if (ch->sample && (ch->sample->IsRAP==RAP_REDUNDANT)) {
				ch->sample = NULL;
				ch->sample_num++;
				if (ch->pck) {
					gf_filter_pck_discard(ch->pck);
					ch->pck = NULL;
					ch->static_sample->alloc_size = ch->static_sample->dataLength = 0;
				}
				isor_reader_get_sample_2(ch);
				return;
			}
		} else {
			skip_sample = GF_TRUE;
		}
	}

	
	if (ch->sample && ch->sample->IsRAP && ch->next_track) {
		ch->track = ch->next_track;
		ch->next_track = 0;
		ch->sample = NULL;
		if (ch->pck) {
			gf_filter_pck_discard(ch->pck);
			ch->pck = NULL;
		}
		isor_reader_get_sample_2(ch);
		return;
	}

	if (!ch->sample) {
		u32 sample_count = gf_isom_get_sample_count(ch->owner->mov, ch->track);
		ch->sample_data_offset = 0;
		
		if (gf_isom_get_missing_bytes(ch->owner->mov, ch->track)) {
			ch->last_state = GF_ISOM_INCOMPLETE_FILE;
			if (ch->owner->mem_load_mode==2)
				ch->owner->force_fetch = GF_TRUE;

			if (!ch->owner->input_loaded) {
				ch->last_state = GF_OK;
				if (!ch->has_edit_list && ch->sample_num)
					ch->sample_num--;
			} else {
				if (ch->to_init && ch->sample_num) {
					GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[IsoMedia] Failed to fetch initial sample %d for track %d\n"", ch->sample_num, ch->track));
					ch->last_state = GF_ISOM_INVALID_FILE;
				} else {
					if (!ch->eos_sent) {
						GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[IsoMedia] File truncated, aborting read for track %d\n"", ch->track));
					}
					ch->last_state = GF_EOS;
				}
			}
		}
		else if (!ch->sample_num
		         || ((ch->speed >= 0) && (ch->sample_num >= sample_count))
#ifndef GPAC_DISABLE_ISOM_FRAGMENTS
		         || ((ch->speed < 0) && (ch->sample_time == gf_isom_get_current_tfdt(ch->owner->mov, ch->track) ))
#endif
		) {

			if (ch->owner->frag_type==1) {
				
				if (ch->sample_num) ch->sample_num--;
				ch->last_state = GF_EOS;
			} else if (ch->last_state != GF_EOS) {
				GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[IsoMedia] Track #%d end of stream reached\n"", ch->track));
				ch->last_state = GF_EOS;
				if (ch->sample_num>sample_count) ch->sample_num = sample_count;
			} else {
				if (ch->sample_num>sample_count) ch->sample_num = sample_count;
			}
		} else if (!skip_sample) {
			e = gf_isom_last_error(ch->owner->mov);
			GF_LOG((e==GF_ISOM_INCOMPLETE_FILE) ? GF_LOG_DEBUG : GF_LOG_WARNING, GF_LOG_CONTAINER, (""[IsoMedia] Track #%d fail to fetch sample %d / %d: %s\n"", ch->track, ch->sample_num, gf_isom_get_sample_count(ch->owner->mov, ch->track), gf_error_to_string(e) ));

			if ((e<GF_OK) && (e!=GF_ISOM_INCOMPLETE_FILE)) {
				ch->last_state = GF_EOS;
			}
		}
		return;
	}

	
	if ((ch->sample_num==1) && ch->hint_first_tfdt && ch->sample->DTS) {
		ch->hint_first_tfdt = 0;
	}
	ch->sample->DTS += ch->hint_first_tfdt;

	if (sample_desc_index != ch->last_sample_desc_index) {
		if (!ch->owner->stsd) {
			
			
			if (!ch->last_sample_desc_index && (sample_desc_index==1)) {

			} else {
				ch->needs_pid_reconfig = 1;
			}
		}
		ch->last_sample_desc_index = sample_desc_index;
	}

	ch->last_state = GF_OK;

	ch->sap_3 = GF_FALSE;
	ch->sap_4_type = 0;
	ch->roll = 0;

	if (ch->sample) {
		gf_isom_get_sample_rap_roll_info(ch->owner->mov, ch->track, ch->sample_num, &ch->sap_3, &ch->sap_4_type, &ch->roll);

		
		if ((ch->speed < 0) || (ch->start <= ch->sample->DTS + ch->sample->CTS_Offset)) {
			ch->dts = ch->sample->DTS;
			ch->cts = ch->sample->DTS + ch->sample->CTS_Offset;
			ch->seek_flag = 0;
		} else {
			ch->cts = ch->start;
			ch->seek_flag = 1;
			ch->dts = ch->start;
		}

		if (ch->end && (ch->end < ch->sample->DTS + ch->sample->CTS_Offset + ch->sample->duration)) {
			GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[IsoMedia] End of Channel ""LLD"" (CTS ""LLD"")\n"", ch->end, ch->sample->DTS + ch->sample->CTS_Offset));
			ch->sample = NULL;
			ch->last_state = GF_EOS;
			ch->playing = 2;
			return;
		}
	}

	if (ch->owner->last_sender_ntp && ch->cts==ch->owner->cts_for_last_sender_ntp) {
		ch->sender_ntp = ch->owner->last_sender_ntp;
		ch->ntp_at_server_ntp = ch->owner->ntp_at_last_sender_ntp;
	} else if (ch->owner->last_sender_ntp && ch->dts==ch->owner->cts_for_last_sender_ntp) {
		ch->sender_ntp = ch->owner->last_sender_ntp;
		ch->ntp_at_server_ntp = ch->owner->ntp_at_last_sender_ntp;
	} else {
		ch->sender_ntp = ch->ntp_at_server_ntp = 0;
	}

	if (!ch->sample_num) return;

	gf_isom_get_sample_flags(ch->owner->mov, ch->track, ch->sample_num, &ch->isLeading, &ch->dependsOn, &ch->dependedOn, &ch->redundant);

	if (ch->is_encrypted) {
		
		if (gf_isom_is_cenc_media(ch->owner->mov, ch->track, ch->last_sample_desc_index)) {
			isor_update_cenc_info(ch, GF_FALSE);

		} else if (gf_isom_is_media_encrypted(ch->owner->mov, ch->track, ch->last_sample_desc_index)) {
			ch->pck_encrypted = GF_TRUE;
		} else {
			ch->pck_encrypted = GF_FALSE;
		}
	}
	if (ch->sample && ch->sample->nb_pack)
		ch->sample_num += ch->sample->nb_pack-1;
}
","1. void isor_reader_get_sample_2(ISOMChannel *ch)
2. if (ch->next_track) {
3. if (!ch->owner->nodata)
4. sample_desc_index = ch->last_sample_desc_index;
5. return;
6. ch->static_sample->alloc_size = 0;
7. if ((e==GF_EOS) || (ch->static_sample->IsRAP)) {
if (!ch->last_rap_sample_time) {
8. if ((e==GF_EOS) && !ch->owner->frag_type) {
9. ch->edit_sync_frame++;
10. } else {
11. if (e==GF_OK) {
12. ch->pck = NULL;
13. if (ch->sample && !ch->sample->IsRAP && ch->has_rap && (ch->sample_num != prev_sample+1)) {
14. ch->sample = NULL;
15. } else if (ch->sap_only==2) {
16. if (ch->owner->nodata) {
ch->sample = gf_isom_get_sample_info_ex(ch->owner->mov, ch->track, ch->sample_num, &sample_desc_index, &ch->sample_data_offset, ch->static_sample);
17. ch->next_track = 0;
18. if (!ch->owner->input_loaded) {
19. GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[IsoMedia] File truncated, aborting read for track %d\n"", ch->track));
20. if (ch->owner->frag_type==1) {
21. if (ch->sample_num) ch->sample_num--;
ch->last_state = GF_EOS;
22. if (!ch->last_sample_desc_index && (sample_desc_index==1)) {
23. ch->sap_4_type = 0;
24. ch->seek_flag = 0;
25. if (ch->end && (ch->end < ch->sample->DTS + ch->sample->CTS_Offset + ch->sample->duration)) {
26. ch->playing = 2;
27. ch->ntp_at_server_ntp = ch->owner->ntp_at_last_sender_ntp;
28. if (!ch->sample_num) return;
29. gf_isom_get_sample_flags(ch->owner->mov, ch->track, ch->sample_num, &ch->isLeading, &ch->dependsOn, &ch->dependedOn, &ch->redundant);
30. } else if (gf_isom_is_media_encrypted(ch->owner->mov, ch->track, ch->last_sample_desc_index)) {","4
11
19
22
26
34
36-37
46
73
96
104
110
123
154
170
175-176
200
219
229
242
244-245
274
286
299
306
310
317
325
327
334","CWE-835,CWE-20,CWE-416,CWE-415"
op_attr_bignum_free-225893430840620,"static void op_attr_bignum_free(void *attr)
{
	struct bignum **bn = attr;

	crypto_bignum_free(bn);
}
","1. static void op_attr_bignum_free(void *attr)
2. struct bignum **bn = attr;","1
3","CWE-190,CWE-20,CWE-264"
snd_ctl_elem_write-134051200544097,"static int snd_ctl_elem_write(struct snd_card *card, struct snd_ctl_file *file,
			      struct snd_ctl_elem_value *control)
{
	struct snd_kcontrol *kctl;
	struct snd_kcontrol_volatile *vd;
	unsigned int index_offset;
	int result;

	down_read(&card->controls_rwsem);
	kctl = snd_ctl_find_id(card, &control->id);
	if (kctl == NULL) {
		result = -ENOENT;
	} else {
		index_offset = snd_ctl_get_ioff(kctl, &control->id);
		vd = &kctl->vd[index_offset];
		if (!(vd->access & SNDRV_CTL_ELEM_ACCESS_WRITE) ||
		    kctl->put == NULL ||
		    (file && vd->owner && vd->owner != file)) {
			result = -EPERM;
		} else {
			snd_ctl_build_ioff(&control->id, kctl, index_offset);
			result = kctl->put(kctl, control);
		}
		if (result > 0) {
			struct snd_ctl_elem_id id = control->id;
			up_read(&card->controls_rwsem);
			snd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE, &id);
			return 0;
		}
	}
	up_read(&card->controls_rwsem);
	return result;
}
","1. struct snd_kcontrol *kctl;
2. unsigned int index_offset;
int result;
3. kctl = snd_ctl_find_id(card, &control->id);
4. index_offset = snd_ctl_get_ioff(kctl, &control->id);
5. result = -EPERM;
6. snd_ctl_build_ioff(&control->id, kctl, index_offset);
result = kctl->put(kctl, control);
7. struct snd_ctl_elem_id id = control->id;
8. return 0;
9. return result;","4
6-7
10
14
19
21-22
25
28
32","CWE-119,CWE-20,CWE-284,CWE-416"
ChopUpSingleUncompressedStrip,"
#define TIFF

ChopUpSingleUncompressedStrip(TIFF* tif)
{
	register TIFFDirectory *td = &tif->tif_dir;
	uint64 bytecount;
	uint64 offset;
	uint32 rowblock;
 	uint64 rowblockbytes;
 	uint64 stripbytes;
 	uint32 strip;
	uint32 nstrips;
 	uint32 rowsperstrip;
 	uint64* newcounts;
 	uint64* newoffsets;

	bytecount = td->td_stripbytecount[0];
	offset = td->td_stripoffset[0];
	assert(td->td_planarconfig == PLANARCONFIG_CONTIG);
	if ((td->td_photometric == PHOTOMETRIC_YCBCR)&&
	    (!isUpSampled(tif)))
		rowblock = td->td_ycbcrsubsampling[1];
	else
		rowblock = 1;
	rowblockbytes = TIFFVTileSize64(tif, rowblock);
	
	if (rowblockbytes > STRIP_SIZE_DEFAULT) {
		stripbytes = rowblockbytes;
		rowsperstrip = rowblock;
	} else if (rowblockbytes > 0 ) {
		uint32 rowblocksperstrip;
		rowblocksperstrip = (uint32) (STRIP_SIZE_DEFAULT / rowblockbytes);
		rowsperstrip = rowblocksperstrip * rowblock;
		stripbytes = rowblocksperstrip * rowblockbytes;
	}
	else
 	    return;
 
 	
 	if (rowsperstrip >= td->td_rowsperstrip)
 		return;
        nstrips = TIFFhowmany_32(td->td_imagelength, rowsperstrip);
        if( nstrips == 0 )
            return;
 
	newcounts = (uint64*) _TIFFCheckMalloc(tif, nstrips, sizeof (uint64),
 				""for chopped \""StripByteCounts\"" array"");
	newoffsets = (uint64*) _TIFFCheckMalloc(tif, nstrips, sizeof (uint64),
 				""for chopped \""StripOffsets\"" array"");
 	if (newcounts == NULL || newoffsets == NULL) {
 		
		if (newcounts != NULL)
			_TIFFfree(newcounts);
		if (newoffsets != NULL)
			_TIFFfree(newoffsets);
		return;
	}
	
	for (strip = 0; strip < nstrips; strip++) {
 		if (stripbytes > bytecount)
 			stripbytes = bytecount;
 		newcounts[strip] = stripbytes;
		newoffsets[strip] = stripbytes ? offset : 0;
 		offset += stripbytes;
 		bytecount -= stripbytes;
 	}
 	
	td->td_stripsperimage = td->td_nstrips = nstrips;
 	TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rowsperstrip);
 
 	_TIFFfree(td->td_stripbytecount);
	_TIFFfree(td->td_stripoffset);
	td->td_stripbytecount = newcounts;
	td->td_stripoffset = newoffsets;
	td->td_stripbytecountsorted = 1;
}
","1. uint32 rowblock;
2. uint64 stripbytes;
3. uint32 nstrips;
4. rowblock = td->td_ycbcrsubsampling[1];
5. rowblock = 1;
6. return;
7. if (rowsperstrip >= td->td_rowsperstrip)
8. newcounts = (uint64*) _TIFFCheckMalloc(tif, nstrips, sizeof (uint64),
9. newcounts[strip] = stripbytes;
10. _TIFFfree(td->td_stripoffset);
11. td->td_stripbytecountsorted = 1;","9
11
13
23
25
41
46
52
74
86
89","CWE-17,CWE-190,CWE-125,CWE-119"
Media_RewriteODFrame-133171927497254,"
#define GF_ISOSample
#define GF_MediaBox

GF_Err Media_RewriteODFrame(GF_MediaBox *mdia, GF_ISOSample *sample)
{
	GF_Err e;
	GF_ODCodec *ODdecode;
	GF_ODCodec *ODencode;
	GF_ODCom *com;

	
	GF_ESDUpdate *esdU, *esdU2;
	GF_ESDRemove *esdR, *esdR2;
	GF_ODUpdate *odU, *odU2;

	
	GF_ObjectDescriptor *od;
	GF_IsomObjectDescriptor *isom_od;
	GF_ESD *esd;
	GF_ES_ID_Ref *ref;
	GF_Descriptor *desc;
	GF_TrackReferenceTypeBox *mpod;
	u32 i, j, skipped;

	if (!mdia || !sample || !sample->data || !sample->dataLength) return GF_BAD_PARAM;

	mpod = NULL;
	e = Track_FindRef(mdia->mediaTrack, GF_ISOM_BOX_TYPE_MPOD, &mpod);
	if (e) return e;
	
	if (!mpod || !mpod->trackIDs) return GF_OK;

	ODdecode = gf_odf_codec_new();
	if (!ODdecode) return GF_OUT_OF_MEM;
	ODencode = gf_odf_codec_new();
	if (!ODencode) {
		gf_odf_codec_del(ODdecode);
		return GF_OUT_OF_MEM;
	}
	e = gf_odf_codec_set_au(ODdecode, sample->data, sample->dataLength);
	if (e) goto err_exit;
	e = gf_odf_codec_decode(ODdecode);
	if (e) goto err_exit;

	while (1) {
		com = gf_odf_codec_get_com(ODdecode);
		if (!com) break;

		
		switch (com->tag) {
		case GF_ODF_OD_UPDATE_TAG:
			odU = (GF_ODUpdate *) com;
			odU2 = (GF_ODUpdate *) gf_odf_com_new(GF_ODF_OD_UPDATE_TAG);

			i=0;
			while ((desc = (GF_Descriptor*)gf_list_enum(odU->objectDescriptors, &i))) {
				switch (desc->tag) {
				case GF_ODF_OD_TAG:
				case GF_ODF_ISOM_OD_TAG:
				
				case GF_ODF_ISOM_IOD_TAG:
					break;
				default:
					return GF_ISOM_INVALID_FILE;
				}
				e = gf_odf_desc_copy(desc, (GF_Descriptor **)&isom_od);
				if (e) goto err_exit;

				
				if (desc->tag == GF_ODF_ISOM_IOD_TAG) {
					od = (GF_ObjectDescriptor *) gf_malloc(sizeof(GF_InitialObjectDescriptor));
				} else {
					od = (GF_ObjectDescriptor *) gf_malloc(sizeof(GF_ObjectDescriptor));
				}
				if (!od) {
					e = GF_OUT_OF_MEM;
					goto err_exit;
				}
				od->ESDescriptors = gf_list_new();
				
				od->objectDescriptorID = isom_od->objectDescriptorID;
				od->tag = GF_ODF_OD_TAG;
				od->URLString = isom_od->URLString;
				isom_od->URLString = NULL;
				od->extensionDescriptors = isom_od->extensionDescriptors;
				isom_od->extensionDescriptors = NULL;
				od->IPMP_Descriptors = isom_od->IPMP_Descriptors;
				isom_od->IPMP_Descriptors = NULL;
				od->OCIDescriptors = isom_od->OCIDescriptors;
				isom_od->OCIDescriptors = NULL;

				
				if (isom_od->tag == GF_ODF_ISOM_IOD_TAG) {
					((GF_InitialObjectDescriptor *)od)->audio_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->audio_profileAndLevel;
					((GF_InitialObjectDescriptor *)od)->inlineProfileFlag = ((GF_IsomInitialObjectDescriptor *)isom_od)->inlineProfileFlag;
					((GF_InitialObjectDescriptor *)od)->graphics_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->graphics_profileAndLevel;
					((GF_InitialObjectDescriptor *)od)->OD_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->OD_profileAndLevel;
					((GF_InitialObjectDescriptor *)od)->scene_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->scene_profileAndLevel;
					((GF_InitialObjectDescriptor *)od)->visual_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->visual_profileAndLevel;
					((GF_InitialObjectDescriptor *)od)->IPMPToolList = ((GF_IsomInitialObjectDescriptor *)isom_od)->IPMPToolList;
					((GF_IsomInitialObjectDescriptor *)isom_od)->IPMPToolList = NULL;
				}

				
				j=0;
				while ((ref = (GF_ES_ID_Ref*)gf_list_enum(isom_od->ES_ID_RefDescriptors, &j))) {
					if (!mpod->trackIDs || !ref->trackRef || (ref->trackRef>mpod->trackIDCount)) continue;
					
					if (gf_isom_get_track_from_id(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1]) == NULL) continue;
					
					e = GetESDForTime(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1], sample->DTS, &esd);
					if (!e) e = gf_odf_desc_add_desc((GF_Descriptor *) od, (GF_Descriptor *) esd);
					if (e) {
						gf_odf_desc_del((GF_Descriptor *)od);
						gf_odf_com_del((GF_ODCom **)&odU2);
						gf_odf_desc_del((GF_Descriptor *)isom_od);
						gf_odf_com_del((GF_ODCom **)&odU);
						goto err_exit;
					}

				}
				
				gf_odf_desc_del((GF_Descriptor *)isom_od);
				gf_list_add(odU2->objectDescriptors, od);
			}
			
			gf_odf_com_del((GF_ODCom **)&odU);
			gf_odf_codec_add_com(ODencode, (GF_ODCom *)odU2);
			break;

		case GF_ODF_ESD_UPDATE_TAG:
			esdU = (GF_ESDUpdate *) com;
			esdU2 = (GF_ESDUpdate *) gf_odf_com_new(GF_ODF_ESD_UPDATE_TAG);
			esdU2->ODID = esdU->ODID;
			i=0;
			while ((ref = (GF_ES_ID_Ref*)gf_list_enum(esdU->ESDescriptors, &i))) {
				if (!mpod->trackIDs || !ref->trackRef || (ref->trackRef>mpod->trackIDCount)) continue;
				
				if (gf_isom_get_track_from_id(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1]) == NULL) continue;
				
				e = GetESDForTime(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1], sample->DTS, &esd);
				if (e) goto err_exit;
				gf_list_add(esdU2->ESDescriptors, esd);
			}
			gf_odf_com_del((GF_ODCom **)&esdU);
			gf_odf_codec_add_com(ODencode, (GF_ODCom *)esdU2);
			break;

		
		case GF_ODF_ESD_REMOVE_REF_TAG:
			
			esdR = (GF_ESDRemove *) com;
			esdR2 = (GF_ESDRemove *) gf_odf_com_new(GF_ODF_ESD_REMOVE_TAG);
			esdR2->ODID = esdR->ODID;
			esdR2->NbESDs = esdR->NbESDs;
			
			esdR2->ES_ID = (unsigned short*)gf_malloc(sizeof(u32) * esdR->NbESDs);
			if (!esdR2->ES_ID) {
				e = GF_OUT_OF_MEM;
				goto err_exit;
			}
			skipped = 0;
			
			for (i = 0; i < esdR->NbESDs; i++) {
				if (!mpod->trackIDs || !esdR->ES_ID[i] || (esdR->ES_ID[i]>mpod->trackIDCount)) continue;
				
				if (gf_isom_get_track_from_id(mdia->mediaTrack->moov, mpod->trackIDs[esdR->ES_ID[i] - 1]) == NULL) {
					skipped ++;
				} else {
					
					esdR2->ES_ID[i - skipped] = mpod->trackIDs[esdR->ES_ID[i] - 1];
				}
			}
			
			if (skipped && (skipped != esdR2->NbESDs) ) {
				esdR2->NbESDs -= skipped;
				esdR2->ES_ID = (unsigned short*)gf_realloc(esdR2->ES_ID, sizeof(u32) * esdR2->NbESDs);
			}
			gf_odf_com_del((GF_ODCom **)&esdR);
			gf_odf_codec_add_com(ODencode, (GF_ODCom *)esdR2);
			break;

		default:
			e = gf_odf_codec_add_com(ODencode, com);
			if (e) goto err_exit;
		}
	}
	
	e = gf_odf_codec_encode(ODencode, 1);
	if (e) goto err_exit;

	
	gf_free(sample->data);
	sample->data = NULL;
	sample->dataLength = 0;
	e = gf_odf_codec_get_au(ODencode, &sample->data, &sample->dataLength);

err_exit:
	gf_odf_codec_del(ODdecode);
	gf_odf_codec_del(ODencode);
	return e;
}
","1. e = gf_odf_codec_decode(ODdecode);
2. ((GF_InitialObjectDescriptor *)od)->OD_profileAndLevel = ((GF_IsomInitialObjectDescriptor *)isom_od)->OD_profileAndLevel;
3. gf_odf_com_del((GF_ODCom **)&odU2);
4. e = GetESDForTime(mdia->mediaTrack->moov, mpod->trackIDs[ref->trackRef - 1], sample->DTS, &esd);
5. sample->dataLength = 0;","43
98
116
142
196","CWE-119,CWE-125,CWE-287,CWE-416"
__ptrace_may_access-145514619756062,"static int __ptrace_may_access(struct task_struct *task, unsigned int mode)
{
	const struct cred *cred = current_cred(), *tcred;

	
	int dumpable = 0;
	
	if (same_thread_group(task, current))
		return 0;
	rcu_read_lock();
	tcred = __task_cred(task);
	if (uid_eq(cred->uid, tcred->euid) &&
	    uid_eq(cred->uid, tcred->suid) &&
	    uid_eq(cred->uid, tcred->uid)  &&
	    gid_eq(cred->gid, tcred->egid) &&
	    gid_eq(cred->gid, tcred->sgid) &&
	    gid_eq(cred->gid, tcred->gid))
		goto ok;
	if (ptrace_has_cap(tcred->user_ns, mode))
		goto ok;
	rcu_read_unlock();
	return -EPERM;
ok:
	rcu_read_unlock();
	smp_rmb();
	if (task->mm)
		dumpable = get_dumpable(task->mm);
	rcu_read_lock();
	if (dumpable != SUID_DUMP_USER &&
	    !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {
		rcu_read_unlock();
		return -EPERM;
	}
	rcu_read_unlock();

	return security_ptrace_access_check(task, mode);
}
","1. const struct cred *cred = current_cred(), *tcred;
2. int dumpable = 0;
3. if (same_thread_group(task, current))
4. uid_eq(cred->uid, tcred->uid)  &&
5. gid_eq(cred->gid, tcred->gid))
goto ok;
if (ptrace_has_cap(tcred->user_ns, mode))
6. rcu_read_unlock();
7. ok:
rcu_read_unlock();
8. if (task->mm)
9. return -EPERM;
10. return security_ptrace_access_check(task, mode);","3
13
15
21
24-26
28
30-31
33
39
43","CWE-264,CWE-200,CWE-285,CWE-400,CWE-436"
aa_read_header,"
#define AVFormatContext

static int aa_read_header(AVFormatContext *s)
{
    int i, j, idx, largest_idx = -1;
    uint32_t nkey, nval, toc_size, npairs, header_seed = 0, start;
    char key[128], val[128], codec_name[64] = {0};
    uint8_t output[24], dst[8], src[8];
    int64_t largest_size = -1, current_size = -1, chapter_pos;
    struct toc_entry {
        uint32_t offset;
        uint32_t size;
    } TOC[MAX_TOC_ENTRIES];
    uint32_t header_key_part[4];
    uint8_t header_key[16] = {0};
     AADemuxContext *c = s->priv_data;
     AVIOContext *pb = s->pb;
     AVStream *st;
    int ret;
 
     
     avio_skip(pb, 4); 
    avio_skip(pb, 4); 
    toc_size = avio_rb32(pb); 
    avio_skip(pb, 4); 
    if (toc_size > MAX_TOC_ENTRIES)
        return AVERROR_INVALIDDATA;
    for (i = 0; i < toc_size; i++) { 
        avio_skip(pb, 4); 
        TOC[i].offset = avio_rb32(pb); 
        TOC[i].size = avio_rb32(pb); 
    }
    avio_skip(pb, 24); 
    npairs = avio_rb32(pb); 
    if (npairs > MAX_DICTIONARY_ENTRIES)
        return AVERROR_INVALIDDATA;
    for (i = 0; i < npairs; i++) {
        memset(val, 0, sizeof(val));
        memset(key, 0, sizeof(key));
        avio_skip(pb, 1); 
        nkey = avio_rb32(pb); 
        nval = avio_rb32(pb); 
        avio_get_str(pb, nkey, key, sizeof(key));
        avio_get_str(pb, nval, val, sizeof(val));
        if (!strcmp(key, ""codec"")) {
            av_log(s, AV_LOG_DEBUG, ""Codec is <%s>\n"", val);
            strncpy(codec_name, val, sizeof(codec_name) - 1);
        } else if (!strcmp(key, ""HeaderSeed"")) {
            av_log(s, AV_LOG_DEBUG, ""HeaderSeed is <%s>\n"", val);
             header_seed = atoi(val);
         } else if (!strcmp(key, ""HeaderKey"")) { 
             av_log(s, AV_LOG_DEBUG, ""HeaderKey is <%s>\n"", val);

            ret = sscanf(val, ""%""SCNu32""%""SCNu32""%""SCNu32""%""SCNu32,
                    &header_key_part[0], &header_key_part[1], &header_key_part[2], &header_key_part[3]);
            if (ret != 4)
                return AVERROR_INVALIDDATA;

             for (idx = 0; idx < 4; idx++) {
                 AV_WB32(&header_key[idx * 4], header_key_part[idx]); 
             }
            av_log(s, AV_LOG_DEBUG, ""Processed HeaderKey is "");
            for (i = 0; i < 16; i++)
                av_log(s, AV_LOG_DEBUG, ""%02x"", header_key[i]);
            av_log(s, AV_LOG_DEBUG, ""\n"");
        } else {
            av_dict_set(&s->metadata, key, val, 0);
        }
    }

    
    if (c->aa_fixed_key_len != 16) {
        av_log(s, AV_LOG_ERROR, ""aa_fixed_key value needs to be 16 bytes!\n"");
        return AVERROR(EINVAL);
    }

    
    if ((c->codec_second_size = get_second_size(codec_name)) == -1) {
        av_log(s, AV_LOG_ERROR, ""unknown codec <%s>!\n"", codec_name);
        return AVERROR(EINVAL);
    }

    
    c->tea_ctx = av_tea_alloc();
    if (!c->tea_ctx)
        return AVERROR(ENOMEM);
    av_tea_init(c->tea_ctx, c->aa_fixed_key, 16);
    output[0] = output[1] = 0; 
    memcpy(output + 2, header_key, 16);
    idx = 0;
    for (i = 0; i < 3; i++) { 
        AV_WB32(src, header_seed);
        AV_WB32(src + 4, header_seed + 1);
        header_seed += 2;
        av_tea_crypt(c->tea_ctx, dst, src, 1, NULL, 0); 
        for (j = 0; j < TEA_BLOCK_SIZE && idx < 18; j+=1, idx+=1) {
            output[idx] = output[idx] ^ dst[j];
        }
    }
    memcpy(c->file_key, output + 2, 16); 
    av_log(s, AV_LOG_DEBUG, ""File key is "");
    for (i = 0; i < 16; i++)
        av_log(s, AV_LOG_DEBUG, ""%02x"", c->file_key[i]);
    av_log(s, AV_LOG_DEBUG, ""\n"");

    
    st = avformat_new_stream(s, NULL);
    if (!st) {
        av_freep(&c->tea_ctx);
        return AVERROR(ENOMEM);
    }
    st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;
    if (!strcmp(codec_name, ""mp332"")) {
        st->codecpar->codec_id = AV_CODEC_ID_MP3;
        st->codecpar->sample_rate = 22050;
        st->need_parsing = AVSTREAM_PARSE_FULL_RAW;
        avpriv_set_pts_info(st, 64, 8, 32000 * TIMEPREC);
    } else if (!strcmp(codec_name, ""acelp85"")) {
        st->codecpar->codec_id = AV_CODEC_ID_SIPR;
        st->codecpar->block_align = 19;
        st->codecpar->channels = 1;
        st->codecpar->sample_rate = 8500;
        st->codecpar->bit_rate = 8500;
        st->need_parsing = AVSTREAM_PARSE_FULL_RAW;
        avpriv_set_pts_info(st, 64, 8, 8500 * TIMEPREC);
    } else if (!strcmp(codec_name, ""acelp16"")) {
        st->codecpar->codec_id = AV_CODEC_ID_SIPR;
        st->codecpar->block_align = 20;
        st->codecpar->channels = 1;
        st->codecpar->sample_rate = 16000;
        st->codecpar->bit_rate = 16000;
        st->need_parsing = AVSTREAM_PARSE_FULL_RAW;
        avpriv_set_pts_info(st, 64, 8, 16000 * TIMEPREC);
    }

    
    for (i = 1; i < toc_size; i++) { 
        current_size = TOC[i].size;
        if (current_size > largest_size) {
            largest_idx = i;
            largest_size = current_size;
        }
    }
    start = TOC[largest_idx].offset;
    avio_seek(pb, start, SEEK_SET);

    st->start_time = 0;
    c->content_start = start;
    c->content_end = start + largest_size;

    while ((chapter_pos = avio_tell(pb)) >= 0 && chapter_pos < c->content_end) {
        int chapter_idx = s->nb_chapters;
        uint32_t chapter_size = avio_rb32(pb);
        if (chapter_size == 0) break;
        chapter_pos -= start + CHAPTER_HEADER_SIZE * chapter_idx;
        avio_skip(pb, 4 + chapter_size);
        if (!avpriv_new_chapter(s, chapter_idx, st->time_base,
            chapter_pos * TIMEPREC, (chapter_pos + chapter_size) * TIMEPREC, NULL))
                return AVERROR(ENOMEM);
    }

    st->duration = (largest_size - CHAPTER_HEADER_SIZE * s->nb_chapters) * TIMEPREC;

    ff_update_cur_dts(s, st, 0);
    avio_seek(pb, start, SEEK_SET);
    c->current_chapter_size = 0;
    c->seek_offset = 0;

    return 0;
}
","1. uint8_t output[24], dst[8], src[8];
2. avio_skip(pb, 4);
3. if (npairs > MAX_DICTIONARY_ENTRIES)
4. av_log(s, AV_LOG_DEBUG, ""%02x"", header_key[i]);
5. output[0] = output[1] = 0;
6. idx = 0;
7. AV_WB32(src + 4, header_seed + 1);
8. output[idx] = output[idx] ^ dst[j];
9. st->codecpar->codec_id = AV_CODEC_ID_MP3;
10. int chapter_idx = s->nb_chapters;","9
23
36
65
89
91
94
98
115
153","CWE-908,CWE-20,CWE-19"
xc2028_set_config,"static int xc2028_set_config(struct dvb_frontend *fe, void *priv_cfg)
{
	struct xc2028_data *priv = fe->tuner_priv;
	struct xc2028_ctrl *p    = priv_cfg;
	int                 rc   = 0;

	tuner_dbg(""%s called\n"", __func__);

	mutex_lock(&priv->lock);

	
 	kfree(priv->ctrl.fname);
	priv->ctrl.fname = NULL;
 	memcpy(&priv->ctrl, p, sizeof(priv->ctrl));
 	if (p->fname) {
 		priv->ctrl.fname = kstrdup(p->fname, GFP_KERNEL);
 		if (priv->ctrl.fname == NULL)
			return -ENOMEM;
 	}
 
 	
	if (!firmware_name[0] && p->fname &&
	    priv->fname && strcmp(p->fname, priv->fname))
		free_firmware(priv);

	if (priv->ctrl.max_len < 9)
		priv->ctrl.max_len = 13;

	if (priv->state == XC2028_NO_FIRMWARE) {
		if (!firmware_name[0])
			priv->fname = priv->ctrl.fname;
		else
			priv->fname = firmware_name;

		rc = request_firmware_nowait(THIS_MODULE, 1,
					     priv->fname,
					     priv->i2c_props.adap->dev.parent,
					     GFP_KERNEL,
					     fe, load_firmware_cb);
		if (rc < 0) {
			tuner_err(""Failed to request firmware %s\n"",
				  priv->fname);
			priv->state = XC2028_NODEV;
		} else
			priv->state = XC2028_WAITING_FIRMWARE;
	}
	mutex_unlock(&priv->lock);

	return rc;
}
","1. memcpy(&priv->ctrl, p, sizeof(priv->ctrl));
2. priv->ctrl.fname = kstrdup(p->fname, GFP_KERNEL);
3. priv->fname && strcmp(p->fname, priv->fname))
free_firmware(priv);
4. if (priv->ctrl.max_len < 9)
priv->ctrl.max_len = 13;
5. if (priv->state == XC2028_NO_FIRMWARE) {
6. priv->fname,
7. if (rc < 0) {","18
20
30-31
33-34
36
43
47","CWE-119,CWE-416"
pkey_gost2018_encrypt-2388469219255,"
#define EVP_PKEY_CTX

static int pkey_gost2018_encrypt(EVP_PKEY_CTX *pctx, unsigned char *out,
                          size_t *out_len, const unsigned char *key,
                          size_t key_len)
{
    PSKeyTransport_gost *pst = NULL;
    EVP_PKEY *pubk = EVP_PKEY_CTX_get0_pkey(pctx);
    struct gost_pmeth_data *data = EVP_PKEY_CTX_get_data(pctx);
    int pkey_nid = EVP_PKEY_base_id(pubk);
    unsigned char expkeys[64];
    EVP_PKEY *sec_key = NULL;
    int ret = 0;
    int mac_nid = NID_undef;
    size_t mac_len = 0;
    int exp_len = 0, iv_len = 0;
    unsigned char *exp_buf = NULL;
    int key_is_ephemeral = 0;
    int res_len = 0;

    switch (data->cipher_nid) {
    case NID_magma_ctr:
        mac_nid = NID_magma_mac;
        mac_len = 8;
        iv_len = 4;
        break;
    case NID_grasshopper_ctr:
        mac_nid = NID_grasshopper_mac;
        mac_len = 16;
        iv_len = 8;
        break;
    default:
        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, GOST_R_INVALID_CIPHER);
        return -1;
        break;
    }
    exp_len = key_len + mac_len;
    exp_buf = OPENSSL_malloc(exp_len);
    if (!exp_buf) {
        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_MALLOC_FAILURE);
        return -1;
    }

    sec_key = EVP_PKEY_CTX_get0_peerkey(pctx);
    if (!sec_key)
    {
      sec_key = EVP_PKEY_new();
      if (sec_key == NULL) {
        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_MALLOC_FAILURE );
        goto err;
      }

      if (!EVP_PKEY_assign(sec_key, EVP_PKEY_base_id(pubk), EC_KEY_new())
          || !EVP_PKEY_copy_parameters(sec_key, pubk)
          || !gost_ec_keygen(EVP_PKEY_get0(sec_key))) {
        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT,
            GOST_R_ERROR_COMPUTING_SHARED_KEY);
        goto err;
      }
      key_is_ephemeral = 1;
    }

    if (data->shared_ukm_size == 0) {
        if (RAND_bytes(data->shared_ukm, 32) <= 0) {
            GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_INTERNAL_ERROR);
            goto err;
        }
        data->shared_ukm_size = 32;
    }

    if (gost_keg(data->shared_ukm, pkey_nid,
                 EC_KEY_get0_public_key(EVP_PKEY_get0(pubk)),
                 EVP_PKEY_get0(sec_key), expkeys) <= 0) {
        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT,
                GOST_R_ERROR_COMPUTING_EXPORT_KEYS);
        goto err;
    }

    if (gost_kexp15(key, key_len, data->cipher_nid, expkeys + 32,
                    mac_nid, expkeys + 0, data->shared_ukm + 24, iv_len,
                    exp_buf, &exp_len) <= 0) {
        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, GOST_R_CANNOT_PACK_EPHEMERAL_KEY);
        goto err;
    }

    pst = PSKeyTransport_gost_new();
    if (!pst) {
        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_MALLOC_FAILURE);
        goto err;
    }

    pst->ukm = ASN1_OCTET_STRING_new();
    if (pst->ukm == NULL) {
        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_MALLOC_FAILURE);
        goto err;
    }

    if (!ASN1_OCTET_STRING_set(pst->ukm, data->shared_ukm, data->shared_ukm_size)) {
        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_MALLOC_FAILURE);
        goto err;
    }

    if (!ASN1_OCTET_STRING_set(pst->psexp, exp_buf, exp_len)) {
        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_MALLOC_FAILURE);
        goto err;
    }

    if (!X509_PUBKEY_set(&pst->ephem_key, out ? sec_key : pubk)) {
        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, GOST_R_CANNOT_PACK_EPHEMERAL_KEY);
        goto err;
    }

    res_len = i2d_PSKeyTransport_gost(pst, NULL);
    if (res_len <= 0) {
        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_ASN1_LIB);
        goto err;
    }

    if (out == NULL) {
        *out_len = res_len;
        ret = 1;
    } else {
        if ((size_t)res_len > *out_len) {
            GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, GOST_R_INVALID_BUFFER_SIZE);
            goto err;
        }
        if ((*out_len = i2d_PSKeyTransport_gost(pst, &out)) > 0)
            ret = 1;
        else
            GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_ASN1_LIB);
    }

 err:
    OPENSSL_cleanse(expkeys, sizeof(expkeys));
    if (key_is_ephemeral)
        EVP_PKEY_free(sec_key);

    PSKeyTransport_gost_free(pst);
    OPENSSL_free(exp_buf);
    return ret;
}
","1. size_t key_len)
2. EVP_PKEY *pubk = EVP_PKEY_CTX_get0_pkey(pctx);
3. int exp_len = 0, iv_len = 0;
4. case NID_magma_ctr:
5. case NID_grasshopper_ctr:
6. iv_len = 8;
7. exp_len = key_len + mac_len;
8. if (RAND_bytes(data->shared_ukm, 32) <= 0) {
9. if (gost_kexp15(key, key_len, data->cipher_nid, expkeys + 32,
10. exp_buf, &exp_len) <= 0) {
11. GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_MALLOC_FAILURE);
12. goto err;
13. PSKeyTransport_gost_free(pst);","6
9
17
23
28
31
38
65
80
82
100
117
139","CWE-200,CWE-120,CWE-399,CWE-119"
flush_completed_IO," int flush_completed_IO(struct inode *inode)
 {
 	ext4_io_end_t *io;
	struct ext4_inode_info *ei = EXT4_I(inode);
	unsigned long flags;
 	int ret = 0;
 	int ret2 = 0;
 
	if (list_empty(&ei->i_completed_io_list))
 		return ret;
 
 	dump_completed_IO(inode);
	spin_lock_irqsave(&ei->i_completed_io_lock, flags);
	while (!list_empty(&ei->i_completed_io_list)){
		io = list_entry(ei->i_completed_io_list.next,
 				ext4_io_end_t, list);
 		
		spin_unlock_irqrestore(&ei->i_completed_io_lock, flags);
 		ret = ext4_end_io_nolock(io);
		spin_lock_irqsave(&ei->i_completed_io_lock, flags);
 		if (ret < 0)
 			ret2 = ret;
 		else
 			list_del_init(&io->list);
 	}
	spin_unlock_irqrestore(&ei->i_completed_io_lock, flags);
 	return (ret2 < 0) ? ret2 : 0;
 }
","1. int flush_completed_IO(struct inode *inode)
2. struct ext4_inode_info *ei = EXT4_I(inode);
unsigned long flags;
3. int ret2 = 0;
4. if (list_empty(&ei->i_completed_io_list))
return ret;
5. dump_completed_IO(inode);
spin_lock_irqsave(&ei->i_completed_io_lock, flags);
while (!list_empty(&ei->i_completed_io_list)){
io = list_entry(ei->i_completed_io_list.next,
ext4_io_end_t, list);
6. spin_unlock_irqrestore(&ei->i_completed_io_lock, flags);
ret = ext4_end_io_nolock(io);
7. if (ret < 0)
ret2 = ret;
8. list_del_init(&io->list);
9. spin_unlock_irqrestore(&ei->i_completed_io_lock, flags);
return (ret2 < 0) ? ret2 : 0;","1
4-5
7
9-10
12-16
31-32
34-35
37
39-40","CWE-17,CWE-125,CWE-416"
__nfs4_get_acl_uncached_1-155939218557128,"static ssize_t __nfs4_get_acl_uncached_1(struct inode *inode, void *buf, size_t buflen)
{
	struct page *pages[NFS4ACL_MAXPAGES] = {NULL, };
	struct nfs_getaclargs args = {
		.fh = NFS_FH(inode),
		.acl_pages = pages,
		.acl_len = buflen,
	};
	struct nfs_getaclres res = {
		.acl_len = buflen,
	};
	void *resp_buf;
	struct rpc_message msg = {
		.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],
		.rpc_argp = &args,
		.rpc_resp = &res,
	};
	int ret = -ENOMEM, npages, i, acl_len = 0;

	npages = (buflen + PAGE_SIZE - 1) >> PAGE_SHIFT;
	
	if (npages == 0)
		npages = 1;

	for (i = 0; i < npages; i++) {
		pages[i] = alloc_page(GFP_KERNEL);
		if (!pages[i])
			goto out_free;
	}
	if (npages > 1) {
		
		res.acl_scratch = alloc_page(GFP_KERNEL);
		if (!res.acl_scratch)
			goto out_free;
	}
	args.acl_len = npages * PAGE_SIZE;
	args.acl_pgbase = 0;
	
	if (buf == NULL)
		res.acl_flags |= NFS4_ACL_LEN_REQUEST;
	resp_buf = page_address(pages[0]);

	dprintk(""%s  buf %p buflen %zu npages %d args.acl_len %zu\n"",
		__func__, buf, buflen, npages, args.acl_len);
	ret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),
			     &msg, &args.seq_args, &res.seq_res, 0);
	if (ret)
		goto out_free;

	acl_len = res.acl_len - res.acl_data_offset;
	if (acl_len > args.acl_len)
		nfs4_write_cached_acl(inode, NULL, acl_len);
	else
		nfs4_write_cached_acl(inode, resp_buf + res.acl_data_offset,
				      acl_len);
	if (buf) {
		ret = -ERANGE;
		if (acl_len > buflen)
			goto out_free;
		_copy_from_pages(buf, pages, res.acl_data_offset,
				acl_len);
	}
	ret = acl_len;
out_free:
	for (i = 0; i < npages; i++)
		if (pages[i])
			__free_page(pages[i]);
	if (res.acl_scratch)
		__free_page(res.acl_scratch);
	return ret;
}
","1. static ssize_t __nfs4_get_acl_uncached_1(struct inode *inode, void *buf, size_t buflen)
2. struct page *pages[NFS4ACL_MAXPAGES] = {NULL, };
struct nfs_getaclargs args = {
3. .acl_len = buflen,
4. .acl_len = buflen,
5. void *resp_buf;
6. .rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],
.rpc_argp = &args,
.rpc_resp = &res,
7. if (npages == 0)
npages = 1;
8. for (i = 0; i < npages; i++) {
pages[i] = alloc_page(GFP_KERNEL);
if (!pages[i])
goto out_free;
9. if (npages > 1) {
10. res.acl_scratch = alloc_page(GFP_KERNEL);
11. goto out_free;
12. args.acl_len = npages * PAGE_SIZE;
13. res.acl_flags |= NFS4_ACL_LEN_REQUEST;
resp_buf = page_address(pages[0]);
14. __func__, buf, buflen, npages, args.acl_len);
15. if (ret)
goto out_free;
16. acl_len = res.acl_len - res.acl_data_offset;
if (acl_len > args.acl_len)
nfs4_write_cached_acl(inode, NULL, acl_len);
17. acl_len);
if (buf) {
ret = -ERANGE;
if (acl_len > buflen)
goto out_free;
_copy_from_pages(buf, pages, res.acl_data_offset,
acl_len);
18. ret = acl_len;
out_free:
for (i = 0; i < npages; i++)
if (pages[i])
__free_page(pages[i]);
if (res.acl_scratch)
__free_page(res.acl_scratch);
return ret;","1
3-4
7
10
12
14-16
23-24
26-29
31
33
35
37
42-43
46
49-50
52-54
57-63
65-72","CWE-119,CWE-20,CWE-17,CWE-189"
xfrm_dump_sa_done-59712724135487,"static int xfrm_dump_sa_done(struct netlink_callback *cb)
{
	struct xfrm_state_walk *walk = (struct xfrm_state_walk *) &cb->args[1];
	struct sock *sk = cb->skb->sk;
	struct net *net = sock_net(sk);

	if (cb->args[0])
		xfrm_state_walk_done(walk, net);
	return 0;
}
","1. if (cb->args[0])
xfrm_state_walk_done(walk, net);
return 0;",7-9,"CWE-362,CWE-476,CWE-20,CWE-416"
Ins_IUP,"
#define INS_ARG

  Ins_IUP( INS_ARG )
  {
    IUP_WorkerRec  V;
    FT_Byte        mask;

    FT_UInt   first_point;   
    FT_UInt   end_point;     

    FT_UInt   first_touched; 
    FT_UInt   cur_touched;   

    FT_UInt   point;         
    FT_Short  contour;       

    FT_UNUSED_ARG;


    
    if ( CUR.pts.n_contours == 0 )
      return;

    if ( CUR.opcode & 1 )
    {
      mask   = FT_CURVE_TAG_TOUCH_X;
      V.orgs = CUR.pts.org;
      V.curs = CUR.pts.cur;
      V.orus = CUR.pts.orus;
    }
    else
    {
      mask   = FT_CURVE_TAG_TOUCH_Y;
      V.orgs = (FT_Vector*)( (FT_Pos*)CUR.pts.org + 1 );
      V.curs = (FT_Vector*)( (FT_Pos*)CUR.pts.cur + 1 );
      V.orus = (FT_Vector*)( (FT_Pos*)CUR.pts.orus + 1 );
    }
    V.max_points = CUR.pts.n_points;

    contour = 0;
    point   = 0;

    do
    {
       end_point   = CUR.pts.contours[contour] - CUR.pts.first_point;
       first_point = point;
 
      if ( BOUNDS ( end_point, CUR.pts.n_points ) )
        end_point = CUR.pts.n_points - 1;
 
       while ( point <= end_point && ( CUR.pts.tags[point] & mask ) == 0 )
         point++;

      if ( point <= end_point )
      {
        first_touched = point;
        cur_touched   = point;

        point++;

        while ( point <= end_point )
        {
          if ( ( CUR.pts.tags[point] & mask ) != 0 )
          {
            if ( point > 0 )
              _iup_worker_interpolate( &V,
                                       cur_touched + 1,
                                       point - 1,
                                       cur_touched,
                                       point );
            cur_touched = point;
          }

          point++;
        }

        if ( cur_touched == first_touched )
          _iup_worker_shift( &V, first_point, end_point, cur_touched );
        else
        {
          _iup_worker_interpolate( &V,
                                   (FT_UShort)( cur_touched + 1 ),
                                   end_point,
                                   cur_touched,
                                   first_touched );

          if ( first_touched > 0 )
            _iup_worker_interpolate( &V,
                                     first_point,
                                     first_touched - 1,
                                     cur_touched,
                                     first_touched );
        }
      }
      contour++;
    } while ( contour < CUR.pts.n_contours );
  }
","1. first_touched - 1,",91,"CWE-20,CWE-824,CWE-476,CWE-276,CWE-119"
cx24116_send_diseqc_msg-5765704368321,"static int cx24116_send_diseqc_msg(struct dvb_frontend *fe,
	struct dvb_diseqc_master_cmd *d)
{
	struct cx24116_state *state = fe->demodulator_priv;
	int i, ret;

	
	if (d->msg_len > sizeof(d->msg))
                return -EINVAL;

	
	if (debug) {
		printk(KERN_INFO ""cx24116: %s("", __func__);
		for (i = 0 ; i < d->msg_len ;) {
			printk(KERN_INFO ""0x%02x"", d->msg[i]);
			if (++i < d->msg_len)
				printk(KERN_INFO "", "");
		}
		printk("") toneburst=%d\n"", toneburst);
	}

	
	for (i = 0; i < d->msg_len; i++)
		state->dsec_cmd.args[CX24116_DISEQC_MSGOFS + i] = d->msg[i];

	
	state->dsec_cmd.args[CX24116_DISEQC_MSGLEN] = d->msg_len;

	
	state->dsec_cmd.len = CX24116_DISEQC_MSGOFS +
		state->dsec_cmd.args[CX24116_DISEQC_MSGLEN];

	
	if (toneburst == CX24116_DISEQC_MESGCACHE)
		
		return 0;

	else if (toneburst == CX24116_DISEQC_TONEOFF)
		
		state->dsec_cmd.args[CX24116_DISEQC_BURST] = 0;

	else if (toneburst == CX24116_DISEQC_TONECACHE) {
		
		if (d->msg_len >= 4 && d->msg[2] == 0x38)
			state->dsec_cmd.args[CX24116_DISEQC_BURST] =
				((d->msg[3] & 4) >> 2);
		if (debug)
			dprintk(""%s burst=%d\n"", __func__,
				state->dsec_cmd.args[CX24116_DISEQC_BURST]);
	}

	
	ret = cx24116_wait_for_lnb(fe);
	if (ret != 0)
		return ret;

	
	msleep(100);

	
	ret = cx24116_cmd_execute(fe, &state->dsec_cmd);
	if (ret != 0)
		return ret;
	
	msleep((state->dsec_cmd.args[CX24116_DISEQC_MSGLEN] << 4) +
		((toneburst == CX24116_DISEQC_TONEOFF) ? 30 : 60));

	return 0;
}
","1. static int cx24116_send_diseqc_msg(struct dvb_frontend *fe,
2. int i, ret;
3. if (d->msg_len > sizeof(d->msg))
4. for (i = 0 ; i < d->msg_len ;) {
5. state->dsec_cmd.args[CX24116_DISEQC_MSGOFS + i] = d->msg[i];
6. state->dsec_cmd.len = CX24116_DISEQC_MSGOFS +
7. state->dsec_cmd.args[CX24116_DISEQC_BURST] = 0;
8. ((d->msg[3] & 4) >> 2);
9. ret = cx24116_wait_for_lnb(fe);
10. msleep(100);
11. ret = cx24116_cmd_execute(fe, &state->dsec_cmd);
12. msleep((state->dsec_cmd.args[CX24116_DISEQC_MSGLEN] << 4) +
((toneburst == CX24116_DISEQC_TONEOFF) ? 30 : 60));
13. return 0;","1
5
8
14
24
30
40
63
70
75
78
91-92
94","CWE-362,CWE-200,CWE-120,CWE-119"
AirPDcapScanForKeys,"
#define AIRPDCAP_SEC_ASSOCIATION_ID
#define PAIRPDCAP_CONTEXT

static INT AirPDcapScanForKeys(
    PAIRPDCAP_CONTEXT ctx,
    const guint8 *data,
    const guint mac_header_len,
    const guint tot_len,
    AIRPDCAP_SEC_ASSOCIATION_ID id
)
{
    const UCHAR *addr;
    guint bodyLength;
    PAIRPDCAP_SEC_ASSOCIATION sta_sa;
    PAIRPDCAP_SEC_ASSOCIATION sa;
    guint offset = 0;
    const guint8 dot1x_header[] = {
        0xAA,             
        0xAA,             
        0x03,             
        0x00, 0x00, 0x00, 
        0x88, 0x8E        
    };
    const guint8 bt_dot1x_header[] = {
        0xAA,             
        0xAA,             
        0x03,             
        0x00, 0x19, 0x58, 
        0x00, 0x03        
    };
    const guint8 tdls_header[] = {
        0xAA,             
        0xAA,             
        0x03,             
        0x00, 0x00, 0x00, 
        0x89, 0x0D,       
        0x02,             
        0X0C              
    };

    const EAPOL_RSN_KEY *pEAPKey;
#ifdef _DEBUG
#define MSGBUF_LEN 255
    CHAR msgbuf[MSGBUF_LEN];
#endif
    AIRPDCAP_DEBUG_TRACE_START(""AirPDcapScanForKeys"");

    
    offset = mac_header_len;

    
    if (memcmp(data+offset, dot1x_header, 8) == 0 || memcmp(data+offset, bt_dot1x_header, 8) == 0) {

        AIRPDCAP_DEBUG_PRINT_LINE(""AirPDcapScanForKeys"", ""Authentication: EAPOL packet"", AIRPDCAP_DEBUG_LEVEL_3);

        
        offset+=8;

        
        if (data[offset+1]!=3) {
            AIRPDCAP_DEBUG_PRINT_LINE(""AirPDcapScanForKeys"", ""Not EAPOL-Key"", AIRPDCAP_DEBUG_LEVEL_3);
            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;
        }
 
         
         bodyLength=pntoh16(data+offset+2);
        if (((tot_len-offset-4) < bodyLength) || (bodyLength < sizeof(EAPOL_RSN_KEY))) { 
             AIRPDCAP_DEBUG_PRINT_LINE(""AirPDcapScanForKeys"", ""EAPOL body too short"", AIRPDCAP_DEBUG_LEVEL_3);
             return AIRPDCAP_RET_NO_VALID_HANDSHAKE;
         }

        
        offset+=4;

        pEAPKey = (const EAPOL_RSN_KEY *) (data+offset);

        
        if ( 
            pEAPKey->type != AIRPDCAP_RSN_WPA2_KEY_DESCRIPTOR &&             
            pEAPKey->type != AIRPDCAP_RSN_WPA_KEY_DESCRIPTOR)           
        {
            AIRPDCAP_DEBUG_PRINT_LINE(""AirPDcapScanForKeys"", ""Not valid key descriptor type"", AIRPDCAP_DEBUG_LEVEL_3);
            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;
        }

        
        offset+=1;

        
        sa = AirPDcapGetSaPtr(ctx, &id);
        if (sa == NULL){
            AIRPDCAP_DEBUG_PRINT_LINE(""AirPDcapScanForKeys"", ""No SA for BSSID found"", AIRPDCAP_DEBUG_LEVEL_3);
            return AIRPDCAP_RET_REQ_DATA;
        }

        
        if (AirPDcapRsna4WHandshake(ctx, data, sa, offset, tot_len) == AIRPDCAP_RET_SUCCESS_HANDSHAKE)
            return AIRPDCAP_RET_SUCCESS_HANDSHAKE;

        if (mac_header_len + GROUP_KEY_PAYLOAD_LEN_MIN > tot_len) {
            AIRPDCAP_DEBUG_PRINT_LINE(""AirPDcapScanForKeys"", ""Message too short for Group Key"", AIRPDCAP_DEBUG_LEVEL_3);
            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;
        }

        
        if (AIRPDCAP_EAP_KEY(data[offset+1])!=0 ||
            AIRPDCAP_EAP_ACK(data[offset+1])!=1 ||
            AIRPDCAP_EAP_MIC(data[offset]) != 1 ||
            AIRPDCAP_EAP_SEC(data[offset]) != 1){

            AIRPDCAP_DEBUG_PRINT_LINE(""AirPDcapScanForKeys"", ""Key bitfields not correct for Group Key"", AIRPDCAP_DEBUG_LEVEL_3);
            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;
        }

        
        memcpy(id.sta, broadcast_mac, AIRPDCAP_MAC_LEN);

        
        sa = AirPDcapGetSaPtr(ctx, &id);
        if (sa == NULL){
            return AIRPDCAP_RET_REQ_DATA;
        }

        

        
        if ( (addr=AirPDcapGetStaAddress((const AIRPDCAP_MAC_FRAME_ADDR4 *)(data))) != NULL) {
            memcpy(id.sta, addr, AIRPDCAP_MAC_LEN);
#ifdef _DEBUG
            g_snprintf(msgbuf, MSGBUF_LEN, ""ST_MAC: %2X.%2X.%2X.%2X.%2X.%2X\t"", id.sta[0],id.sta[1],id.sta[2],id.sta[3],id.sta[4],id.sta[5]);
#endif
            AIRPDCAP_DEBUG_PRINT_LINE(""AirPDcapScanForKeys"", msgbuf, AIRPDCAP_DEBUG_LEVEL_3);
        } else {
            AIRPDCAP_DEBUG_PRINT_LINE(""AirPDcapScanForKeys"", ""SA not found"", AIRPDCAP_DEBUG_LEVEL_5);
            return AIRPDCAP_RET_REQ_DATA;
        }

        sta_sa = AirPDcapGetSaPtr(ctx, &id);
        if (sta_sa == NULL){
            return AIRPDCAP_RET_REQ_DATA;
        }

        
        return (AirPDcapDecryptWPABroadcastKey(pEAPKey, sta_sa->wpa.ptk+16, sa, tot_len-offset+1));

    } else if (memcmp(data+offset, tdls_header, 10) == 0) {
        const guint8 *initiator, *responder;
        guint8 action;
        guint status, offset_rsne = 0, offset_fte = 0, offset_link = 0, offset_timeout = 0;
        AIRPDCAP_DEBUG_PRINT_LINE(""AirPDcapScanForKeys"", ""Authentication: TDLS Action Frame"", AIRPDCAP_DEBUG_LEVEL_3);

        
        offset+=10;

        
        action = data[offset];
        if (action!=1 && action!=2) {
            AIRPDCAP_DEBUG_PRINT_LINE(""AirPDcapScanForKeys"", ""Not Response nor confirm"", AIRPDCAP_DEBUG_LEVEL_3);
            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;
        }

        
        offset++;
        status=pntoh16(data+offset);
        if (status!=0) {
            AIRPDCAP_DEBUG_PRINT_LINE(""AirPDcapScanForKeys"", ""TDLS setup not successfull"", AIRPDCAP_DEBUG_LEVEL_3);
            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;
        }

        
        offset+=5;

        

        while(offset < (tot_len - 2)) {
            if (data[offset] == 48) {
                offset_rsne = offset;
            } else if (data[offset] == 55) {
                offset_fte = offset;
            } else if (data[offset] == 56) {
                offset_timeout = offset;
            } else if (data[offset] == 101) {
                offset_link = offset;
            }

            if (tot_len < offset + data[offset + 1] + 2) {
                return AIRPDCAP_RET_NO_VALID_HANDSHAKE;
            }
            offset += data[offset + 1] + 2;
        }

        if (offset_rsne == 0 || offset_fte == 0 ||
            offset_timeout == 0 || offset_link == 0)
        {
            AIRPDCAP_DEBUG_PRINT_LINE(""AirPDcapScanForKeys"", ""Cannot Find all necessary IEs"", AIRPDCAP_DEBUG_LEVEL_3);
            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;
        }

        AIRPDCAP_DEBUG_PRINT_LINE(""AirPDcapScanForKeys"", ""Found RSNE/Fast BSS/Timeout Interval/Link IEs"", AIRPDCAP_DEBUG_LEVEL_3);

        
        initiator = &data[offset_link + 8];
        responder = &data[offset_link + 14];

        if (memcmp(initiator, responder, AIRPDCAP_MAC_LEN) < 0) {
            memcpy(id.sta, initiator, AIRPDCAP_MAC_LEN);
            memcpy(id.bssid, responder, AIRPDCAP_MAC_LEN);
        } else {
            memcpy(id.sta, responder, AIRPDCAP_MAC_LEN);
            memcpy(id.bssid, initiator, AIRPDCAP_MAC_LEN);
        }

        sa = AirPDcapGetSaPtr(ctx, &id);
        if (sa == NULL){
            return AIRPDCAP_RET_REQ_DATA;
        }

        if (sa->validKey) {
            if (memcmp(sa->wpa.nonce, data + offset_fte + 52, AIRPDCAP_WPA_NONCE_LEN) == 0) {
                
                return AIRPDCAP_RET_SUCCESS_HANDSHAKE;
            } else {
                
                AIRPDCAP_SEC_ASSOCIATION *tmp_sa = g_new(AIRPDCAP_SEC_ASSOCIATION, 1);
                memcpy(tmp_sa, sa, sizeof(AIRPDCAP_SEC_ASSOCIATION));
                sa->next=tmp_sa;
                sa->validKey = FALSE;
            }
        }

        if (AirPDcapTDLSDeriveKey(sa, data, offset_rsne, offset_fte, offset_timeout, offset_link, action)
            == AIRPDCAP_RET_SUCCESS) {
            AIRPDCAP_DEBUG_TRACE_END(""AirPDcapScanForKeys"");
            return AIRPDCAP_RET_SUCCESS_HANDSHAKE;
        }
    } else {
        AIRPDCAP_DEBUG_PRINT_LINE(""AirPDcapScanForKeys"", ""Skipping: not an EAPOL packet"", AIRPDCAP_DEBUG_LEVEL_3);
    }

    AIRPDCAP_DEBUG_TRACE_END(""AirPDcapScanForKeys"");
    return AIRPDCAP_RET_NO_VALID_HANDSHAKE;
}
","1. const guint8 *data,
2. 0X0C
3. if (
4. AIRPDCAP_DEBUG_PRINT_LINE(""AirPDcapScanForKeys"", ""No SA for BSSID found"", AIRPDCAP_DEBUG_LEVEL_3);
5. AIRPDCAP_EAP_SEC(data[offset]) != 1){
6. if (sta_sa == NULL){
7. guint8 action;
8. AIRPDCAP_DEBUG_PRINT_LINE(""AirPDcapScanForKeys"", ""Not Response nor confirm"", AIRPDCAP_DEBUG_LEVEL_3);
9. if (status!=0) {
10. AIRPDCAP_DEBUG_PRINT_LINE(""AirPDcapScanForKeys"", ""Cannot Find all necessary IEs"", AIRPDCAP_DEBUG_LEVEL_3);
11. if (memcmp(initiator, responder, AIRPDCAP_MAC_LEN) < 0) {
12. } else {","7
39
79
93
110
140
149
159
166
196
206
209","CWE-120,CWE-20,CWE-125,CWE-416"
bmp_read_rle8_data,"
#define FILE
#define IN
#define OPJ_UINT32
#define OPJ_UINT8

 static OPJ_BOOL bmp_read_rle8_data(FILE* IN, OPJ_UINT8* pData,
                                    OPJ_UINT32 stride, OPJ_UINT32 width, OPJ_UINT32 height)
 {
    OPJ_UINT32 x, y, written;
     OPJ_UINT8 *pix;
     const OPJ_UINT8 *beyond;
 
     beyond = pData + stride * height;
     pix = pData;
 
    x = y = written = 0U;
     while (y < height) {
         int c = getc(IN);
         if (c == EOF) {
            return OPJ_FALSE;
        }

        if (c) {
            int j, c1_int;
            OPJ_UINT8 c1;

            c1_int = getc(IN);
            if (c1_int == EOF) {
                return OPJ_FALSE;
            }
            c1 = (OPJ_UINT8)c1_int;

             for (j = 0; (j < c) && (x < width) &&
                     ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {
                 *pix = c1;
                written++;
             }
         } else {
             c = getc(IN);
            if (c == EOF) {
                return OPJ_FALSE;
            }

            if (c == 0x00) { 
                x = 0;
                ++y;
                pix = pData + y * stride + x;
            } else if (c == 0x01) { 
                break;
            } else if (c == 0x02) { 
                c = getc(IN);
                if (c == EOF) {
                    return OPJ_FALSE;
                }
                x += (OPJ_UINT32)c;
                c = getc(IN);
                if (c == EOF) {
                    return OPJ_FALSE;
                }
                y += (OPJ_UINT32)c;
                pix = pData + y * stride + x;
            } else { 
                int j;
                for (j = 0; (j < c) && (x < width) &&
                        ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {
                    int c1_int;
                    OPJ_UINT8 c1;
                    c1_int = getc(IN);
                    if (c1_int == EOF) {
                        return OPJ_FALSE;
                     }
                     c1 = (OPJ_UINT8)c1_int;
                     *pix = c1;
                    written++;
                 }
                 if ((OPJ_UINT32)c & 1U) { 
                     c = getc(IN);
                    if (c == EOF) {
                        return OPJ_FALSE;
                    }
                }
             }
         }
     }

    if (written != width * height) {
        fprintf(stderr, ""warning, image's actual size does not match advertized one\n"");
        return OPJ_FALSE;
    }

     return OPJ_TRUE;
 }
","1. OPJ_UINT32 stride, OPJ_UINT32 width, OPJ_UINT32 height)
2. pix = pData;
3. if (c == EOF) {
4. return OPJ_FALSE;
5. c1 = (OPJ_UINT8)c1_int;
6. for (j = 0; (j < c) && (x < width) &&
7. } else {
8. if (c == EOF) {
9. if (c == EOF) {
return OPJ_FALSE;
10. return OPJ_FALSE;
11. } else {
12. written++;
13. if (written != width * height) {
14. return OPJ_FALSE;
15. return OPJ_TRUE;","8
15
20
30
32
34
39
41
53-54
59
63
75
87
89
92","CWE-416,CWE-125,CWE-399,CWE-400"
on_stream_io-233068890590309,"static int on_stream_io(sd_event_source *es, int fd, uint32_t revents, void *userdata) {
        _cleanup_(dns_stream_unrefp) DnsStream *s = dns_stream_ref(userdata); 
        int r;

        assert(s);

#if ENABLE_DNS_OVER_TLS
        if (s->encrypted) {
                r = dnstls_stream_on_io(s, revents);
                if (r == DNSTLS_STREAM_CLOSED)
                        return 0;
                if (r == -EAGAIN)
                        return dns_stream_update_io(s);
                if (r < 0)
                        return dns_stream_complete(s, -r);

                r = dns_stream_update_io(s);
                if (r < 0)
                        return r;
        }
#endif

        
        if (s->tfo_salen == 0) {
                r = dns_stream_identify(s);
                if (r < 0)
                        return dns_stream_complete(s, -r);
        }

        if ((revents & EPOLLOUT) &&
            s->write_packet &&
            s->n_written < sizeof(s->write_size) + s->write_packet->size) {

                struct iovec iov[2];
                ssize_t ss;

                iov[0] = IOVEC_MAKE(&s->write_size, sizeof(s->write_size));
                iov[1] = IOVEC_MAKE(DNS_PACKET_DATA(s->write_packet), s->write_packet->size);

                IOVEC_INCREMENT(iov, 2, s->n_written);

                ss = dns_stream_writev(s, iov, 2, 0);
                if (ss < 0) {
                        if (!IN_SET(-ss, EINTR, EAGAIN))
                                return dns_stream_complete(s, -ss);
                } else
                        s->n_written += ss;

                
                if (s->n_written >= sizeof(s->write_size) + s->write_packet->size) {
                        r = dns_stream_update_io(s);
                        if (r < 0)
                                return dns_stream_complete(s, -r);
                }
        }

        if ((revents & (EPOLLIN|EPOLLHUP|EPOLLRDHUP)) &&
            (!s->read_packet ||
             s->n_read < sizeof(s->read_size) + s->read_packet->size)) {

                if (s->n_read < sizeof(s->read_size)) {
                        ssize_t ss;

                        ss = dns_stream_read(s, (uint8_t*) &s->read_size + s->n_read, sizeof(s->read_size) - s->n_read);
                        if (ss < 0) {
                                if (!IN_SET(-ss, EINTR, EAGAIN))
                                        return dns_stream_complete(s, -ss);
                        } else if (ss == 0)
                                return dns_stream_complete(s, ECONNRESET);
                        else
                                s->n_read += ss;
                }

                if (s->n_read >= sizeof(s->read_size)) {

                        if (be16toh(s->read_size) < DNS_PACKET_HEADER_SIZE)
                                return dns_stream_complete(s, EBADMSG);

                        if (s->n_read < sizeof(s->read_size) + be16toh(s->read_size)) {
                                ssize_t ss;

                                if (!s->read_packet) {
                                        r = dns_packet_new(&s->read_packet, s->protocol, be16toh(s->read_size), DNS_PACKET_SIZE_MAX);
                                        if (r < 0)
                                                return dns_stream_complete(s, -r);

                                        s->read_packet->size = be16toh(s->read_size);
                                        s->read_packet->ipproto = IPPROTO_TCP;
                                        s->read_packet->family = s->peer.sa.sa_family;
                                        s->read_packet->ttl = s->ttl;
                                        s->read_packet->ifindex = s->ifindex;

                                        if (s->read_packet->family == AF_INET) {
                                                s->read_packet->sender.in = s->peer.in.sin_addr;
                                                s->read_packet->sender_port = be16toh(s->peer.in.sin_port);
                                                s->read_packet->destination.in = s->local.in.sin_addr;
                                                s->read_packet->destination_port = be16toh(s->local.in.sin_port);
                                        } else {
                                                assert(s->read_packet->family == AF_INET6);
                                                s->read_packet->sender.in6 = s->peer.in6.sin6_addr;
                                                s->read_packet->sender_port = be16toh(s->peer.in6.sin6_port);
                                                s->read_packet->destination.in6 = s->local.in6.sin6_addr;
                                                s->read_packet->destination_port = be16toh(s->local.in6.sin6_port);

                                                if (s->read_packet->ifindex == 0)
                                                        s->read_packet->ifindex = s->peer.in6.sin6_scope_id;
                                                if (s->read_packet->ifindex == 0)
                                                        s->read_packet->ifindex = s->local.in6.sin6_scope_id;
                                        }
                                }

                                ss = dns_stream_read(s,
                                          (uint8_t*) DNS_PACKET_DATA(s->read_packet) + s->n_read - sizeof(s->read_size),
                                          sizeof(s->read_size) + be16toh(s->read_size) - s->n_read);
                                if (ss < 0) {
                                        if (!IN_SET(-ss, EINTR, EAGAIN))
                                                return dns_stream_complete(s, -ss);
                                } else if (ss == 0)
                                        return dns_stream_complete(s, ECONNRESET);
                                else
                                        s->n_read += ss;
                        }

                        
                        if (s->n_read >= sizeof(s->read_size) + be16toh(s->read_size)) {
                                
                                if (s->on_packet) {
                                        r = s->on_packet(s);
                                        if (r < 0)
                                                return r;
                                }

                                r = dns_stream_update_io(s);
                                if (r < 0)
                                        return dns_stream_complete(s, -r);
                        }
                }
        }

        if ((s->write_packet && s->n_written >= sizeof(s->write_size) + s->write_packet->size) &&
            (s->read_packet && s->n_read >= sizeof(s->read_size) + s->read_packet->size))
                return dns_stream_complete(s, 0);

        return 0;
}
","1. r = dns_stream_identify(s);
if (r < 0)
2. r = dns_stream_update_io(s);
3. ss = dns_stream_read(s, (uint8_t*) &s->read_size + s->n_read, sizeof(s->read_size) - s->n_read);
4. if (!s->read_packet) {
5. if (r < 0)
6. s->read_packet->family = s->peer.sa.sa_family;
7. assert(s->read_packet->family == AF_INET6);
8. s->read_packet->sender_port = be16toh(s->peer.in6.sin6_port);
9. return dns_stream_complete(s, -ss);
10. return r;","25-26
51
64
82
84
89
99
101
117
132","CWE-787,CWE-119,CWE-59,CWE-416"
generic_permission,"int generic_permission(struct inode *inode, int mask)
{
	int ret;

	
	ret = acl_permission_check(inode, mask);
	if (ret != -EACCES)
		return ret;
 
 	if (S_ISDIR(inode->i_mode)) {
 		
		if (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))
 			return 0;
 		if (!(mask & MAY_WRITE))
			if (capable_wrt_inode_uidgid(inode,
						     CAP_DAC_READ_SEARCH))
 				return 0;
 		return -EACCES;
 	}
	
 	if (!(mask & MAY_EXEC) || (inode->i_mode & S_IXUGO))
		if (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))
 			return 0;
 
 	
 	mask &= MAY_READ | MAY_WRITE | MAY_EXEC;
 	if (mask == MAY_READ)
		if (capable_wrt_inode_uidgid(inode, CAP_DAC_READ_SEARCH))
 			return 0;
 
 	return -EACCES;
}
","1. int generic_permission(struct inode *inode, int mask)
2. int ret;
3. ret = acl_permission_check(inode, mask);
4. if (S_ISDIR(inode->i_mode)) {
5. if (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))
return 0;
if (!(mask & MAY_WRITE))
if (capable_wrt_inode_uidgid(inode,
CAP_DAC_READ_SEARCH))
return 0;
return -EACCES;
6. if (!(mask & MAY_EXEC) || (inode->i_mode & S_IXUGO))
if (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))
7. mask &= MAY_READ | MAY_WRITE | MAY_EXEC;
if (mask == MAY_READ)
8. return 0;
9. return -EACCES;","1
3
8
12
14-20
27-28
34-35
37
39","CWE-17,CWE-20,CWE-264,CWE-119"
asn1_write_BOOLEAN_context," bool asn1_write_BOOLEAN_context(struct asn1_data *data, bool v, int context)
 {
       if (!asn1_push_tag(data, ASN1_CONTEXT_SIMPLE(context))) return false;
       if (!asn1_write_uint8(data, v ? 0xFF : 0)) return false;
       return asn1_pop_tag(data);
 }
","1. bool asn1_write_BOOLEAN_context(struct asn1_data *data, bool v, int context)
2. if (!asn1_push_tag(data, ASN1_CONTEXT_SIMPLE(context))) return false;
if (!asn1_write_uint8(data, v ? 0xFF : 0)) return false;
return asn1_pop_tag(data);","1
3-5","CWE-476,CWE-241,CWE-20,CWE-399"
dce120_create_resource_pool-234519034659796,"struct resource_pool *dce120_create_resource_pool(
	uint8_t num_virtual_links,
	struct dc *dc)
{
	struct dce110_resource_pool *pool =
		kzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);

	if (!pool)
		return NULL;

	if (construct(num_virtual_links, dc, pool))
		return &pool->base;

	kfree(pool);
	BREAK_TO_DEBUGGER();
	return NULL;
}
","1. struct resource_pool *dce120_create_resource_pool(
uint8_t num_virtual_links,
2. if (construct(num_virtual_links, dc, pool))","1-2
11","CWE-190,CWE-401"
pfkey_recvmsg-3861656654733,"static int pfkey_recvmsg(struct kiocb *kiocb,
			 struct socket *sock, struct msghdr *msg, size_t len,
			 int flags)
{
	struct sock *sk = sock->sk;
	struct pfkey_sock *pfk = pfkey_sk(sk);
	struct sk_buff *skb;
	int copied, err;

	err = -EINVAL;
	if (flags & ~(MSG_PEEK|MSG_DONTWAIT|MSG_TRUNC|MSG_CMSG_COMPAT))
		goto out;

	skb = skb_recv_datagram(sk, flags, flags & MSG_DONTWAIT, &err);
	if (skb == NULL)
		goto out;

	copied = skb->len;
	if (copied > len) {
		msg->msg_flags |= MSG_TRUNC;
		copied = len;
	}

	skb_reset_transport_header(skb);
	err = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);
	if (err)
		goto out_free;

	sock_recv_ts_and_drops(msg, sk, skb);

	err = (flags & MSG_TRUNC) ? skb->len : copied;

	if (pfk->dump.dump != NULL &&
	    3 * atomic_read(&sk->sk_rmem_alloc) <= sk->sk_rcvbuf)
		pfkey_do_dump(pfk);

out_free:
	skb_free_datagram(sk, skb);
out:
	return err;
}
","1. struct pfkey_sock *pfk = pfkey_sk(sk);
2. int copied, err;
3. if (copied > len) {
4. pfkey_do_dump(pfk);","6
8
19
35",CWE-20
ip_identify_match_check-209835848201692,"static int ip_identify_match_check(void *obj, void *arg, int flags)
{
	struct ip_identify_match *identify = obj;
	struct ast_sockaddr *addr = arg;
	int sense;

	sense = ast_apply_ha(identify->matches, addr);
	if (sense != AST_SENSE_ALLOW) {
		ast_debug(3, ""Source address %s matches identify '%s'\n"",
				ast_sockaddr_stringify(addr),
				ast_sorcery_object_get_id(identify));
		return CMP_MATCH;
	} else {
		ast_debug(3, ""Source address %s does not match identify '%s'\n"",
				ast_sockaddr_stringify(addr),
				ast_sorcery_object_get_id(identify));
		return 0;
	}
}
","1. } else {
ast_debug(3, ""Source address %s does not match identify '%s'\n"",
2. ast_sorcery_object_get_id(identify));","13-14
16","CWE-476,CWE-190,CWE-20,CWE-416"
module_load,"
#define YR_OBJECT
#define YR_SCAN_CONTEXT

int module_load(
    YR_SCAN_CONTEXT* context,
    YR_OBJECT* module_object,
    void* module_data,
    size_t module_data_size)
{
  set_integer(1, module_object, ""constants.one"");
  set_integer(2, module_object, ""constants.two"");
  set_string(""foo"", module_object, ""constants.foo"");
  set_string("""", module_object, ""constants.empty"");

  set_integer(1, module_object, ""struct_array[1].i"");

   set_integer(0, module_object, ""integer_array[%i]"", 0);
   set_integer(1, module_object, ""integer_array[%i]"", 1);
   set_integer(2, module_object, ""integer_array[%i]"", 2);
  set_integer(256, module_object, ""integer_array[%i]"", 256);
 
   set_string(""foo"", module_object, ""string_array[%i]"", 0);
   set_string(""bar"", module_object, ""string_array[%i]"", 1);
  set_string(""baz"", module_object, ""string_array[%i]"", 2);

  set_sized_string(""foo\0bar"", 7, module_object, ""string_array[%i]"", 3);

  set_string(""foo"", module_object, ""string_dict[%s]"", ""foo"");
  set_string(""bar"", module_object, ""string_dict[\""bar\""]"");

  set_string(""foo"", module_object, ""struct_dict[%s].s"", ""foo"");
  set_integer(1, module_object, ""struct_dict[%s].i"", ""foo"");

  return ERROR_SUCCESS;
}
","1. int module_load(
2. YR_OBJECT* module_object,
3. set_integer(2, module_object, ""constants.two"");
4. set_string(""baz"", module_object, ""string_array[%i]"", 2);","5
7
12
25","CWE-20,CWE-264,CWE-125,CWE-119"
ncrush_decompress-235076468291600,"
#define BYTE
#define NCRUSH_CONTEXT
#define SrcSize
#define UINT32

int ncrush_decompress(NCRUSH_CONTEXT* ncrush, const BYTE* pSrcData, UINT32 SrcSize,
                      const BYTE** ppDstData, UINT32* pDstSize, UINT32 flags)
{
	UINT32 index;
	BYTE Literal;
	UINT32 IndexLEC;
	UINT32 BitLength;
	UINT32 CopyOffset;
	UINT32 CopyLength;
	UINT32 OldCopyOffset;
	BYTE* CopyOffsetPtr;
	UINT32 LengthOfMatch;
	UINT32 CopyOffsetIndex;
	UINT32 OffsetCacheIndex;
	UINT32 CopyOffsetBits;
	UINT32 CopyOffsetBase;
	UINT32 LengthOfMatchBits;
	UINT32 LengthOfMatchBase;

	WINPR_ASSERT(ncrush);
	WINPR_ASSERT(pSrcData);
	WINPR_ASSERT(ppDstData);
	WINPR_ASSERT(pDstSize);

	if (ncrush->HistoryEndOffset != 65535)
		return -1001;

	BYTE* HistoryBuffer = ncrush->HistoryBuffer;
	const BYTE* HistoryBufferEnd = &HistoryBuffer[ncrush->HistoryEndOffset];

	if (flags & PACKET_AT_FRONT)
	{
		if ((ncrush->HistoryPtr - 32768) <= HistoryBuffer)
			return -1002;

		MoveMemory(HistoryBuffer, (ncrush->HistoryPtr - 32768), 32768);
		ncrush->HistoryPtr = &(HistoryBuffer[32768]);
		ZeroMemory(&HistoryBuffer[32768], 32768);
	}

	if (flags & PACKET_FLUSHED)
	{
		ncrush->HistoryPtr = HistoryBuffer;
		ZeroMemory(HistoryBuffer, sizeof(ncrush->HistoryBuffer));
		ZeroMemory(&(ncrush->OffsetCache), sizeof(ncrush->OffsetCache));
	}

	BYTE* HistoryPtr = ncrush->HistoryPtr;

	if (!(flags & PACKET_COMPRESSED))
	{
		*ppDstData = pSrcData;
		*pDstSize = SrcSize;
		return 1;
	}

	const BYTE* SrcEnd = &pSrcData[SrcSize];
	const BYTE* SrcPtr = pSrcData + 4;

	INT32 nbits = 32;
	UINT32 bits = get_dword(pSrcData);
	while (1)
	{
		while (1)
		{
			const UINT16 Mask = get_word(&HuffTableMask[29]);
			const UINT32 MaskedBits = bits & Mask;
			if (MaskedBits >= ARRAYSIZE(HuffTableLEC))
				return -1;
			IndexLEC = HuffTableLEC[MaskedBits] & 0xFFF;
			BitLength = HuffTableLEC[MaskedBits] >> 12;
			bits >>= BitLength;
			nbits -= BitLength;

			if (!NCrushFetchBits(&SrcPtr, &SrcEnd, &nbits, &bits))
				return -1;

			if (IndexLEC >= 256)
				break;

			if (HistoryPtr >= HistoryBufferEnd)
			{
				WLog_ERR(TAG, ""ncrush_decompress error: HistoryPtr (%p) >= HistoryBufferEnd (%p)"",
				         (void*)HistoryPtr, (void*)HistoryBufferEnd);
				return -1003;
			}

			Literal = (HuffTableLEC[MaskedBits] & 0xFF);
			*HistoryPtr++ = Literal;
		}

		if (IndexLEC == 256)
			break; 

		CopyOffsetIndex = IndexLEC - 257;

		if (CopyOffsetIndex >= 32)
		{
			OffsetCacheIndex = IndexLEC - 289;

			if (OffsetCacheIndex >= 4)
				return -1004;

			CopyOffset = ncrush->OffsetCache[OffsetCacheIndex];
			const UINT16 Mask = get_word(&HuffTableMask[21]);
			const UINT32 MaskedBits = bits & Mask;
			if (MaskedBits > ARRAYSIZE(HuffTableLOM))
				return -1;
			LengthOfMatch = HuffTableLOM[MaskedBits] & 0xFFF;
			BitLength = HuffTableLOM[MaskedBits] >> 12;
			bits >>= BitLength;
			nbits -= BitLength;

			if (!NCrushFetchBits(&SrcPtr, &SrcEnd, &nbits, &bits))
				return -1;

			if (LengthOfMatch >= ARRAYSIZE(LOMBitsLUT))
				return -1;

			LengthOfMatchBits = LOMBitsLUT[LengthOfMatch];

			if (LengthOfMatch >= ARRAYSIZE(LOMBaseLUT))
				return -1;
			LengthOfMatchBase = LOMBaseLUT[LengthOfMatch];

			if (LengthOfMatchBits)
			{
				const size_t idx = (2ull * LengthOfMatchBits) + 3ull;
				if (idx >= ARRAYSIZE(HuffTableMask))
					return -1;

				const UINT16 Mask = get_word(&HuffTableMask[idx]);
				const UINT32 MaskedBits = bits & Mask;
				bits >>= LengthOfMatchBits;
				nbits -= LengthOfMatchBits;
				LengthOfMatchBase += MaskedBits;

				if (!NCrushFetchBits(&SrcPtr, &SrcEnd, &nbits, &bits))
					return -1;
			}

			OldCopyOffset = ncrush->OffsetCache[OffsetCacheIndex];
			ncrush->OffsetCache[OffsetCacheIndex] = ncrush->OffsetCache[0];
			ncrush->OffsetCache[0] = OldCopyOffset;
		}
		else
		{
			if (CopyOffsetIndex >= ARRAYSIZE(CopyOffsetBitsLUT))
				return -1;

			CopyOffsetBits = CopyOffsetBitsLUT[CopyOffsetIndex];

			if (CopyOffsetIndex >= ARRAYSIZE(CopyOffsetBaseLUT))
				return -1;
			CopyOffsetBase = CopyOffsetBaseLUT[CopyOffsetIndex];
			CopyOffset = CopyOffsetBase - 1;

			if (CopyOffsetBits)
			{
				const size_t idx = (2ull * CopyOffsetBits) + 3ull;
				if (idx >= ARRAYSIZE(HuffTableMask))
					return -1;

				const UINT16 Mask = get_word(&HuffTableMask[idx]);
				const UINT32 MaskedBits = bits & Mask;
				const UINT32 tmp = CopyOffsetBase + MaskedBits;
				if (tmp < 1)
					return -1;
				CopyOffset = tmp - 1;
				bits >>= CopyOffsetBits;
				nbits -= CopyOffsetBits;

				if (!NCrushFetchBits(&SrcPtr, &SrcEnd, &nbits, &bits))
					return -1;
			}

			const UINT16 Mask = get_word(&HuffTableMask[21]);
			const UINT32 MaskedBits = bits & Mask;
			if (MaskedBits >= ARRAYSIZE(HuffTableLOM))
				return -1;

			LengthOfMatch = HuffTableLOM[MaskedBits] & 0xFFF;
			BitLength = HuffTableLOM[MaskedBits] >> 12;
			bits >>= BitLength;
			nbits -= BitLength;

			if (!NCrushFetchBits(&SrcPtr, &SrcEnd, &nbits, &bits))
				return -1;

			if (LengthOfMatch >= ARRAYSIZE(LOMBitsLUT))
				return -1;

			LengthOfMatchBits = LOMBitsLUT[LengthOfMatch];

			if (LengthOfMatch >= ARRAYSIZE(LOMBaseLUT))
				return -1;
			LengthOfMatchBase = LOMBaseLUT[LengthOfMatch];

			if (LengthOfMatchBits)
			{
				const size_t idx = (2ull * LengthOfMatchBits) + 3ull;
				if (idx >= ARRAYSIZE(HuffTableMask))
					return -1;

				const UINT16 Mask = get_word(&HuffTableMask[idx]);
				const UINT32 MaskedBits = bits & Mask;
				bits >>= LengthOfMatchBits;
				nbits -= LengthOfMatchBits;
				LengthOfMatchBase += MaskedBits;

				if (!NCrushFetchBits(&SrcPtr, &SrcEnd, &nbits, &bits))
					return -1;
			}

			ncrush->OffsetCache[3] = ncrush->OffsetCache[2];
			ncrush->OffsetCache[2] = ncrush->OffsetCache[1];
			ncrush->OffsetCache[1] = ncrush->OffsetCache[0];
			ncrush->OffsetCache[0] = CopyOffset;
		}

		CopyOffsetPtr = &HistoryBuffer[(HistoryPtr - HistoryBuffer - CopyOffset) & 0xFFFF];
		LengthOfMatch = LengthOfMatchBase;

		if (LengthOfMatch < 2)
			return -1005;

		if ((CopyOffsetPtr >= (HistoryBufferEnd - LengthOfMatch)) ||
		    (HistoryPtr >= (HistoryBufferEnd - LengthOfMatch)))
			return -1006;

		CopyOffsetPtr = HistoryPtr - CopyOffset;
		index = 0;
		CopyLength = (LengthOfMatch > CopyOffset) ? CopyOffset : LengthOfMatch;

		if (CopyOffsetPtr >= HistoryBuffer)
		{
			while (CopyLength > 0)
			{
				*HistoryPtr++ = *CopyOffsetPtr++;
				CopyLength--;
			}

			while (LengthOfMatch > CopyOffset)
			{
				index = ((index >= CopyOffset)) ? 0 : index;
				*HistoryPtr++ = *(CopyOffsetPtr + index++);
				LengthOfMatch--;
			}
		}
		else
		{
			CopyOffsetPtr = HistoryBufferEnd - (CopyOffset - (HistoryPtr - HistoryBuffer));
			CopyOffsetPtr++;

			while (CopyLength && (CopyOffsetPtr <= HistoryBufferEnd))
			{
				*HistoryPtr++ = *CopyOffsetPtr++;
				CopyLength--;
			}

			CopyOffsetPtr = HistoryBuffer;

			while (LengthOfMatch > CopyOffset)
			{
				index = ((index >= CopyOffset)) ? 0 : index;
				*HistoryPtr++ = *(CopyOffsetPtr + index++);
				LengthOfMatch--;
			}
		}

		LengthOfMatch = LengthOfMatchBase;

		if (LengthOfMatch == 2)
			continue;
	}

	if (IndexLEC != 256)
		return -1;

	if (ncrush->HistoryBufferFence != 0xABABABAB)
	{
		WLog_ERR(TAG, ""NCrushDecompress: history buffer fence was overwritten, potential buffer ""
		              ""overflow detected!"");
		return -1007;
	}

	const intptr_t hsize = HistoryPtr - ncrush->HistoryPtr;
	WINPR_ASSERT(hsize >= 0);
	WINPR_ASSERT(hsize <= UINT32_MAX);
	*pDstSize = (UINT32)hsize;
	*ppDstData = ncrush->HistoryPtr;
	ncrush->HistoryPtr = HistoryPtr;
	return 1;
}
","1. UINT32 CopyOffsetIndex;
2. UINT32 CopyOffsetBits;
3. WINPR_ASSERT(pDstSize);
4. BYTE* HistoryBuffer = ncrush->HistoryBuffer;
5. MoveMemory(HistoryBuffer, (ncrush->HistoryPtr - 32768), 32768);
6. while (1)
7. const UINT16 Mask = get_word(&HuffTableMask[29]);
8. IndexLEC = HuffTableLEC[MaskedBits] & 0xFFF;
BitLength = HuffTableLEC[MaskedBits] >> 12;
9. nbits -= BitLength;
10. if (!NCrushFetchBits(&SrcPtr, &SrcEnd, &nbits, &bits))
11. break;
12. return -1003;
13. if (IndexLEC == 256)
break;
14. if (CopyOffsetIndex >= 32)
15. CopyOffset = ncrush->OffsetCache[OffsetCacheIndex];
const UINT16 Mask = get_word(&HuffTableMask[21]);
16. BitLength = HuffTableLOM[MaskedBits] >> 12;
17. if (LengthOfMatchBits)
18. bits >>= LengthOfMatchBits;
nbits -= LengthOfMatchBits;
19. return -1;
20. if (CopyOffsetIndex >= ARRAYSIZE(CopyOffsetBitsLUT))
21. return -1;
22. const size_t idx = (2ull * CopyOffsetBits) + 3ull;
if (idx >= ARRAYSIZE(HuffTableMask))
23. const UINT32 MaskedBits = bits & Mask;
const UINT32 tmp = CopyOffsetBase + MaskedBits;
if (tmp < 1)
24. CopyOffset = tmp - 1;
bits >>= CopyOffsetBits;
nbits -= CopyOffsetBits;
25. return -1;
26. const UINT16 Mask = get_word(&HuffTableMask[21]);
27. LengthOfMatch = HuffTableLOM[MaskedBits] & 0xFFF;
28. return -1;
29. LengthOfMatchBits = LOMBitsLUT[LengthOfMatch];
30. if (LengthOfMatch >= ARRAYSIZE(LOMBaseLUT))
31. if (idx >= ARRAYSIZE(HuffTableMask))
32. const UINT32 MaskedBits = bits & Mask;
33. ncrush->OffsetCache[0] = CopyOffset;
34. return -1005;
35. if ((CopyOffsetPtr >= (HistoryBufferEnd - LengthOfMatch)) ||
36. CopyOffsetPtr = HistoryPtr - CopyOffset;
37. CopyLength = (LengthOfMatch > CopyOffset) ? CopyOffset : LengthOfMatch;
38. while (LengthOfMatch > CopyOffset)
39. index = ((index >= CopyOffset)) ? 0 : index;
40. while (LengthOfMatch > CopyOffset)
41. *HistoryPtr++ = *(CopyOffsetPtr + index++);
42. WLog_ERR(TAG, ""NCrushDecompress: history buffer fence was overwritten, potential buffer ""
43. return 1;","19
21
29
34
42
70
72
76-77
79
81
85
91
98-99
103
110-111
116
132
140-141
145
154
160
166-167
171-173
175-177
180
183
188
194
199
201
208
212
224
231
233
237
239
249
251
269
272
288
299","CWE-772,CWE-17,CWE-787,CWE-125"
sas_destruct_devices-250902042718276,"void sas_destruct_devices(struct asd_sas_port *port)
{
	struct domain_device *dev, *n;

	list_for_each_entry_safe(dev, n, &port->destroy_list, disco_list_node) {
		list_del_init(&dev->disco_list_node);

		sas_remove_children(&dev->rphy->dev);
		sas_rphy_delete(dev->rphy);
		sas_unregister_common_dev(port, dev);
	}
}
","1. void sas_destruct_devices(struct asd_sas_port *port)
2. struct domain_device *dev, *n;
3. list_for_each_entry_safe(dev, n, &port->destroy_list, disco_list_node) {
list_del_init(&dev->disco_list_node);
4. sas_remove_children(&dev->rphy->dev);
sas_rphy_delete(dev->rphy);","1
3
5-6
8-9","CWE-362,CWE-1284,CWE-20,CWE-416"
ProcRenderAddGlyphs,"
#define ClientPtr

ProcRenderAddGlyphs (ClientPtr client)
{
    GlyphSetPtr     glyphSet;
    REQUEST(xRenderAddGlyphsReq);
    GlyphNewRec	    glyphsLocal[NLOCALGLYPH];
    GlyphNewPtr	    glyphsBase, glyphs, glyph_new;
    int		    remain, nglyphs;
    CARD32	    *gids;
    xGlyphInfo	    *gi;
    CARD8	    *bits;
    unsigned int    size;
    int		    err;
    int		    i, screen;
    PicturePtr	    pSrc = NULL, pDst = NULL;
    PixmapPtr	    pSrcPix = NULL, pDstPix = NULL;
    CARD32	    component_alpha;

    REQUEST_AT_LEAST_SIZE(xRenderAddGlyphsReq);
    err = dixLookupResourceByType((pointer *)&glyphSet, stuff->glyphset, GlyphSetType,
			    client, DixAddAccess);
    if (err != Success)
    {
	client->errorValue = stuff->glyphset;
	return err;
    }

    err = BadAlloc;
    nglyphs = stuff->nglyphs;
    if (nglyphs > UINT32_MAX / sizeof(GlyphNewRec))
	    return BadAlloc;

    component_alpha = NeedsComponent (glyphSet->format->format);

    if (nglyphs <= NLOCALGLYPH) {
	memset (glyphsLocal, 0, sizeof (glyphsLocal));
	glyphsBase = glyphsLocal;
    }
    else
    {
	glyphsBase = (GlyphNewPtr)calloc(nglyphs, sizeof (GlyphNewRec));
	if (!glyphsBase)
	    return BadAlloc;
    }

    remain = (client->req_len << 2) - sizeof (xRenderAddGlyphsReq);

    glyphs = glyphsBase;

    gids = (CARD32 *) (stuff + 1);
     gi = (xGlyphInfo *) (gids + nglyphs);
     bits = (CARD8 *) (gi + nglyphs);
     remain -= (sizeof (CARD32) + sizeof (xGlyphInfo)) * nglyphs;

    
    if (gi < stuff || gi > ((CARD32 *)stuff + client->req_len) ||
        bits < stuff || bits > ((CARD32 *)stuff + client->req_len)) {
        err = BadLength;
        goto bail;
    }

     for (i = 0; i < nglyphs; i++)
     {
 	size_t padded_width;
	size = gi[i].height * padded_width;
	if (remain < size)
	    break;

	err = HashGlyph (&gi[i], bits, size, glyph_new->sha1);
	if (err)
	    goto bail;

	glyph_new->glyph = FindGlyphByHash (glyph_new->sha1,
					    glyphSet->fdepth);

	if (glyph_new->glyph && glyph_new->glyph != DeletedGlyph)
	{
	    glyph_new->found = TRUE;
	}
	else
	{
	    GlyphPtr glyph;

	    glyph_new->found = FALSE;
	    glyph_new->glyph = glyph = AllocateGlyph (&gi[i], glyphSet->fdepth);
	    if (! glyph)
	    {
		err = BadAlloc;
		goto bail;
	    }

	    for (screen = 0; screen < screenInfo.numScreens; screen++)
	    {
		int	    width = gi[i].width;
		int	    height = gi[i].height;
		int	    depth = glyphSet->format->depth;
		ScreenPtr   pScreen;
		int	    error;

		
		if (!width || !height)
		    break;

		pScreen = screenInfo.screens[screen];
		pSrcPix = GetScratchPixmapHeader (pScreen,
						  width, height,
						  depth, depth,
						  -1, bits);
		if (! pSrcPix)
		{
		    err = BadAlloc;
		    goto bail;
		}

		pSrc = CreatePicture (0, &pSrcPix->drawable,
				      glyphSet->format, 0, NULL,
				      serverClient, &error);
		if (! pSrc)
		{
		    err = BadAlloc;
		    goto bail;
		}

		pDstPix = (pScreen->CreatePixmap) (pScreen,
						   width, height, depth,
						   CREATE_PIXMAP_USAGE_GLYPH_PICTURE);

		if (!pDstPix)
		{
		    err = BadAlloc;
		    goto bail;
		}

		GlyphPicture (glyph)[screen] = pDst =
			CreatePicture (0, &pDstPix->drawable,
				       glyphSet->format,
				       CPComponentAlpha, &component_alpha,
				       serverClient, &error);

		
		(pScreen->DestroyPixmap) (pDstPix);
		pDstPix = NULL;

		if (! pDst)
		{
		    err = BadAlloc;
		    goto bail;
		}

		CompositePicture (PictOpSrc,
				  pSrc,
				  None,
				  pDst,
				  0, 0,
				  0, 0,
				  0, 0,
				  width, height);

		FreePicture ((pointer) pSrc, 0);
		pSrc = NULL;
		FreeScratchPixmapHeader (pSrcPix);
		pSrcPix = NULL;
	    }

	    memcpy (glyph_new->glyph->sha1, glyph_new->sha1, 20);
	}

	glyph_new->id = gids[i];
	
	if (size & 3)
	    size += 4 - (size & 3);
	bits += size;
	remain -= size;
    }
    if (remain || i < nglyphs)
    {
	err = BadLength;
	goto bail;
    }
    if (!ResizeGlyphSet (glyphSet, nglyphs))
    {
	err = BadAlloc;
	goto bail;
    }
    for (i = 0; i < nglyphs; i++)
	AddGlyph (glyphSet, glyphs[i].glyph, glyphs[i].id);

    if (glyphsBase != glyphsLocal)
	free(glyphsBase);
    return Success;
bail:
    if (pSrc)
	FreePicture ((pointer) pSrc, 0);
    if (pSrcPix)
	FreeScratchPixmapHeader (pSrcPix);
    for (i = 0; i < nglyphs; i++)
	if (glyphs[i].glyph && ! glyphs[i].found)
	    free(glyphs[i].glyph);
    if (glyphsBase != glyphsLocal)
	free(glyphsBase);
    return err;
}
","1. err = BadAlloc;
2. return BadAlloc;
3. component_alpha = NeedsComponent (glyphSet->format->format);
4. for (i = 0; i < nglyphs; i++)
5. if (remain < size)
6. break;
7. pScreen = screenInfo.screens[screen];
8. pSrc = CreatePicture (0, &pSrcPix->drawable,
9. serverClient, &error);
10. err = BadAlloc;
11. memcpy (glyph_new->glyph->sha1, glyph_new->sha1, 20);
12. size += 4 - (size & 3);
13. remain -= size;
14. FreePicture ((pointer) pSrc, 0);
15. for (i = 0; i < nglyphs; i++)
16. if (glyphsBase != glyphsLocal)","30
33
35
64
68
104
106
117
119
122
168
174
176
196
199
202","CWE-20,CWE-119,CWE-862,CWE-17,CWE-59"
sudo_auth_begin_session-242336340677667,"int
sudo_auth_begin_session(const struct sudoers_context *ctx, struct passwd *pw,
    char **user_env[])
{
    sudo_auth *auth;
    int ret = true;
    debug_decl(sudo_auth_begin_session, SUDOERS_DEBUG_AUTH);

    for (auth = auth_switch; auth->name; auth++) {
	if (auth->begin_session && !IS_DISABLED(auth)) {
	    int status = (auth->begin_session)(ctx, pw, user_env, auth);
	    switch (status) {
	    case AUTH_SUCCESS:
		break;
	    case AUTH_FAILURE:
		ret = false;
		break;
	    default:
		
		ret = -1;
		break;
	    }
	}
    }
    debug_return_int(ret);
}
","1. if (auth->begin_session && !IS_DISABLED(auth)) {
2. break;
3. default:
4. ret = -1;
5. debug_return_int(ret);","10
14
18
20
25","CWE-190,CWE-287,CWE-400"
cg_opendir,"static int cg_opendir(const char *path, struct fuse_file_info *fi)
{
	struct fuse_context *fc = fuse_get_context();
	const char *cgroup;
	struct file_info *dir_info;
	char *controller = NULL;

	if (!fc)
		return -EIO;

	if (strcmp(path, ""/cgroup"") == 0) {
		cgroup = NULL;
		controller = NULL;
	} else {
		controller = pick_controller_from_path(fc, path);
		if (!controller)
			return -EIO;

		cgroup = find_cgroup_in_path(path);
		if (!cgroup) {
			
			cgroup = ""/"";
 		}
 	}
 
	if (cgroup) {
		if (!caller_may_see_dir(fc->pid, controller, cgroup))
			return -ENOENT;
		if (!fc_may_access(fc, controller, cgroup, NULL, O_RDONLY))
			return -EACCES;
 	}
 
 	
	dir_info = malloc(sizeof(*dir_info));
	if (!dir_info)
		return -ENOMEM;
	dir_info->controller = must_copy_string(controller);
	dir_info->cgroup = must_copy_string(cgroup);
	dir_info->type = LXC_TYPE_CGDIR;
	dir_info->buf = NULL;
	dir_info->file = NULL;
	dir_info->buflen = 0;

	fi->fh = (unsigned long)dir_info;
	return 0;
}
","1. struct file_info *dir_info;
char *controller = NULL;
2. if (!fc)
3. } else {
controller = pick_controller_from_path(fc, path);
if (!controller)
return -EIO;
4. if (!cgroup) {
5. if (!caller_may_see_dir(fc->pid, controller, cgroup))
return -ENOENT;
6. return -EACCES;
7. dir_info = malloc(sizeof(*dir_info));
if (!dir_info)
return -ENOMEM;
dir_info->controller = must_copy_string(controller);
8. dir_info->file = NULL;
dir_info->buflen = 0;
9. return 0;","5-6
8
14-17
20
27-28
30
34-37
41-42
45","CWE-264,CWE-125,CWE-189"
pixBlockconv-264359558452578,"
#define PIX

PIX  *
pixBlockconv(PIX     *pix,
             l_int32  wc,
             l_int32  hc)
{
l_int32  w, h, d;
PIX     *pixs, *pixd, *pixr, *pixrc, *pixg, *pixgc, *pixb, *pixbc;

    PROCNAME(""pixBlockconv"");

    if (!pix)
        return (PIX *)ERROR_PTR(""pix not defined"", procName, NULL);
    if (wc <= 0 || hc <= 0)
        return pixCopy(NULL, pix);
    pixGetDimensions(pix, &w, &h, &d);
    if (w < 2 * wc + 1 || h < 2 * hc + 1) {
        L_ERROR(""kernel is too large: w = %d, wc = %d, h = %d, hc = %d\n"",
                procName, w, wc, h, hc);
        return pixCopy(NULL, pix);  
    }

        
    if ((d == 2 || d == 4 || d == 8) && pixGetColormap(pix)) {
        L_WARNING(""pix has colormap; removing\n"", procName);
        pixs = pixRemoveColormap(pix, REMOVE_CMAP_BASED_ON_SRC);
        d = pixGetDepth(pixs);
    } else {
        pixs = pixClone(pix);
    }

    if (d != 8 && d != 32) {
        pixDestroy(&pixs);
        return (PIX *)ERROR_PTR(""depth not 8 or 32 bpp"", procName, NULL);
    }

    if (d == 8) {
        pixd = pixBlockconvGray(pixs, NULL, wc, hc);
    } else { 
        pixr = pixGetRGBComponent(pixs, COLOR_RED);
        pixrc = pixBlockconvGray(pixr, NULL, wc, hc);
        pixDestroy(&pixr);
        pixg = pixGetRGBComponent(pixs, COLOR_GREEN);
        pixgc = pixBlockconvGray(pixg, NULL, wc, hc);
        pixDestroy(&pixg);
        pixb = pixGetRGBComponent(pixs, COLOR_BLUE);
        pixbc = pixBlockconvGray(pixb, NULL, wc, hc);
        pixDestroy(&pixb);
        pixd = pixCreateRGBImage(pixrc, pixgc, pixbc);
        pixDestroy(&pixrc);
        pixDestroy(&pixgc);
        pixDestroy(&pixbc);
    }

    pixDestroy(&pixs);
    return pixd;
}
","1. pixGetDimensions(pix, &w, &h, &d);
2. L_ERROR(""kernel is too large: w = %d, wc = %d, h = %d, hc = %d\n"",
procName, w, wc, h, hc);
return pixCopy(NULL, pix);
3. if ((d == 2 || d == 4 || d == 8) && pixGetColormap(pix)) {
4. } else {
5. pixDestroy(&pixs);
6. pixd = pixBlockconvGray(pixs, NULL, wc, hc);
7. pixr = pixGetRGBComponent(pixs, COLOR_RED);
pixrc = pixBlockconvGray(pixr, NULL, wc, hc);
8. pixbc = pixBlockconvGray(pixb, NULL, wc, hc);
pixDestroy(&pixb);
pixd = pixCreateRGBImage(pixrc, pixgc, pixbc);
pixDestroy(&pixrc);
9. pixDestroy(&pixbc);
10. pixDestroy(&pixs);
return pixd;","18
20-22
26
30
35
40
42-43
49-52
54
57-58","CWE-119,CWE-125,CWE-369"
check_shellsize-148070802083007,"    void
check_shellsize(void)
{
    if (Rows < min_rows())	
	Rows = min_rows();
    limit_screen_size();

    
    if (cmdline_row >= Rows)
	cmdline_row = Rows - 1;
    if (msg_row >= Rows)
	msg_row = Rows - 1;
}
","1. if (Rows < min_rows())
Rows = min_rows();
2. if (cmdline_row >= Rows)
cmdline_row = Rows - 1;
if (msg_row >= Rows)","4-5
9-11","CWE-20,CWE-120,CWE-476,CWE-787,CWE-354"
smb2_handle_negotiate-55630648246451,"int smb2_handle_negotiate(struct ksmbd_work *work)
{
	struct ksmbd_conn *conn = work->conn;
	struct smb2_negotiate_req *req = smb2_get_msg(work->request_buf);
	struct smb2_negotiate_rsp *rsp = smb2_get_msg(work->response_buf);
	int rc = 0;
	unsigned int smb2_buf_len, smb2_neg_size;
	__le32 status;

	ksmbd_debug(SMB, ""Received negotiate request\n"");
	conn->need_neg = false;
	if (ksmbd_conn_good(work)) {
		pr_err(""conn->tcp_status is already in CifsGood State\n"");
		work->send_no_response = 1;
		return rc;
	}

	if (req->DialectCount == 0) {
		pr_err(""malformed packet\n"");
		rsp->hdr.Status = STATUS_INVALID_PARAMETER;
		rc = -EINVAL;
		goto err_out;
	}

	smb2_buf_len = get_rfc1002_len(work->request_buf);
	smb2_neg_size = offsetof(struct smb2_negotiate_req, Dialects);
	if (smb2_neg_size > smb2_buf_len) {
		rsp->hdr.Status = STATUS_INVALID_PARAMETER;
		rc = -EINVAL;
		goto err_out;
	}

	if (conn->dialect == SMB311_PROT_ID) {
		unsigned int nego_ctxt_off = le32_to_cpu(req->NegotiateContextOffset);

		if (smb2_buf_len < nego_ctxt_off) {
			rsp->hdr.Status = STATUS_INVALID_PARAMETER;
			rc = -EINVAL;
			goto err_out;
		}

		if (smb2_neg_size > nego_ctxt_off) {
			rsp->hdr.Status = STATUS_INVALID_PARAMETER;
			rc = -EINVAL;
			goto err_out;
		}

		if (smb2_neg_size + le16_to_cpu(req->DialectCount) * sizeof(__le16) >
		    nego_ctxt_off) {
			rsp->hdr.Status = STATUS_INVALID_PARAMETER;
			rc = -EINVAL;
			goto err_out;
		}
	} else {
		if (smb2_neg_size + le16_to_cpu(req->DialectCount) * sizeof(__le16) >
		    smb2_buf_len) {
			rsp->hdr.Status = STATUS_INVALID_PARAMETER;
			rc = -EINVAL;
			goto err_out;
		}
	}

	conn->cli_cap = le32_to_cpu(req->Capabilities);
	switch (conn->dialect) {
	case SMB311_PROT_ID:
		conn->preauth_info =
			kzalloc(sizeof(struct preauth_integrity_info),
				GFP_KERNEL);
		if (!conn->preauth_info) {
			rc = -ENOMEM;
			rsp->hdr.Status = STATUS_INVALID_PARAMETER;
			goto err_out;
		}

		status = deassemble_neg_contexts(conn, req,
						 get_rfc1002_len(work->request_buf));
		if (status != STATUS_SUCCESS) {
			pr_err(""deassemble_neg_contexts error(0x%x)\n"",
			       status);
			rsp->hdr.Status = status;
			rc = -EINVAL;
			kfree(conn->preauth_info);
			conn->preauth_info = NULL;
			goto err_out;
		}

		rc = init_smb3_11_server(conn);
		if (rc < 0) {
			rsp->hdr.Status = STATUS_INVALID_PARAMETER;
			kfree(conn->preauth_info);
			conn->preauth_info = NULL;
			goto err_out;
		}

		ksmbd_gen_preauth_integrity_hash(conn,
						 work->request_buf,
						 conn->preauth_info->Preauth_HashValue);
		rsp->NegotiateContextOffset =
				cpu_to_le32(OFFSET_OF_NEG_CONTEXT);
		assemble_neg_contexts(conn, rsp, work->response_buf);
		break;
	case SMB302_PROT_ID:
		init_smb3_02_server(conn);
		break;
	case SMB30_PROT_ID:
		init_smb3_0_server(conn);
		break;
	case SMB21_PROT_ID:
		init_smb2_1_server(conn);
		break;
	case SMB2X_PROT_ID:
	case BAD_PROT_ID:
	default:
		ksmbd_debug(SMB, ""Server dialect :0x%x not supported\n"",
			    conn->dialect);
		rsp->hdr.Status = STATUS_NOT_SUPPORTED;
		rc = -EINVAL;
		goto err_out;
	}
	rsp->Capabilities = cpu_to_le32(conn->vals->capabilities);

	
	conn->connection_type = conn->dialect;

	rsp->MaxTransactSize = cpu_to_le32(conn->vals->max_trans_size);
	rsp->MaxReadSize = cpu_to_le32(conn->vals->max_read_size);
	rsp->MaxWriteSize = cpu_to_le32(conn->vals->max_write_size);

	memcpy(conn->ClientGUID, req->ClientGUID,
			SMB2_CLIENT_GUID_SIZE);
	conn->cli_sec_mode = le16_to_cpu(req->SecurityMode);

	rsp->StructureSize = cpu_to_le16(65);
	rsp->DialectRevision = cpu_to_le16(conn->dialect);
	
	memset(rsp->ServerGUID, 0, SMB2_CLIENT_GUID_SIZE);

	rsp->SystemTime = cpu_to_le64(ksmbd_systime());
	rsp->ServerStartTime = 0;
	ksmbd_debug(SMB, ""negotiate context offset %d, count %d\n"",
		    le32_to_cpu(rsp->NegotiateContextOffset),
		    le16_to_cpu(rsp->NegotiateContextCount));

	rsp->SecurityBufferOffset = cpu_to_le16(128);
	rsp->SecurityBufferLength = cpu_to_le16(AUTH_GSS_LENGTH);
	ksmbd_copy_gss_neg_header((char *)(&rsp->hdr) +
				  le16_to_cpu(rsp->SecurityBufferOffset));
	inc_rfc1001_len(work->response_buf, sizeof(struct smb2_negotiate_rsp) -
			sizeof(struct smb2_hdr) - sizeof(rsp->Buffer) +
			 AUTH_GSS_LENGTH);
	rsp->SecurityMode = SMB2_NEGOTIATE_SIGNING_ENABLED_LE;
	conn->use_spnego = true;

	if ((server_conf.signing == KSMBD_CONFIG_OPT_AUTO ||
	     server_conf.signing == KSMBD_CONFIG_OPT_DISABLED) &&
	    req->SecurityMode & SMB2_NEGOTIATE_SIGNING_REQUIRED_LE)
		conn->sign = true;
	else if (server_conf.signing == KSMBD_CONFIG_OPT_MANDATORY) {
		server_conf.enforced_signing = true;
		rsp->SecurityMode |= SMB2_NEGOTIATE_SIGNING_REQUIRED_LE;
		conn->sign = true;
	}

	conn->srv_sec_mode = le16_to_cpu(rsp->SecurityMode);
	ksmbd_conn_set_need_negotiate(work);

err_out:
	if (rc < 0)
		smb2_set_err_rsp(work);

	return rc;
}
","1. __le32 status;
2. pr_err(""conn->tcp_status is already in CifsGood State\n"");
3. rc = -EINVAL;
4. goto err_out;
5. kzalloc(sizeof(struct preauth_integrity_info),
6. kfree(conn->preauth_info);
7. rsp->MaxWriteSize = cpu_to_le32(conn->vals->max_write_size);
8. memcpy(conn->ClientGUID, req->ClientGUID,
SMB2_CLIENT_GUID_SIZE);
9. rsp->DialectRevision = cpu_to_le16(conn->dialect);
10. ksmbd_debug(SMB, ""negotiate context offset %d, count %d\n"",
11. le16_to_cpu(rsp->SecurityBufferOffset));
12. conn->srv_sec_mode = le16_to_cpu(rsp->SecurityMode);
ksmbd_conn_set_need_negotiate(work);","8
13
21
59
67
90
127
129-130
134
142
149
166-167","CWE-20,CWE-189,CWE-401,CWE-200,CWE-287"
socket_accept-219145396694725,"int socket_accept(int fd, uint16_t port)
{
#ifdef WIN32
	int addr_len;
#else
	socklen_t addr_len;
#endif
	int result;
	struct sockaddr_in addr;

	memset(&addr, 0, sizeof(addr));
	addr.sin_family = AF_INET;
	addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
	addr.sin_port = htons(port);

	addr_len = sizeof(addr);
	result = accept(fd, (struct sockaddr*)&addr, &addr_len);

	return result;
}
","1. socklen_t addr_len;
2. struct sockaddr_in addr;
3. memset(&addr, 0, sizeof(addr));
4. addr.sin_port = htons(port);","6
9
11
14","CWE-200,CWE-284,CWE-399"
rds_sendmsg,"int rds_sendmsg(struct socket *sock, struct msghdr *msg, size_t payload_len)
{
	struct sock *sk = sock->sk;
	struct rds_sock *rs = rds_sk_to_rs(sk);
	DECLARE_SOCKADDR(struct sockaddr_in *, usin, msg->msg_name);
	__be32 daddr;
	__be16 dport;
	struct rds_message *rm = NULL;
	struct rds_connection *conn;
	int ret = 0;
	int queued = 0, allocated_mr = 0;
	int nonblock = msg->msg_flags & MSG_DONTWAIT;
	long timeo = sock_sndtimeo(sk, nonblock);

	
	
	if (msg->msg_flags & ~(MSG_DONTWAIT | MSG_CMSG_COMPAT)) {
		ret = -EOPNOTSUPP;
		goto out;
	}

	if (msg->msg_namelen) {
		
		if (msg->msg_namelen < sizeof(*usin) || usin->sin_family != AF_INET) {
			ret = -EINVAL;
			goto out;
		}
		daddr = usin->sin_addr.s_addr;
		dport = usin->sin_port;
	} else {
		
		lock_sock(sk);
		daddr = rs->rs_conn_addr;
		dport = rs->rs_conn_port;
 		release_sock(sk);
 	}
 
	lock_sock(sk);
 	if (daddr == 0 || rs->rs_bound_addr == 0) {
		release_sock(sk);
 		ret = -ENOTCONN; 
 		goto out;
 	}
	release_sock(sk);
 
 	if (payload_len > rds_sk_sndbuf(rs)) {
 		ret = -EMSGSIZE;
		goto out;
	}

	
	ret = rds_rm_size(msg, payload_len);
	if (ret < 0)
		goto out;

	rm = rds_message_alloc(ret, GFP_KERNEL);
	if (!rm) {
		ret = -ENOMEM;
		goto out;
	}

	
	if (payload_len) {
		rm->data.op_sg = rds_message_alloc_sgs(rm, ceil(payload_len, PAGE_SIZE));
		if (!rm->data.op_sg) {
			ret = -ENOMEM;
			goto out;
		}
		ret = rds_message_copy_from_user(rm, &msg->msg_iter);
		if (ret)
			goto out;
	}
	rm->data.op_active = 1;

	rm->m_daddr = daddr;

	
	if (rs->rs_conn && rs->rs_conn->c_faddr == daddr)
		conn = rs->rs_conn;
	else {
		conn = rds_conn_create_outgoing(sock_net(sock->sk),
						rs->rs_bound_addr, daddr,
					rs->rs_transport,
					sock->sk->sk_allocation);
		if (IS_ERR(conn)) {
			ret = PTR_ERR(conn);
			goto out;
		}
		rs->rs_conn = conn;
	}

	
	ret = rds_cmsg_send(rs, rm, msg, &allocated_mr);
	if (ret)
		goto out;

	if (rm->rdma.op_active && !conn->c_trans->xmit_rdma) {
		printk_ratelimited(KERN_NOTICE ""rdma_op %p conn xmit_rdma %p\n"",
			       &rm->rdma, conn->c_trans->xmit_rdma);
		ret = -EOPNOTSUPP;
		goto out;
	}

	if (rm->atomic.op_active && !conn->c_trans->xmit_atomic) {
		printk_ratelimited(KERN_NOTICE ""atomic_op %p conn xmit_atomic %p\n"",
			       &rm->atomic, conn->c_trans->xmit_atomic);
		ret = -EOPNOTSUPP;
		goto out;
	}

	rds_conn_connect_if_down(conn);

	ret = rds_cong_wait(conn->c_fcong, dport, nonblock, rs);
	if (ret) {
		rs->rs_seen_congestion = 1;
		goto out;
	}

	while (!rds_send_queue_rm(rs, conn, rm, rs->rs_bound_port,
				  dport, &queued)) {
		rds_stats_inc(s_send_queue_full);

		if (nonblock) {
			ret = -EAGAIN;
			goto out;
		}

		timeo = wait_event_interruptible_timeout(*sk_sleep(sk),
					rds_send_queue_rm(rs, conn, rm,
							  rs->rs_bound_port,
							  dport,
							  &queued),
					timeo);
		rdsdebug(""sendmsg woke queued %d timeo %ld\n"", queued, timeo);
		if (timeo > 0 || timeo == MAX_SCHEDULE_TIMEOUT)
			continue;

		ret = timeo;
		if (ret == 0)
			ret = -ETIMEDOUT;
		goto out;
	}

	
	rds_stats_inc(s_send_queued);

	ret = rds_send_xmit(conn);
	if (ret == -ENOMEM || ret == -EAGAIN)
		queue_delayed_work(rds_wq, &conn->c_send_w, 1);

	rds_message_put(rm);
	return payload_len;

out:
	
	if (allocated_mr)
		rds_rdma_unuse(rs, rds_rdma_cookie_key(rm->m_rdma_cookie), 1);

	if (rm)
		rds_message_put(rm);
	return ret;
}
","1. __be16 dport;
2. int queued = 0, allocated_mr = 0;
3. goto out;
4. if (!rm) {
5. goto out;
6. rm->data.op_active = 1;
7. ret = rds_cmsg_send(rs, rm, msg, &allocated_mr);
8. while (!rds_send_queue_rm(rs, conn, rm, rs->rs_bound_port,
dport, &queued)) {
9. if (nonblock) {
10. continue;
11. queue_delayed_work(rds_wq, &conn->c_send_w, 1);
12. rds_message_put(rm);
13. if (allocated_mr)
14. if (rm)","7
11
42
57
67
73
94
120-121
124
137
153
155
162
165","CWE-20,CWE-824,CWE-200,CWE-400,CWE-287"
crypto_report_acomp,"static int crypto_report_acomp(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_acomp racomp;
 
	strncpy(racomp.type, ""acomp"", sizeof(racomp.type));
 
 	if (nla_put(skb, CRYPTOCFGA_REPORT_ACOMP,
 		    sizeof(struct crypto_report_acomp), &racomp))
		goto nla_put_failure;
	return 0;

nla_put_failure:
	return -EMSGSIZE;
}
","1. struct crypto_report_acomp racomp;
2. strncpy(racomp.type, ""acomp"", sizeof(racomp.type));
3. sizeof(struct crypto_report_acomp), &racomp))
4. return -EMSGSIZE;","3
5
8
13","CWE-310,CWE-200"
do_mathemu_1,"int do_mathemu_1(struct pt_regs *regs, struct fpustate *f)
{
	unsigned long pc = regs->tpc;
	unsigned long tstate = regs->tstate;
	u32 insn = 0;
	int type = 0;
	
#define TYPE(ftt, r, ru, b, bu, a, au) type = (au << 2) | (a << 0) | (bu << 5) | (b << 3) | (ru << 8) | (r << 6) | (ftt << 9)
	int freg;
	static u64 zero[2] = { 0L, 0L };
	int flags;
	FP_DECL_EX;
	FP_DECL_S(SA); FP_DECL_S(SB); FP_DECL_S(SR);
	FP_DECL_D(DA); FP_DECL_D(DB); FP_DECL_D(DR);
	FP_DECL_Q(QA); FP_DECL_Q(QB); FP_DECL_Q(QR);
	int IR;
	long XR, xfsr;
 
 	if (tstate & TSTATE_PRIV)
 		die_if_kernel(""unfinished/unimplemented FPop from kernel"", regs);
	perf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, regs, 0);
 	if (test_thread_flag(TIF_32BIT))
 		pc = (u32)pc;
 	if (get_user(insn, (u32 __user *) pc) != -EFAULT) {
		if ((insn & 0xc1f80000) == 0x81a00000)  {
			switch ((insn >> 5) & 0x1ff) {
			
			case FMOVQ:
			case FNEGQ:
			case FABSQ: TYPE(3,3,0,3,0,0,0); break;
			case FSQRTQ: TYPE(3,3,1,3,1,0,0); break;
			case FADDQ:
			case FSUBQ:
			case FMULQ:
			case FDIVQ: TYPE(3,3,1,3,1,3,1); break;
			case FDMULQ: TYPE(3,3,1,2,1,2,1); break;
			case FQTOX: TYPE(3,2,0,3,1,0,0); break;
			case FXTOQ: TYPE(3,3,1,2,0,0,0); break;
			case FQTOS: TYPE(3,1,1,3,1,0,0); break;
			case FQTOD: TYPE(3,2,1,3,1,0,0); break;
			case FITOQ: TYPE(3,3,1,1,0,0,0); break;
			case FSTOQ: TYPE(3,3,1,1,1,0,0); break;
			case FDTOQ: TYPE(3,3,1,2,1,0,0); break;
			case FQTOI: TYPE(3,1,0,3,1,0,0); break;

			
			case FSQRTS: {
				unsigned long x = current_thread_info()->xfsr[0];

				x = (x >> 14) & 0xf;
				TYPE(x,1,1,1,1,0,0);
				break;
			}

			case FSQRTD: {
				unsigned long x = current_thread_info()->xfsr[0];

				x = (x >> 14) & 0xf;
				TYPE(x,2,1,2,1,0,0);
				break;
			}

			
			case FADDD:
			case FSUBD:
			case FMULD:
			case FDIVD: TYPE(2,2,1,2,1,2,1); break;
			case FADDS:
			case FSUBS:
			case FMULS:
			case FDIVS: TYPE(2,1,1,1,1,1,1); break;
			case FSMULD: TYPE(2,2,1,1,1,1,1); break;
			case FSTOX: TYPE(2,2,0,1,1,0,0); break;
			case FDTOX: TYPE(2,2,0,2,1,0,0); break;
			case FDTOS: TYPE(2,1,1,2,1,0,0); break;
			case FSTOD: TYPE(2,2,1,1,1,0,0); break;
			case FSTOI: TYPE(2,1,0,1,1,0,0); break;
			case FDTOI: TYPE(2,1,0,2,1,0,0); break;

			
			case FXTOS: TYPE(2,1,1,2,0,0,0); break;
			case FXTOD: TYPE(2,2,1,2,0,0,0); break;
#if 0			
			case FITOS: TYPE(2,1,1,1,0,0,0); break;
#endif
			case FITOD: TYPE(2,2,1,1,0,0,0); break;
			}
		}
		else if ((insn & 0xc1f80000) == 0x81a80000)  {
			IR = 2;
			switch ((insn >> 5) & 0x1ff) {
			case FCMPQ: TYPE(3,0,0,3,1,3,1); break;
			case FCMPEQ: TYPE(3,0,0,3,1,3,1); break;
			
			case FMOVQ0:
			case FMOVQ1:
			case FMOVQ2:
			case FMOVQ3:
				
				if (!((insn >> 11) & 3))
					XR = current_thread_info()->xfsr[0] >> 10;
				else
					XR = current_thread_info()->xfsr[0] >> (30 + ((insn >> 10) & 0x6));
				XR &= 3;
				IR = 0;
				switch ((insn >> 14) & 0x7) {
							
				case 1: if (XR) IR = 1; break;			
				case 2: if (XR == 1 || XR == 2) IR = 1; break;	
				case 3: if (XR & 1) IR = 1; break;		
				case 4: if (XR == 1) IR = 1; break;		
				case 5: if (XR & 2) IR = 1; break;		
				case 6: if (XR == 2) IR = 1; break;		
				case 7: if (XR == 3) IR = 1; break;		
				}
				if ((insn >> 14) & 8)
					IR ^= 1;
				break;
			case FMOVQI:
			case FMOVQX:
				
				XR = regs->tstate >> 32;
				if ((insn >> 5) & 0x80)
					XR >>= 4;
				XR &= 0xf;
				IR = 0;
				freg = ((XR >> 2) ^ XR) & 2;
				switch ((insn >> 14) & 0x7) {
							
				case 1: if (XR & 4) IR = 1; break;		
				case 2: if ((XR & 4) || freg) IR = 1; break;	
				case 3: if (freg) IR = 1; break;		
				case 4: if (XR & 5) IR = 1; break;		
				case 5: if (XR & 1) IR = 1; break;		
				case 6: if (XR & 8) IR = 1; break;		
				case 7: if (XR & 2) IR = 1; break;		
				}
				if ((insn >> 14) & 8)
					IR ^= 1;
				break;
			case FMOVQZ:
			case FMOVQLE:
			case FMOVQLZ:
			case FMOVQNZ:
			case FMOVQGZ:
			case FMOVQGE:
				freg = (insn >> 14) & 0x1f;
				if (!freg)
					XR = 0;
				else if (freg < 16)
					XR = regs->u_regs[freg];
				else if (test_thread_flag(TIF_32BIT)) {
					struct reg_window32 __user *win32;
					flushw_user ();
					win32 = (struct reg_window32 __user *)((unsigned long)((u32)regs->u_regs[UREG_FP]));
					get_user(XR, &win32->locals[freg - 16]);
				} else {
					struct reg_window __user *win;
					flushw_user ();
					win = (struct reg_window __user *)(regs->u_regs[UREG_FP] + STACK_BIAS);
					get_user(XR, &win->locals[freg - 16]);
				}
				IR = 0;
				switch ((insn >> 10) & 3) {
				case 1: if (!XR) IR = 1; break;			
				case 2: if (XR <= 0) IR = 1; break;		
				case 3: if (XR < 0) IR = 1; break;		
				}
				if ((insn >> 10) & 4)
					IR ^= 1;
				break;
			}
			if (IR == 0) {
				
				current_thread_info()->xfsr[0] &= ~(FSR_CEXC_MASK);
				regs->tpc = regs->tnpc;
				regs->tnpc += 4;
				return 1;
			} else if (IR == 1) {
				
				insn = (insn & 0x3e00001f) | 0x81a00060;
				TYPE(3,3,0,3,0,0,0); 
			}
		}
	}
	if (type) {
		argp rs1 = NULL, rs2 = NULL, rd = NULL;
		
		freg = (current_thread_info()->xfsr[0] >> 14) & 0xf;
		if (freg != (type >> 9))
			goto err;
		current_thread_info()->xfsr[0] &= ~0x1c000;
		freg = ((insn >> 14) & 0x1f);
		switch (type & 0x3) {
		case 3: if (freg & 2) {
				current_thread_info()->xfsr[0] |= (6 << 14) ;
				goto err;
			}
		case 2: freg = ((freg & 1) << 5) | (freg & 0x1e);
		case 1: rs1 = (argp)&f->regs[freg];
			flags = (freg < 32) ? FPRS_DL : FPRS_DU; 
			if (!(current_thread_info()->fpsaved[0] & flags))
				rs1 = (argp)&zero;
			break;
		}
		switch (type & 0x7) {
		case 7: FP_UNPACK_QP (QA, rs1); break;
		case 6: FP_UNPACK_DP (DA, rs1); break;
		case 5: FP_UNPACK_SP (SA, rs1); break;
		}
		freg = (insn & 0x1f);
		switch ((type >> 3) & 0x3) {
		case 3: if (freg & 2) {
				current_thread_info()->xfsr[0] |= (6 << 14) ;
				goto err;
			}
		case 2: freg = ((freg & 1) << 5) | (freg & 0x1e);
		case 1: rs2 = (argp)&f->regs[freg];
			flags = (freg < 32) ? FPRS_DL : FPRS_DU; 
			if (!(current_thread_info()->fpsaved[0] & flags))
				rs2 = (argp)&zero;
			break;
		}
		switch ((type >> 3) & 0x7) {
		case 7: FP_UNPACK_QP (QB, rs2); break;
		case 6: FP_UNPACK_DP (DB, rs2); break;
		case 5: FP_UNPACK_SP (SB, rs2); break;
		}
		freg = ((insn >> 25) & 0x1f);
		switch ((type >> 6) & 0x3) {
		case 3: if (freg & 2) {
				current_thread_info()->xfsr[0] |= (6 << 14) ;
				goto err;
			}
		case 2: freg = ((freg & 1) << 5) | (freg & 0x1e);
		case 1: rd = (argp)&f->regs[freg];
			flags = (freg < 32) ? FPRS_DL : FPRS_DU; 
			if (!(current_thread_info()->fpsaved[0] & FPRS_FEF)) {
				current_thread_info()->fpsaved[0] = FPRS_FEF;
				current_thread_info()->gsr[0] = 0;
			}
			if (!(current_thread_info()->fpsaved[0] & flags)) {
				if (freg < 32)
					memset(f->regs, 0, 32*sizeof(u32));
				else
					memset(f->regs+32, 0, 32*sizeof(u32));
			}
			current_thread_info()->fpsaved[0] |= flags;
			break;
		}
		switch ((insn >> 5) & 0x1ff) {
		
		case FADDS: FP_ADD_S (SR, SA, SB); break;
		case FADDD: FP_ADD_D (DR, DA, DB); break;
		case FADDQ: FP_ADD_Q (QR, QA, QB); break;
		
		case FSUBS: FP_SUB_S (SR, SA, SB); break;
		case FSUBD: FP_SUB_D (DR, DA, DB); break;
		case FSUBQ: FP_SUB_Q (QR, QA, QB); break;
		
		case FMULS: FP_MUL_S (SR, SA, SB); break;
		case FSMULD: FP_CONV (D, S, 1, 1, DA, SA);
			     FP_CONV (D, S, 1, 1, DB, SB);
		case FMULD: FP_MUL_D (DR, DA, DB); break;
		case FDMULQ: FP_CONV (Q, D, 2, 1, QA, DA);
			     FP_CONV (Q, D, 2, 1, QB, DB);
		case FMULQ: FP_MUL_Q (QR, QA, QB); break;
		
		case FDIVS: FP_DIV_S (SR, SA, SB); break;
		case FDIVD: FP_DIV_D (DR, DA, DB); break;
		case FDIVQ: FP_DIV_Q (QR, QA, QB); break;
		
		case FSQRTS: FP_SQRT_S (SR, SB); break;
		case FSQRTD: FP_SQRT_D (DR, DB); break;
		case FSQRTQ: FP_SQRT_Q (QR, QB); break;
		
		case FMOVQ: rd->q[0] = rs2->q[0]; rd->q[1] = rs2->q[1]; break;
		case FABSQ: rd->q[0] = rs2->q[0] & 0x7fffffffffffffffUL; rd->q[1] = rs2->q[1]; break;
		case FNEGQ: rd->q[0] = rs2->q[0] ^ 0x8000000000000000UL; rd->q[1] = rs2->q[1]; break;
		
		case FSTOI: FP_TO_INT_S (IR, SB, 32, 1); break;
		case FDTOI: FP_TO_INT_D (IR, DB, 32, 1); break;
		case FQTOI: FP_TO_INT_Q (IR, QB, 32, 1); break;
		case FSTOX: FP_TO_INT_S (XR, SB, 64, 1); break;
		case FDTOX: FP_TO_INT_D (XR, DB, 64, 1); break;
		case FQTOX: FP_TO_INT_Q (XR, QB, 64, 1); break;
		
		case FITOQ: IR = rs2->s; FP_FROM_INT_Q (QR, IR, 32, int); break;
		case FXTOQ: XR = rs2->d; FP_FROM_INT_Q (QR, XR, 64, long); break;
		
		case FXTOS: XR = rs2->d; FP_FROM_INT_S (SR, XR, 64, long); break;
		case FXTOD: XR = rs2->d; FP_FROM_INT_D (DR, XR, 64, long); break;
#if 0		
		case FITOS: IR = rs2->s; FP_FROM_INT_S (SR, IR, 32, int); break;
#endif
		case FITOD: IR = rs2->s; FP_FROM_INT_D (DR, IR, 32, int); break;
		
		case FSTOD: FP_CONV (D, S, 1, 1, DR, SB); break;
		case FSTOQ: FP_CONV (Q, S, 2, 1, QR, SB); break;
		case FDTOQ: FP_CONV (Q, D, 2, 1, QR, DB); break;
		case FDTOS: FP_CONV (S, D, 1, 1, SR, DB); break;
		case FQTOS: FP_CONV (S, Q, 1, 2, SR, QB); break;
		case FQTOD: FP_CONV (D, Q, 1, 2, DR, QB); break;
		
		case FCMPQ:
		case FCMPEQ:
			FP_CMP_Q(XR, QB, QA, 3);
			if (XR == 3 &&
			    (((insn >> 5) & 0x1ff) == FCMPEQ ||
			     FP_ISSIGNAN_Q(QA) ||
			     FP_ISSIGNAN_Q(QB)))
				FP_SET_EXCEPTION (FP_EX_INVALID);
		}
		if (!FP_INHIBIT_RESULTS) {
			switch ((type >> 6) & 0x7) {
			case 0: xfsr = current_thread_info()->xfsr[0];
				if (XR == -1) XR = 2;
				switch (freg & 3) {
				
				case 0: xfsr &= ~0xc00; xfsr |= (XR << 10); break;
				case 1: xfsr &= ~0x300000000UL; xfsr |= (XR << 32); break;
				case 2: xfsr &= ~0xc00000000UL; xfsr |= (XR << 34); break;
				case 3: xfsr &= ~0x3000000000UL; xfsr |= (XR << 36); break;
				}
				current_thread_info()->xfsr[0] = xfsr;
				break;
			case 1: rd->s = IR; break;
			case 2: rd->d = XR; break;
			case 5: FP_PACK_SP (rd, SR); break;
			case 6: FP_PACK_DP (rd, DR); break;
			case 7: FP_PACK_QP (rd, QR); break;
			}
		}

		if(_fex != 0)
			return record_exception(regs, _fex);

		
		current_thread_info()->xfsr[0] &= ~(FSR_CEXC_MASK);
		regs->tpc = regs->tnpc;
		regs->tnpc += 4;
		return 1;
	}
err:	return 0;
}
","1. case FNEGQ:
2. case FDTOI: TYPE(2,1,0,2,1,0,0); break;
3. case 2: if ((XR & 4) || freg) IR = 1; break;
4. return 1;
5. rs1 = (argp)&zero;
6. case 2: freg = ((freg & 1) << 5) | (freg & 0x1e);
7. if (!(current_thread_info()->fpsaved[0] & flags)) {
if (freg < 32)
8. case FMULQ: FP_MUL_Q (QR, QA, QB); break;
9. case FDIVQ: FP_DIV_Q (QR, QA, QB); break;
10. case 6: FP_PACK_DP (rd, DR); break;","31
84
137
184
209
241
248-249
273
277
336","CWE-399,CWE-400"
do_check_1,"static int do_check_1(struct bpf_verifier_env *env)
{
	struct bpf_verifier_state *state = &env->cur_state;
	struct bpf_insn *insns = env->prog->insnsi;
	struct bpf_reg_state *regs = state->regs;
	int insn_cnt = env->prog->len;
	int insn_idx, prev_insn_idx = 0;
	int insn_processed = 0;
	bool do_print_state = false;

	init_reg_state(regs);
	insn_idx = 0;
	env->varlen_map_value_access = false;
	for (;;) {
		struct bpf_insn *insn;
		u8 class;
		int err;

		if (insn_idx >= insn_cnt) {
			verbose(""invalid insn idx %d insn_cnt %d\n"",
				insn_idx, insn_cnt);
			return -EFAULT;
		}

		insn = &insns[insn_idx];
		class = BPF_CLASS(insn->code);

		if (++insn_processed > BPF_COMPLEXITY_LIMIT_INSNS) {
			verbose(""BPF program is too large. Processed %d insn\n"",
				insn_processed);
			return -E2BIG;
		}

		err = is_state_visited(env, insn_idx);
		if (err < 0)
			return err;
		if (err == 1) {
			
			if (log_level) {
				if (do_print_state)
					verbose(""\nfrom %d to %d: safe\n"",
						prev_insn_idx, insn_idx);
				else
					verbose(""%d: safe\n"", insn_idx);
			}
			goto process_bpf_exit;
		}

		if (log_level && do_print_state) {
			verbose(""\nfrom %d to %d:"", prev_insn_idx, insn_idx);
			print_verifier_state(&env->cur_state);
			do_print_state = false;
		}
 
 		if (log_level) {
 			verbose(""%d: "", insn_idx);
			print_bpf_insn(env, insn);
 		}
 
 		err = ext_analyzer_insn_hook(env, insn_idx, prev_insn_idx);
		if (err)
			return err;

		if (class == BPF_ALU || class == BPF_ALU64) {
			err = check_alu_op(env, insn);
			if (err)
				return err;

		} else if (class == BPF_LDX) {
			enum bpf_reg_type *prev_src_type, src_reg_type;

			

			
			err = check_reg_arg(regs, insn->src_reg, SRC_OP);
			if (err)
				return err;

			err = check_reg_arg(regs, insn->dst_reg, DST_OP_NO_MARK);
			if (err)
				return err;

			src_reg_type = regs[insn->src_reg].type;

			
			err = check_mem_access(env, insn->src_reg, insn->off,
					       BPF_SIZE(insn->code), BPF_READ,
					       insn->dst_reg);
			if (err)
				return err;

			if (BPF_SIZE(insn->code) != BPF_W &&
			    BPF_SIZE(insn->code) != BPF_DW) {
				insn_idx++;
				continue;
			}

			prev_src_type = &env->insn_aux_data[insn_idx].ptr_type;

			if (*prev_src_type == NOT_INIT) {
				
				*prev_src_type = src_reg_type;

			} else if (src_reg_type != *prev_src_type &&
				   (src_reg_type == PTR_TO_CTX ||
				    *prev_src_type == PTR_TO_CTX)) {
				
				verbose(""same insn cannot be used with different pointers\n"");
				return -EINVAL;
			}

		} else if (class == BPF_STX) {
			enum bpf_reg_type *prev_dst_type, dst_reg_type;

			if (BPF_MODE(insn->code) == BPF_XADD) {
				err = check_xadd(env, insn);
				if (err)
					return err;
				insn_idx++;
				continue;
			}

			
			err = check_reg_arg(regs, insn->src_reg, SRC_OP);
			if (err)
				return err;
			
			err = check_reg_arg(regs, insn->dst_reg, SRC_OP);
			if (err)
				return err;

			dst_reg_type = regs[insn->dst_reg].type;

			
			err = check_mem_access(env, insn->dst_reg, insn->off,
					       BPF_SIZE(insn->code), BPF_WRITE,
					       insn->src_reg);
			if (err)
				return err;

			prev_dst_type = &env->insn_aux_data[insn_idx].ptr_type;

			if (*prev_dst_type == NOT_INIT) {
				*prev_dst_type = dst_reg_type;
			} else if (dst_reg_type != *prev_dst_type &&
				   (dst_reg_type == PTR_TO_CTX ||
				    *prev_dst_type == PTR_TO_CTX)) {
				verbose(""same insn cannot be used with different pointers\n"");
				return -EINVAL;
			}

		} else if (class == BPF_ST) {
			if (BPF_MODE(insn->code) != BPF_MEM ||
			    insn->src_reg != BPF_REG_0) {
				verbose(""BPF_ST uses reserved fields\n"");
				return -EINVAL;
			}
			
			err = check_reg_arg(regs, insn->dst_reg, SRC_OP);
			if (err)
				return err;

			
			err = check_mem_access(env, insn->dst_reg, insn->off,
					       BPF_SIZE(insn->code), BPF_WRITE,
					       -1);
			if (err)
				return err;

		} else if (class == BPF_JMP) {
			u8 opcode = BPF_OP(insn->code);

			if (opcode == BPF_CALL) {
				if (BPF_SRC(insn->code) != BPF_K ||
				    insn->off != 0 ||
				    insn->src_reg != BPF_REG_0 ||
				    insn->dst_reg != BPF_REG_0) {
					verbose(""BPF_CALL uses reserved fields\n"");
					return -EINVAL;
				}

				err = check_call(env, insn->imm, insn_idx);
				if (err)
					return err;

			} else if (opcode == BPF_JA) {
				if (BPF_SRC(insn->code) != BPF_K ||
				    insn->imm != 0 ||
				    insn->src_reg != BPF_REG_0 ||
				    insn->dst_reg != BPF_REG_0) {
					verbose(""BPF_JA uses reserved fields\n"");
					return -EINVAL;
				}

				insn_idx += insn->off + 1;
				continue;

			} else if (opcode == BPF_EXIT) {
				if (BPF_SRC(insn->code) != BPF_K ||
				    insn->imm != 0 ||
				    insn->src_reg != BPF_REG_0 ||
				    insn->dst_reg != BPF_REG_0) {
					verbose(""BPF_EXIT uses reserved fields\n"");
					return -EINVAL;
				}

				
				err = check_reg_arg(regs, BPF_REG_0, SRC_OP);
				if (err)
					return err;

				if (is_pointer_value(env, BPF_REG_0)) {
					verbose(""R0 leaks addr as return value\n"");
					return -EACCES;
				}

process_bpf_exit:
				insn_idx = pop_stack(env, &prev_insn_idx);
				if (insn_idx < 0) {
					break;
				} else {
					do_print_state = true;
					continue;
				}
			} else {
				err = check_cond_jmp_op(env, insn, &insn_idx);
				if (err)
					return err;
			}
		} else if (class == BPF_LD) {
			u8 mode = BPF_MODE(insn->code);

			if (mode == BPF_ABS || mode == BPF_IND) {
				err = check_ld_abs(env, insn);
				if (err)
					return err;

			} else if (mode == BPF_IMM) {
				err = check_ld_imm(env, insn);
				if (err)
					return err;

				insn_idx++;
			} else {
				verbose(""invalid BPF_LD mode\n"");
				return -EINVAL;
			}
			reset_reg_range_values(regs, insn->dst_reg);
		} else {
			verbose(""unknown insn class %d\n"", class);
			return -EINVAL;
		}

		insn_idx++;
	}

	verbose(""processed %d insns\n"", insn_processed);
	return 0;
}
","1. struct bpf_verifier_state *state = &env->cur_state;
2. int insn_cnt = env->prog->len;
3. int insn_processed = 0;
bool do_print_state = false;
4. int err;
5. insn_idx, insn_cnt);
6. err = is_state_visited(env, insn_idx);
if (err < 0)
return err;
if (err == 1) {
7. prev_insn_idx, insn_idx);
8. verbose(""%d: safe\n"", insn_idx);
9. if (log_level && do_print_state) {
10. do_print_state = false;
11. verbose(""%d: "", insn_idx);
12. return err;
13. if (class == BPF_ALU || class == BPF_ALU64) {
14. src_reg_type = regs[insn->src_reg].type;
15. insn_idx++;
16. } else if (src_reg_type != *prev_src_type &&
(src_reg_type == PTR_TO_CTX ||
17. return -EINVAL;
18. if (err)
19. continue;
20. if (err)
21. if (err)
22. if (BPF_MODE(insn->code) != BPF_MEM ||
insn->src_reg != BPF_REG_0) {
verbose(""BPF_ST uses reserved fields\n"");
23. return err;
24. err = check_mem_access(env, insn->dst_reg, insn->off,
BPF_SIZE(insn->code), BPF_WRITE,
-1);
25. insn->off != 0 ||
26. insn->dst_reg != BPF_REG_0) {
verbose(""BPF_CALL uses reserved fields\n"");
27. err = check_call(env, insn->imm, insn_idx);
28. if (BPF_SRC(insn->code) != BPF_K ||
29. err = check_reg_arg(regs, BPF_REG_0, SRC_OP);
30. return -EACCES;
31. break;
32. continue;
33. return err;
34. } else {
35. reset_reg_range_values(regs, insn->dst_reg);
36. verbose(""unknown insn class %d\n"", class);
37. insn_idx++;
38. return 0;","3
6
8-9
17
21
34-37
42
44
49
52
56
62
64
83
96
109-110
120
128
131
136
149
164-166
172
175-177
186
188-189
193
210
224
230
236
239
252
260
264
266
270
274","CWE-200,CWE-59,CWE-416"
htmlGetText-188762665576951,"uchar *				
htmlGetText(tree_t *t)		
{
  uchar		*s,		
		*s2,		
		*tdata = NULL,	
		*talloc = NULL;	
  size_t	slen,		
		tlen;		


  
  slen = 0;
  s    = NULL;

  while (t != NULL)
  {
    if (t->child)
      tdata = talloc = htmlGetText(t->child);
    else
      tdata = t->data;

    tlen = tdata ? strlen((char *)tdata) : 0;

    if (tdata != NULL && tlen > 0)
    {
      
      if (s)
        s2 = (uchar *)realloc(s, 1 + slen + tlen);
      else
        s2 = (uchar *)malloc(1 + tlen);

      if (!s2)
        break;

      s = s2;

      memcpy((char *)s + slen, (char *)tdata, tlen);

      slen += tlen;
    }

    if (talloc)
    {
      free(talloc);
      talloc = NULL;
    }

    t = t->next;
  }

  if (slen)
    s[slen] = '\0';

  if (talloc)
    free(talloc);

  return (s);
}
","1. uchar *
htmlGetText(tree_t *t)
2. *s2,
3. *talloc = NULL;
4. s    = NULL;
5. tdata = talloc = htmlGetText(t->child);
6. tdata = t->data;
7. free(talloc);
8. if (slen)","1-2
5
7
14
19
21
45
52","CWE-20,CWE-120,CWE-416,CWE-190,CWE-399"
wb_id,"wb_id(netdissect_options *ndo,
      const struct pkt_id *id, u_int len)
{
	int i;
	const char *cp;
	const struct id_off *io;
	char c;
	int nid;

	ND_PRINT((ndo, "" wb-id:""));
	if (len < sizeof(*id) || !ND_TTEST(*id))
		return (-1);
	len -= sizeof(*id);

	ND_PRINT((ndo, "" %u/%s:%u (max %u/%s:%u) "",
	       EXTRACT_32BITS(&id->pi_ps.slot),
	       ipaddr_string(ndo, &id->pi_ps.page.p_sid),
	       EXTRACT_32BITS(&id->pi_ps.page.p_uid),
	       EXTRACT_32BITS(&id->pi_mslot),
	       ipaddr_string(ndo, &id->pi_mpage.p_sid),
	       EXTRACT_32BITS(&id->pi_mpage.p_uid)));

	nid = EXTRACT_16BITS(&id->pi_ps.nid);
 	len -= sizeof(*io) * nid;
 	io = (struct id_off *)(id + 1);
 	cp = (char *)(io + nid);
	if (ND_TTEST2(cp, len)) {
 		ND_PRINT((ndo, ""\""""));
 		fn_print(ndo, (u_char *)cp, (u_char *)cp + len);
 		ND_PRINT((ndo, ""\""""));
	}

	c = '<';
	for (i = 0; i < nid && ND_TTEST(*io); ++io, ++i) {
		ND_PRINT((ndo, ""%c%s:%u"",
		    c, ipaddr_string(ndo, &io->id), EXTRACT_32BITS(&io->off)));
		c = ',';
	}
	if (i >= nid) {
		ND_PRINT((ndo, "">""));
		return (0);
	}
	return (-1);
}
","1. const struct pkt_id *id, u_int len)
2. return (-1);
3. EXTRACT_32BITS(&id->pi_mslot),
4. ND_PRINT((ndo, ""\""""));
5. ND_PRINT((ndo, ""\""""));
6. c = '<';
7. c, ipaddr_string(ndo, &io->id), EXTRACT_32BITS(&io->off)));
8. if (i >= nid) {","2
12
19
28
30
33
36
39","CWE-20,CWE-125,CWE-119"
ntlm_print_message_fields,"
#define NTLM_MESSAGE_FIELDS

void ntlm_print_message_fields(NTLM_MESSAGE_FIELDS* fields, const char* name)
static void ntlm_print_message_fields(NTLM_MESSAGE_FIELDS* fields, const char* name)
 {
 	WLog_DBG(TAG, ""%s (Len: %""PRIu16"" MaxLen: %""PRIu16"" BufferOffset: %""PRIu32"")"",
 	         name, fields->Len, fields->MaxLen, fields->BufferOffset);

	if (fields->Len > 0)
		winpr_HexDump(TAG, WLOG_DEBUG, fields->Buffer, fields->Len);
}
","1. static void ntlm_print_message_fields(NTLM_MESSAGE_FIELDS* fields, const char* name)
2. if (fields->Len > 0)
winpr_HexDump(TAG, WLOG_DEBUG, fields->Buffer, fields->Len);","5
10-11",CWE-125
keyring_describe,"static void keyring_describe(const struct key *keyring, struct seq_file *m)
{
	if (keyring->description)
		seq_puts(m, keyring->description);
 	else
 		seq_puts(m, ""[anon]"");
 
	if (key_is_positive(keyring)) {
 		if (keyring->keys.nr_leaves_on_tree != 0)
 			seq_printf(m, "": %lu"", keyring->keys.nr_leaves_on_tree);
 		else
			seq_puts(m, "": empty"");
	}
}
","1. if (keyring->description)
seq_puts(m, keyring->description);
2. if (key_is_positive(keyring)) {
if (keyring->keys.nr_leaves_on_tree != 0)
seq_printf(m, "": %lu"", keyring->keys.nr_leaves_on_tree);","3-4
8-10","CWE-200,CWE-264,CWE-399"
get_sb_block,"static ext3_fsblk_t get_sb_block(void **data, struct super_block *sb)
{
	ext3_fsblk_t	sb_block;
	char		*options = (char *) *data;

	if (!options || strncmp(options, ""sb="", 3) != 0)
		return 1;	
	options += 3;
 	
 	sb_block = simple_strtoul(options, &options, 0);
 	if (*options && *options != ',') {
		ext3_msg(sb, KERN_ERR, ""error: invalid sb specification: %s"",
 		       (char *) *data);
 		return 1;
 	}
	if (*options == ',')
		options++;
	*data = (void *) options;
	return sb_block;
}
","1. if (!options || strncmp(options, ""sb="", 3) != 0)
2. options += 3;
3. sb_block = simple_strtoul(options, &options, 0);
if (*options && *options != ',') {
4. options++;","6
8
10-11
17","CWE-20,CWE-399,CWE-119"
l2cap_sock_getname,"static int l2cap_sock_getname(struct socket *sock, struct sockaddr *addr, int *len, int peer)
{
	struct sockaddr_l2 *la = (struct sockaddr_l2 *) addr;
	struct sock *sk = sock->sk;
	struct l2cap_chan *chan = l2cap_pi(sk)->chan;
 
 	BT_DBG(""sock %p, sk %p"", sock, sk);
 
	memset(la, 0, sizeof(struct sockaddr_l2));
 	addr->sa_family = AF_BLUETOOTH;
 	*len = sizeof(struct sockaddr_l2);
 
	if (peer) {
		la->l2_psm = chan->psm;
		bacpy(&la->l2_bdaddr, &bt_sk(sk)->dst);
		la->l2_cid = cpu_to_le16(chan->dcid);
	} else {
		la->l2_psm = chan->sport;
		bacpy(&la->l2_bdaddr, &bt_sk(sk)->src);
		la->l2_cid = cpu_to_le16(chan->scid);
	}

	return 0;
}
","1. static int l2cap_sock_getname(struct socket *sock, struct sockaddr *addr, int *len, int peer)
2. struct l2cap_chan *chan = l2cap_pi(sk)->chan;
3. addr->sa_family = AF_BLUETOOTH;
4. if (peer) {
la->l2_psm = chan->psm;
bacpy(&la->l2_bdaddr, &bt_sk(sk)->dst);
5. bacpy(&la->l2_bdaddr, &bt_sk(sk)->src);","1
5
10
13-15
19","CWE-200,CWE-125,CWE-399"
log_flush-176589676194813,"
#define LOG_MODE

void log_flush(LOG_MODE new_mode) {
    CRYPTO_THREAD_write_lock(stunnel_locks[LOCK_LOG_MODE]);

    log_mode=new_mode;

    
    if(new_mode!=LOG_MODE_BUFFER) {
        
        CRYPTO_THREAD_write_lock(stunnel_locks[LOCK_LOG_BUFFER]);
        while(head) {
            struct LIST *tmp=head;
            head=head->next;
            log_raw(tmp->opt, tmp->level, tmp->stamp, tmp->id, tmp->text);
            str_free(tmp);
        }
        head=tail=NULL;
        CRYPTO_THREAD_unlock(stunnel_locks[LOCK_LOG_BUFFER]);
    }

    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_LOG_MODE]);
}
",1. str_free(tmp);,17,"CWE-362,CWE-189,CWE-200,CWE-354,CWE-116"
krb5_ldap_put_principal," krb5_ldap_put_principal(krb5_context context, krb5_db_entry *entry,
                         char **db_args)
{
    int                         l=0, kerberos_principal_object_type=0;
    unsigned int                ntrees=0, tre=0;
    krb5_error_code             st=0, tempst=0;
    LDAP                        *ld=NULL;
     LDAPMessage                 *result=NULL, *ent=NULL;
     char                        **subtreelist = NULL;
     char                        *user=NULL, *subtree=NULL, *principal_dn=NULL;
    char                        *strval[10]={NULL}, errbuf[1024];
     char                        *filtuser=NULL;
     struct berval               **bersecretkey=NULL;
     LDAPMod                     **mods=NULL;
     krb5_boolean                create_standalone=FALSE;
    krb5_boolean                establish_links=FALSE;
     char                        *standalone_principal_dn=NULL;
     krb5_tl_data                *tl_data=NULL;
     krb5_key_data               **keys=NULL;
    kdb5_dal_handle             *dal_handle=NULL;
    krb5_ldap_context           *ldap_context=NULL;
    krb5_ldap_server_handle     *ldap_server_handle=NULL;
    osa_princ_ent_rec           princ_ent = {0};
    xargs_t                     xargs = {0};
    char                        *polname = NULL;
    OPERATION optype;
    krb5_boolean                found_entry = FALSE;

    
    krb5_clear_error_message(context);

    SETUP_CONTEXT();
    if (ldap_context->lrparams == NULL || ldap_context->container_dn == NULL)
        return EINVAL;

    
    GET_HANDLE();

    if (!is_principal_in_realm(ldap_context, entry->princ)) {
        st = EINVAL;
        k5_setmsg(context, st,
                  _(""Principal does not belong to the default realm""));
        goto cleanup;
    }

    
    if (((st=krb5_unparse_name(context, entry->princ, &user)) != 0) ||
        ((st=krb5_ldap_unparse_principal_name(user)) != 0))
        goto cleanup;
    filtuser = ldap_filter_correct(user);
    if (filtuser == NULL) {
        st = ENOMEM;
        goto cleanup;
    }

    
    if (entry->mask & KADM5_PRINCIPAL)
        optype = ADD_PRINCIPAL;
    else
        optype = MODIFY_PRINCIPAL;

    if (((st=krb5_get_princ_type(context, entry, &kerberos_principal_object_type)) != 0) ||
        ((st=krb5_get_userdn(context, entry, &principal_dn)) != 0))
        goto cleanup;

    if ((st=process_db_args(context, db_args, &xargs, optype)) != 0)
        goto cleanup;

    if (entry->mask & KADM5_LOAD) {
        unsigned int     tree = 0;
        int              numlentries = 0;
        char             *filter = NULL;

        
        if (asprintf(&filter, FILTER""%s))"", filtuser) < 0) {
            filter = NULL;
            st = ENOMEM;
            goto cleanup;
        }

        
        if ((st = krb5_get_subtree_info(ldap_context, &subtreelist, &ntrees)) != 0)
            goto cleanup;

        found_entry = FALSE;
        
        for (tree = 0; found_entry == FALSE && tree < ntrees; ++tree) {
            if (principal_dn == NULL) {
                LDAP_SEARCH_1(subtreelist[tree], ldap_context->lrparams->search_scope, filter, principal_attributes, IGNORE_STATUS);
            } else {
                
                LDAP_SEARCH_1(principal_dn, LDAP_SCOPE_BASE, filter, principal_attributes, IGNORE_STATUS);
            }
            if (st == LDAP_SUCCESS) {
                numlentries = ldap_count_entries(ld, result);
                if (numlentries > 1) {
                    free(filter);
                    st = EINVAL;
                    k5_setmsg(context, st,
                              _(""operation can not continue, more than one ""
                                ""entry with principal name \""%s\"" found""),
                              user);
                    goto cleanup;
                } else if (numlentries == 1) {
                    found_entry = TRUE;
                    if (principal_dn == NULL) {
                        ent = ldap_first_entry(ld, result);
                        if (ent != NULL) {
                            
                            if ((principal_dn = ldap_get_dn(ld, ent)) == NULL) {
                                ldap_get_option (ld, LDAP_OPT_RESULT_CODE, &st);
                                st = set_ldap_error (context, st, 0);
                                free(filter);
                                goto cleanup;
                            }
                        }
                    }
                }
            } else if (st != LDAP_NO_SUCH_OBJECT) {
                
                st = set_ldap_error (context, st, 0);
                free(filter);
                goto cleanup;
            }
            ldap_msgfree(result);
            result = NULL;
            
        } 

        free(filter);

        if (found_entry == FALSE && principal_dn != NULL) {
            
            create_standalone = TRUE;
            standalone_principal_dn = strdup(principal_dn);
            CHECK_NULL(standalone_principal_dn);
        }
    } 

    
    if (principal_dn == NULL && xargs.dn == NULL) { 
        
        if (entry->princ->length == 2 && entry->princ->data[0].length == strlen(""krbtgt"") &&
            strncmp(entry->princ->data[0].data, ""krbtgt"", entry->princ->data[0].length) == 0) {
            
            subtree = strdup(ldap_context->lrparams->realmdn);
        } else if (xargs.containerdn) {
            if ((st=checkattributevalue(ld, xargs.containerdn, NULL, NULL, NULL)) != 0) {
                if (st == KRB5_KDB_NOENTRY || st == KRB5_KDB_CONSTRAINT_VIOLATION) {
                    int ost = st;
                    st = EINVAL;
                    k5_wrapmsg(context, ost, st, _(""'%s' not found""),
                               xargs.containerdn);
                }
                goto cleanup;
            }
            subtree = strdup(xargs.containerdn);
        } else if (ldap_context->lrparams->containerref && strlen(ldap_context->lrparams->containerref) != 0) {
            
            subtree = strdup(ldap_context->lrparams->containerref);
        } else {
            subtree = strdup(ldap_context->lrparams->realmdn);
        }
        CHECK_NULL(subtree);

        if (asprintf(&standalone_principal_dn, ""krbprincipalname=%s,%s"",
                     filtuser, subtree) < 0)
            standalone_principal_dn = NULL;
        CHECK_NULL(standalone_principal_dn);
        
        create_standalone = TRUE;
        free(subtree);
        subtree = NULL;
    }

    
     if (xargs.dn_from_kbd == TRUE) {
         
         if (subtreelist == NULL) {
             st = krb5_get_subtree_info(ldap_context, &subtreelist, &ntrees);
             if (st)
                 goto cleanup;
         }
 
        st = validate_xargs(context, ldap_server_handle, &xargs,
                            standalone_principal_dn, subtreelist, ntrees);
        if (st)
             goto cleanup;
     }
 
     if (xargs.linkdn != NULL) {
        
        if (optype == MODIFY_PRINCIPAL &&
            kerberos_principal_object_type != KDB_STANDALONE_PRINCIPAL_OBJECT) {
            st = EINVAL;
            snprintf(errbuf, sizeof(errbuf),
                     _(""link information can not be set/updated as the ""
                       ""kerberos principal belongs to an ldap object""));
            k5_setmsg(context, st, ""%s"", errbuf);
            goto cleanup;
        }
        
        {
            char **linkdns=NULL;
            int  j=0;

            if ((st=krb5_get_linkdn(context, entry, &linkdns)) != 0) {
                snprintf(errbuf, sizeof(errbuf),
                         _(""Failed getting object references""));
                k5_setmsg(context, st, ""%s"", errbuf);
                goto cleanup;
            }
            if (linkdns != NULL) {
                st = EINVAL;
                snprintf(errbuf, sizeof(errbuf),
                         _(""kerberos principal is already linked to a ldap ""
                           ""object""));
                k5_setmsg(context, st, ""%s"", errbuf);
                for (j=0; linkdns[j] != NULL; ++j)
                    free (linkdns[j]);
                free (linkdns);
                goto cleanup;
            }
        }

        establish_links = TRUE;
    }

    if (entry->mask & KADM5_LAST_SUCCESS) {
        memset(strval, 0, sizeof(strval));
        if ((strval[0]=getstringtime(entry->last_success)) == NULL)
            goto cleanup;
        if ((st=krb5_add_str_mem_ldap_mod(&mods, ""krbLastSuccessfulAuth"", LDAP_MOD_REPLACE, strval)) != 0) {
            free (strval[0]);
            goto cleanup;
        }
        free (strval[0]);
    }

    if (entry->mask & KADM5_LAST_FAILED) {
        memset(strval, 0, sizeof(strval));
        if ((strval[0]=getstringtime(entry->last_failed)) == NULL)
            goto cleanup;
        if ((st=krb5_add_str_mem_ldap_mod(&mods, ""krbLastFailedAuth"", LDAP_MOD_REPLACE, strval)) != 0) {
            free (strval[0]);
            goto cleanup;
        }
        free(strval[0]);
    }

    if (entry->mask & KADM5_FAIL_AUTH_COUNT) {
        krb5_kvno fail_auth_count;

        fail_auth_count = entry->fail_auth_count;
        if (entry->mask & KADM5_FAIL_AUTH_COUNT_INCREMENT)
            fail_auth_count++;

        st = krb5_add_int_mem_ldap_mod(&mods, ""krbLoginFailedCount"",
                                       LDAP_MOD_REPLACE,
                                       fail_auth_count);
        if (st != 0)
            goto cleanup;
    } else if (entry->mask & KADM5_FAIL_AUTH_COUNT_INCREMENT) {
        int attr_mask = 0;
        krb5_boolean has_fail_count;

        
        st = krb5_get_attributes_mask(context, entry, &attr_mask);
        if (st != 0)
            goto cleanup;
        has_fail_count = ((attr_mask & KDB_FAIL_AUTH_COUNT_ATTR) != 0);

        
#ifdef LDAP_MOD_INCREMENT
        if (ldap_server_handle->server_info->modify_increment &&
            has_fail_count) {
            st = krb5_add_int_mem_ldap_mod(&mods, ""krbLoginFailedCount"",
                                           LDAP_MOD_INCREMENT, 1);
            if (st != 0)
                goto cleanup;
        } else {
#endif 
            if (has_fail_count) {
                st = krb5_add_int_mem_ldap_mod(&mods,
                                               ""krbLoginFailedCount"",
                                               LDAP_MOD_DELETE,
                                               entry->fail_auth_count);
                if (st != 0)
                    goto cleanup;
            }
            st = krb5_add_int_mem_ldap_mod(&mods, ""krbLoginFailedCount"",
                                           LDAP_MOD_ADD,
                                           entry->fail_auth_count + 1);
            if (st != 0)
                goto cleanup;
#ifdef LDAP_MOD_INCREMENT
        }
#endif
    } else if (optype == ADD_PRINCIPAL) {
        
        st = krb5_add_int_mem_ldap_mod(&mods, ""krbLoginFailedCount"",
                                       LDAP_MOD_ADD, 0);
    }

    if (entry->mask & KADM5_MAX_LIFE) {
        if ((st=krb5_add_int_mem_ldap_mod(&mods, ""krbmaxticketlife"", LDAP_MOD_REPLACE, entry->max_life)) != 0)
            goto cleanup;
    }

    if (entry->mask & KADM5_MAX_RLIFE) {
        if ((st=krb5_add_int_mem_ldap_mod(&mods, ""krbmaxrenewableage"", LDAP_MOD_REPLACE,
                                          entry->max_renewable_life)) != 0)
            goto cleanup;
    }

    if (entry->mask & KADM5_ATTRIBUTES) {
        if ((st=krb5_add_int_mem_ldap_mod(&mods, ""krbticketflags"", LDAP_MOD_REPLACE,
                                          entry->attributes)) != 0)
            goto cleanup;
    }

    if (entry->mask & KADM5_PRINCIPAL) {
        memset(strval, 0, sizeof(strval));
        strval[0] = user;
        if ((st=krb5_add_str_mem_ldap_mod(&mods, ""krbprincipalname"", LDAP_MOD_REPLACE, strval)) != 0)
            goto cleanup;
    }

    if (entry->mask & KADM5_PRINC_EXPIRE_TIME) {
        memset(strval, 0, sizeof(strval));
        if ((strval[0]=getstringtime(entry->expiration)) == NULL)
            goto cleanup;
        if ((st=krb5_add_str_mem_ldap_mod(&mods, ""krbprincipalexpiration"", LDAP_MOD_REPLACE, strval)) != 0) {
            free (strval[0]);
            goto cleanup;
        }
        free (strval[0]);
    }

    if (entry->mask & KADM5_PW_EXPIRATION) {
        memset(strval, 0, sizeof(strval));
        if ((strval[0]=getstringtime(entry->pw_expiration)) == NULL)
            goto cleanup;
        if ((st=krb5_add_str_mem_ldap_mod(&mods, ""krbpasswordexpiration"",
                                          LDAP_MOD_REPLACE,
                                          strval)) != 0) {
            free (strval[0]);
            goto cleanup;
        }
        free (strval[0]);
    }

    if (entry->mask & KADM5_POLICY || entry->mask & KADM5_KEY_HIST) {
        memset(&princ_ent, 0, sizeof(princ_ent));
        for (tl_data=entry->tl_data; tl_data; tl_data=tl_data->tl_data_next) {
            if (tl_data->tl_data_type == KRB5_TL_KADM_DATA) {
                if ((st = krb5_lookup_tl_kadm_data(tl_data, &princ_ent)) != 0) {
                    goto cleanup;
                }
                break;
            }
        }
    }

    if (entry->mask & KADM5_POLICY) {
        if (princ_ent.aux_attributes & KADM5_POLICY) {
            memset(strval, 0, sizeof(strval));
            if ((st = krb5_ldap_name_to_policydn (context, princ_ent.policy, &polname)) != 0)
                goto cleanup;
            strval[0] = polname;
            if ((st=krb5_add_str_mem_ldap_mod(&mods, ""krbpwdpolicyreference"", LDAP_MOD_REPLACE, strval)) != 0)
                goto cleanup;
        } else {
            st = EINVAL;
            k5_setmsg(context, st, ""Password policy value null"");
            goto cleanup;
        }
    } else if (entry->mask & KADM5_LOAD && found_entry == TRUE) {
        

        if ((st=krb5_add_str_mem_ldap_mod(&mods, ""krbpwdpolicyreference"", LDAP_MOD_REPLACE, NULL)) != 0)
            goto cleanup;
    }

    if (entry->mask & KADM5_POLICY_CLR) {
        if ((st=krb5_add_str_mem_ldap_mod(&mods, ""krbpwdpolicyreference"", LDAP_MOD_DELETE, NULL)) != 0)
            goto cleanup;
    }

    if (entry->mask & KADM5_KEY_HIST) {
        bersecretkey = krb5_encode_histkey(&princ_ent);
        if (bersecretkey == NULL) {
            st = ENOMEM;
            goto cleanup;
        }

        st = krb5_add_ber_mem_ldap_mod(&mods, ""krbpwdhistory"",
                                       LDAP_MOD_REPLACE | LDAP_MOD_BVALUES,
                                       bersecretkey);
        if (st != 0)
            goto cleanup;
        free_berdata(bersecretkey);
        bersecretkey = NULL;
    }

    if (entry->mask & KADM5_KEY_DATA || entry->mask & KADM5_KVNO) {
        krb5_kvno mkvno;

        if ((st=krb5_dbe_lookup_mkvno(context, entry, &mkvno)) != 0)
            goto cleanup;
        bersecretkey = krb5_encode_krbsecretkey (entry->key_data,
                                                 entry->n_key_data, mkvno);

        if (bersecretkey == NULL) {
            st = ENOMEM;
            goto cleanup;
        }
        
        if (bersecretkey[0] != NULL || !create_standalone) {
            st = krb5_add_ber_mem_ldap_mod(&mods, ""krbprincipalkey"",
                                           LDAP_MOD_REPLACE | LDAP_MOD_BVALUES,
                                           bersecretkey);
            if (st != 0)
                goto cleanup;
        }

        if (!(entry->mask & KADM5_PRINCIPAL)) {
            memset(strval, 0, sizeof(strval));
            if ((strval[0]=getstringtime(entry->pw_expiration)) == NULL)
                goto cleanup;
            if ((st=krb5_add_str_mem_ldap_mod(&mods,
                                              ""krbpasswordexpiration"",
                                              LDAP_MOD_REPLACE, strval)) != 0) {
                free (strval[0]);
                goto cleanup;
            }
            free (strval[0]);
        }

        
        {
            krb5_timestamp last_pw_changed;
            if ((st=krb5_dbe_lookup_last_pwd_change(context, entry,
                                                    &last_pw_changed)) != 0)
                goto cleanup;

            memset(strval, 0, sizeof(strval));
            if ((strval[0] = getstringtime(last_pw_changed)) == NULL)
                goto cleanup;

            if ((st=krb5_add_str_mem_ldap_mod(&mods, ""krbLastPwdChange"",
                                              LDAP_MOD_REPLACE, strval)) != 0) {
                free (strval[0]);
                goto cleanup;
            }
            free (strval[0]);
        }

    } 

    
    st = update_ldap_mod_auth_ind(context, entry, &mods);
    if (st != 0)
        goto cleanup;

    
    if (entry->tl_data != NULL) {
        int count = 0;
        struct berval **ber_tl_data = NULL;
        krb5_tl_data *ptr;
        krb5_timestamp unlock_time;
        for (ptr = entry->tl_data; ptr != NULL; ptr = ptr->tl_data_next) {
            if (ptr->tl_data_type == KRB5_TL_LAST_PWD_CHANGE
#ifdef SECURID
                || ptr->tl_data_type == KRB5_TL_DB_ARGS
#endif
                || ptr->tl_data_type == KRB5_TL_KADM_DATA
                || ptr->tl_data_type == KDB_TL_USER_INFO
                || ptr->tl_data_type == KRB5_TL_CONSTRAINED_DELEGATION_ACL
                || ptr->tl_data_type == KRB5_TL_LAST_ADMIN_UNLOCK)
                continue;
            count++;
        }
        if (count != 0) {
            int j;
            ber_tl_data = (struct berval **) calloc (count + 1,
                                                     sizeof (struct berval*));
            if (ber_tl_data == NULL) {
                st = ENOMEM;
                goto cleanup;
            }
            for (j = 0, ptr = entry->tl_data; ptr != NULL; ptr = ptr->tl_data_next) {
                
                if (ptr->tl_data_type == KRB5_TL_LAST_PWD_CHANGE
#ifdef SECURID
                    || ptr->tl_data_type == KRB5_TL_DB_ARGS
#endif
                    || ptr->tl_data_type == KRB5_TL_KADM_DATA
                    || ptr->tl_data_type == KDB_TL_USER_INFO
                    || ptr->tl_data_type == KRB5_TL_CONSTRAINED_DELEGATION_ACL
                    || ptr->tl_data_type == KRB5_TL_LAST_ADMIN_UNLOCK)
                    continue;
                if ((st = tl_data2berval (ptr, &ber_tl_data[j])) != 0)
                    break;
                j++;
            }
            if (st == 0) {
                ber_tl_data[count] = NULL;
                st=krb5_add_ber_mem_ldap_mod(&mods, ""krbExtraData"",
                                             LDAP_MOD_REPLACE |
                                             LDAP_MOD_BVALUES, ber_tl_data);
            }
            free_berdata(ber_tl_data);
            if (st != 0)
                goto cleanup;
        }
        if ((st=krb5_dbe_lookup_last_admin_unlock(context, entry,
                                                  &unlock_time)) != 0)
            goto cleanup;
        if (unlock_time != 0) {
            
            memset(strval, 0, sizeof(strval));
            if ((strval[0] = getstringtime(unlock_time)) == NULL)
                goto cleanup;

            if ((st=krb5_add_str_mem_ldap_mod(&mods, ""krbLastAdminUnlock"",
                                              LDAP_MOD_REPLACE, strval)) != 0) {
                free (strval[0]);
                goto cleanup;
            }
            free (strval[0]);
        }
    }

    
    if (xargs.tktpolicydn != NULL) {
        int tmask=0;

        if (strlen(xargs.tktpolicydn) != 0) {
            st = checkattributevalue(ld, xargs.tktpolicydn, ""objectclass"", policyclass, &tmask);
            CHECK_CLASS_VALIDITY(st, tmask, _(""ticket policy object value: ""));

            strval[0] = xargs.tktpolicydn;
            strval[1] = NULL;
            if ((st=krb5_add_str_mem_ldap_mod(&mods, ""krbticketpolicyreference"", LDAP_MOD_REPLACE, strval)) != 0)
                goto cleanup;

        } else {
            
            if ((st=krb5_add_str_mem_ldap_mod(&mods, ""krbticketpolicyreference"", LDAP_MOD_DELETE, NULL)) != 0)
                goto cleanup;
        }

    }

    if (establish_links == TRUE) {
        memset(strval, 0, sizeof(strval));
        strval[0] = xargs.linkdn;
        if ((st=krb5_add_str_mem_ldap_mod(&mods, ""krbObjectReferences"", LDAP_MOD_REPLACE, strval)) != 0)
            goto cleanup;
    }

    
    if (mods == NULL)
        goto cleanup;

    if (create_standalone == TRUE) {
        memset(strval, 0, sizeof(strval));
        strval[0] = ""krbprincipal"";
        strval[1] = ""krbprincipalaux"";
        strval[2] = ""krbTicketPolicyAux"";

        if ((st=krb5_add_str_mem_ldap_mod(&mods, ""objectclass"", LDAP_MOD_ADD, strval)) != 0)
            goto cleanup;

        st = ldap_add_ext_s(ld, standalone_principal_dn, mods, NULL, NULL);
        if (st == LDAP_ALREADY_EXISTS && entry->mask & KADM5_LOAD) {
            
            st = ldap_delete_ext_s(ld, standalone_principal_dn, NULL, NULL);
            if (st != LDAP_SUCCESS) {
                snprintf(errbuf, sizeof(errbuf),
                         _(""Principal delete failed (trying to replace ""
                           ""entry): %s""), ldap_err2string(st));
                st = translate_ldap_error (st, OP_ADD);
                k5_setmsg(context, st, ""%s"", errbuf);
                goto cleanup;
            } else {
                st = ldap_add_ext_s(ld, standalone_principal_dn, mods, NULL, NULL);
            }
        }
        if (st != LDAP_SUCCESS) {
            snprintf(errbuf, sizeof(errbuf), _(""Principal add failed: %s""),
                     ldap_err2string(st));
            st = translate_ldap_error (st, OP_ADD);
            k5_setmsg(context, st, ""%s"", errbuf);
            goto cleanup;
        }
    } else {
        
        {
            char *attrvalues[] = {""krbprincipalaux"", ""krbTicketPolicyAux"", NULL};
            int p, q, r=0, amask=0;

            if ((st=checkattributevalue(ld, (xargs.dn) ? xargs.dn : principal_dn,
                                        ""objectclass"", attrvalues, &amask)) != 0)
                goto cleanup;

            memset(strval, 0, sizeof(strval));
            for (p=1, q=0; p<=2; p<<=1, ++q) {
                if ((p & amask) == 0)
                    strval[r++] = attrvalues[q];
            }
            if (r != 0) {
                if ((st=krb5_add_str_mem_ldap_mod(&mods, ""objectclass"", LDAP_MOD_ADD, strval)) != 0)
                    goto cleanup;
            }
        }
        if (xargs.dn != NULL)
            st=ldap_modify_ext_s(ld, xargs.dn, mods, NULL, NULL);
        else
            st = ldap_modify_ext_s(ld, principal_dn, mods, NULL, NULL);

        if (st != LDAP_SUCCESS) {
            snprintf(errbuf, sizeof(errbuf), _(""User modification failed: %s""),
                     ldap_err2string(st));
            st = translate_ldap_error (st, OP_MOD);
            k5_setmsg(context, st, ""%s"", errbuf);
            goto cleanup;
        }

        if (entry->mask & KADM5_FAIL_AUTH_COUNT_INCREMENT)
            entry->fail_auth_count++;
    }

cleanup:
    if (user)
        free(user);

    if (filtuser)
        free(filtuser);

    free_xargs(xargs);

    if (standalone_principal_dn)
        free(standalone_principal_dn);

    if (principal_dn)
        free (principal_dn);

    if (polname != NULL)
        free(polname);

    for (tre = 0; tre < ntrees; tre++)
        free(subtreelist[tre]);
    free(subtreelist);

    if (subtree)
        free (subtree);

    if (bersecretkey) {
        for (l=0; bersecretkey[l]; ++l) {
            if (bersecretkey[l]->bv_val)
                free (bersecretkey[l]->bv_val);
            free (bersecretkey[l]);
        }
        free (bersecretkey);
    }

    if (keys)
        free (keys);

    ldap_mods_free(mods, 1);
    ldap_osa_free_princ_ent(&princ_ent);
    ldap_msgfree(result);
    krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);
    return(st);
}
","1. int                         l=0, kerberos_principal_object_type=0;
2. char                        *filtuser=NULL;
3. kdb5_dal_handle             *dal_handle=NULL;
4. char                        *polname = NULL;
5. goto cleanup;
6. optype = ADD_PRINCIPAL;
7. if (asprintf(&filter, FILTER""%s))"", filtuser) < 0) {
8. LDAP_SEARCH_1(subtreelist[tree], ldap_context->lrparams->search_scope, filter, principal_attributes, IGNORE_STATUS);
9. numlentries = ldap_count_entries(ld, result);
10. st = EINVAL;
11. goto cleanup;
12. if (ent != NULL) {
13. st = set_ldap_error (context, st, 0);
14. if (st == KRB5_KDB_NOENTRY || st == KRB5_KDB_CONSTRAINT_VIOLATION) {
15. filtuser, subtree) < 0)
16. free(subtree);
17. st = EINVAL;
snprintf(errbuf, sizeof(errbuf),
18. k5_setmsg(context, st, ""%s"", errbuf);
19. if (entry->mask & KADM5_LAST_SUCCESS) {
20. if ((strval[0]=getstringtime(entry->last_success)) == NULL)
21. goto cleanup;
22. goto cleanup;
23. int attr_mask = 0;
24. goto cleanup;
25. LDAP_MOD_DELETE,
26. if (st != 0)
27. st = krb5_add_int_mem_ldap_mod(&mods, ""krbLoginFailedCount"",
28. } else if (optype == ADD_PRINCIPAL) {
29. goto cleanup;
30. if (entry->mask & KADM5_PRINCIPAL) {
31. if ((strval[0]=getstringtime(entry->pw_expiration)) == NULL)
32. strval[0] = polname;
33. goto cleanup;
34. if ((st=krb5_add_str_mem_ldap_mod(&mods, ""krbpwdpolicyreference"", LDAP_MOD_DELETE, NULL)) != 0)
35. goto cleanup;
36. goto cleanup;
bersecretkey = krb5_encode_krbsecretkey (entry->key_data,
37. free (strval[0]);
38. free (strval[0]);
39. free (strval[0]);
40. if (entry->tl_data != NULL) {
int count = 0;
41. continue;
42. if (ptr->tl_data_type == KRB5_TL_LAST_PWD_CHANGE
43. || ptr->tl_data_type == KRB5_TL_KADM_DATA
44. if ((st = tl_data2berval (ptr, &ber_tl_data[j])) != 0)
45. st=krb5_add_ber_mem_ldap_mod(&mods, ""krbExtraData"",
LDAP_MOD_REPLACE |
46. free_berdata(ber_tl_data);
47. goto cleanup;
48. goto cleanup;
if (unlock_time != 0) {
49. if ((strval[0] = getstringtime(unlock_time)) == NULL)
50. if ((st=krb5_add_str_mem_ldap_mod(&mods, ""krbLastAdminUnlock"",
51. if (xargs.tktpolicydn != NULL) {
52. strval[1] = NULL;
53. goto cleanup;
54. if (mods == NULL)
55. if (create_standalone == TRUE) {
56. strval[2] = ""krbTicketPolicyAux"";
57. goto cleanup;
58. st = translate_ldap_error (st, OP_ADD);
59. if (st != LDAP_SUCCESS) {
60. for (p=1, q=0; p<=2; p<<=1, ++q) {
61. goto cleanup;
62. free (subtree);","4
12
20
25
43
62
85
99
105
108
113
118
122
170
191
199
235-236
253
272
274
286
289
307
314
335
337
340
348
369
372
392
420
422
439
454
463-464
491
507
510
522-523
536
550
554
559
565-566
569
571
575-576
579
582
592
600
608
627
630
634
637
647
654
678
684
727","CWE-362,CWE-1284,CWE-20,CWE-19"
php_zip_get_from,"static void php_zip_get_from(INTERNAL_FUNCTION_PARAMETERS, int type) 
{
	struct zip *intern;
	zval *self = getThis();

	struct zip_stat sb;
	struct zip_file *zf;

	zend_long index = -1;
	zend_long flags = 0;
	zend_long len = 0;

	zend_string *filename;
	zend_string *buffer;

	int n = 0;

	if (!self) {
		RETURN_FALSE;
	}

	ZIP_FROM_OBJECT(intern, self);

	if (type == 1) {
		if (zend_parse_parameters(ZEND_NUM_ARGS(), ""P|ll"", &filename, &len, &flags) == FAILURE) {
			return;
		}
		PHP_ZIP_STAT_PATH(intern, ZSTR_VAL(filename), ZSTR_LEN(filename), flags, sb);
	} else {
		if (zend_parse_parameters(ZEND_NUM_ARGS(), ""l|ll"", &index, &len, &flags) == FAILURE) {
			return;
		}
		PHP_ZIP_STAT_INDEX(intern, index, 0, sb);
	}

	if (sb.size < 1) {
		RETURN_EMPTY_STRING();
	}

	if (len < 1) {
		len = sb.size;
	}
	if (index >= 0) {
		zf = zip_fopen_index(intern, index, flags);
	} else {
		zf = zip_fopen(intern, ZSTR_VAL(filename), flags);
	}

	if (zf == NULL) {
 		RETURN_FALSE;
 	}
 
	buffer = zend_string_safe_alloc(1, len, 0, 0);
 	n = zip_fread(zf, ZSTR_VAL(buffer), ZSTR_LEN(buffer));
 	if (n < 1) {
 		zend_string_free(buffer);
		RETURN_EMPTY_STRING();
	}

	zip_fclose(zf);
	ZSTR_VAL(buffer)[n] = '\0';
	ZSTR_LEN(buffer) = n;
	RETURN_NEW_STR(buffer);
}

","1. struct zip *intern;
2. zend_long flags = 0;
zend_long len = 0;
3. if (type == 1) {
4. if (sb.size < 1) {
5. zf = zip_fopen_index(intern, index, flags);
} else {
zf = zip_fopen(intern, ZSTR_VAL(filename), flags);
6. if (zf == NULL) {
7. n = zip_fread(zf, ZSTR_VAL(buffer), ZSTR_LEN(buffer));
8. zip_fclose(zf);","3
10-11
24
36
44-46
49
54
60","CWE-134,CWE-59,CWE-399,CWE-119"
show_object-62075068869299,"static void show_object(struct object *obj, const char *name, void *data)
{
	add_preferred_base_object(name);
	add_object_entry(obj->oid.hash, obj->type, name, 0);
	obj->flags |= OBJECT_ADDED;
}
","1. static void show_object(struct object *obj, const char *name, void *data)
2. add_preferred_base_object(name);
add_object_entry(obj->oid.hash, obj->type, name, 0);
obj->flags |= OBJECT_ADDED;","1
3-5","CWE-416,CWE-264,CWE-119"
create_qp_common-66860776677113,"static int create_qp_common(struct mlx5_ib_dev *dev, struct ib_pd *pd,
			    struct ib_qp_init_attr *init_attr,
			    struct ib_udata *udata, struct mlx5_ib_qp *qp)
{
	struct mlx5_ib_resources *devr = &dev->devr;
	int inlen = MLX5_ST_SZ_BYTES(create_qp_in);
	struct mlx5_core_dev *mdev = dev->mdev;
	struct mlx5_ib_create_qp_resp resp = {};
	struct mlx5_ib_cq *send_cq;
	struct mlx5_ib_cq *recv_cq;
	unsigned long flags;
	u32 uidx = MLX5_IB_DEFAULT_UIDX;
	struct mlx5_ib_create_qp ucmd;
	struct mlx5_ib_qp_base *base;
	int mlx5_st;
	void *qpc;
	u32 *in;
	int err;

	mutex_init(&qp->mutex);
	spin_lock_init(&qp->sq.lock);
	spin_lock_init(&qp->rq.lock);

	mlx5_st = to_mlx5_st(init_attr->qp_type);
	if (mlx5_st < 0)
		return -EINVAL;

	if (init_attr->rwq_ind_tbl) {
		if (!udata)
			return -ENOSYS;

		err = create_rss_raw_qp_tir(dev, qp, pd, init_attr, udata);
		return err;
	}

	if (init_attr->create_flags & IB_QP_CREATE_BLOCK_MULTICAST_LOOPBACK) {
		if (!MLX5_CAP_GEN(mdev, block_lb_mc)) {
			mlx5_ib_dbg(dev, ""block multicast loopback isn't supported\n"");
			return -EINVAL;
		} else {
			qp->flags |= MLX5_IB_QP_BLOCK_MULTICAST_LOOPBACK;
		}
	}

	if (init_attr->create_flags &
			(IB_QP_CREATE_CROSS_CHANNEL |
			 IB_QP_CREATE_MANAGED_SEND |
			 IB_QP_CREATE_MANAGED_RECV)) {
		if (!MLX5_CAP_GEN(mdev, cd)) {
			mlx5_ib_dbg(dev, ""cross-channel isn't supported\n"");
			return -EINVAL;
		}
		if (init_attr->create_flags & IB_QP_CREATE_CROSS_CHANNEL)
			qp->flags |= MLX5_IB_QP_CROSS_CHANNEL;
		if (init_attr->create_flags & IB_QP_CREATE_MANAGED_SEND)
			qp->flags |= MLX5_IB_QP_MANAGED_SEND;
		if (init_attr->create_flags & IB_QP_CREATE_MANAGED_RECV)
			qp->flags |= MLX5_IB_QP_MANAGED_RECV;
	}

	if (init_attr->qp_type == IB_QPT_UD &&
	    (init_attr->create_flags & IB_QP_CREATE_IPOIB_UD_LSO))
		if (!MLX5_CAP_GEN(mdev, ipoib_basic_offloads)) {
			mlx5_ib_dbg(dev, ""ipoib UD lso qp isn't supported\n"");
			return -EOPNOTSUPP;
		}

	if (init_attr->create_flags & IB_QP_CREATE_SCATTER_FCS) {
		if (init_attr->qp_type != IB_QPT_RAW_PACKET) {
			mlx5_ib_dbg(dev, ""Scatter FCS is supported only for Raw Packet QPs"");
			return -EOPNOTSUPP;
		}
		if (!MLX5_CAP_GEN(dev->mdev, eth_net_offloads) ||
		    !MLX5_CAP_ETH(dev->mdev, scatter_fcs)) {
			mlx5_ib_dbg(dev, ""Scatter FCS isn't supported\n"");
			return -EOPNOTSUPP;
		}
		qp->flags |= MLX5_IB_QP_CAP_SCATTER_FCS;
	}

	if (init_attr->sq_sig_type == IB_SIGNAL_ALL_WR)
		qp->sq_signal_bits = MLX5_WQE_CTRL_CQ_UPDATE;

	if (init_attr->create_flags & IB_QP_CREATE_CVLAN_STRIPPING) {
		if (!(MLX5_CAP_GEN(dev->mdev, eth_net_offloads) &&
		      MLX5_CAP_ETH(dev->mdev, vlan_cap)) ||
		    (init_attr->qp_type != IB_QPT_RAW_PACKET))
			return -EOPNOTSUPP;
		qp->flags |= MLX5_IB_QP_CVLAN_STRIPPING;
	}

	if (pd && pd->uobject) {
		if (ib_copy_from_udata(&ucmd, udata, sizeof(ucmd))) {
			mlx5_ib_dbg(dev, ""copy failed\n"");
			return -EFAULT;
		}

		err = get_qp_user_index(to_mucontext(pd->uobject->context),
					&ucmd, udata->inlen, &uidx);
		if (err)
			return err;

		qp->wq_sig = !!(ucmd.flags & MLX5_QP_FLAG_SIGNATURE);
		qp->scat_cqe = !!(ucmd.flags & MLX5_QP_FLAG_SCATTER_CQE);
		if (ucmd.flags & MLX5_QP_FLAG_TUNNEL_OFFLOADS) {
			if (init_attr->qp_type != IB_QPT_RAW_PACKET ||
			    !tunnel_offload_supported(mdev)) {
				mlx5_ib_dbg(dev, ""Tunnel offload isn't supported\n"");
				return -EOPNOTSUPP;
			}
			qp->tunnel_offload_en = true;
		}

		if (init_attr->create_flags & IB_QP_CREATE_SOURCE_QPN) {
			if (init_attr->qp_type != IB_QPT_UD ||
			    (MLX5_CAP_GEN(dev->mdev, port_type) !=
			     MLX5_CAP_PORT_TYPE_IB) ||
			    !mlx5_get_flow_namespace(dev->mdev, MLX5_FLOW_NAMESPACE_BYPASS)) {
				mlx5_ib_dbg(dev, ""Source QP option isn't supported\n"");
				return -EOPNOTSUPP;
			}

			qp->flags |= MLX5_IB_QP_UNDERLAY;
			qp->underlay_qpn = init_attr->source_qpn;
		}
	} else {
		qp->wq_sig = !!wq_signature;
	}

	base = (init_attr->qp_type == IB_QPT_RAW_PACKET ||
		qp->flags & MLX5_IB_QP_UNDERLAY) ?
	       &qp->raw_packet_qp.rq.base :
	       &qp->trans_qp.base;

	qp->has_rq = qp_has_rq(init_attr);
	err = set_rq_size(dev, &init_attr->cap, qp->has_rq,
			  qp, (pd && pd->uobject) ? &ucmd : NULL);
	if (err) {
		mlx5_ib_dbg(dev, ""err %d\n"", err);
		return err;
	}

	if (pd) {
		if (pd->uobject) {
			__u32 max_wqes =
				1 << MLX5_CAP_GEN(mdev, log_max_qp_sz);
			mlx5_ib_dbg(dev, ""requested sq_wqe_count (%d)\n"", ucmd.sq_wqe_count);
			if (ucmd.rq_wqe_shift != qp->rq.wqe_shift ||
			    ucmd.rq_wqe_count != qp->rq.wqe_cnt) {
				mlx5_ib_dbg(dev, ""invalid rq params\n"");
				return -EINVAL;
			}
			if (ucmd.sq_wqe_count > max_wqes) {
				mlx5_ib_dbg(dev, ""requested sq_wqe_count (%d) > max allowed (%d)\n"",
					    ucmd.sq_wqe_count, max_wqes);
				return -EINVAL;
			}
			if (init_attr->create_flags &
			    mlx5_ib_create_qp_sqpn_qp1()) {
				mlx5_ib_dbg(dev, ""user-space is not allowed to create UD QPs spoofing as QP1\n"");
				return -EINVAL;
			}
			err = create_user_qp(dev, pd, qp, udata, init_attr, &in,
					     &resp, &inlen, base);
			if (err)
				mlx5_ib_dbg(dev, ""err %d\n"", err);
		} else {
			err = create_kernel_qp(dev, init_attr, qp, &in, &inlen,
					       base);
			if (err)
				mlx5_ib_dbg(dev, ""err %d\n"", err);
		}

		if (err)
			return err;
	} else {
		in = kvzalloc(inlen, GFP_KERNEL);
		if (!in)
			return -ENOMEM;

		qp->create_type = MLX5_QP_EMPTY;
	}

	if (is_sqp(init_attr->qp_type))
		qp->port = init_attr->port_num;

	qpc = MLX5_ADDR_OF(create_qp_in, in, qpc);

	MLX5_SET(qpc, qpc, st, mlx5_st);
	MLX5_SET(qpc, qpc, pm_state, MLX5_QP_PM_MIGRATED);

	if (init_attr->qp_type != MLX5_IB_QPT_REG_UMR)
		MLX5_SET(qpc, qpc, pd, to_mpd(pd ? pd : devr->p0)->pdn);
	else
		MLX5_SET(qpc, qpc, latency_sensitive, 1);


	if (qp->wq_sig)
		MLX5_SET(qpc, qpc, wq_signature, 1);

	if (qp->flags & MLX5_IB_QP_BLOCK_MULTICAST_LOOPBACK)
		MLX5_SET(qpc, qpc, block_lb_mc, 1);

	if (qp->flags & MLX5_IB_QP_CROSS_CHANNEL)
		MLX5_SET(qpc, qpc, cd_master, 1);
	if (qp->flags & MLX5_IB_QP_MANAGED_SEND)
		MLX5_SET(qpc, qpc, cd_slave_send, 1);
	if (qp->flags & MLX5_IB_QP_MANAGED_RECV)
		MLX5_SET(qpc, qpc, cd_slave_receive, 1);

	if (qp->scat_cqe && is_connected(init_attr->qp_type)) {
		int rcqe_sz;
		int scqe_sz;

		rcqe_sz = mlx5_ib_get_cqe_size(dev, init_attr->recv_cq);
		scqe_sz = mlx5_ib_get_cqe_size(dev, init_attr->send_cq);

		if (rcqe_sz == 128)
			MLX5_SET(qpc, qpc, cs_res, MLX5_RES_SCAT_DATA64_CQE);
		else
			MLX5_SET(qpc, qpc, cs_res, MLX5_RES_SCAT_DATA32_CQE);

		if (init_attr->sq_sig_type == IB_SIGNAL_ALL_WR) {
			if (scqe_sz == 128)
				MLX5_SET(qpc, qpc, cs_req, MLX5_REQ_SCAT_DATA64_CQE);
			else
				MLX5_SET(qpc, qpc, cs_req, MLX5_REQ_SCAT_DATA32_CQE);
		}
	}

	if (qp->rq.wqe_cnt) {
		MLX5_SET(qpc, qpc, log_rq_stride, qp->rq.wqe_shift - 4);
		MLX5_SET(qpc, qpc, log_rq_size, ilog2(qp->rq.wqe_cnt));
	}

	MLX5_SET(qpc, qpc, rq_type, get_rx_type(qp, init_attr));

	if (qp->sq.wqe_cnt) {
		MLX5_SET(qpc, qpc, log_sq_size, ilog2(qp->sq.wqe_cnt));
	} else {
		MLX5_SET(qpc, qpc, no_sq, 1);
		if (init_attr->srq &&
		    init_attr->srq->srq_type == IB_SRQT_TM)
			MLX5_SET(qpc, qpc, offload_type,
				 MLX5_QPC_OFFLOAD_TYPE_RNDV);
	}

	
	switch (init_attr->qp_type) {
	case IB_QPT_XRC_TGT:
		MLX5_SET(qpc, qpc, cqn_rcv, to_mcq(devr->c0)->mcq.cqn);
		MLX5_SET(qpc, qpc, cqn_snd, to_mcq(devr->c0)->mcq.cqn);
		MLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(devr->s0)->msrq.srqn);
		MLX5_SET(qpc, qpc, xrcd, to_mxrcd(init_attr->xrcd)->xrcdn);
		break;
	case IB_QPT_XRC_INI:
		MLX5_SET(qpc, qpc, cqn_rcv, to_mcq(devr->c0)->mcq.cqn);
		MLX5_SET(qpc, qpc, xrcd, to_mxrcd(devr->x1)->xrcdn);
		MLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(devr->s0)->msrq.srqn);
		break;
	default:
		if (init_attr->srq) {
			MLX5_SET(qpc, qpc, xrcd, to_mxrcd(devr->x0)->xrcdn);
			MLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(init_attr->srq)->msrq.srqn);
		} else {
			MLX5_SET(qpc, qpc, xrcd, to_mxrcd(devr->x1)->xrcdn);
			MLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(devr->s1)->msrq.srqn);
		}
	}

	if (init_attr->send_cq)
		MLX5_SET(qpc, qpc, cqn_snd, to_mcq(init_attr->send_cq)->mcq.cqn);

	if (init_attr->recv_cq)
		MLX5_SET(qpc, qpc, cqn_rcv, to_mcq(init_attr->recv_cq)->mcq.cqn);

	MLX5_SET64(qpc, qpc, dbr_addr, qp->db.dma);

	
	if (MLX5_CAP_GEN(mdev, cqe_version) == MLX5_CQE_VERSION_V1)
		MLX5_SET(qpc, qpc, user_index, uidx);

	
	if (init_attr->qp_type == IB_QPT_UD &&
	    (init_attr->create_flags & IB_QP_CREATE_IPOIB_UD_LSO)) {
		MLX5_SET(qpc, qpc, ulp_stateless_offload_mode, 1);
		qp->flags |= MLX5_IB_QP_LSO;
	}

	if (init_attr->create_flags & IB_QP_CREATE_PCI_WRITE_END_PADDING) {
		if (!MLX5_CAP_GEN(dev->mdev, end_pad)) {
			mlx5_ib_dbg(dev, ""scatter end padding is not supported\n"");
			err = -EOPNOTSUPP;
			goto err;
		} else if (init_attr->qp_type != IB_QPT_RAW_PACKET) {
			MLX5_SET(qpc, qpc, end_padding_mode,
				 MLX5_WQ_END_PAD_MODE_ALIGN);
		} else {
			qp->flags |= MLX5_IB_QP_PCI_WRITE_END_PADDING;
		}
	}

	if (inlen < 0) {
		err = -EINVAL;
		goto err;
	}

	if (init_attr->qp_type == IB_QPT_RAW_PACKET ||
	    qp->flags & MLX5_IB_QP_UNDERLAY) {
		qp->raw_packet_qp.sq.ubuffer.buf_addr = ucmd.sq_buf_addr;
		raw_packet_qp_copy_info(qp, &qp->raw_packet_qp);
		err = create_raw_packet_qp(dev, qp, in, inlen, pd);
	} else {
		err = mlx5_core_create_qp(dev->mdev, &base->mqp, in, inlen);
	}

	if (err) {
		mlx5_ib_dbg(dev, ""create qp failed\n"");
		goto err_create;
	}

	kvfree(in);

	base->container_mibqp = qp;
	base->mqp.event = mlx5_ib_qp_event;

	get_cqs(init_attr->qp_type, init_attr->send_cq, init_attr->recv_cq,
		&send_cq, &recv_cq);
	spin_lock_irqsave(&dev->reset_flow_resource_lock, flags);
	mlx5_ib_lock_cqs(send_cq, recv_cq);
	
	list_add_tail(&qp->qps_list, &dev->qp_list);
	
	if (send_cq)
		list_add_tail(&qp->cq_send_list, &send_cq->list_send_qp);
	if (recv_cq)
		list_add_tail(&qp->cq_recv_list, &recv_cq->list_recv_qp);
	mlx5_ib_unlock_cqs(send_cq, recv_cq);
	spin_unlock_irqrestore(&dev->reset_flow_resource_lock, flags);

	return 0;

err_create:
	if (qp->create_type == MLX5_QP_USER)
		destroy_qp_user(dev, pd, qp, base);
	else if (qp->create_type == MLX5_QP_KERNEL)
		destroy_qp_kernel(dev, qp);

err:
	kvfree(in);
	return err;
}
","1. static int create_qp_common(struct mlx5_ib_dev *dev, struct ib_pd *pd,
2. struct mlx5_ib_resources *devr = &dev->devr;
3. unsigned long flags;
4. qp->flags |= MLX5_IB_QP_CROSS_CHANNEL;
5. qp->flags |= MLX5_IB_QP_MANAGED_SEND;
6. if (!MLX5_CAP_GEN(mdev, ipoib_basic_offloads)) {
mlx5_ib_dbg(dev, ""ipoib UD lso qp isn't supported\n"");
return -EOPNOTSUPP;
7. if (init_attr->create_flags & IB_QP_CREATE_CVLAN_STRIPPING) {
8. mlx5_ib_dbg(dev, ""copy failed\n"");
9. if (err)
return err;
10. qp->wq_sig = !!(ucmd.flags & MLX5_QP_FLAG_SIGNATURE);
11. if (init_attr->create_flags & IB_QP_CREATE_SOURCE_QPN) {
12. base = (init_attr->qp_type == IB_QPT_RAW_PACKET ||
qp->flags & MLX5_IB_QP_UNDERLAY) ?
13. qp->has_rq = qp_has_rq(init_attr);
14. if (pd->uobject) {
15. mlx5_ib_dbg(dev, ""invalid rq params\n"");
16. mlx5_ib_dbg(dev, ""err %d\n"", err);
17. qp->create_type = MLX5_QP_EMPTY;
18. MLX5_SET(qpc, qpc, cd_master, 1);
if (qp->flags & MLX5_IB_QP_MANAGED_SEND)
19. if (qp->scat_cqe && is_connected(init_attr->qp_type)) {
20. MLX5_SET(qpc, qpc, rq_type, get_rx_type(qp, init_attr));
21. MLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(devr->s0)->msrq.srqn);
22. if (init_attr->qp_type == IB_QPT_UD &&
23. mlx5_ib_dbg(dev, ""scatter end padding is not supported\n"");
24. } else {
25. goto err;
26. err = mlx5_core_create_qp(dev->mdev, &base->mqp, in, inlen);
27. mlx5_ib_dbg(dev, ""create qp failed\n"");
28. base->container_mibqp = qp;
29. list_add_tail(&qp->qps_list, &dev->qp_list);
30. list_add_tail(&qp->cq_recv_list, &recv_cq->list_recv_qp);
31. destroy_qp_kernel(dev, qp);","1
5
11
54
56
63-65
84
94
100-101
103
114
130-131
135
144
150
171
181
205-206
211
236
259
284
292
298
305
314
318
324
334
340
350","CWE-189,CWE-17,CWE-399,CWE-400"
jpc_bitstream_getbits-93391484769833,"long jpc_bitstream_getbits(jpc_bitstream_t *bitstream, int n)
{
	long v;
	int u;

	
	
	if (n < 0 || n >= 32) {
		return -1;
	}

	
	v = 0;
	while (--n >= 0) {
		if ((u = jpc_bitstream_getbit(bitstream)) < 0) {
			return -1;
		}
		v = (v << 1) | u;
	}
	return v;
}
","1. long jpc_bitstream_getbits(jpc_bitstream_t *bitstream, int n)
2. long v;
3. return -1;
4. while (--n >= 0) {
if ((u = jpc_bitstream_getbit(bitstream)) < 0) {
return -1;
5. return v;","1
3
10
15-17
21","CWE-190,CWE-264,CWE-125,CWE-119"
ReadDDSImage_1,"
#define ExceptionInfo
#define ImageInfo

static Image *ReadDDSImage_1(const ImageInfo *image_info,ExceptionInfo *exception)
{
  Image
    *image;

  MagickBooleanType
    status,
    cubemap = MagickFalse,
    volume = MagickFalse,
    matte;

  CompressionType
    compression;

  DDSInfo
    dds_info;

  DDSDecoder
    *decoder;

  size_t
    n,
    num_images;

  
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickSignature);
  image=AcquireImage(image_info);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }

  
  if (ReadDDSInfo(image, &dds_info) != MagickTrue) {
    ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
  }

  if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP)
    cubemap = MagickTrue;

  if (dds_info.ddscaps2 & DDSCAPS2_VOLUME && dds_info.depth > 0)
    volume = MagickTrue;

  (void) SeekBlob(image, 128, SEEK_SET);

  
  if (dds_info.pixelformat.flags & DDPF_RGB)
    {
      compression = NoCompression;
      if (dds_info.pixelformat.flags & DDPF_ALPHAPIXELS)
        {
          matte = MagickTrue;
          decoder = ReadUncompressedRGBA;
        }
      else
        {
          matte = MagickTrue;
          decoder = ReadUncompressedRGB;
        }
    }
  else if (dds_info.pixelformat.flags & DDPF_LUMINANCE)
   {
      compression = NoCompression;
      if (dds_info.pixelformat.flags & DDPF_ALPHAPIXELS)
        {
          
          ThrowReaderException(CorruptImageError, ""ImageTypeNotSupported"");
        }
      else
        {
          matte = MagickFalse;
          decoder = ReadUncompressedRGB;
        }
    }
  else if (dds_info.pixelformat.flags & DDPF_FOURCC)
    {
      switch (dds_info.pixelformat.fourcc)
      {
        case FOURCC_DXT1:
        {
          matte = MagickFalse;
          compression = DXT1Compression;
          decoder = ReadDXT1;
          break;
        }
        case FOURCC_DXT3:
        {
          matte = MagickTrue;
          compression = DXT3Compression;
          decoder = ReadDXT3;
          break;
        }
        case FOURCC_DXT5:
        {
          matte = MagickTrue;
          compression = DXT5Compression;
          decoder = ReadDXT5;
          break;
        }
        default:
        {
          
          ThrowReaderException(CorruptImageError, ""ImageTypeNotSupported"");
        }
      }
    }
  else
    {
      
      ThrowReaderException(CorruptImageError, ""ImageTypeNotSupported"");
    }

  num_images = 1;
  if (cubemap)
    {
      
      num_images = 0;
      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEX) num_images++;
      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEX) num_images++;
      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEY) num_images++;
      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEY) num_images++;
      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEZ) num_images++;
      if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ) num_images++;
    }

  if (volume)
    num_images = dds_info.depth;

  for (n = 0; n < num_images; n++)
   {
     if (n != 0)
       {
        if (EOFBlob(image) != MagickFalse)
          ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
         
         AcquireNextImage(image_info,image);
         if (GetNextImageInList(image) == (Image *) NULL)
          return(DestroyImageList(image));
        image=SyncNextImageInList(image);
      }
 
    image->matte = matte;
    image->compression = compression;
    image->columns = dds_info.width;
    image->rows = dds_info.height;
    image->storage_class = DirectClass;
    image->endian = LSBEndian;
    image->depth = 8;
    if (image_info->ping != MagickFalse)
      {
        (void) CloseBlob(image);
        return(GetFirstImageInList(image));
      }
    status=SetImageExtent(image,image->columns,image->rows);
    if (status == MagickFalse)
      {
        InheritException(exception,&image->exception);
        return(DestroyImageList(image));
      }

    if ((decoder)(image, &dds_info, exception) != MagickTrue)
      {
        (void) CloseBlob(image);
        return(GetFirstImageInList(image));
      }
  }

  if (EOFBlob(image) != MagickFalse)
    ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
      image->filename);

  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}
","1. image=AcquireImage(image_info);
2. if (status == MagickFalse)
3. if (ReadDDSInfo(image, &dds_info) != MagickTrue) {
4. if (dds_info.pixelformat.flags & DDPF_RGB)
5. if (dds_info.pixelformat.flags & DDPF_ALPHAPIXELS)
6. decoder = ReadUncompressedRGB;
7. else if (dds_info.pixelformat.flags & DDPF_FOURCC)
8. decoder = ReadDXT5;
break;
9. if (cubemap)
10. num_images = 0;
11. if (EOFBlob(image) != MagickFalse)
12. image->compression = compression;
13. return(GetFirstImageInList(image));
14. return(GetFirstImageInList(image));
15. if (EOFBlob(image) != MagickFalse)","39
41
50
65
68
90
93
115-116
132
137
153
163
172
184
188",CWE-119
nested_vmx_exit_handled,"static bool nested_vmx_exit_handled(struct kvm_vcpu *vcpu)
{
	u32 intr_info = vmcs_read32(VM_EXIT_INTR_INFO);
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	struct vmcs12 *vmcs12 = get_vmcs12(vcpu);
	u32 exit_reason = vmx->exit_reason;

	trace_kvm_nested_vmexit(kvm_rip_read(vcpu), exit_reason,
				vmcs_readl(EXIT_QUALIFICATION),
				vmx->idt_vectoring_info,
				intr_info,
				vmcs_read32(VM_EXIT_INTR_ERROR_CODE),
				KVM_ISA_VMX);

	if (vmx->nested.nested_run_pending)
		return false;

	if (unlikely(vmx->fail)) {
		pr_info_ratelimited(""%s failed vm entry %x\n"", __func__,
				    vmcs_read32(VM_INSTRUCTION_ERROR));
		return true;
	}
 
 	switch (exit_reason) {
 	case EXIT_REASON_EXCEPTION_NMI:
		if (is_nmi(intr_info))
 			return false;
 		else if (is_page_fault(intr_info))
 			return enable_ept;
		else if (is_no_device(intr_info) &&
			 !(vmcs12->guest_cr0 & X86_CR0_TS))
			return false;
		else if (is_debug(intr_info) &&
			 vcpu->guest_debug &
			 (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP))
			return false;
		else if (is_breakpoint(intr_info) &&
			 vcpu->guest_debug & KVM_GUESTDBG_USE_SW_BP)
			return false;
		return vmcs12->exception_bitmap &
				(1u << (intr_info & INTR_INFO_VECTOR_MASK));
	case EXIT_REASON_EXTERNAL_INTERRUPT:
		return false;
	case EXIT_REASON_TRIPLE_FAULT:
		return true;
	case EXIT_REASON_PENDING_INTERRUPT:
		return nested_cpu_has(vmcs12, CPU_BASED_VIRTUAL_INTR_PENDING);
	case EXIT_REASON_NMI_WINDOW:
		return nested_cpu_has(vmcs12, CPU_BASED_VIRTUAL_NMI_PENDING);
	case EXIT_REASON_TASK_SWITCH:
		return true;
	case EXIT_REASON_CPUID:
		if (kvm_register_read(vcpu, VCPU_REGS_RAX) == 0xa)
			return false;
		return true;
	case EXIT_REASON_HLT:
		return nested_cpu_has(vmcs12, CPU_BASED_HLT_EXITING);
	case EXIT_REASON_INVD:
		return true;
	case EXIT_REASON_INVLPG:
		return nested_cpu_has(vmcs12, CPU_BASED_INVLPG_EXITING);
	case EXIT_REASON_RDPMC:
		return nested_cpu_has(vmcs12, CPU_BASED_RDPMC_EXITING);
	case EXIT_REASON_RDTSC: case EXIT_REASON_RDTSCP:
		return nested_cpu_has(vmcs12, CPU_BASED_RDTSC_EXITING);
	case EXIT_REASON_VMCALL: case EXIT_REASON_VMCLEAR:
	case EXIT_REASON_VMLAUNCH: case EXIT_REASON_VMPTRLD:
	case EXIT_REASON_VMPTRST: case EXIT_REASON_VMREAD:
	case EXIT_REASON_VMRESUME: case EXIT_REASON_VMWRITE:
	case EXIT_REASON_VMOFF: case EXIT_REASON_VMON:
	case EXIT_REASON_INVEPT: case EXIT_REASON_INVVPID:
		
		return true;
	case EXIT_REASON_CR_ACCESS:
		return nested_vmx_exit_handled_cr(vcpu, vmcs12);
	case EXIT_REASON_DR_ACCESS:
		return nested_cpu_has(vmcs12, CPU_BASED_MOV_DR_EXITING);
	case EXIT_REASON_IO_INSTRUCTION:
		return nested_vmx_exit_handled_io(vcpu, vmcs12);
	case EXIT_REASON_GDTR_IDTR: case EXIT_REASON_LDTR_TR:
		return nested_cpu_has2(vmcs12, SECONDARY_EXEC_DESC);
	case EXIT_REASON_MSR_READ:
	case EXIT_REASON_MSR_WRITE:
		return nested_vmx_exit_handled_msr(vcpu, vmcs12, exit_reason);
	case EXIT_REASON_INVALID_STATE:
		return true;
	case EXIT_REASON_MWAIT_INSTRUCTION:
		return nested_cpu_has(vmcs12, CPU_BASED_MWAIT_EXITING);
	case EXIT_REASON_MONITOR_TRAP_FLAG:
		return nested_cpu_has(vmcs12, CPU_BASED_MONITOR_TRAP_FLAG);
	case EXIT_REASON_MONITOR_INSTRUCTION:
		return nested_cpu_has(vmcs12, CPU_BASED_MONITOR_EXITING);
	case EXIT_REASON_PAUSE_INSTRUCTION:
		return nested_cpu_has(vmcs12, CPU_BASED_PAUSE_EXITING) ||
			nested_cpu_has2(vmcs12,
				SECONDARY_EXEC_PAUSE_LOOP_EXITING);
	case EXIT_REASON_MCE_DURING_VMENTRY:
		return false;
	case EXIT_REASON_TPR_BELOW_THRESHOLD:
		return nested_cpu_has(vmcs12, CPU_BASED_TPR_SHADOW);
	case EXIT_REASON_APIC_ACCESS:
		return nested_cpu_has2(vmcs12,
			SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES);
	case EXIT_REASON_APIC_WRITE:
	case EXIT_REASON_EOI_INDUCED:
		
		return true;
	case EXIT_REASON_EPT_VIOLATION:
		
		return false;
	case EXIT_REASON_EPT_MISCONFIG:
		
		return false;
	case EXIT_REASON_WBINVD:
		return nested_cpu_has2(vmcs12, SECONDARY_EXEC_WBINVD_EXITING);
	case EXIT_REASON_XSETBV:
		return true;
	case EXIT_REASON_XSAVES: case EXIT_REASON_XRSTORS:
		
		return nested_cpu_has2(vmcs12, SECONDARY_EXEC_XSAVES);
	case EXIT_REASON_PREEMPTION_TIMER:
		return false;
	default:
		return true;
	}
}
",1. return true;,89,"CWE-200,CWE-264,CWE-611"
sched_read_attr-270553394330001,"
#define __user

static int sched_read_attr(struct sched_attr __user *uattr,
			   struct sched_attr *attr,
			   unsigned int usize)
{
	int ret;

	if (!access_ok(VERIFY_WRITE, uattr, usize))
		return -EFAULT;

	
	if (usize < sizeof(*attr)) {
		unsigned char *addr;
		unsigned char *end;

		addr = (void *)attr + usize;
		end  = (void *)attr + sizeof(*attr);

		for (; addr < end; addr++) {
			if (*addr)
				goto err_size;
		}

		attr->size = usize;
	}

	ret = copy_to_user(uattr, attr, attr->size);
	if (ret)
		return -EFAULT;

out:
	return ret;

err_size:
	ret = -E2BIG;
	goto out;
}
","1. static int sched_read_attr(struct sched_attr __user *uattr,
2. unsigned char *addr;
3. end  = (void *)attr + sizeof(*attr);
4. if (*addr)
goto err_size;
5. if (ret)
6. return ret;
7. ret = -E2BIG;","4
19
23
26-27
34
38
41","CWE-362,CWE-200,CWE-189"
encrypt_1,"static int encrypt_1(struct blkcipher_desc *desc,
		   struct scatterlist *dst, struct scatterlist *src,
		   unsigned int nbytes)
{
	struct blkcipher_walk walk;
	struct crypto_blkcipher *tfm = desc->tfm;
	struct salsa20_ctx *ctx = crypto_blkcipher_ctx(tfm);
	int err;

	blkcipher_walk_init(&walk, dst, src, nbytes);
	err = blkcipher_walk_virt_block(desc, &walk, 64);
 
 	salsa20_ivsetup(ctx, walk.iv);
 
 	while (walk.nbytes >= 64) {
 		salsa20_encrypt_bytes(ctx, walk.dst.virt.addr,
 				      walk.src.virt.addr,
				      walk.nbytes - (walk.nbytes % 64));
		err = blkcipher_walk_done(desc, &walk, walk.nbytes % 64);
	}

	if (walk.nbytes) {
		salsa20_encrypt_bytes(ctx, walk.dst.virt.addr,
				      walk.src.virt.addr, walk.nbytes);
		err = blkcipher_walk_done(desc, &walk, 0);
	}

	return err;
}
","1. struct scatterlist *dst, struct scatterlist *src,
unsigned int nbytes)
2. struct blkcipher_walk walk;
struct crypto_blkcipher *tfm = desc->tfm;
struct salsa20_ctx *ctx = crypto_blkcipher_ctx(tfm);
3. blkcipher_walk_init(&walk, dst, src, nbytes);
err = blkcipher_walk_virt_block(desc, &walk, 64);
4. while (walk.nbytes >= 64) {
5. err = blkcipher_walk_done(desc, &walk, walk.nbytes % 64);
6. salsa20_encrypt_bytes(ctx, walk.dst.virt.addr,
walk.src.virt.addr, walk.nbytes);
err = blkcipher_walk_done(desc, &walk, 0);
7. return err;","2-3
5-7
10-11
15
19
23-25
28","CWE-20,CWE-125,CWE-416"
rand_bytes-280838322055399,"void rand_bytes(uint8_t *buf, size_t size) {
	uint8_t hash[RLC_MD_LEN];
	int carry, len  = (RLC_RAND_SIZE - 1)/2;
	ctx_t *ctx = core_get();

	if (sizeof(int) > 2 && size > (1 << 16)) {
		RLC_THROW(ERR_NO_VALID);
		return;
	}

	
	rand_gen(buf, size);
	
	ctx->rand[0] = 0x3;
	md_map(hash, ctx->rand, 1 + len);
	
	rand_add(ctx->rand + 1, ctx->rand + 1 + len, len);
	carry = rand_add(ctx->rand + 1 + (len - RLC_MD_LEN), hash, RLC_MD_LEN);
	rand_inc(ctx->rand, len - RLC_MD_LEN + 1, carry);
	rand_inc(ctx->rand, len + 1, ctx->counter);
	ctx->counter = ctx->counter + 1;
}
","1. void rand_bytes(uint8_t *buf, size_t size) {
uint8_t hash[RLC_MD_LEN];
int carry, len  = (RLC_RAND_SIZE - 1)/2;
ctx_t *ctx = core_get();
2. if (sizeof(int) > 2 && size > (1 << 16)) {
RLC_THROW(ERR_NO_VALID);
return;
3. rand_gen(buf, size);
4. ctx->rand[0] = 0x3;
md_map(hash, ctx->rand, 1 + len);
5. rand_add(ctx->rand + 1, ctx->rand + 1 + len, len);
carry = rand_add(ctx->rand + 1 + (len - RLC_MD_LEN), hash, RLC_MD_LEN);
rand_inc(ctx->rand, len - RLC_MD_LEN + 1, carry);
rand_inc(ctx->rand, len + 1, ctx->counter);
ctx->counter = ctx->counter + 1;","1-4
6-8
12
14-15
17-21","CWE-476,CWE-119"
kvm_set_msr_common_1,"int kvm_set_msr_common_1(struct kvm_vcpu *vcpu, struct msr_data *msr_info)
{
	bool pr = false;
	u32 msr = msr_info->index;
	u64 data = msr_info->data;

	switch (msr) {
	case MSR_AMD64_NB_CFG:
	case MSR_IA32_UCODE_REV:
	case MSR_IA32_UCODE_WRITE:
	case MSR_VM_HSAVE_PA:
	case MSR_AMD64_PATCH_LOADER:
	case MSR_AMD64_BU_CFG2:
		break;

	case MSR_EFER:
		return set_efer(vcpu, data);
	case MSR_K7_HWCR:
		data &= ~(u64)0x40;	
		data &= ~(u64)0x100;	
		data &= ~(u64)0x8;	
		if (data != 0) {
			vcpu_unimpl(vcpu, ""unimplemented HWCR wrmsr: 0x%llx\n"",
				    data);
			return 1;
		}
		break;
	case MSR_FAM10H_MMIO_CONF_BASE:
		if (data != 0) {
			vcpu_unimpl(vcpu, ""unimplemented MMIO_CONF_BASE wrmsr: ""
				    ""0x%llx\n"", data);
			return 1;
		}
		break;
	case MSR_IA32_DEBUGCTLMSR:
		if (!data) {
			
			break;
		} else if (data & ~(DEBUGCTLMSR_LBR | DEBUGCTLMSR_BTF)) {
			
			return 1;
		}
		vcpu_unimpl(vcpu, ""%s: MSR_IA32_DEBUGCTLMSR 0x%llx, nop\n"",
			    __func__, data);
		break;
	case 0x200 ... 0x2ff:
		return set_msr_mtrr(vcpu, msr, data);
	case MSR_IA32_APICBASE:
		kvm_set_apic_base(vcpu, data);
		break;
	case APIC_BASE_MSR ... APIC_BASE_MSR + 0x3ff:
		return kvm_x2apic_msr_write(vcpu, msr, data);
	case MSR_IA32_TSCDEADLINE:
		kvm_set_lapic_tscdeadline_msr(vcpu, data);
		break;
	case MSR_IA32_TSC_ADJUST:
		if (guest_cpuid_has_tsc_adjust(vcpu)) {
			if (!msr_info->host_initiated) {
				u64 adj = data - vcpu->arch.ia32_tsc_adjust_msr;
				kvm_x86_ops->adjust_tsc_offset(vcpu, adj, true);
			}
			vcpu->arch.ia32_tsc_adjust_msr = data;
		}
		break;
	case MSR_IA32_MISC_ENABLE:
		vcpu->arch.ia32_misc_enable_msr = data;
		break;
	case MSR_KVM_WALL_CLOCK_NEW:
	case MSR_KVM_WALL_CLOCK:
		vcpu->kvm->arch.wall_clock = data;
		kvm_write_wall_clock(vcpu->kvm, data);
 		break;
 	case MSR_KVM_SYSTEM_TIME_NEW:
 	case MSR_KVM_SYSTEM_TIME: {
		u64 gpa_offset;
 		kvmclock_reset(vcpu);
 
 		vcpu->arch.time = data;
		kvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);

		
 		if (!(data & 1))
 			break;
 
		gpa_offset = data & ~(PAGE_MASK | 1);
 
 		
		if (gpa_offset & (sizeof(struct pvclock_vcpu_time_info) - 1))
 			break;
 
		if (kvm_gfn_to_hva_cache_init(vcpu->kvm,
		     &vcpu->arch.pv_time, data & ~1ULL))
			vcpu->arch.pv_time_enabled = false;
		else
			vcpu->arch.pv_time_enabled = true;
 
 		break;
 	}
	case MSR_KVM_ASYNC_PF_EN:
		if (kvm_pv_enable_async_pf(vcpu, data))
			return 1;
		break;
	case MSR_KVM_STEAL_TIME:

		if (unlikely(!sched_info_on()))
			return 1;

		if (data & KVM_STEAL_RESERVED_MASK)
			return 1;

		if (kvm_gfn_to_hva_cache_init(vcpu->kvm, &vcpu->arch.st.stime,
							data & KVM_STEAL_VALID_BITS))
			return 1;

		vcpu->arch.st.msr_val = data;

		if (!(data & KVM_MSR_ENABLED))
			break;

		vcpu->arch.st.last_steal = current->sched_info.run_delay;

		preempt_disable();
		accumulate_steal_time(vcpu);
		preempt_enable();

		kvm_make_request(KVM_REQ_STEAL_UPDATE, vcpu);

		break;
	case MSR_KVM_PV_EOI_EN:
		if (kvm_lapic_enable_pv_eoi(vcpu, data))
			return 1;
		break;

	case MSR_IA32_MCG_CTL:
	case MSR_IA32_MCG_STATUS:
	case MSR_IA32_MC0_CTL ... MSR_IA32_MC0_CTL + 4 * KVM_MAX_MCE_BANKS - 1:
		return set_msr_mce(vcpu, msr, data);

	
	case MSR_K7_EVNTSEL0:
	case MSR_K7_EVNTSEL1:
	case MSR_K7_EVNTSEL2:
	case MSR_K7_EVNTSEL3:
		if (data != 0)
			vcpu_unimpl(vcpu, ""unimplemented perfctr wrmsr: ""
				    ""0x%x data 0x%llx\n"", msr, data);
		break;
	
	case MSR_K7_PERFCTR0:
	case MSR_K7_PERFCTR1:
	case MSR_K7_PERFCTR2:
	case MSR_K7_PERFCTR3:
		vcpu_unimpl(vcpu, ""unimplemented perfctr wrmsr: ""
			    ""0x%x data 0x%llx\n"", msr, data);
		break;
	case MSR_P6_PERFCTR0:
	case MSR_P6_PERFCTR1:
		pr = true;
	case MSR_P6_EVNTSEL0:
	case MSR_P6_EVNTSEL1:
		if (kvm_pmu_msr(vcpu, msr))
			return kvm_pmu_set_msr(vcpu, msr, data);

		if (pr || data != 0)
			vcpu_unimpl(vcpu, ""disabled perfctr wrmsr: ""
				    ""0x%x data 0x%llx\n"", msr, data);
		break;
	case MSR_K7_CLK_CTL:
		
		break;
	case HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15:
		if (kvm_hv_msr_partition_wide(msr)) {
			int r;
			mutex_lock(&vcpu->kvm->lock);
			r = set_msr_hyperv_pw(vcpu, msr, data);
			mutex_unlock(&vcpu->kvm->lock);
			return r;
		} else
			return set_msr_hyperv(vcpu, msr, data);
		break;
	case MSR_IA32_BBL_CR_CTL3:
		
		vcpu_unimpl(vcpu, ""ignored wrmsr: 0x%x data %llx\n"", msr, data);
		break;
	case MSR_AMD64_OSVW_ID_LENGTH:
		if (!guest_cpuid_has_osvw(vcpu))
			return 1;
		vcpu->arch.osvw.length = data;
		break;
	case MSR_AMD64_OSVW_STATUS:
		if (!guest_cpuid_has_osvw(vcpu))
			return 1;
		vcpu->arch.osvw.status = data;
		break;
	default:
		if (msr && (msr == vcpu->kvm->arch.xen_hvm_config.msr))
			return xen_hvm_config(vcpu, data);
		if (kvm_pmu_msr(vcpu, msr))
			return kvm_pmu_set_msr(vcpu, msr, data);
		if (!ignore_msrs) {
			vcpu_unimpl(vcpu, ""unhandled wrmsr: 0x%x data %llx\n"",
				    msr, data);
			return 1;
		} else {
			vcpu_unimpl(vcpu, ""ignored wrmsr: 0x%x data %llx\n"",
				    msr, data);
			break;
		}
	}
	return 0;
}
","1. if (data != 0) {
2. case MSR_IA32_TSC_ADJUST:
3. if (!msr_info->host_initiated) {
4. vcpu->arch.pv_time_enabled = false;
5. break;
6. case MSR_IA32_MCG_CTL:
7. break;
8. if (!guest_cpuid_has_osvw(vcpu))
9. if (msr && (msr == vcpu->kvm->arch.xen_hvm_config.msr))
10. } else {","29
57
59
94
119
135
154
209
214
222","CWE-120,CWE-119,CWE-674,CWE-125,CWE-399"
crypto_shash_report,"static int crypto_shash_report(struct sk_buff *skb, struct crypto_alg *alg)
{
 	struct crypto_report_hash rhash;
 	struct shash_alg *salg = __crypto_shash_alg(alg);
 
	strncpy(rhash.type, ""shash"", sizeof(rhash.type));

 	rhash.blocksize = alg->cra_blocksize;
 	rhash.digestsize = salg->digestsize;
 
	if (nla_put(skb, CRYPTOCFGA_REPORT_HASH,
		    sizeof(struct crypto_report_hash), &rhash))
		goto nla_put_failure;
	return 0;

nla_put_failure:
	return -EMSGSIZE;
}
","1. rhash.blocksize = alg->cra_blocksize;
2. return 0;
3. return -EMSGSIZE;","8
14
17","CWE-122,CWE-310,CWE-200"
dhcps_send_ack-173392188470348,"static void dhcps_send_ack(struct pbuf *packet_buffer)
{
	struct pbuf *newly_malloc_packet_buffer = NULL;

	
	newly_malloc_packet_buffer = pbuf_alloc(PBUF_TRANSPORT, DHCP_MSG_LEN + DHCP_OPTION_TOTAL_LENGTH_MAX, PBUF_RAM);
	if(newly_malloc_packet_buffer == NULL)
	{
		printf(""\r\n[%s] error:  pbuf alloc fail !"", __func__);
		return;
	}
	if(pbuf_copy(newly_malloc_packet_buffer, packet_buffer) != ERR_OK)
	{
		printf(""\r\n[%s] error:  pbuf copy fail !"", __func__);
		pbuf_free(newly_malloc_packet_buffer);	
		return;
	}	
	dhcp_message_total_options_lenth = DHCP_OPTION_TOTAL_LENGTH_MAX;
	dhcp_message_repository = (struct dhcp_msg *)newly_malloc_packet_buffer->payload;
	dhcps_initialize_message(dhcp_message_repository);
	if(add_offer_options(add_msg_type(&dhcp_message_repository->options[4], DHCP_MESSAGE_TYPE_ACK)) == 0){
		if(dhcp_message_repository->flags == 0x0){
			
			for(int i=0;i<6;i++)
				dhcps_allocated_client_ethaddr.addr[i] = dhcp_message_repository->chaddr[i];
#if ETHARP_SUPPORT_STATIC_ENTRIES
#if LWIP_VERSION_MAJOR >= 2
			etharp_add_static_entry(ip_2_ip4(&dhcps_allocated_client_address), &dhcps_allocated_client_ethaddr);
#else
			etharp_add_static_entry(&dhcps_allocated_client_address, &dhcps_allocated_client_ethaddr);
#endif
#endif
			udp_sendto_if(dhcps_pcb, newly_malloc_packet_buffer, &dhcps_allocated_client_address, DHCP_CLIENT_PORT, dhcps_netif);
#if ETHARP_SUPPORT_STATIC_ENTRIES	
#if LWIP_VERSION_MAJOR >= 2
			etharp_remove_static_entry(ip_2_ip4(&dhcps_allocated_client_address));
#else
			etharp_remove_static_entry(&dhcps_allocated_client_address);
#endif
#endif
		}
		else
			
			udp_sendto_if(dhcps_pcb, newly_malloc_packet_buffer, &dhcps_send_broadcast_address, DHCP_CLIENT_PORT, dhcps_netif);
	}
	pbuf_free(newly_malloc_packet_buffer);
}
","1. printf(""\r\n[%s] error:  pbuf copy fail !"", __func__);
2. return;
3. dhcp_message_total_options_lenth = DHCP_OPTION_TOTAL_LENGTH_MAX;
4. dhcps_initialize_message(dhcp_message_repository);
5. dhcps_allocated_client_ethaddr.addr[i] = dhcp_message_repository->chaddr[i];
6. udp_sendto_if(dhcps_pcb, newly_malloc_packet_buffer, &dhcps_send_broadcast_address, DHCP_CLIENT_PORT, dhcps_netif);","14
16
18
20
25
44","CWE-20,CWE-78,CWE-399,CWE-823,CWE-287"
userfaultfd_unregister,"static int userfaultfd_unregister(struct userfaultfd_ctx *ctx,
				  unsigned long arg)
{
	struct mm_struct *mm = ctx->mm;
	struct vm_area_struct *vma, *prev, *cur;
	int ret;
	struct uffdio_range uffdio_unregister;
	unsigned long new_flags;
	bool found;
	unsigned long start, end, vma_end;
	const void __user *buf = (void __user *)arg;

	ret = -EFAULT;
	if (copy_from_user(&uffdio_unregister, buf, sizeof(uffdio_unregister)))
		goto out;

	ret = validate_range(mm, uffdio_unregister.start,
			     uffdio_unregister.len);
	if (ret)
		goto out;

	start = uffdio_unregister.start;
	end = start + uffdio_unregister.len;

	ret = -ENOMEM;
	if (!mmget_not_zero(mm))
		goto out;

	down_write(&mm->mmap_sem);
	vma = find_vma_prev(mm, start, &prev);
	if (!vma)
		goto out_unlock;

	
	ret = -EINVAL;
	if (vma->vm_start >= end)
		goto out_unlock;

	
	if (is_vm_hugetlb_page(vma)) {
		unsigned long vma_hpagesize = vma_kernel_pagesize(vma);

		if (start & (vma_hpagesize - 1))
			goto out_unlock;
	}

	
	found = false;
	ret = -EINVAL;
	for (cur = vma; cur && cur->vm_start < end; cur = cur->vm_next) {
		cond_resched();

		BUG_ON(!!cur->vm_userfaultfd_ctx.ctx ^
		       !!(cur->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP)));

		
		if (!vma_can_userfault(cur))
			goto out_unlock;

		found = true;
	}
	BUG_ON(!found);

	if (vma->vm_start < start)
		prev = vma;

	ret = 0;
	do {
 		cond_resched();
 
 		BUG_ON(!vma_can_userfault(vma));
		WARN_ON(!(vma->vm_flags & VM_MAYWRITE));
 
 		
		if (!vma->vm_userfaultfd_ctx.ctx)
			goto skip;

		if (vma->vm_start > start)
			start = vma->vm_start;
		vma_end = min(end, vma->vm_end);

		if (userfaultfd_missing(vma)) {
			
			struct userfaultfd_wake_range range;
			range.start = start;
			range.len = vma_end - start;
			wake_userfault(vma->vm_userfaultfd_ctx.ctx, &range);
		}

		new_flags = vma->vm_flags & ~(VM_UFFD_MISSING | VM_UFFD_WP);
		prev = vma_merge(mm, prev, start, vma_end, new_flags,
				 vma->anon_vma, vma->vm_file, vma->vm_pgoff,
				 vma_policy(vma),
				 NULL_VM_UFFD_CTX);
		if (prev) {
			vma = prev;
			goto next;
		}
		if (vma->vm_start < start) {
			ret = split_vma(mm, vma, start, 1);
			if (ret)
				break;
		}
		if (vma->vm_end > end) {
			ret = split_vma(mm, vma, end, 0);
			if (ret)
				break;
		}
	next:
		
		vma->vm_flags = new_flags;
		vma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;

	skip:
		prev = vma;
		start = vma->vm_end;
		vma = vma->vm_next;
	} while (vma && vma->vm_start < end);
out_unlock:
	up_write(&mm->mmap_sem);
	mmput(mm);
out:
	return ret;
}
","1. uffdio_unregister.len);
2. vma = find_vma_prev(mm, start, &prev);
3. !!(cur->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP)));
4. BUG_ON(!vma_can_userfault(vma));
WARN_ON(!(vma->vm_flags & VM_MAYWRITE));
5. if (vma->vm_start > start)
start = vma->vm_start;
6. up_write(&mm->mmap_sem);","18
30
59
82-83
92-93
143","CWE-190,CWE-20,CWE-284,CWE-863"
DefragVlanQinQTest,"DefragVlanQinQTest(void)
{
    Packet *p1 = NULL, *p2 = NULL, *r = NULL;
    int ret = 0;
 
     DefragInit();
 
    p1 = BuildTestPacket(IPPROTO_ICMP, 1, 0, 1, 'A', 8);
     if (p1 == NULL)
         goto end;
    p2 = BuildTestPacket(IPPROTO_ICMP, 1, 1, 0, 'B', 8);
     if (p2 == NULL)
         goto end;
 
    
    if ((r = Defrag(NULL, NULL, p1, NULL)) != NULL)
        goto end;
    if ((r = Defrag(NULL, NULL, p2, NULL)) == NULL)
        goto end;
    SCFree(r);

    
    p1->vlan_id[0] = 1;
    p2->vlan_id[0] = 1;
    p1->vlan_id[1] = 1;
    p2->vlan_id[1] = 2;
    if ((r = Defrag(NULL, NULL, p1, NULL)) != NULL)
        goto end;
    if ((r = Defrag(NULL, NULL, p2, NULL)) != NULL)
        goto end;

    
    ret = 1;

end:
    if (p1 != NULL)
        SCFree(p1);
    if (p2 != NULL)
        SCFree(p2);
    DefragDestroy();

    return ret;
}
","1. DefragVlanQinQTest(void)
2. Packet *p1 = NULL, *p2 = NULL, *r = NULL;
int ret = 0;
3. if (p1 == NULL)
4. goto end;
if ((r = Defrag(NULL, NULL, p2, NULL)) == NULL)","1
3-4
9
17-18",CWE-358
main_62-232364243882000,"int main_62(int argc, char *argv[]) {
	(void)argc;

	const char *usage = ""Usage: seatd-launch [options] [--] command\n""
			    ""\n""
			    ""  -h	Show this help message\n""
			    ""  -v	Show the version number\n""
			    ""\n"";

	int c;
	while ((c = getopt(argc, argv, ""vh"")) != -1) {
		switch (c) {
		case 'v':
			printf(""seatd-launch version %s\n"", SEATD_VERSION);
			return 0;
		case 'h':
			printf(""%s"", usage);
			return 0;
		case '?':
			fprintf(stderr, ""Try '%s -h' for more information.\n"", argv[0]);
			return 1;
		default:
			abort();
		}
	}

	if (optind >= argc) {
		fprintf(stderr, ""A command must be specified\n\n%s"", usage);
		return 1;
	}
	char **command = &argv[optind];

	char sockpath[256];
	sprintf(sockpath, ""/tmp/seatd.%d.sock"", getpid());

	int fds[2];
	if (pipe(fds) == -1) {
		perror(""Could not create pipe"");
		goto error;
	}

	pid_t seatd_child = fork();
	if (seatd_child == -1) {
		perror(""Could not fork seatd process"");
		goto error;
	} else if (seatd_child == 0) {
		close(fds[0]);

		char pipebuf[16] = {0};
		snprintf(pipebuf, sizeof pipebuf, ""%d"", fds[1]);

		char *env[2] = {NULL, NULL};
		char loglevelbuf[32] = {0};
		char *cur_loglevel = getenv(""SEATD_LOGLEVEL"");
		if (cur_loglevel != NULL) {
			snprintf(loglevelbuf, sizeof loglevelbuf, ""SEATD_LOGLEVEL=%s"", cur_loglevel);
			env[0] = loglevelbuf;
		}

		char *command[] = {""seatd"", ""-n"", pipebuf, ""-s"", sockpath, NULL};
		execve(SEATD_INSTALLPATH, command, env);
		perror(""Could not start seatd"");
		_exit(1);
	}
	close(fds[1]);

	
	char buf[1] = {0};
	while (true) {
		pid_t p = waitpid(seatd_child, NULL, WNOHANG);
		if (p == seatd_child) {
			fprintf(stderr, ""seatd exited prematurely\n"");
			goto error_seatd;
		} else if (p == -1 && (errno != EINTR && errno != ECHILD)) {
			perror(""Could not wait for seatd process"");
			goto error_seatd;
		}

		struct pollfd fd = {
			.fd = fds[0],
			.events = POLLIN,
		};

		
		if (poll(&fd, 1, 1000) == -1) {
			if (errno == EAGAIN || errno == EINTR) {
				continue;
			} else {
				perror(""Could not poll notification fd"");
				goto error_seatd;
			}
		}

		if (fd.revents & POLLIN) {
			ssize_t n = read(fds[0], buf, 1);
			if (n == -1 && errno != EINTR) {
				perror(""Could not read from pipe"");
				goto error_seatd;
			} else if (n > 0) {
				break;
			}
		}
	}
	close(fds[0]);

	uid_t uid = getuid();
	gid_t gid = getgid();

	
	if (chown(sockpath, uid, gid) == -1) {
		perror(""Could not chown seatd socket"");
		goto error_seatd;
	}
	if (chmod(sockpath, 0700) == -1) {
		perror(""Could not chmod socket"");
		goto error_seatd;
	}

	
	if (setgid(gid) == -1) {
		perror(""Could not set gid to drop privileges"");
		goto error_seatd;
	}
	if (setuid(uid) == -1) {
		perror(""Could not set uid to drop privileges"");
		goto error_seatd;
	}

	pid_t child = fork();
	if (child == -1) {
		perror(""Could not fork target process"");
		goto error_seatd;
	} else if (child == 0) {
		setenv(""SEATD_SOCK"", sockpath, 1);
		execvp(command[0], command);
		perror(""Could not start target"");
		_exit(1);
	}

	int status = 0;
	while (true) {
		pid_t p = waitpid(child, &status, 0);
		if (p == child) {
			break;
		} else if (p == -1 && errno != EINTR) {
			perror(""Could not wait for target process"");
			goto error_seatd;
		}
	}

	if (kill(seatd_child, SIGTERM) != 0) {
		perror(""Could not kill seatd"");
	}

	if (WIFEXITED(status)) {
		return WEXITSTATUS(status);
	} else if (WIFSIGNALED(status)) {
		return 128 + WTERMSIG(status);
	} else {
		abort(); 
	}

error_seatd:
	kill(seatd_child, SIGTERM);
error:
	return 1;
}
","1. fprintf(stderr, ""Try '%s -h' for more information.\n"", argv[0]);
2. if (cur_loglevel != NULL) {
3. while (true) {
4. ssize_t n = read(fds[0], buf, 1);
5. break;
6. _exit(1);
7. } else if (p == -1 && errno != EINTR) {
8. perror(""Could not kill seatd"");
9. abort();
10. error:","20
55
69
95
100
137
145
152
160
165","CWE-200,CWE-59,CWE-189"
my_login-139792641265278,"
#define SV

static int my_login(pTHX_ SV* dbh, imp_dbh_t *imp_dbh)
{
  SV* sv;
  HV* hv;
  char* dbname;
  char* host;
  char* port;
  char* user;
  char* password;
  char* mysql_socket;
  int   result;
  int	fresh = 0;
  D_imp_xxh(dbh);

  
#define TAKE_IMP_DATA_VERSION 1
#if TAKE_IMP_DATA_VERSION
  if (DBIc_has(imp_dbh, DBIcf_IMPSET))
  { 
    if (DBIc_has(imp_dbh, DBIcf_ACTIVE))
    {
      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
        PerlIO_printf(DBIc_LOGPIO(imp_xxh), ""my_login skip connect\n"");
      
      ++DBIc_ACTIVE_KIDS(DBIc_PARENT_COM(imp_dbh));
      return TRUE;
    }
    if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
      PerlIO_printf(DBIc_LOGPIO(imp_xxh),
                    ""my_login IMPSET but not ACTIVE so connect not skipped\n"");
  }
#endif

  sv = DBIc_IMP_DATA(imp_dbh);

  if (!sv  ||  !SvROK(sv))
    return FALSE;

  hv = (HV*) SvRV(sv);
  if (SvTYPE(hv) != SVt_PVHV)
    return FALSE;

  host=		safe_hv_fetch(aTHX_ hv, ""host"", 4);
  port=		safe_hv_fetch(aTHX_ hv, ""port"", 4);
  user=		safe_hv_fetch(aTHX_ hv, ""user"", 4);
  password=	safe_hv_fetch(aTHX_ hv, ""password"", 8);
  dbname=	safe_hv_fetch(aTHX_ hv, ""database"", 8);
  mysql_socket=	safe_hv_fetch(aTHX_ hv, ""mysql_socket"", 12);

  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
    PerlIO_printf(DBIc_LOGPIO(imp_xxh),
		  ""imp_dbh->my_login : dbname = %s, uid = %s, pwd = %s,"" \
		  ""host = %s, port = %s\n"",
		  dbname ? dbname : ""NULL"",
		  user ? user : ""NULL"",
		  password ? password : ""NULL"",
		  host ? host : ""NULL"",
		  port ? port : ""NULL"");

  if (!imp_dbh->pmysql) {
     fresh = 1;
     Newz(908, imp_dbh->pmysql, 1, MYSQL);
  }
  result = mysql_dr_connect(dbh, imp_dbh->pmysql, mysql_socket, host, port, user,
			  password, dbname, imp_dbh) ? TRUE : FALSE;
  if (fresh && !result) {
      
      do_error(dbh, mysql_errno(imp_dbh->pmysql),
              mysql_error(imp_dbh->pmysql) ,mysql_sqlstate(imp_dbh->pmysql));
      Safefree(imp_dbh->pmysql);
      imp_dbh->pmysql = NULL;
  }
  return result;
}
","1. char* password;
2. int   result;
3. return TRUE;
4. return FALSE;
5. result = mysql_dr_connect(dbh, imp_dbh->pmysql, mysql_socket, host, port, user,","12
14
29
40
67","CWE-362,CWE-269,CWE-264,CWE-787"
aio_setup_single_vector-205295793952386,"static ssize_t aio_setup_single_vector(int type, struct file * file, struct kiocb *kiocb)
{
	int bytes;

	bytes = rw_verify_area(type, file, &kiocb->ki_pos, kiocb->ki_left);
	if (bytes < 0)
		return bytes;

	kiocb->ki_iovec = &kiocb->ki_inline_vec;
	kiocb->ki_iovec->iov_base = kiocb->ki_buf;
	kiocb->ki_iovec->iov_len = bytes;
	kiocb->ki_nr_segs = 1;
	kiocb->ki_cur_seg = 0;
	return 0;
}
","1. static ssize_t aio_setup_single_vector(int type, struct file * file, struct kiocb *kiocb)
2. bytes = rw_verify_area(type, file, &kiocb->ki_pos, kiocb->ki_left);
if (bytes < 0)
return bytes;
3. kiocb->ki_iovec = &kiocb->ki_inline_vec;
4. kiocb->ki_iovec->iov_len = bytes;
kiocb->ki_nr_segs = 1;
kiocb->ki_cur_seg = 0;
return 0;","1
5-7
9
11-14","CWE-17,CWE-399,CWE-119"
fmt_mtm_load_song-278871300424215,"int fmt_mtm_load_song(song_t *song, slurp_t *fp, unsigned int lflags)
{
	uint8_t b[192];
	uint8_t nchan, nord, npat, nsmp;
	uint16_t ntrk, comment_len;
	int n, pat, chan, smp, rows, todo = 0;
	song_note_t *note;
	uint16_t tmp;
	uint32_t tmplong;
	song_note_t **trackdata, *tracknote;
	song_sample_t *sample;

	slurp_read(fp, b, 3);
	if (memcmp(b, ""MTM"", 3) != 0)
		return LOAD_UNSUPPORTED;
	n = slurp_getc(fp);
	sprintf(song->tracker_id, ""MultiTracker %d.%d"", n >> 4, n & 0xf);
	slurp_read(fp, song->title, 20);
	song->title[20] = 0;
	slurp_read(fp, &ntrk, 2);
	ntrk = bswapLE16(ntrk);
	npat = slurp_getc(fp);
	nord = slurp_getc(fp) + 1;

	slurp_read(fp, &comment_len, 2);
	comment_len = bswapLE16(comment_len);

	nsmp = slurp_getc(fp);
	slurp_getc(fp); 
	rows = slurp_getc(fp); 
	if (rows != 64)
		todo |= 64;
	rows = MIN(rows, 64);
	nchan = slurp_getc(fp);

	if (slurp_eof(fp)) {
		return LOAD_FORMAT_ERROR;
	}

	for (n = 0; n < 32; n++) {
		int pan = slurp_getc(fp) & 0xf;
		pan = SHORT_PANNING(pan);
		pan *= 4; 
		song->channels[n].panning = pan;
	}
	for (n = nchan; n < MAX_CHANNELS; n++)
		song->channels[n].flags = CHN_MUTE;

	
	if (nsmp > MAX_SAMPLES) {
		log_appendf(4, "" Warning: Too many samples"");
	}
	for (n = 1, sample = song->samples + 1; n <= nsmp; n++, sample++) {
		if (n > MAX_SAMPLES) {
			slurp_seek(fp, 37, SEEK_CUR);
			continue;
		}

		
		char name[23];
		slurp_read(fp, name, 22);
		name[22] = '\0';
		strcpy(sample->name, name);
		slurp_read(fp, &tmplong, 4);
		sample->length = bswapLE32(tmplong);
		slurp_read(fp, &tmplong, 4);
		sample->loop_start = bswapLE32(tmplong);
		slurp_read(fp, &tmplong, 4);
		sample->loop_end = bswapLE32(tmplong);
		if ((sample->loop_end - sample->loop_start) > 2) {
			sample->flags |= CHN_LOOP;
		} else {
			
			sample->loop_start = 0;
			sample->loop_end = 0;
		}
		song->samples[n].c5speed = MOD_FINETUNE(slurp_getc(fp));
		sample->volume = slurp_getc(fp);
		sample->volume *= 4; 
		sample->global_volume = 64;
		if (slurp_getc(fp) & 1) {
			todo |= 16;
			sample->flags |= CHN_16BIT;
			sample->length >>= 1;
			sample->loop_start >>= 1;
			sample->loop_end >>= 1;
		}
		song->samples[n].vib_type = 0;
		song->samples[n].vib_rate = 0;
		song->samples[n].vib_depth = 0;
		song->samples[n].vib_speed = 0;
	}

	
	slurp_read(fp, song->orderlist, 128);
	memset(song->orderlist + nord, ORDER_LAST, MAX_ORDERS - nord);

	
	trackdata = mem_calloc(ntrk, sizeof(song_note_t *));
	for (n = 0; n < ntrk; n++) {
		slurp_read(fp, b, 3 * rows);
		trackdata[n] = mem_calloc(rows, sizeof(song_note_t));
		mtm_unpack_track(b, trackdata[n], rows);
	}

	
	if (npat >= MAX_PATTERNS) {
		log_appendf(4, "" Warning: Too many patterns"");
	}
	for (pat = 0; pat <= npat; pat++) {
		
		if (pat >= MAX_PATTERNS) {
			slurp_seek(fp, 64, SEEK_CUR);
			continue;
		}

		song->patterns[pat] = csf_allocate_pattern(MAX(rows, 32));
		song->pattern_size[pat] = song->pattern_alloc_size[pat] = 64;
		for (chan = 0; chan < 32; chan++) {
			slurp_read(fp, &tmp, 2);
			tmp = bswapLE16(tmp);
			if (tmp == 0) {
				continue;
			} else if (tmp > ntrk) {
				for (n = 0; n < ntrk; n++)
					free(trackdata[n]);
				free(trackdata);
				return LOAD_FORMAT_ERROR;
			}
			note = song->patterns[pat] + chan;
			tracknote = trackdata[tmp - 1];
			for (n = 0; n < rows; n++, tracknote++, note += MAX_CHANNELS)
				*note = *tracknote;
		}
		if (rows < 32) {
			
			note = song->patterns[pat] + 64 * (rows - 1);
			while (note->effect || note->param)
				note++;
			note->effect = FX_PATTERNBREAK;
		}
	}

	
	for (n = 0; n < ntrk; n++)
		free(trackdata[n]);
	free(trackdata);

	read_lined_message(song->message, fp, comment_len, 40);

	
	if (!(lflags & LOAD_NOSAMPLES)) {
		for (smp = 1; smp <= nsmp && smp <= MAX_SAMPLES; smp++) {
			uint32_t ssize;

			if (song->samples[smp].length == 0)
				continue;
			ssize = csf_read_sample(song->samples + smp,
				(SF_LE | SF_PCMU | SF_M
				 | ((song->samples[smp].flags & CHN_16BIT) ? SF_16 : SF_8)),
				fp->data + fp->pos, fp->length - fp->pos);
			slurp_seek(fp, ssize, SEEK_CUR);
		}
	}

	
	song->flags = SONG_ITOLDEFFECTS | SONG_COMPATGXX;





	if (todo & 64)
		log_appendf(2, "" TODO: test this file with other players (beats per track != 64)"");
	if (todo & 16)
		log_appendf(2, "" TODO: double check 16 bit sample loading"");

	
	return LOAD_SUCCESS;
}
","1. song_note_t **trackdata, *tracknote;
2. if (memcmp(b, ""MTM"", 3) != 0)
3. char name[23];
4. sample->loop_start = bswapLE32(tmplong);
5. sample->loop_end = 0;
6. sample->volume *= 4;
7. sample->loop_start >>= 1;
8. slurp_seek(fp, 64, SEEK_CUR);
continue;
9. song->pattern_size[pat] = song->pattern_alloc_size[pat] = 64;
10. tracknote = trackdata[tmp - 1];
11. note = song->patterns[pat] + 64 * (rows - 1);
12. note++;
13. if (song->samples[smp].length == 0)
14. if (todo & 64)","10
14
61
68
76
80
86
114-115
119
132
139
141
158
175","CWE-362,CWE-200,CWE-125,CWE-59"
nfp_flower_spawn_vnic_reprs-153019045907487,"static int
nfp_flower_spawn_vnic_reprs(struct nfp_app *app,
			    enum nfp_flower_cmsg_port_vnic_type vnic_type,
			    enum nfp_repr_type repr_type, unsigned int cnt)
{
	u8 nfp_pcie = nfp_cppcore_pcie_unit(app->pf->cpp);
	struct nfp_flower_priv *priv = app->priv;
	atomic_t *replies = &priv->reify_replies;
	struct nfp_flower_repr_priv *repr_priv;
	enum nfp_port_type port_type;
	struct nfp_repr *nfp_repr;
	struct nfp_reprs *reprs;
	int i, err, reify_cnt;
	const u8 queue = 0;

	port_type = repr_type == NFP_REPR_TYPE_PF ? NFP_PORT_PF_PORT :
						    NFP_PORT_VF_PORT;

	reprs = nfp_reprs_alloc(cnt);
	if (!reprs)
		return -ENOMEM;

	for (i = 0; i < cnt; i++) {
		struct net_device *repr;
		struct nfp_port *port;
		u32 port_id;

		repr = nfp_repr_alloc(app);
		if (!repr) {
			err = -ENOMEM;
			goto err_reprs_clean;
		}

		repr_priv = kzalloc(sizeof(*repr_priv), GFP_KERNEL);
		if (!repr_priv) {
			err = -ENOMEM;
			nfp_repr_free(repr);
			goto err_reprs_clean;
		}

		nfp_repr = netdev_priv(repr);
		nfp_repr->app_priv = repr_priv;
		repr_priv->nfp_repr = nfp_repr;

		
		WARN_ON(repr_type == NFP_REPR_TYPE_PF && i);

		port = nfp_port_alloc(app, port_type, repr);
		if (IS_ERR(port)) {
			err = PTR_ERR(port);
			kfree(repr_priv);
			nfp_repr_free(repr);
			goto err_reprs_clean;
		}
		if (repr_type == NFP_REPR_TYPE_PF) {
			port->pf_id = i;
			port->vnic = priv->nn->dp.ctrl_bar;
		} else {
			port->pf_id = 0;
			port->vf_id = i;
			port->vnic =
				app->pf->vf_cfg_mem + i * NFP_NET_CFG_BAR_SZ;
		}

		eth_hw_addr_random(repr);

		port_id = nfp_flower_cmsg_pcie_port(nfp_pcie, vnic_type,
						    i, queue);
		err = nfp_repr_init(app, repr,
				    port_id, port, priv->nn->dp.netdev);
		if (err) {
			kfree(repr_priv);
			nfp_port_free(port);
			nfp_repr_free(repr);
			goto err_reprs_clean;
		}

		RCU_INIT_POINTER(reprs->reprs[i], repr);
		nfp_info(app->cpp, ""%s%d Representor(%s) created\n"",
			 repr_type == NFP_REPR_TYPE_PF ? ""PF"" : ""VF"", i,
			 repr->name);
	}

	nfp_app_reprs_set(app, repr_type, reprs);

	atomic_set(replies, 0);
	reify_cnt = nfp_flower_reprs_reify(app, repr_type, true);
	if (reify_cnt < 0) {
		err = reify_cnt;
		nfp_warn(app->cpp, ""Failed to notify firmware about repr creation\n"");
		goto err_reprs_remove;
	}

	err = nfp_flower_wait_repr_reify(app, replies, reify_cnt);
	if (err)
		goto err_reprs_remove;

	return 0;
err_reprs_remove:
	reprs = nfp_app_reprs_set(app, repr_type, NULL);
err_reprs_clean:
	nfp_reprs_clean_and_free(app, reprs);
	return err;
}
","1. NFP_PORT_VF_PORT;
2. err = -ENOMEM;
3. repr->name);
4. nfp_app_reprs_set(app, repr_type, reprs);
5. if (reify_cnt < 0) {
6. reprs = nfp_app_reprs_set(app, repr_type, NULL);","17
36
81
84
88
100","CWE-119,CWE-189"
fm_mgr_config_mgr_connect-246343641966945,"fm_mgr_config_errno_t

fm_mgr_config_mgr_connect

(

	fm_config_conx_hdl	*hdl, 

	fm_mgr_type_t 		mgr

)

{

	char                    s_path[256];

	char                    c_path[256];

	char                    *mgr_prefix;

	p_hsm_com_client_hdl_t  *mgr_hdl;



	memset(s_path,0,sizeof(s_path));

	memset(c_path,0,sizeof(c_path));



	switch ( mgr )

	{

		case FM_MGR_SM:

			mgr_prefix  = HSM_FM_SCK_SM;

			mgr_hdl     = &hdl->sm_hdl;

			break;

		case FM_MGR_PM:

			mgr_prefix  = HSM_FM_SCK_PM;

			mgr_hdl     = &hdl->pm_hdl;

			break;

		case FM_MGR_FE:

			mgr_prefix  = HSM_FM_SCK_FE;

			mgr_hdl     = &hdl->fe_hdl;

			break;

		default:

			return FM_CONF_INIT_ERR;

	}



	

	sprintf(s_path,""%s%s%d"",HSM_FM_SCK_PREFIX,mgr_prefix,hdl->instance);



	sprintf(c_path,""%s%s%d_C_XXXXXX"",HSM_FM_SCK_PREFIX,mgr_prefix,hdl->instance);



	if ( *mgr_hdl == NULL )

	{

		if ( hcom_client_init(mgr_hdl,s_path,c_path,32768) != HSM_COM_OK )

		{

			return FM_CONF_INIT_ERR;

		}

	}



	if ( hcom_client_connect(*mgr_hdl) == HSM_COM_OK )

	{

		hdl->conx_mask |= mgr;

		return FM_CONF_OK;

	}



	return FM_CONF_CONX_ERR;



}
","1. p_hsm_com_client_hdl_t  *mgr_hdl;
2. case FM_MGR_PM:
3. mgr_prefix  = HSM_FM_SCK_FE;
4. mgr_hdl     = &hdl->fe_hdl;
5. sprintf(c_path,""%s%s%d_C_XXXXXX"",HSM_FM_SCK_PREFIX,mgr_prefix,hdl->instance);","21
43
53
55
73","CWE-787,CWE-399,CWE-119"
zgfx_decompress,"
#define BYTE
#define SrcSize
#define UINT32
#define ZGFX_CONTEXT

int zgfx_decompress(ZGFX_CONTEXT* zgfx, const BYTE* pSrcData, UINT32 SrcSize, BYTE** ppDstData,
                    UINT32* pDstSize, UINT32 flags)
 {
 	int status = -1;
 	BYTE descriptor;
 	wStream* stream = Stream_New((BYTE*)pSrcData, SrcSize);

 	if (!stream)
 		return -1;
 
	if (Stream_GetRemainingLength(stream) < 1)
		goto fail;

	Stream_Read_UINT8(stream, descriptor); 

	if (descriptor == ZGFX_SEGMENTED_SINGLE)
	{
		if (!zgfx_decompress_segment(zgfx, stream, Stream_GetRemainingLength(stream)))
 			goto fail;
 
 		*ppDstData = NULL;

 		if (zgfx->OutputCount > 0)
 			*ppDstData = (BYTE*) malloc(zgfx->OutputCount);
 
		if (!*ppDstData)
			goto fail;

		*pDstSize = zgfx->OutputCount;
		CopyMemory(*ppDstData, zgfx->OutputBuffer, zgfx->OutputCount);
	}
	else if (descriptor == ZGFX_SEGMENTED_MULTIPART)
	{
		UINT32 segmentSize;
		UINT16 segmentNumber;
 		UINT16 segmentCount;
 		UINT32 uncompressedSize;
 		BYTE* pConcatenated;
		size_t used = 0;
 
 		if (Stream_GetRemainingLength(stream) < 6)
 			goto fail;

		Stream_Read_UINT16(stream, segmentCount); 
		Stream_Read_UINT32(stream, uncompressedSize); 

		if (Stream_GetRemainingLength(stream) < segmentCount * sizeof(UINT32))
			goto fail;

		pConcatenated = (BYTE*) malloc(uncompressedSize);

		if (!pConcatenated)
			goto fail;

		*ppDstData = pConcatenated;
		*pDstSize = uncompressedSize;

		for (segmentNumber = 0; segmentNumber < segmentCount; segmentNumber++)
		{
			if (Stream_GetRemainingLength(stream) < sizeof(UINT32))
				goto fail;

			Stream_Read_UINT32(stream, segmentSize); 

 			if (!zgfx_decompress_segment(zgfx, stream, segmentSize))
 				goto fail;
 
			if (zgfx->OutputCount > UINT32_MAX - used)
				goto fail;

			if (used + zgfx->OutputCount > uncompressedSize)
				goto fail;

 			CopyMemory(pConcatenated, zgfx->OutputBuffer, zgfx->OutputCount);
 			pConcatenated += zgfx->OutputCount;
			used += zgfx->OutputCount;
 		}
 	}
 	else
	{
		goto fail;
	}

	status = 1;
fail:
	Stream_Free(stream, FALSE);
	return status;
}
","1. int status = -1;
2. wStream* stream = Stream_New((BYTE*)pSrcData, SrcSize);
3. if (!stream)
4. if (Stream_GetRemainingLength(stream) < 1)
5. Stream_Read_UINT8(stream, descriptor);
6. *ppDstData = NULL;
7. CopyMemory(*ppDstData, zgfx->OutputBuffer, zgfx->OutputCount);
8. UINT32 uncompressedSize;
9. goto fail;
10. goto fail;
11. goto fail;
12. return status;","10
12
14
17
20
27
36
43
59
72
75
93","CWE-617,CWE-119"
curl_easy_unescape-57506861202908,"
#define CURL

char *curl_easy_unescape(CURL *handle, const char *string, int length,
                         int *olen)
{
  char *str = NULL;
  size_t inputlen = length;
  size_t outputlen;
  CURLcode res = Curl_urldecode(handle, string, inputlen, &str, &outputlen,
                                FALSE);
  if(res)
    return NULL;
  if(olen)
    *olen = curlx_uztosi(outputlen);
  return str;
}
","1. int *olen)
2. size_t outputlen;
3. return NULL;
4. *olen = curlx_uztosi(outputlen);","5
9
13
15","CWE-362,CWE-326,CWE-19,CWE-119"
lookup1_values,"static int lookup1_values(int entries, int dim)
{
    int r = (int) floor(exp((float) log((float) entries) / dim));
    if ((int) floor(pow((float) r+1, dim)) <= entries)   
       ++r;                                              
   if (pow((float) r+1, dim) <= entries)
      return -1;
   if ((int) floor(pow((float) r, dim)) > entries)
      return -1;
    return r;
 }
","1. static int lookup1_values(int entries, int dim)
2. ++r;
if (pow((float) r+1, dim) <= entries)
3. return r;","1
5-6
10","CWE-190,CWE-125,CWE-189"
AddInputMethodNames,"
#define GList
#define InputMethodDescriptors

void AddInputMethodNames(const GList* engines, InputMethodDescriptors* out) {
  DCHECK(out);
  for (; engines; engines = g_list_next(engines)) {
    IBusEngineDesc* engine_desc = IBUS_ENGINE_DESC(engines->data);
    const gchar* name = ibus_engine_desc_get_name(engine_desc);
    const gchar* longname = ibus_engine_desc_get_longname(engine_desc);
    const gchar* layout = ibus_engine_desc_get_layout(engine_desc);
    const gchar* language = ibus_engine_desc_get_language(engine_desc);
    if (InputMethodIdIsWhitelisted(name)) {
      out->push_back(CreateInputMethodDescriptor(name,
                                                  longname,
                                                  layout,
                                                  language));
      VLOG(1) << name << "" (preloaded)"";
     }
   }
 }
","1. const gchar* longname = ibus_engine_desc_get_longname(engine_desc);
2. out->push_back(CreateInputMethodDescriptor(name,
longname,","10
14-15","CWE-367,CWE-190,CWE-787,CWE-119,CWE-59"
dccp_v4_connect-278554882074056,"int dccp_v4_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)
{
	const struct sockaddr_in *usin = (struct sockaddr_in *)uaddr;
	struct inet_sock *inet = inet_sk(sk);
	struct dccp_sock *dp = dccp_sk(sk);
	__be16 orig_sport, orig_dport;
	__be32 daddr, nexthop;
	struct flowi4 fl4;
	struct rtable *rt;
	int err;
	struct ip_options_rcu *inet_opt;

	dp->dccps_role = DCCP_ROLE_CLIENT;

	if (addr_len < sizeof(struct sockaddr_in))
		return -EINVAL;

	if (usin->sin_family != AF_INET)
		return -EAFNOSUPPORT;

	nexthop = daddr = usin->sin_addr.s_addr;

	inet_opt = rcu_dereference_protected(inet->inet_opt,
					     sock_owned_by_user(sk));
	if (inet_opt != NULL && inet_opt->opt.srr) {
		if (daddr == 0)
			return -EINVAL;
		nexthop = inet_opt->opt.faddr;
	}

	orig_sport = inet->inet_sport;
	orig_dport = usin->sin_port;
	rt = ip_route_connect(&fl4, nexthop, inet->inet_saddr,
			      RT_CONN_FLAGS(sk), sk->sk_bound_dev_if,
			      IPPROTO_DCCP,
			      orig_sport, orig_dport, sk, true);
	if (IS_ERR(rt))
		return PTR_ERR(rt);

	if (rt->rt_flags & (RTCF_MULTICAST | RTCF_BROADCAST)) {
		ip_rt_put(rt);
		return -ENETUNREACH;
	}

	if (inet_opt == NULL || !inet_opt->opt.srr)
		daddr = rt->rt_dst;

	if (inet->inet_saddr == 0)
		inet->inet_saddr = rt->rt_src;
	inet->inet_rcv_saddr = inet->inet_saddr;

	inet->inet_dport = usin->sin_port;
	inet->inet_daddr = daddr;

	inet_csk(sk)->icsk_ext_hdr_len = 0;
	if (inet_opt)
		inet_csk(sk)->icsk_ext_hdr_len = inet_opt->opt.optlen;
	
	dccp_set_state(sk, DCCP_REQUESTING);
	err = inet_hash_connect(&dccp_death_row, sk);
	if (err != 0)
		goto failure;

	rt = ip_route_newports(&fl4, rt, orig_sport, orig_dport,
			       inet->inet_sport, inet->inet_dport, sk);
	if (IS_ERR(rt)) {
		rt = NULL;
		goto failure;
	}
	
	sk_setup_caps(sk, &rt->dst);

	dp->dccps_iss = secure_dccp_sequence_number(inet->inet_saddr,
						    inet->inet_daddr,
						    inet->inet_sport,
						    inet->inet_dport);
	inet->inet_id = dp->dccps_iss ^ jiffies;

	err = dccp_connect(sk);
	rt = NULL;
	if (err != 0)
		goto failure;
out:
	return err;
failure:
	
	dccp_set_state(sk, DCCP_CLOSED);
	ip_rt_put(rt);
	sk->sk_route_caps = 0;
	inet->inet_dport = 0;
	goto out;
}
","1. struct dccp_sock *dp = dccp_sk(sk);
2. int err;
struct ip_options_rcu *inet_opt;
3. dp->dccps_role = DCCP_ROLE_CLIENT;
4. return -EAFNOSUPPORT;
5. nexthop = daddr = usin->sin_addr.s_addr;
6. return -EINVAL;
nexthop = inet_opt->opt.faddr;
7. orig_dport = usin->sin_port;
8. RT_CONN_FLAGS(sk), sk->sk_bound_dev_if,
9. orig_sport, orig_dport, sk, true);
10. inet->inet_daddr = daddr;
11. if (err != 0)
12. inet->inet_sport, inet->inet_dport, sk);
if (IS_ERR(rt)) {
13. sk_setup_caps(sk, &rt->dst);
14. inet->inet_daddr,
inet->inet_sport,
inet->inet_dport);
15. err = dccp_connect(sk);
rt = NULL;
16. goto failure;
17. dccp_set_state(sk, DCCP_CLOSED);
ip_rt_put(rt);
sk->sk_route_caps = 0;","5
10-11
13
19
21
27-28
32
34
36
53
66
70-71
76
79-81
84-85
87
94-96",CWE-362
xfs_attr_leaf_addname,"xfs_attr_leaf_addname(xfs_da_args_t *args)
{
	xfs_inode_t *dp;
	struct xfs_buf *bp;
	int retval, error, committed, forkoff;

	trace_xfs_attr_leaf_addname(args);

	
	dp = args->dp;
	args->blkno = 0;
	error = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);
	if (error)
		return error;

	
	retval = xfs_attr3_leaf_lookup_int(bp, args);
	if ((args->flags & ATTR_REPLACE) && (retval == ENOATTR)) {
		xfs_trans_brelse(args->trans, bp);
		return retval;
	} else if (retval == EEXIST) {
		if (args->flags & ATTR_CREATE) {	
			xfs_trans_brelse(args->trans, bp);
			return retval;
		}
 
 		trace_xfs_attr_leaf_replace(args);
 
		
 		args->op_flags |= XFS_DA_OP_RENAME;	
 		args->blkno2 = args->blkno;		
 		args->index2 = args->index;
 		args->rmtblkno2 = args->rmtblkno;
 		args->rmtblkcnt2 = args->rmtblkcnt;
		args->rmtvaluelen2 = args->rmtvaluelen;

		
		args->rmtblkno = 0;
		args->rmtblkcnt = 0;
		args->rmtvaluelen = 0;
 	}
 
 	
	retval = xfs_attr3_leaf_add(bp, args);
	if (retval == ENOSPC) {
		
		xfs_bmap_init(args->flist, args->firstblock);
		error = xfs_attr3_leaf_to_node(args);
		if (!error) {
			error = xfs_bmap_finish(&args->trans, args->flist,
						&committed);
		}
		if (error) {
			ASSERT(committed);
			args->trans = NULL;
			xfs_bmap_cancel(args->flist);
			return(error);
		}

		
		if (committed)
			xfs_trans_ijoin(args->trans, dp, 0);

		
		error = xfs_trans_roll(&args->trans, dp);
		if (error)
			return (error);

		
		error = xfs_attr_node_addname(args);
		return(error);
	}

	
	error = xfs_trans_roll(&args->trans, dp);
	if (error)
		return (error);

	
	if (args->rmtblkno > 0) {
		error = xfs_attr_rmtval_set(args);
		if (error)
			return(error);
	}

	
	if (args->op_flags & XFS_DA_OP_RENAME) {
		
		error = xfs_attr3_leaf_flipflags(args);
		if (error)
			return(error);

		
		args->index = args->index2;
 		args->blkno = args->blkno2;
 		args->rmtblkno = args->rmtblkno2;
 		args->rmtblkcnt = args->rmtblkcnt2;
		args->rmtvaluelen = args->rmtvaluelen2;
 		if (args->rmtblkno) {
 			error = xfs_attr_rmtval_remove(args);
 			if (error)
				return(error);
		}

		
		error = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno,
					   -1, &bp);
		if (error)
			return error;

		xfs_attr3_leaf_remove(bp, args);

		
		if ((forkoff = xfs_attr_shortform_allfit(bp, dp))) {
			xfs_bmap_init(args->flist, args->firstblock);
			error = xfs_attr3_leaf_to_shortform(bp, args, forkoff);
			
			if (!error) {
				error = xfs_bmap_finish(&args->trans,
							args->flist,
							&committed);
			}
			if (error) {
				ASSERT(committed);
				args->trans = NULL;
				xfs_bmap_cancel(args->flist);
				return(error);
			}

			
			if (committed)
				xfs_trans_ijoin(args->trans, dp, 0);
		}

		
		error = xfs_trans_roll(&args->trans, dp);

	} else if (args->rmtblkno > 0) {
		
		error = xfs_attr3_leaf_clearflag(args);
	}
	return error;
}
","1. } else if (retval == EEXIST) {
2. error = xfs_bmap_finish(&args->trans, args->flist,
3. xfs_bmap_cancel(args->flist);
4. args->blkno = args->blkno2;
args->rmtblkno = args->rmtblkno2;
5. if (args->rmtblkno) {","26
66
72
138-139
142","CWE-476,CWE-125,CWE-787,CWE-416"
ares__read_line-93772701995712,"
#define FILE

ares_status_t ares__read_line(FILE *fp, char **buf, size_t *bufsize)
{
  char  *newbuf;
  size_t offset = 0;
  size_t len;

  if (*buf == NULL) {
    *buf = ares_malloc(128);
    if (!*buf) {
      return ARES_ENOMEM;
    }
    *bufsize = 128;
  }

  for (;;) {
    int bytestoread = (int)(*bufsize - offset);

    if (!fgets(*buf + offset, bytestoread, fp)) {
      return (offset != 0) ? 0 : (ferror(fp)) ? ARES_EFILE : ARES_EOF;
    }
    len = offset + ares_strlen(*buf + offset);

    
    if (len == 0) {
      offset = 0;
      continue;
    }

    if ((*buf)[len - 1] == '\n') {
      (*buf)[len - 1] = 0;
      break;
    }
    offset = len;
    if (len < *bufsize - 1) {
      continue;
    }

    
    newbuf = ares_realloc(*buf, *bufsize * 2);
    if (!newbuf) {
      ares_free(*buf);
      *buf = NULL;
      return ARES_ENOMEM;
    }
    *buf      = newbuf;
    *bufsize *= 2;
  }
  return ARES_SUCCESS;
}
","1. size_t len;
2. int bytestoread = (int)(*bufsize - offset);
3. if (!fgets(*buf + offset, bytestoread, fp)) {
return (offset != 0) ? 0 : (ferror(fp)) ? ARES_EFILE : ARES_EOF;
4. if (len == 0) {
5. if ((*buf)[len - 1] == '\n') {
6. ares_free(*buf);
7. return ARES_ENOMEM;
8. *buf      = newbuf;","8
19
21-22
28
33
45
47
49","CWE-191,CWE-20,CWE-264,CWE-787"
bittok2str_internal-40173311612157,"static char *
bittok2str_internal(register const struct tok *lp, register const char *fmt,
	   register u_int v, const char *sep)
{
        static char buf[1024+1]; 
        char *bufp = buf;
        size_t space_left = sizeof(buf), string_size;
        register u_int rotbit; 
        register u_int tokval;
        const char * sepstr = """";

	while (lp != NULL && lp->s != NULL) {
            tokval=lp->v;   
            rotbit=1;
            while (rotbit != 0) {
                
		if (tokval == (v&rotbit)) {
                    
                    if (space_left <= 1)
                        return (buf); 
                    string_size = strlcpy(bufp, sepstr, space_left);
                    if (string_size >= space_left)
                        return (buf);    
                    bufp += string_size;
                    space_left -= string_size;
                    if (space_left <= 1)
                        return (buf); 
                    string_size = strlcpy(bufp, lp->s, space_left);
                    if (string_size >= space_left)
                        return (buf);    
                    bufp += string_size;
                    space_left -= string_size;
                    sepstr = sep;
                    break;
                }
                rotbit=rotbit<<1; 
            }
            lp++;
	}

        if (bufp == buf)
            
            (void)snprintf(buf, sizeof(buf), fmt == NULL ? ""#%08x"" : fmt, v);
        return (buf);
}
","1. static char *
bittok2str_internal(register const struct tok *lp, register const char *fmt,
register u_int v, const char *sep)
2. char *bufp = buf;
size_t space_left = sizeof(buf), string_size;
register u_int rotbit;
register u_int tokval;
const char * sepstr = """";
3. tokval=lp->v;
rotbit=1;
while (rotbit != 0) {
4. if (tokval == (v&rotbit)) {
5. return (buf);
string_size = strlcpy(bufp, sepstr, space_left);
if (string_size >= space_left)
return (buf);
bufp += string_size;
space_left -= string_size;
if (space_left <= 1)
return (buf);
6. return (buf);
bufp += string_size;
space_left -= string_size;
sepstr = sep;
break;
7. return (buf);","1-3
6-10
13-15
20
23-30
33-37
47","CWE-787,CWE-119"
yyjson_ptr_get_uint-119660847088957,"yyjson_api_inline bool yyjson_ptr_get_uint(
    yyjson_val *root, const char *ptr, uint64_t *value) {
    yyjson_val *val = yyjson_ptr_get(root, ptr);
    if (value && val) {
        uint64_t ret = val->uni.u64;
        if (unsafe_yyjson_is_uint(val) ||
            (unsafe_yyjson_is_sint(val) && !(ret >> 63))) {
            *value = ret;
            return true;
        }
    }
    return false;
}
","1. yyjson_api_inline bool yyjson_ptr_get_uint(
yyjson_val *root, const char *ptr, uint64_t *value) {
yyjson_val *val = yyjson_ptr_get(root, ptr);
2. uint64_t ret = val->uni.u64;
if (unsafe_yyjson_is_uint(val) ||
3. *value = ret;
return true;
4. return false;","1-3
5-6
8-9
12","CWE-310,CWE-770,CWE-323,CWE-189,CWE-200"
ReadVIFFImage_1,"
#define ExceptionInfo
#define ImageInfo

static Image *ReadVIFFImage_1(const ImageInfo *image_info,
  ExceptionInfo *exception)
{
#define VFF_CM_genericRGB  15
#define VFF_CM_ntscRGB  1
#define VFF_CM_NONE  0
#define VFF_DEP_DECORDER  0x4
#define VFF_DEP_NSORDER  0x8
#define VFF_DES_RAW  0
#define VFF_LOC_IMPLICIT  1
#define VFF_MAPTYP_NONE  0
#define VFF_MAPTYP_1_BYTE  1
#define VFF_MAPTYP_2_BYTE  2
#define VFF_MAPTYP_4_BYTE  4
#define VFF_MAPTYP_FLOAT  5
#define VFF_MAPTYP_DOUBLE  7
#define VFF_MS_NONE  0
#define VFF_MS_ONEPERBAND  1
#define VFF_MS_SHARED  3
#define VFF_TYP_BIT  0
#define VFF_TYP_1_BYTE  1
#define VFF_TYP_2_BYTE  2
#define VFF_TYP_4_BYTE  4
#define VFF_TYP_FLOAT  5
#define VFF_TYP_DOUBLE  9

  typedef struct _ViffInfo
  {
    unsigned char
      identifier,
      file_type,
      release,
      version,
      machine_dependency,
      reserve[3];

    char
      comment[512];

    unsigned int
      rows,
      columns,
      subrows;

    int
      x_offset,
      y_offset;

    float
      x_bits_per_pixel,
      y_bits_per_pixel;

    unsigned int
      location_type,
      location_dimension,
      number_of_images,
      number_data_bands,
      data_storage_type,
      data_encode_scheme,
      map_scheme,
      map_storage_type,
      map_rows,
      map_columns,
      map_subrows,
      map_enable,
      maps_per_cycle,
      color_space_model;
  } ViffInfo;

  double
    min_value,
    scale_factor,
    value;

  Image
    *image;

  int
    bit;

  MagickBooleanType
    status;

  MagickSizeType
    number_pixels;

  register ssize_t
    x;

  register Quantum
    *q;

  register ssize_t
    i;

  register unsigned char
    *p;

  size_t
    bytes_per_pixel,
    max_packets,
    quantum;

  ssize_t
    count,
    y;

  unsigned char
    *pixels;

  unsigned long
    lsb_first;

  ViffInfo
    viff_info;

  
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  image=AcquireImage(image_info,exception);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  
  count=ReadBlob(image,1,&viff_info.identifier);
  do
  {
    
    if ((count != 1) || ((unsigned char) viff_info.identifier != 0xab))
      ThrowReaderException(CorruptImageError,""NotAVIFFImage"");
    
    (void) ReadBlob(image,sizeof(viff_info.file_type),&viff_info.file_type);
    (void) ReadBlob(image,sizeof(viff_info.release),&viff_info.release);
    (void) ReadBlob(image,sizeof(viff_info.version),&viff_info.version);
    (void) ReadBlob(image,sizeof(viff_info.machine_dependency),
      &viff_info.machine_dependency);
    (void) ReadBlob(image,sizeof(viff_info.reserve),viff_info.reserve);
    count=ReadBlob(image,512,(unsigned char *) viff_info.comment);
    if (count != 512)
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    viff_info.comment[511]='\0';
    if (strlen(viff_info.comment) > 4)
      (void) SetImageProperty(image,""comment"",viff_info.comment,exception);
    if ((viff_info.machine_dependency == VFF_DEP_DECORDER) ||
        (viff_info.machine_dependency == VFF_DEP_NSORDER))
      image->endian=LSBEndian;
    else
      image->endian=MSBEndian;
    viff_info.rows=ReadBlobLong(image);
    viff_info.columns=ReadBlobLong(image);
    viff_info.subrows=ReadBlobLong(image);
    viff_info.x_offset=ReadBlobSignedLong(image);
    viff_info.y_offset=ReadBlobSignedLong(image);
    viff_info.x_bits_per_pixel=(float) ReadBlobLong(image);
    viff_info.y_bits_per_pixel=(float) ReadBlobLong(image);
    viff_info.location_type=ReadBlobLong(image);
    viff_info.location_dimension=ReadBlobLong(image);
    viff_info.number_of_images=ReadBlobLong(image);
    viff_info.number_data_bands=ReadBlobLong(image);
    viff_info.data_storage_type=ReadBlobLong(image);
    viff_info.data_encode_scheme=ReadBlobLong(image);
    viff_info.map_scheme=ReadBlobLong(image);
    viff_info.map_storage_type=ReadBlobLong(image);
    viff_info.map_rows=ReadBlobLong(image);
    viff_info.map_columns=ReadBlobLong(image);
    viff_info.map_subrows=ReadBlobLong(image);
    viff_info.map_enable=ReadBlobLong(image);
    viff_info.maps_per_cycle=ReadBlobLong(image);
    viff_info.color_space_model=ReadBlobLong(image);
    for (i=0; i < 420; i++)
      (void) ReadBlobByte(image);
    if (EOFBlob(image) != MagickFalse)
      ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile"");
    number_pixels=(MagickSizeType) viff_info.columns*viff_info.rows;
    if (number_pixels > GetBlobSize(image))
      ThrowReaderException(CorruptImageError,""InsufficientImageDataInFile"");
    if (number_pixels != (size_t) number_pixels)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    if (number_pixels == 0)
      ThrowReaderException(CoderError,""ImageColumnOrRowSizeIsNotSupported"");
    image->columns=viff_info.rows;
    image->rows=viff_info.columns;
    image->depth=viff_info.x_bits_per_pixel <= 8 ? 8UL :
      MAGICKCORE_QUANTUM_DEPTH;
    image->alpha_trait=viff_info.number_data_bands == 4 ? BlendPixelTrait :
      UndefinedPixelTrait;
    status=SetImageExtent(image,image->columns,image->rows,exception);
    if (status == MagickFalse)
      return(DestroyImageList(image));
    (void) SetImageBackgroundColor(image,exception);
    
    if ((viff_info.number_data_bands < 1) || (viff_info.number_data_bands > 4))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    if ((viff_info.data_storage_type != VFF_TYP_BIT) &&
        (viff_info.data_storage_type != VFF_TYP_1_BYTE) &&
        (viff_info.data_storage_type != VFF_TYP_2_BYTE) &&
        (viff_info.data_storage_type != VFF_TYP_4_BYTE) &&
        (viff_info.data_storage_type != VFF_TYP_FLOAT) &&
        (viff_info.data_storage_type != VFF_TYP_DOUBLE))
      ThrowReaderException(CoderError,""DataStorageTypeIsNotSupported"");
    if (viff_info.data_encode_scheme != VFF_DES_RAW)
      ThrowReaderException(CoderError,""DataEncodingSchemeIsNotSupported"");
    if ((viff_info.map_storage_type != VFF_MAPTYP_NONE) &&
        (viff_info.map_storage_type != VFF_MAPTYP_1_BYTE) &&
        (viff_info.map_storage_type != VFF_MAPTYP_2_BYTE) &&
        (viff_info.map_storage_type != VFF_MAPTYP_4_BYTE) &&
        (viff_info.map_storage_type != VFF_MAPTYP_FLOAT) &&
        (viff_info.map_storage_type != VFF_MAPTYP_DOUBLE))
      ThrowReaderException(CoderError,""MapStorageTypeIsNotSupported"");
    if ((viff_info.color_space_model != VFF_CM_NONE) &&
        (viff_info.color_space_model != VFF_CM_ntscRGB) &&
        (viff_info.color_space_model != VFF_CM_genericRGB))
      ThrowReaderException(CoderError,""ColorspaceModelIsNotSupported"");
    if (viff_info.location_type != VFF_LOC_IMPLICIT)
      ThrowReaderException(CoderError,""LocationTypeIsNotSupported"");
    if (viff_info.number_of_images != 1)
      ThrowReaderException(CoderError,""NumberOfImagesIsNotSupported"");
    if (viff_info.map_rows == 0)
      viff_info.map_scheme=VFF_MS_NONE;
    switch ((int) viff_info.map_scheme)
    {
      case VFF_MS_NONE:
      {
        if (viff_info.number_data_bands < 3)
          {
            
            if (viff_info.data_storage_type == VFF_TYP_BIT)
              image->colors=2;
            else
              if (viff_info.data_storage_type == VFF_MAPTYP_1_BYTE)
                image->colors=256UL;
              else
                image->colors=image->depth <= 8 ? 256UL : 65536UL;
            status=AcquireImageColormap(image,image->colors,exception);
            if (status == MagickFalse)
              ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
          }
        break;
      }
      case VFF_MS_ONEPERBAND:
      case VFF_MS_SHARED:
      {
        unsigned char
          *viff_colormap;

        
        switch ((int) viff_info.map_storage_type)
        {
          case VFF_MAPTYP_1_BYTE: bytes_per_pixel=1; break;
          case VFF_MAPTYP_2_BYTE: bytes_per_pixel=2; break;
          case VFF_MAPTYP_4_BYTE: bytes_per_pixel=4; break;
          case VFF_MAPTYP_FLOAT: bytes_per_pixel=4; break;
          case VFF_MAPTYP_DOUBLE: bytes_per_pixel=8; break;
          default: bytes_per_pixel=1; break;
        }
        image->colors=viff_info.map_columns;
        if ((MagickSizeType) (viff_info.map_rows*image->colors) > GetBlobSize(image))
          ThrowReaderException(CorruptImageError,""InsufficientImageDataInFile"");
        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        if ((MagickSizeType) viff_info.map_rows > GetBlobSize(image))
          ThrowReaderException(CorruptImageError,""InsufficientImageDataInFile"");
        if ((MagickSizeType) viff_info.map_rows >
            (viff_info.map_rows*bytes_per_pixel*sizeof(*viff_colormap)))
          ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
        viff_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,
          viff_info.map_rows*bytes_per_pixel*sizeof(*viff_colormap));
        if (viff_colormap == (unsigned char *) NULL)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        
        count=ReadBlob(image,bytes_per_pixel*image->colors*viff_info.map_rows,
          viff_colormap);
        lsb_first=1;
        if (*(char *) &lsb_first &&
            ((viff_info.machine_dependency != VFF_DEP_DECORDER) &&
             (viff_info.machine_dependency != VFF_DEP_NSORDER)))
          switch ((int) viff_info.map_storage_type)
          {
            case VFF_MAPTYP_2_BYTE:
            {
              MSBOrderShort(viff_colormap,(bytes_per_pixel*image->colors*
                viff_info.map_rows));
              break;
            }
            case VFF_MAPTYP_4_BYTE:
            case VFF_MAPTYP_FLOAT:
            {
              MSBOrderLong(viff_colormap,(bytes_per_pixel*image->colors*
                viff_info.map_rows));
              break;
            }
            default: break;
          }
        for (i=0; i < (ssize_t) (viff_info.map_rows*image->colors); i++)
        {
          switch ((int) viff_info.map_storage_type)
          {
            case VFF_MAPTYP_2_BYTE: value=1.0*((short *) viff_colormap)[i]; break;
            case VFF_MAPTYP_4_BYTE: value=1.0*((int *) viff_colormap)[i]; break;
            case VFF_MAPTYP_FLOAT: value=((float *) viff_colormap)[i]; break;
            case VFF_MAPTYP_DOUBLE: value=((double *) viff_colormap)[i]; break;
            default: value=1.0*viff_colormap[i]; break;
          }
          if (i < (ssize_t) image->colors)
            {
              image->colormap[i].red=(MagickRealType)
                ScaleCharToQuantum((unsigned char) value);
              image->colormap[i].green=(MagickRealType)
                ScaleCharToQuantum((unsigned char) value);
              image->colormap[i].blue=(MagickRealType)
                ScaleCharToQuantum((unsigned char) value);
            }
          else
            if (i < (ssize_t) (2*image->colors))
              image->colormap[i % image->colors].green=(MagickRealType)
                ScaleCharToQuantum((unsigned char) value);
            else
              if (i < (ssize_t) (3*image->colors))
                image->colormap[i % image->colors].blue=(MagickRealType)
                  ScaleCharToQuantum((unsigned char) value);
        }
        viff_colormap=(unsigned char *) RelinquishMagickMemory(viff_colormap);
        break;
      }
      default:
        ThrowReaderException(CoderError,""ColormapTypeNotSupported"");
    }
    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    if (viff_info.data_storage_type == VFF_TYP_BIT)
      {
        
        image->colors=2;
        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        image->colorspace=GRAYColorspace;
      }
    
    switch ((int) viff_info.data_storage_type)
    {
      case VFF_TYP_2_BYTE: bytes_per_pixel=2; break;
      case VFF_TYP_4_BYTE: bytes_per_pixel=4; break;
      case VFF_TYP_FLOAT: bytes_per_pixel=4; break;
      case VFF_TYP_DOUBLE: bytes_per_pixel=8; break;
      default: bytes_per_pixel=1; break;
    }
    if (viff_info.data_storage_type == VFF_TYP_BIT)
      {
        if (HeapOverflowSanityCheck((image->columns+7UL) >> 3UL,image->rows) != MagickFalse)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        max_packets=((image->columns+7UL) >> 3UL)*image->rows;
      }
    else
      {
        if (HeapOverflowSanityCheck((size_t) number_pixels,viff_info.number_data_bands) != MagickFalse)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        max_packets=(size_t) (number_pixels*viff_info.number_data_bands);
      }
    if ((MagickSizeType) (bytes_per_pixel*max_packets) > GetBlobSize(image))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    pixels=(unsigned char *) AcquireQuantumMemory((size_t) MagickMax(
      number_pixels,max_packets),bytes_per_pixel*sizeof(*pixels));
    if (pixels == (unsigned char *) NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    (void) memset(pixels,0,MagickMax(number_pixels,max_packets)*
      bytes_per_pixel*sizeof(*pixels));
    count=ReadBlob(image,bytes_per_pixel*max_packets,pixels);
    lsb_first=1;
    if (*(char *) &lsb_first &&
        ((viff_info.machine_dependency != VFF_DEP_DECORDER) &&
         (viff_info.machine_dependency != VFF_DEP_NSORDER)))
      switch ((int) viff_info.data_storage_type)
      {
        case VFF_TYP_2_BYTE:
        {
          MSBOrderShort(pixels,bytes_per_pixel*max_packets);
          break;
        }
        case VFF_TYP_4_BYTE:
        case VFF_TYP_FLOAT:
        {
          MSBOrderLong(pixels,bytes_per_pixel*max_packets);
          break;
        }
        default: break;
      }
    min_value=0.0;
    scale_factor=1.0;
    if ((viff_info.data_storage_type != VFF_TYP_1_BYTE) &&
        (viff_info.map_scheme == VFF_MS_NONE))
      {
        double
          max_value;

        
        switch ((int) viff_info.data_storage_type)
        {
          case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[0]; break;
          case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[0]; break;
          case VFF_TYP_FLOAT: value=((float *) pixels)[0]; break;
          case VFF_TYP_DOUBLE: value=((double *) pixels)[0]; break;
          default: value=1.0*pixels[0]; break;
        }
        max_value=value;
        min_value=value;
        for (i=0; i < (ssize_t) max_packets; i++)
        {
          switch ((int) viff_info.data_storage_type)
          {
            case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[i]; break;
            case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[i]; break;
            case VFF_TYP_FLOAT: value=((float *) pixels)[i]; break;
            case VFF_TYP_DOUBLE: value=((double *) pixels)[i]; break;
            default: value=1.0*pixels[i]; break;
          }
          if (value > max_value)
            max_value=value;
          else
            if (value < min_value)
              min_value=value;
        }
        if ((min_value == 0) && (max_value == 0))
          scale_factor=0;
        else
          if (min_value == max_value)
            {
              scale_factor=(double) QuantumRange/min_value;
              min_value=0;
            }
          else
            scale_factor=(double) QuantumRange/(max_value-min_value);
      }
    
    p=(unsigned char *) pixels;
    for (i=0; i < (ssize_t) max_packets; i++)
    {
      switch ((int) viff_info.data_storage_type)
      {
        case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[i]; break;
        case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[i]; break;
        case VFF_TYP_FLOAT: value=((float *) pixels)[i]; break;
        case VFF_TYP_DOUBLE: value=((double *) pixels)[i]; break;
        default: value=1.0*pixels[i]; break;
      }
      if (viff_info.map_scheme == VFF_MS_NONE)
        {
          value=(value-min_value)*scale_factor;
          if (value > QuantumRange)
            value=QuantumRange;
          else
            if (value < 0)
              value=0;
        }
      *p=(unsigned char) ((Quantum) value);
      p++;
    }
    
    p=(unsigned char *) pixels;
    if (viff_info.data_storage_type == VFF_TYP_BIT)
      {
        
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
          if (q == (Quantum *) NULL)
            break;
          for (x=0; x < (ssize_t) (image->columns-7); x+=8)
          {
            for (bit=0; bit < 8; bit++)
            {
              quantum=(size_t) ((*p) & (0x01 << bit) ? 0 : 1);
              SetPixelRed(image,quantum == 0 ? 0 : QuantumRange,q);
              SetPixelGreen(image,quantum == 0 ? 0 : QuantumRange,q);
              SetPixelBlue(image,quantum == 0 ? 0 : QuantumRange,q);
              if (image->storage_class == PseudoClass)
                SetPixelIndex(image,(Quantum) quantum,q);
              q+=GetPixelChannels(image);
            }
            p++;
          }
          if ((image->columns % 8) != 0)
            {
              for (bit=0; bit < (int) (image->columns % 8); bit++)
              {
                quantum=(size_t) ((*p) & (0x01 << bit) ? 0 : 1);
                SetPixelRed(image,quantum == 0 ? 0 : QuantumRange,q);
                SetPixelGreen(image,quantum == 0 ? 0 : QuantumRange,q);
                SetPixelBlue(image,quantum == 0 ? 0 : QuantumRange,q);
                if (image->storage_class == PseudoClass)
                  SetPixelIndex(image,(Quantum) quantum,q);
                q+=GetPixelChannels(image);
              }
              p++;
            }
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
      }
    else
      if (image->storage_class == PseudoClass)
        for (y=0; y < (ssize_t) image->rows; y++)
        {
          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
          if (q == (Quantum *) NULL)
            break;
          for (x=0; x < (ssize_t) image->columns; x++)
          {
            SetPixelIndex(image,*p++,q);
            q+=GetPixelChannels(image);
          }
          if (SyncAuthenticPixels(image,exception) == MagickFalse)
            break;
          if (image->previous == (Image *) NULL)
            {
              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
              if (status == MagickFalse)
                break;
            }
        }
      else
        {
          
          number_pixels=(MagickSizeType) image->columns*image->rows;
          for (y=0; y < (ssize_t) image->rows; y++)
          {
            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
            if (q == (Quantum *) NULL)
              break;
            for (x=0; x < (ssize_t) image->columns; x++)
            {
              SetPixelRed(image,ScaleCharToQuantum(*p),q);
              SetPixelGreen(image,ScaleCharToQuantum(*(p+number_pixels)),q);
              SetPixelBlue(image,ScaleCharToQuantum(*(p+2*number_pixels)),q);
              if (image->colors != 0)
                {
                  ssize_t
                    index;

                  index=(ssize_t) GetPixelRed(image,q);
                  SetPixelRed(image,ClampToQuantum(image->colormap[
                    ConstrainColormapIndex(image,index,exception)].red),q);
                  index=(ssize_t) GetPixelGreen(image,q);
                  SetPixelGreen(image,ClampToQuantum(image->colormap[
                    ConstrainColormapIndex(image,index,exception)].green),q);
                  index=(ssize_t) GetPixelBlue(image,q);
                  SetPixelBlue(image,ClampToQuantum(image->colormap[
                    ConstrainColormapIndex(image,index,exception)].blue),q);
                }
              SetPixelAlpha(image,image->alpha_trait != UndefinedPixelTrait ?
                ScaleCharToQuantum(*(p+number_pixels*3)) : OpaqueAlpha,q);
              p++;
              q+=GetPixelChannels(image);
            }
            if (SyncAuthenticPixels(image,exception) == MagickFalse)
              break;
            if (image->previous == (Image *) NULL)
              {
                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
                if (status == MagickFalse)
                  break;
              }
          }
        }
    pixels=(unsigned char *) RelinquishMagickMemory(pixels);
    if (image->storage_class == PseudoClass)
      (void) SyncImage(image,exception);
    if (EOFBlob(image) != MagickFalse)
      {
        ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
          image->filename);
        break;
      }
    
    if (image_info->number_scenes != 0)
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    count=ReadBlob(image,1,&viff_info.identifier);
    if ((count == 1) && (viff_info.identifier == 0xab))
      {
        
         AcquireNextImage(image_info,image,exception);
         if (GetNextImageInList(image) == (Image *) NULL)
           {
            status=MagickFalse;
            break;
           }
         image=SyncNextImageInList(image);
         status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
          GetBlobSize(image));
        if (status == MagickFalse)
          break;
      }
  } while ((count != 0) && (viff_info.identifier == 0xab));
  (void) CloseBlob(image);
  if (status == MagickFalse)
    return(DestroyImageList(image));
  return(GetFirstImageInList(image));
}
","1. x;
2. number_pixels=(MagickSizeType) viff_info.columns*viff_info.rows;
3. (viff_info.data_storage_type != VFF_TYP_1_BYTE) &&
4. ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
5. if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))
6. image->colorspace=GRAYColorspace;
7. (void) memset(pixels,0,MagickMax(number_pixels,max_packets)*
8. MSBOrderLong(pixels,bytes_per_pixel*max_packets);
9. switch ((int) viff_info.data_storage_type)
10. case VFF_TYP_DOUBLE: value=((double *) pixels)[i]; break;","92
194
217
291
356
367
398
415
474
479","CWE-416,CWE-190,CWE-284,CWE-119"
string_of_NPNVariable,"const char *string_of_NPNVariable(int variable)
{
  const char *str;

  switch (variable) {
#define _(VAL) case VAL: str = #VAL; break;
	_(NPNVxDisplay);
	_(NPNVxtAppContext);
	_(NPNVnetscapeWindow);
	_(NPNVjavascriptEnabledBool);
	_(NPNVasdEnabledBool);
	_(NPNVisOfflineBool);
	_(NPNVserviceManager);
	_(NPNVDOMElement);
	_(NPNVDOMWindow);
	_(NPNVToolkit);
	_(NPNVSupportsXEmbedBool);
 	_(NPNVWindowNPObject);
 	_(NPNVPluginElementNPObject);
 	_(NPNVSupportsWindowless);
	_(NPNVprivateModeBool);
	_(NPNVsupportsAdvancedKeyHandling);
 #undef _
   default:
 	switch (variable & 0xff) {
#define _(VAL, VAR) case VAL: str = #VAR; break
	  _(10, NPNVserviceManager);
	  _(11, NPNVDOMElement);
	  _(12, NPNVDOMWindow);
	  _(13, NPNVToolkit);
#undef _
	default:
	  str = ""<unknown variable>"";
	  break;
	}
	break;
  }

  return str;
}
","1. const char *string_of_NPNVariable(int variable)
2. const char *str;
3. switch (variable) {
4. _(NPNVxDisplay);
5. _(NPNVjavascriptEnabledBool);
_(NPNVasdEnabledBool);
_(NPNVisOfflineBool);
_(NPNVserviceManager);
6. _(NPNVDOMWindow);
7. _(NPNVSupportsXEmbedBool);
_(NPNVWindowNPObject);
_(NPNVPluginElementNPObject);
8. _(NPNVsupportsAdvancedKeyHandling);
9. switch (variable & 0xff) {
10. _(10, NPNVserviceManager);
11. _(12, NPNVDOMWindow);
_(13, NPNVToolkit);
12. str = ""<unknown variable>"";
13. break;","1
3
5
7
10-13
15
17-19
22
25
27
29-30
33
36","CWE-617,CWE-362,CWE-264,CWE-119,CWE-399"
tls_construct_cke_ecdhe,"
#define SSL

static int tls_construct_cke_ecdhe(SSL *s, unsigned char **p, int *len, int *al)
{
#ifndef OPENSSL_NO_EC
    unsigned char *encodedPoint = NULL;
    int encoded_pt_len = 0;
    EVP_PKEY *ckey = NULL, *skey = NULL;

    skey = s->s3->peer_tmp;
    if (skey == NULL) {
        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);
        return 0;
     }
 
     ckey = ssl_generate_pkey(skey);
    if (ckey == NULL) {
        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);
        goto err;
    }
 
     if (ssl_derive(s, ckey, skey) == 0) {
         SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_EVP_LIB);
        goto err;
    }

    
    encoded_pt_len = EVP_PKEY_get1_tls_encodedpoint(ckey, &encodedPoint);

    if (encoded_pt_len == 0) {
        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_EC_LIB);
        goto err;
    }

    EVP_PKEY_free(ckey);
    ckey = NULL;

    *len = encoded_pt_len;

    
    **p = *len;
    *p += 1;
    
    memcpy(*p, encodedPoint, *len);
    
    *len += 1;

    OPENSSL_free(encodedPoint);

    return 1;
 err:
    EVP_PKEY_free(ckey);
    return 0;
#else
    SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);
    *al = SSL_AD_INTERNAL_ERROR;
    return 0;
#endif
}
","1. int encoded_pt_len = 0;
2. SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);
3. if (ckey == NULL) {
4. if (ssl_derive(s, ckey, skey) == 0) {
5. encoded_pt_len = EVP_PKEY_get1_tls_encodedpoint(ckey, &encodedPoint);
6. SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_EC_LIB);
7. **p = *len;
8. *len += 1;
9. OPENSSL_free(encodedPoint);
10. err:
11. return 0;","8
13
18
23
29
32
42
47
49
52
54","CWE-476,CWE-20,CWE-120,CWE-125"
ieee80211_tx_h_unicast_ps_buf,"ieee80211_tx_h_unicast_ps_buf(struct ieee80211_tx_data *tx)
{
	struct sta_info *sta = tx->sta;
	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);
	struct ieee80211_local *local = tx->local;

	if (unlikely(!sta))
		return TX_CONTINUE;

	if (unlikely((test_sta_flag(sta, WLAN_STA_PS_STA) ||
		      test_sta_flag(sta, WLAN_STA_PS_DRIVER)) &&
		     !(info->flags & IEEE80211_TX_CTL_NO_PS_BUFFER))) {
		int ac = skb_get_queue_mapping(tx->skb);

		ps_dbg(sta->sdata, ""STA %pM aid %d: PS buffer for AC %d\n"",
 		       sta->sta.addr, sta->sta.aid, ac);
 		if (tx->local->total_ps_buffered >= TOTAL_MAX_TX_BUFFER)
 			purge_old_ps_buffers(tx->local);

		
		spin_lock(&sta->ps_lock);
		
		if (!test_sta_flag(sta, WLAN_STA_PS_STA) &&
		    !test_sta_flag(sta, WLAN_STA_PS_DRIVER)) {
			spin_unlock(&sta->ps_lock);
			return TX_CONTINUE;
		}

 		if (skb_queue_len(&sta->ps_tx_buf[ac]) >= STA_MAX_TX_BUFFER) {
 			struct sk_buff *old = skb_dequeue(&sta->ps_tx_buf[ac]);
 			ps_dbg(tx->sdata,
			       ""STA %pM TX buffer for AC %d full - dropping oldest frame\n"",
			       sta->sta.addr, ac);
			ieee80211_free_txskb(&local->hw, old);
		} else
			tx->local->total_ps_buffered++;

		info->control.jiffies = jiffies;
		info->control.vif = &tx->sdata->vif;
 		info->flags |= IEEE80211_TX_INTFL_NEED_TXPROCESSING;
 		info->flags &= ~IEEE80211_TX_TEMPORARY_FLAGS;
 		skb_queue_tail(&sta->ps_tx_buf[ac], tx->skb);
		spin_unlock(&sta->ps_lock);
 
 		if (!timer_pending(&local->sta_cleanup))
 			mod_timer(&local->sta_cleanup,
				  round_jiffies(jiffies +
						STA_INFO_CLEANUP_INTERVAL));

		
		sta_info_recalc_tim(sta);

		return TX_QUEUED;
	} else if (unlikely(test_sta_flag(sta, WLAN_STA_PS_STA))) {
		ps_dbg(tx->sdata,
		       ""STA %pM in PS mode, but polling/in SP -> send frame\n"",
		       sta->sta.addr);
	}

	return TX_CONTINUE;
}
","1. ieee80211_tx_h_unicast_ps_buf(struct ieee80211_tx_data *tx)
2. struct sta_info *sta = tx->sta;
struct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);
struct ieee80211_local *local = tx->local;
3. return TX_CONTINUE;
4. if (unlikely((test_sta_flag(sta, WLAN_STA_PS_STA) ||
test_sta_flag(sta, WLAN_STA_PS_DRIVER)) &&
5. sta->sta.addr, sta->sta.aid, ac);
6. purge_old_ps_buffers(tx->local);
7. !test_sta_flag(sta, WLAN_STA_PS_DRIVER)) {
8. struct sk_buff *old = skb_dequeue(&sta->ps_tx_buf[ac]);
ps_dbg(tx->sdata,
""STA %pM TX buffer for AC %d full - dropping oldest frame\n"",
sta->sta.addr, ac);
9. info->flags &= ~IEEE80211_TX_TEMPORARY_FLAGS;
skb_queue_tail(&sta->ps_tx_buf[ac], tx->skb);
10. if (!timer_pending(&local->sta_cleanup))
mod_timer(&local->sta_cleanup,
11. sta_info_recalc_tim(sta);
12. } else if (unlikely(test_sta_flag(sta, WLAN_STA_PS_STA))) {
ps_dbg(tx->sdata,
""STA %pM in PS mode, but polling/in SP -> send frame\n"",
sta->sta.addr);
13. return TX_CONTINUE;","1
3-5
8
10-11
16
18
28
34-37
45-46
49-50
58
61-64
67","CWE-362,CWE-20,CWE-189,CWE-119"
fp24_exp_cyc_sps-102105593159304,"void fp24_exp_cyc_sps(fp24_t c, const fp24_t a, const int *b, size_t len,
		int sign) {
	size_t i, j, k, w = len;
    fp24_t t, *u = RLC_ALLOCA(fp24_t, w);

	if (len == 0) {
		RLC_FREE(u);
		fp24_set_dig(c, 1);
		return;
	}

	fp24_null(t);

	RLC_TRY {
		if (u == NULL) {
			RLC_THROW(ERR_NO_MEMORY);
		}
		for (i = 0; i < w; i++) {
			fp24_null(u[i]);
			fp24_new(u[i]);
		}
		fp24_new(t);

		fp24_copy(t, a);
		if (b[0] == 0) {
			for (j = 0, i = 1; i < len; i++) {
				k = (b[i] < 0 ? -b[i] : b[i]);
				for (; j < k; j++) {
					fp24_sqr_pck(t, t);
				}
				if (b[i] < 0) {
					fp24_inv_cyc(u[i - 1], t);
				} else {
					fp24_copy(u[i - 1], t);
				}
			}

			fp24_back_cyc_sim(u, u, w - 1);

			fp24_copy(c, a);
			for (i = 0; i < w - 1; i++) {
				fp24_mul(c, c, u[i]);
			}
		} else {
			for (j = 0, i = 0; i < len; i++) {
				k = (b[i] < 0 ? -b[i] : b[i]);
				for (; j < k; j++) {
					fp24_sqr_pck(t, t);
				}
				if (b[i] < 0) {
					fp24_inv_cyc(u[i], t);
				} else {
					fp24_copy(u[i], t);
				}
			}

			fp24_back_cyc_sim(u, u, w);

			fp24_copy(c, u[0]);
			for (i = 1; i < w; i++) {
				fp24_mul(c, c, u[i]);
			}
		}

		if (sign == RLC_NEG) {
			fp24_inv_cyc(c, c);
		}
	}
	RLC_CATCH_ANY {
		RLC_THROW(ERR_CAUGHT);
	}
	RLC_FINALLY {
		for (i = 0; i < w; i++) {
			fp24_free(u[i]);
		}
		fp24_free(t);
		RLC_FREE(u);
	}
}
","1. fp24_t t, *u = RLC_ALLOCA(fp24_t, w);
2. if (len == 0) {
RLC_FREE(u);
fp24_set_dig(c, 1);
3. RLC_THROW(ERR_NO_MEMORY);
4. fp24_new(u[i]);
5. k = (b[i] < 0 ? -b[i] : b[i]);
for (; j < k; j++) {
6. if (b[i] < 0) {
7. fp24_back_cyc_sim(u, u, w - 1);
8. fp24_copy(c, a);
9. } else {
10. for (; j < k; j++) {
fp24_sqr_pck(t, t);
11. if (b[i] < 0) {
fp24_inv_cyc(u[i], t);
12. fp24_back_cyc_sim(u, u, w);
13. fp24_copy(c, u[0]);
14. fp24_inv_cyc(c, c);
15. RLC_FINALLY {
16. fp24_free(t);","4
6-8
16
20
27-28
31
38
40
44
47-48
50-51
57
59
66
72
76","CWE-119,CWE-190,CWE-400"
xdr_nullstring,"
#define XDR

bool_t xdr_nullstring(XDR *xdrs, char **objp)
{
     u_int size;

     if (xdrs->x_op == XDR_ENCODE) {
	  if (*objp == NULL)
	       size = 0;
	  else
	       size = strlen(*objp) + 1;
     }
     if (! xdr_u_int(xdrs, &size)) {
	  return FALSE;
	}
     switch (xdrs->x_op) {
     case XDR_DECODE:
	  if (size == 0) {
	       *objp = NULL;
	       return TRUE;
	  } else if (*objp == NULL) {
	       *objp = (char *) mem_alloc(size);
	       if (*objp == NULL) {
		    errno = ENOMEM;
 		    return FALSE;
 	       }
 	  }
	  if (!xdr_opaque(xdrs, *objp, size))
		  return FALSE;
	  
	  if ((*objp)[size - 1] != '\0')
		  return FALSE;
	  if (memchr(*objp, '\0', size - 1) != NULL)
		  return FALSE;
	  return TRUE;
 
      case XDR_ENCODE:
 	  if (size != 0)
	       return (xdr_opaque(xdrs, *objp, size));
	  return TRUE;

     case XDR_FREE:
	  if (*objp != NULL)
	       mem_free(*objp, size);
	  *objp = NULL;
	  return TRUE;
     }

     return FALSE;
}
","1. u_int size;
2. if (xdrs->x_op == XDR_ENCODE) {
if (*objp == NULL)
size = 0;
3. return FALSE;
4. case XDR_DECODE:
if (size == 0) {
*objp = NULL;
5. } else if (*objp == NULL) {
*objp = (char *) mem_alloc(size);
if (*objp == NULL) {
6. return FALSE;
7. if (!xdr_opaque(xdrs, *objp, size))
return FALSE;
8. if ((*objp)[size - 1] != '\0')
9. return FALSE;
10. case XDR_ENCODE:
11. return TRUE;
12. *objp = NULL;
return TRUE;","6
8-10
15
18-20
22-24
26
29-30
32
35
38
41
46-47","CWE-125,CWE-119"
RunMemCheck,"   void RunMemCheck() {
     ACMRandom rnd(ACMRandom::DeterministicSeed());
     const int count_test_block = 5000;
    DECLARE_ALIGNED(16, int16_t, input_extreme_block[kNumCoeffs]);
    DECLARE_ALIGNED(16, tran_low_t, output_ref_block[kNumCoeffs]);
    DECLARE_ALIGNED(16, tran_low_t, output_block[kNumCoeffs]);
 
     for (int i = 0; i < count_test_block; ++i) {
      
       for (int j = 0; j < kNumCoeffs; ++j) {
        input_extreme_block[j] = rnd.Rand8() % 2 ? mask_ : -mask_;
       }
      if (i == 0) {
         for (int j = 0; j < kNumCoeffs; ++j)
          input_extreme_block[j] = mask_;
      } else if (i == 1) {
         for (int j = 0; j < kNumCoeffs; ++j)
          input_extreme_block[j] = -mask_;
      }
 
       fwd_txfm_ref(input_extreme_block, output_ref_block, pitch_, tx_type_);
      ASM_REGISTER_STATE_CHECK(RunFwdTxfm(input_extreme_block,
                                          output_block, pitch_));
 
       for (int j = 0; j < kNumCoeffs; ++j) {
         EXPECT_EQ(output_block[j], output_ref_block[j]);
        EXPECT_GE(4 * DCT_MAX_VALUE << (bit_depth_ - 8), abs(output_block[j]))
            << ""Error: 4x4 FDCT has coefficient larger than 4*DCT_MAX_VALUE"";
       }
     }
   }
","1. void RunMemCheck() {
2. const int count_test_block = 5000;
DECLARE_ALIGNED(16, int16_t, input_extreme_block[kNumCoeffs]);
3. DECLARE_ALIGNED(16, tran_low_t, output_block[kNumCoeffs]);
4. for (int i = 0; i < count_test_block; ++i) {
5. for (int j = 0; j < kNumCoeffs; ++j) {
6. for (int j = 0; j < kNumCoeffs; ++j)
input_extreme_block[j] = mask_;
} else if (i == 1) {
for (int j = 0; j < kNumCoeffs; ++j)
input_extreme_block[j] = -mask_;
7. fwd_txfm_ref(input_extreme_block, output_ref_block, pitch_, tx_type_);
ASM_REGISTER_STATE_CHECK(RunFwdTxfm(input_extreme_block,
8. for (int j = 0; j < kNumCoeffs; ++j) {","1
3-4
6
8
10
14-18
21-22
25",CWE-119
ape_read_header-35297365278823,"
#define AVFormatContext
#define AVFormatParameters

static int ape_read_header(AVFormatContext * s, AVFormatParameters * ap)
{
    AVIOContext *pb = s->pb;
    APEContext *ape = s->priv_data;
    AVStream *st;
    uint32_t tag;
    int i;
    int total_blocks;
    int64_t pts;

    
    ape->junklength = 0;

    tag = avio_rl32(pb);
    if (tag != MKTAG('M', 'A', 'C', ' '))
        return -1;

    ape->fileversion = avio_rl16(pb);

    if (ape->fileversion < APE_MIN_VERSION || ape->fileversion > APE_MAX_VERSION) {
        av_log(s, AV_LOG_ERROR, ""Unsupported file version - %d.%02d\n"", ape->fileversion / 1000, (ape->fileversion % 1000) / 10);
        return -1;
    }

    if (ape->fileversion >= 3980) {
        ape->padding1             = avio_rl16(pb);
        ape->descriptorlength     = avio_rl32(pb);
        ape->headerlength         = avio_rl32(pb);
        ape->seektablelength      = avio_rl32(pb);
        ape->wavheaderlength      = avio_rl32(pb);
        ape->audiodatalength      = avio_rl32(pb);
        ape->audiodatalength_high = avio_rl32(pb);
        ape->wavtaillength        = avio_rl32(pb);
        avio_read(pb, ape->md5, 16);

        
        if (ape->descriptorlength > 52)
            avio_seek(pb, ape->descriptorlength - 52, SEEK_CUR);

        
        ape->compressiontype      = avio_rl16(pb);
        ape->formatflags          = avio_rl16(pb);
        ape->blocksperframe       = avio_rl32(pb);
        ape->finalframeblocks     = avio_rl32(pb);
        ape->totalframes          = avio_rl32(pb);
        ape->bps                  = avio_rl16(pb);
        ape->channels             = avio_rl16(pb);
        ape->samplerate           = avio_rl32(pb);
    } else {
        ape->descriptorlength = 0;
        ape->headerlength = 32;

        ape->compressiontype      = avio_rl16(pb);
        ape->formatflags          = avio_rl16(pb);
        ape->channels             = avio_rl16(pb);
        ape->samplerate           = avio_rl32(pb);
        ape->wavheaderlength      = avio_rl32(pb);
        ape->wavtaillength        = avio_rl32(pb);
        ape->totalframes          = avio_rl32(pb);
        ape->finalframeblocks     = avio_rl32(pb);

        if (ape->formatflags & MAC_FORMAT_FLAG_HAS_PEAK_LEVEL) {
            avio_seek(pb, 4, SEEK_CUR); 
            ape->headerlength += 4;
        }

        if (ape->formatflags & MAC_FORMAT_FLAG_HAS_SEEK_ELEMENTS) {
            ape->seektablelength = avio_rl32(pb);
            ape->headerlength += 4;
            ape->seektablelength *= sizeof(int32_t);
        } else
            ape->seektablelength = ape->totalframes * sizeof(int32_t);

        if (ape->formatflags & MAC_FORMAT_FLAG_8_BIT)
            ape->bps = 8;
        else if (ape->formatflags & MAC_FORMAT_FLAG_24_BIT)
            ape->bps = 24;
        else
            ape->bps = 16;

        if (ape->fileversion >= 3950)
            ape->blocksperframe = 73728 * 4;
        else if (ape->fileversion >= 3900 || (ape->fileversion >= 3800  && ape->compressiontype >= 4000))
            ape->blocksperframe = 73728;
        else
            ape->blocksperframe = 9216;

        
        if (!(ape->formatflags & MAC_FORMAT_FLAG_CREATE_WAV_HEADER))
            avio_seek(pb, ape->wavheaderlength, SEEK_CUR);
    }

    if(!ape->totalframes){
        av_log(s, AV_LOG_ERROR, ""No frames in the file!\n"");
        return AVERROR(EINVAL);
    }
    if(ape->totalframes > UINT_MAX / sizeof(APEFrame)){
        av_log(s, AV_LOG_ERROR, ""Too many frames: %d\n"", ape->totalframes);
        return -1;
    }
    ape->frames       = av_malloc(ape->totalframes * sizeof(APEFrame));
    if(!ape->frames)
        return AVERROR(ENOMEM);
    ape->firstframe   = ape->junklength + ape->descriptorlength + ape->headerlength + ape->seektablelength + ape->wavheaderlength;
    ape->currentframe = 0;


    ape->totalsamples = ape->finalframeblocks;
    if (ape->totalframes > 1)
        ape->totalsamples += ape->blocksperframe * (ape->totalframes - 1);

    if (ape->seektablelength > 0) {
        ape->seektable = av_malloc(ape->seektablelength);
        for (i = 0; i < ape->seektablelength / sizeof(uint32_t); i++)
            ape->seektable[i] = avio_rl32(pb);
    }

    ape->frames[0].pos     = ape->firstframe;
    ape->frames[0].nblocks = ape->blocksperframe;
    ape->frames[0].skip    = 0;
    for (i = 1; i < ape->totalframes; i++) {
        ape->frames[i].pos      = ape->seektable[i]; 
        ape->frames[i].nblocks  = ape->blocksperframe;
        ape->frames[i - 1].size = ape->frames[i].pos - ape->frames[i - 1].pos;
        ape->frames[i].skip     = (ape->frames[i].pos - ape->frames[0].pos) & 3;
    }
    ape->frames[ape->totalframes - 1].size    = ape->finalframeblocks * 4;
    ape->frames[ape->totalframes - 1].nblocks = ape->finalframeblocks;

    for (i = 0; i < ape->totalframes; i++) {
        if(ape->frames[i].skip){
            ape->frames[i].pos  -= ape->frames[i].skip;
            ape->frames[i].size += ape->frames[i].skip;
        }
        ape->frames[i].size = (ape->frames[i].size + 3) & ~3;
    }


    ape_dumpinfo(s, ape);

    
    if (!url_is_streamed(pb)) {
        ff_ape_parse_tag(s);
        avio_seek(pb, 0, SEEK_SET);
    }

    av_log(s, AV_LOG_DEBUG, ""Decoding file - v%d.%02d, compression level %d\n"", ape->fileversion / 1000, (ape->fileversion % 1000) / 10, ape->compressiontype);

    
    st = av_new_stream(s, 0);
    if (!st)
        return -1;

    total_blocks = (ape->totalframes == 0) ? 0 : ((ape->totalframes - 1) * ape->blocksperframe) + ape->finalframeblocks;

    st->codec->codec_type      = AVMEDIA_TYPE_AUDIO;
    st->codec->codec_id        = CODEC_ID_APE;
    st->codec->codec_tag       = MKTAG('A', 'P', 'E', ' ');
    st->codec->channels        = ape->channels;
    st->codec->sample_rate     = ape->samplerate;
    st->codec->bits_per_coded_sample = ape->bps;
    st->codec->frame_size      = MAC_SUBFRAME_SIZE;

    st->nb_frames = ape->totalframes;
    st->start_time = 0;
    st->duration  = total_blocks / MAC_SUBFRAME_SIZE;
    av_set_pts_info(st, 64, MAC_SUBFRAME_SIZE, ape->samplerate);

    st->codec->extradata = av_malloc(APE_EXTRADATA_SIZE);
    st->codec->extradata_size = APE_EXTRADATA_SIZE;
    AV_WL16(st->codec->extradata + 0, ape->fileversion);
    AV_WL16(st->codec->extradata + 2, ape->compressiontype);
    AV_WL16(st->codec->extradata + 4, ape->formatflags);

    pts = 0;
    for (i = 0; i < ape->totalframes; i++) {
        ape->frames[i].pts = pts;
        av_add_index_entry(st, ape->frames[i].pos, ape->frames[i].pts, 0, 0, AVINDEX_KEYFRAME);
        pts += ape->blocksperframe / MAC_SUBFRAME_SIZE;
    }

    return 0;
}
","1. AVIOContext *pb = s->pb;
2. ape->blocksperframe       = avio_rl32(pb);
3. ape->channels             = avio_rl16(pb);
4. ape->descriptorlength = 0;
5. ape->samplerate           = avio_rl32(pb);
6. avio_seek(pb, 4, SEEK_CUR);
7. ape->headerlength += 4;
ape->seektablelength *= sizeof(int32_t);
8. ape->seektablelength = ape->totalframes * sizeof(int32_t);
9. if (ape->fileversion >= 3950)
10. ape->currentframe = 0;
11. if (ape->seektablelength > 0) {
12. ape->frames[i].nblocks  = ape->blocksperframe;
ape->frames[i - 1].size = ape->frames[i].pos - ape->frames[i - 1].pos;
13. ape->frames[ape->totalframes - 1].nblocks = ape->finalframeblocks;
14. ape->frames[i].pos  -= ape->frames[i].skip;
15. if (!url_is_streamed(pb)) {
16. st = av_new_stream(s, 0);
17. total_blocks = (ape->totalframes == 0) ? 0 : ((ape->totalframes - 1) * ape->blocksperframe) + ape->finalframeblocks;
18. st->codec->sample_rate     = ape->samplerate;
19. st->codec->extradata = av_malloc(APE_EXTRADATA_SIZE);
20. AV_WL16(st->codec->extradata + 2, ape->compressiontype);
21. for (i = 0; i < ape->totalframes; i++) {","7
48
52
55
61
68
74-75
77
86
110
117
128-129
133
137
147
155
159
165
174
177
181","CWE-129,CWE-125,CWE-401"
build_ntlmssp_auth_blob-121685818971547,"int build_ntlmssp_auth_blob(unsigned char **pbuffer,
					u16 *buflen,
				   struct cifs_ses *ses,
				   const struct nls_table *nls_cp)
{
	int rc;
	AUTHENTICATE_MESSAGE *sec_blob;
	__u32 flags;
	unsigned char *tmp;

	rc = setup_ntlmv2_rsp(ses, nls_cp);
	if (rc) {
		cifs_dbg(VFS, ""Error %d during NTLMSSP authentication\n"", rc);
		*buflen = 0;
		goto setup_ntlmv2_ret;
	}
	*pbuffer = kmalloc(size_of_ntlmssp_blob(ses), GFP_KERNEL);
	sec_blob = (AUTHENTICATE_MESSAGE *)*pbuffer;

	memcpy(sec_blob->Signature, NTLMSSP_SIGNATURE, 8);
	sec_blob->MessageType = NtLmAuthenticate;

	flags = NTLMSSP_NEGOTIATE_56 |
		NTLMSSP_REQUEST_TARGET | NTLMSSP_NEGOTIATE_TARGET_INFO |
		NTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |
		NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC |
		NTLMSSP_NEGOTIATE_SEAL;
	if (ses->server->sign)
		flags |= NTLMSSP_NEGOTIATE_SIGN;
	if (!ses->server->session_estab || ses->ntlmssp->sesskey_per_smbsess)
		flags |= NTLMSSP_NEGOTIATE_KEY_XCH;

	tmp = *pbuffer + sizeof(AUTHENTICATE_MESSAGE);
	sec_blob->NegotiateFlags = cpu_to_le32(flags);

	sec_blob->LmChallengeResponse.BufferOffset =
				cpu_to_le32(sizeof(AUTHENTICATE_MESSAGE));
	sec_blob->LmChallengeResponse.Length = 0;
	sec_blob->LmChallengeResponse.MaximumLength = 0;

	sec_blob->NtChallengeResponse.BufferOffset =
				cpu_to_le32(tmp - *pbuffer);
	if (ses->user_name != NULL) {
		memcpy(tmp, ses->auth_key.response + CIFS_SESS_KEY_SIZE,
				ses->auth_key.len - CIFS_SESS_KEY_SIZE);
		tmp += ses->auth_key.len - CIFS_SESS_KEY_SIZE;

		sec_blob->NtChallengeResponse.Length =
				cpu_to_le16(ses->auth_key.len - CIFS_SESS_KEY_SIZE);
		sec_blob->NtChallengeResponse.MaximumLength =
				cpu_to_le16(ses->auth_key.len - CIFS_SESS_KEY_SIZE);
	} else {
		
		sec_blob->NtChallengeResponse.Length = 0;
		sec_blob->NtChallengeResponse.MaximumLength = 0;
	}

	if (ses->domainName == NULL) {
		sec_blob->DomainName.BufferOffset = cpu_to_le32(tmp - *pbuffer);
		sec_blob->DomainName.Length = 0;
		sec_blob->DomainName.MaximumLength = 0;
		tmp += 2;
	} else {
		int len;
		len = cifs_strtoUTF16((__le16 *)tmp, ses->domainName,
				      CIFS_MAX_DOMAINNAME_LEN, nls_cp);
		len *= 2; 
		sec_blob->DomainName.BufferOffset = cpu_to_le32(tmp - *pbuffer);
		sec_blob->DomainName.Length = cpu_to_le16(len);
		sec_blob->DomainName.MaximumLength = cpu_to_le16(len);
		tmp += len;
	}

	if (ses->user_name == NULL) {
		sec_blob->UserName.BufferOffset = cpu_to_le32(tmp - *pbuffer);
		sec_blob->UserName.Length = 0;
		sec_blob->UserName.MaximumLength = 0;
		tmp += 2;
	} else {
		int len;
		len = cifs_strtoUTF16((__le16 *)tmp, ses->user_name,
				      CIFS_MAX_USERNAME_LEN, nls_cp);
		len *= 2; 
		sec_blob->UserName.BufferOffset = cpu_to_le32(tmp - *pbuffer);
		sec_blob->UserName.Length = cpu_to_le16(len);
		sec_blob->UserName.MaximumLength = cpu_to_le16(len);
		tmp += len;
	}

	sec_blob->WorkstationName.BufferOffset = cpu_to_le32(tmp - *pbuffer);
	sec_blob->WorkstationName.Length = 0;
	sec_blob->WorkstationName.MaximumLength = 0;
	tmp += 2;

	if (((ses->ntlmssp->server_flags & NTLMSSP_NEGOTIATE_KEY_XCH) ||
		(ses->ntlmssp->server_flags & NTLMSSP_NEGOTIATE_EXTENDED_SEC))
			&& !calc_seckey(ses)) {
		memcpy(tmp, ses->ntlmssp->ciphertext, CIFS_CPHTXT_SIZE);
		sec_blob->SessionKey.BufferOffset = cpu_to_le32(tmp - *pbuffer);
		sec_blob->SessionKey.Length = cpu_to_le16(CIFS_CPHTXT_SIZE);
		sec_blob->SessionKey.MaximumLength =
				cpu_to_le16(CIFS_CPHTXT_SIZE);
		tmp += CIFS_CPHTXT_SIZE;
	} else {
		sec_blob->SessionKey.BufferOffset = cpu_to_le32(tmp - *pbuffer);
		sec_blob->SessionKey.Length = 0;
		sec_blob->SessionKey.MaximumLength = 0;
	}

	*buflen = tmp - *pbuffer;
setup_ntlmv2_ret:
	return rc;
}
","1. int build_ntlmssp_auth_blob(unsigned char **pbuffer,
2. sec_blob->MessageType = NtLmAuthenticate;
3. flags = NTLMSSP_NEGOTIATE_56 |
4. if (!ses->server->session_estab || ses->ntlmssp->sesskey_per_smbsess)
flags |= NTLMSSP_NEGOTIATE_KEY_XCH;
5. sec_blob->LmChallengeResponse.Length = 0;
6. if (ses->user_name != NULL) {
7. cpu_to_le16(ses->auth_key.len - CIFS_SESS_KEY_SIZE);
sec_blob->NtChallengeResponse.MaximumLength =
8. CIFS_MAX_USERNAME_LEN, nls_cp);
9. tmp += len;
10. (ses->ntlmssp->server_flags & NTLMSSP_NEGOTIATE_EXTENDED_SEC))
11. setup_ntlmv2_ret:","1
21
23
30-31
38
43
49-50
84
89
98
113","CWE-362,CWE-404,CWE-787,CWE-119"
syscall_obj_generate_key,"TEE_Result syscall_obj_generate_key(unsigned long obj, unsigned long key_size,
			const struct utee_attribute *usr_params,
			unsigned long param_count)
{
	TEE_Result res;
	struct tee_ta_session *sess;
	const struct tee_cryp_obj_type_props *type_props;
	struct tee_obj *o;
	struct tee_cryp_obj_secret *key;
	size_t byte_size;
	TEE_Attribute *params = NULL;

	res = tee_ta_get_current_session(&sess);
	if (res != TEE_SUCCESS)
		return res;

	res = tee_obj_get(to_user_ta_ctx(sess->ctx),
			  tee_svc_uref_to_vaddr(obj), &o);
	if (res != TEE_SUCCESS)
		return res;

	
	if ((o->info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT) != 0)
		return TEE_ERROR_BAD_STATE;

	
	if ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) != 0)
		return TEE_ERROR_BAD_STATE;

	
	type_props = tee_svc_find_type_props(o->info.objectType);
	if (!type_props)
		return TEE_ERROR_NOT_SUPPORTED;

	
	if (key_size % type_props->quanta != 0)
		return TEE_ERROR_NOT_SUPPORTED;
	if (key_size < type_props->min_size)
		return TEE_ERROR_NOT_SUPPORTED;
 	if (key_size > type_props->max_size)
 		return TEE_ERROR_NOT_SUPPORTED;
 
	size_t alloc_size = 0;

	if (MUL_OVERFLOW(sizeof(TEE_Attribute), param_count, &alloc_size))
		return TEE_ERROR_OVERFLOW;

	params = malloc(alloc_size);
 	if (!params)
 		return TEE_ERROR_OUT_OF_MEMORY;
 	res = copy_in_attrs(to_user_ta_ctx(sess->ctx), usr_params, param_count,
			    params);
	if (res != TEE_SUCCESS)
		goto out;

	res = tee_svc_cryp_check_attr(ATTR_USAGE_GENERATE_KEY, type_props,
				      params, param_count);
	if (res != TEE_SUCCESS)
		goto out;

	switch (o->info.objectType) {
	case TEE_TYPE_AES:
	case TEE_TYPE_DES:
	case TEE_TYPE_DES3:
	case TEE_TYPE_HMAC_MD5:
	case TEE_TYPE_HMAC_SHA1:
	case TEE_TYPE_HMAC_SHA224:
	case TEE_TYPE_HMAC_SHA256:
	case TEE_TYPE_HMAC_SHA384:
	case TEE_TYPE_HMAC_SHA512:
	case TEE_TYPE_GENERIC_SECRET:
		byte_size = key_size / 8;

		
		if (o->info.objectType == TEE_TYPE_DES ||
		    o->info.objectType == TEE_TYPE_DES3) {
			byte_size = (key_size + key_size / 7) / 8;
		}

		key = (struct tee_cryp_obj_secret *)o->attr;
		if (byte_size > key->alloc_size) {
			res = TEE_ERROR_EXCESS_DATA;
			goto out;
		}

		res = crypto_rng_read((void *)(key + 1), byte_size);
		if (res != TEE_SUCCESS)
			goto out;

		key->key_size = byte_size;

		
		o->have_attrs = (1 << type_props->num_type_attrs) - 1;

		break;

	case TEE_TYPE_RSA_KEYPAIR:
		res = tee_svc_obj_generate_key_rsa(o, type_props, key_size,
						   params, param_count);
		if (res != TEE_SUCCESS)
			goto out;
		break;

	case TEE_TYPE_DSA_KEYPAIR:
		res = tee_svc_obj_generate_key_dsa(o, type_props, key_size);
		if (res != TEE_SUCCESS)
			goto out;
		break;

	case TEE_TYPE_DH_KEYPAIR:
		res = tee_svc_obj_generate_key_dh(o, type_props, key_size,
						  params, param_count);
		if (res != TEE_SUCCESS)
			goto out;
		break;

	case TEE_TYPE_ECDSA_KEYPAIR:
	case TEE_TYPE_ECDH_KEYPAIR:
		res = tee_svc_obj_generate_key_ecc(o, type_props, key_size,
						  params, param_count);
		if (res != TEE_SUCCESS)
			goto out;
		break;

	default:
		res = TEE_ERROR_BAD_FORMAT;
	}

out:
	free(params);
	if (res == TEE_SUCCESS) {
		o->info.keySize = key_size;
		o->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;
	}
	return res;
}
","1. const struct utee_attribute *usr_params,
2. return res;
3. if ((o->info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT) != 0)
4. return TEE_ERROR_OVERFLOW;
5. params = malloc(alloc_size);
6. case TEE_TYPE_GENERIC_SECRET:
7. if (byte_size > key->alloc_size) {
8. case TEE_TYPE_RSA_KEYPAIR:
9. if (res != TEE_SUCCESS)
goto out;","2
20
23
46
48
71
84
100
103-104","CWE-190,CWE-119"
mif_hdr_get," static mif_hdr_t *mif_hdr_get(jas_stream_t *in)
 {
	jas_uchar magicbuf[MIF_MAGICLEN];
 	char buf[4096];
 	mif_hdr_t *hdr;
 	bool done;
	jas_tvparser_t *tvp;
	int id;

	hdr = 0;
	tvp = 0;

	if (jas_stream_read(in, magicbuf, MIF_MAGICLEN) != MIF_MAGICLEN) {
		goto error;
	}
	if (magicbuf[0] != (MIF_MAGIC >> 24) || magicbuf[1] != ((MIF_MAGIC >> 16) &
	  0xff) || magicbuf[2] != ((MIF_MAGIC >> 8) & 0xff) || magicbuf[3] !=
	  (MIF_MAGIC & 0xff)) {
		jas_eprintf(""error: bad signature\n"");
		goto error;
	}

	if (!(hdr = mif_hdr_create(0))) {
		goto error;
	}

	done = false;
	do {
		if (!mif_getline(in, buf, sizeof(buf))) {
			jas_eprintf(""mif_getline failed\n"");
			goto error;
		}
		if (buf[0] == '\0') {
			continue;
		}
		JAS_DBGLOG(10, (""header line: len=%d; %s\n"", strlen(buf), buf));
		if (!(tvp = jas_tvparser_create(buf))) {
			jas_eprintf(""jas_tvparser_create failed\n"");
			goto error;
		}
		if (jas_tvparser_next(tvp)) {
			jas_eprintf(""cannot get record type\n"");
			goto error;
		}
		id = jas_taginfo_nonull(jas_taginfos_lookup(mif_tags2,
		  jas_tvparser_gettag(tvp)))->id;
		jas_tvparser_destroy(tvp);
		tvp = 0;
		switch (id) {
		case MIF_CMPT:
			if (mif_process_cmpt(hdr, buf)) {
				jas_eprintf(""cannot get component information\n"");
				goto error;
			}
			break;
		case MIF_END:
			done = 1;
			break;
		default:
			jas_eprintf(""invalid header information: %s\n"", buf);
			goto error;
			break;
		}
	} while (!done);

	return hdr;

error:
	if (hdr) {
		mif_hdr_destroy(hdr);
	}
	if (tvp) {
		jas_tvparser_destroy(tvp);
	}
	return 0;
}
","1. JAS_DBGLOG(10, (""header line: len=%d; %s\n"", strlen(buf), buf));
2. switch (id) {
3. break;
4. break;
5. } while (!done);
6. return 0;","36
49
58
62
64
75","CWE-20,CWE-78,CWE-787,CWE-125,CWE-399"
get_info_from_frame-90503178350896,"static void get_info_from_frame (mpeg2ps_stream_t *sptr,
                                 u8 *buffer,
                                 u32 buflen)
{
	if (sptr->is_video) {
		if (MPEG12_ParseSeqHdr(buffer, buflen,
		                       &sptr->have_mpeg2,
		                       &sptr->h,
		                       &sptr->w,
		                       &sptr->frame_rate,
		                       &sptr->bit_rate,
		                       &sptr->par) < 0) {
			sptr->m_stream_id = 0;
			sptr->m_fd = FDNULL;
			return;
		}
		sptr->ticks_per_frame = (u64)(90000.0 / sptr->frame_rate);
		return;
	}

	if (sptr->m_stream_id >= 0xc0) {
		
		u32 hdr = GF_4CC((u32)buffer[0],buffer[1],buffer[2],buffer[3]);

		sptr->channels = gf_mp3_num_channels(hdr);
		sptr->freq = gf_mp3_sampling_rate(hdr);
		sptr->samples_per_frame = gf_mp3_window_size(hdr);
		sptr->bitrate = gf_mp3_bit_rate(hdr) * 1000; 
		sptr->layer = gf_mp3_layer(hdr);
	} else if (sptr->m_stream_id == 0xbd) {
		if (sptr->m_substream_id >= 0xa0) {
			
		} else if (sptr->m_substream_id >= 0x80) {
			u32 pos;
			GF_AC3Config hdr;
			memset(&hdr, 0, sizeof(GF_AC3Config));
			gf_ac3_parser(buffer, buflen, &pos, &hdr, 0);
			sptr->bitrate = gf_ac3_get_bitrate(hdr.brcode);
			sptr->freq = hdr.sample_rate;
			sptr->channels = hdr.streams[0].channels;
			sptr->samples_per_frame = 256 * 6;
		} else {
			return;
		}
	} else {
		return;
	}
}
","1. if (MPEG12_ParseSeqHdr(buffer, buflen,
&sptr->have_mpeg2,
2. &sptr->w,
3. return;
4. sptr->freq = gf_mp3_sampling_rate(hdr);
5. gf_ac3_parser(buffer, buflen, &pos, &hdr, 0);
6. return;","6-7
9
15
26
37
43","CWE-20,CWE-125,CWE-119"
process_nested_data-210793174695991,"
#define HashTable
#define UNSERIALIZE_PARAMETER

static inline int process_nested_data(UNSERIALIZE_PARAMETER, HashTable *ht, long elements, int objprops)
{
	while (elements-- > 0) {
		zval *key, *data, **old_data;

		ALLOC_INIT_ZVAL(key);

		if (!php_var_unserialize(&key, p, max, NULL TSRMLS_CC)) {
			zval_dtor(key);
			FREE_ZVAL(key);
			return 0;
		}

		if (Z_TYPE_P(key) != IS_LONG && Z_TYPE_P(key) != IS_STRING) {
			zval_dtor(key);
			FREE_ZVAL(key);
			return 0;
		}

		ALLOC_INIT_ZVAL(data);

		if (!php_var_unserialize(&data, p, max, var_hash TSRMLS_CC)) {
			zval_dtor(key);
			FREE_ZVAL(key);
			zval_dtor(data);
			FREE_ZVAL(data);
			return 0;
		}

		if (!objprops) {
			switch (Z_TYPE_P(key)) {
			case IS_LONG:
				if (zend_hash_index_find(ht, Z_LVAL_P(key), (void **)&old_data)==SUCCESS) {
					var_push_dtor(var_hash, old_data);
				}
				zend_hash_index_update(ht, Z_LVAL_P(key), &data, sizeof(data), NULL);
				break;
			case IS_STRING:
				if (zend_symtable_find(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, (void **)&old_data)==SUCCESS) {
					var_push_dtor(var_hash, old_data);
				}
				zend_symtable_update(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, &data, sizeof(data), NULL);
				break;
			}
		} else {
			
			convert_to_string(key);
			if (zend_hash_find(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, (void **)&old_data)==SUCCESS) {
				var_push_dtor(var_hash, old_data);
			}
			zend_hash_update(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, &data,
					sizeof data, NULL);
		}
		
		zval_dtor(key);
		FREE_ZVAL(key);

		if (elements && *(*p-1) != ';' && *(*p-1) != '}') {
			(*p)--;
			return 0;
		}
	}

	return 1;
}
","1. if (Z_TYPE_P(key) != IS_LONG && Z_TYPE_P(key) != IS_STRING) {
2. ALLOC_INIT_ZVAL(data);
3. zval_dtor(data);
4. switch (Z_TYPE_P(key)) {
5. if (zend_symtable_find(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, (void **)&old_data)==SUCCESS) {
6. var_push_dtor(var_hash, old_data);","18
24
29
35
43
53","CWE-190,CWE-125"
sco_sock_bind,"static int sco_sock_bind(struct socket *sock, struct sockaddr *addr,
			 int addr_len)
{
	struct sockaddr_sco *sa = (struct sockaddr_sco *) addr;
	struct sock *sk = sock->sk;
	int err = 0;

	BT_DBG(""sk %p %pMR"", sk, &sa->sco_bdaddr);

 	if (!addr || addr->sa_family != AF_BLUETOOTH)
 		return -EINVAL;
 
	if (addr_len < sizeof(struct sockaddr_sco))
		return -EINVAL;

 	lock_sock(sk);
 
 	if (sk->sk_state != BT_OPEN) {
		err = -EBADFD;
		goto done;
	}

	if (sk->sk_type != SOCK_SEQPACKET) {
		err = -EINVAL;
		goto done;
	}

	bacpy(&sco_pi(sk)->src, &sa->sco_bdaddr);

	sk->sk_state = BT_BOUND;

done:
	release_sock(sk);
	return err;
}
","1. int addr_len)
2. struct sockaddr_sco *sa = (struct sockaddr_sco *) addr;
3. int err = 0;
4. if (!addr || addr->sa_family != AF_BLUETOOTH)
5. return -EINVAL;
6. lock_sock(sk);
7. if (sk->sk_type != SOCK_SEQPACKET) {
8. bacpy(&sco_pi(sk)->src, &sa->sco_bdaddr);","2
4
6
10
14
16
23
28","CWE-189,CWE-200,CWE-285,CWE-787,CWE-119"
read_super_2-67382261958027,"int read_super_2(squashfs_operations **s_ops, void *s)
{
	 squashfs_super_block_3 *sBlk_3 = s;

	if(sBlk_3->s_magic != SQUASHFS_MAGIC || sBlk_3->s_major != 2 ||
							sBlk_3->s_minor > 1)
		return -1;

	sBlk.s.s_magic = sBlk_3->s_magic;
	sBlk.s.inodes = sBlk_3->inodes;
	sBlk.s.mkfs_time = sBlk_3->mkfs_time;
	sBlk.s.block_size = sBlk_3->block_size;
	sBlk.s.fragments = sBlk_3->fragments;
	sBlk.s.block_log = sBlk_3->block_log;
	sBlk.s.flags = sBlk_3->flags;
	sBlk.s.s_major = sBlk_3->s_major;
	sBlk.s.s_minor = sBlk_3->s_minor;
	sBlk.s.root_inode = sBlk_3->root_inode;
	sBlk.s.bytes_used = sBlk_3->bytes_used_2;
	sBlk.s.inode_table_start = sBlk_3->inode_table_start;
	sBlk.s.directory_table_start = sBlk_3->directory_table_start_2;
	sBlk.s.fragment_table_start = sBlk_3->fragment_table_start_2;
	sBlk.s.inode_table_start = sBlk_3->inode_table_start_2;
	sBlk.no_uids = sBlk_3->no_uids;
	sBlk.no_guids = sBlk_3->no_guids;
	sBlk.uid_start = sBlk_3->uid_start_2;
	sBlk.guid_start = sBlk_3->guid_start_2;
	sBlk.s.xattr_id_table_start = SQUASHFS_INVALID_BLK;

	*s_ops = &ops;

	
	comp = lookup_compressor(""gzip"");

	if(sBlk_3->s_minor == 0)
		needs_sorting = TRUE;

	return TRUE;
}
","1. sBlk.s.block_log = sBlk_3->block_log;
2. sBlk.s.s_major = sBlk_3->s_major;
sBlk.s.s_minor = sBlk_3->s_minor;
3. sBlk.s.bytes_used = sBlk_3->bytes_used_2;
4. comp = lookup_compressor(""gzip"");","14
16-17
19
35","CWE-362,CWE-190,CWE-399,CWE-119"
allocFromUTF16,"static char* allocFromUTF16(const char16_t* in, size_t len)

 {
     if (len == 0) return getEmptyString();
 
     
    const ssize_t resultStrLen = utf16_to_utf8_length(in, len) + 1;
    if (resultStrLen < 1) {
         return getEmptyString();
     }
 
    SharedBuffer* buf = SharedBuffer::alloc(resultStrLen);
     ALOG_ASSERT(buf, ""Unable to allocate shared buffer"");
     if (!buf) {
         return getEmptyString();
     }
 
    char* resultStr = (char*)buf->data();
    utf16_to_utf8(in, len, resultStr, resultStrLen);
    return resultStr;
 }
","1. static char* allocFromUTF16(const char16_t* in, size_t len)
2. if (len == 0) return getEmptyString();
3. if (!buf) {
return getEmptyString();
4. utf16_to_utf8(in, len, resultStr, resultStrLen);
return resultStr;","1
4
14-15
19-20","CWE-125,CWE-787,CWE-189,CWE-119"
ext4_split_unwritten_extents_1-180974596237708,"static int ext4_split_unwritten_extents_1(handle_t *handle,
					struct inode *inode,
					struct ext4_map_blocks *map,
					struct ext4_ext_path *path,
					int flags)
{
	ext4_lblk_t eof_block;
	ext4_lblk_t ee_block;
	struct ext4_extent *ex;
	unsigned int ee_len;
	int split_flag = 0, depth;

	ext_debug(""ext4_split_unwritten_extents_1: inode %lu, logical""
		""block %llu, max_blocks %u\n"", inode->i_ino,
		(unsigned long long)map->m_lblk, map->m_len);

	eof_block = (inode->i_size + inode->i_sb->s_blocksize - 1) >>
		inode->i_sb->s_blocksize_bits;
	if (eof_block < map->m_lblk + map->m_len)
		eof_block = map->m_lblk + map->m_len;
	
	depth = ext_depth(inode);
	ex = path[depth].p_ext;
	ee_block = le32_to_cpu(ex->ee_block);
	ee_len = ext4_ext_get_actual_len(ex);

	split_flag |= ee_block + ee_len <= eof_block ? EXT4_EXT_MAY_ZEROOUT : 0;
	split_flag |= EXT4_EXT_MARK_UNINIT2;
	if (flags & EXT4_GET_BLOCKS_CONVERT)
		split_flag |= EXT4_EXT_DATA_VALID2;
	flags |= EXT4_GET_BLOCKS_PRE_IO;
	return ext4_split_extent(handle, inode, path, map, split_flag, flags);
}
","1. struct inode *inode,
struct ext4_map_blocks *map,
struct ext4_ext_path *path,
int flags)
2. struct ext4_extent *ex;
unsigned int ee_len;
int split_flag = 0, depth;
3. ""block %llu, max_blocks %u\n"", inode->i_ino,
(unsigned long long)map->m_lblk, map->m_len);
4. eof_block = (inode->i_size + inode->i_sb->s_blocksize - 1) >>
inode->i_sb->s_blocksize_bits;
5. split_flag |= ee_block + ee_len <= eof_block ? EXT4_EXT_MAY_ZEROOUT : 0;
split_flag |= EXT4_EXT_MARK_UNINIT2;
if (flags & EXT4_GET_BLOCKS_CONVERT)","2-5
9-11
14-15
17-18
30-32","CWE-362,CWE-88,CWE-125,CWE-399"
update_notification_destroy-133825847659137,"void
update_notification_destroy(struct update_notification *file)
{
	doc_data_cleanup(&file->snapshot);
	global_data_cleanup(&file->global_data);
	deltas_head_cleanup(&file->deltas_list, delta_head_destroy);
	free(file->uri);
	free(file);
}
","1. void
update_notification_destroy(struct update_notification *file)
2. doc_data_cleanup(&file->snapshot);
global_data_cleanup(&file->global_data);
deltas_head_cleanup(&file->deltas_list, delta_head_destroy);
3. free(file);","1-2
4-6
8","CWE-476,CWE-824,CWE-254,CWE-787"
copyIPv6IfDifferent," static void copyIPv6IfDifferent(void * dest, const void * src)
 {
	if(dest != src && src != NULL) {
 		memcpy(dest, src, sizeof(struct in6_addr));
 	}
 }
","1. static void copyIPv6IfDifferent(void * dest, const void * src)
2. memcpy(dest, src, sizeof(struct in6_addr));","1
4","CWE-772,CWE-119"
r_bin_dwarf_dump_debug_info,"
#define FILE
#define RBinDwarfDebugInfo

static void r_bin_dwarf_dump_debug_info(FILE *f, const RBinDwarfDebugInfo *inf) {
	size_t i, j, k;
	RBinDwarfDIE *dies;
	RBinDwarfAttrValue *values;
	if (!inf || !f) {
		return;
	}

	for (i = 0; i < inf->length; i++) {
		fprintf (f, ""  Compilation Unit @ offset 0x%""PFMT64x"":\n"", inf->comp_units [i].offset);
		fprintf (f, ""   Length:        0x%x\n"", inf->comp_units [i].hdr.length);
		fprintf (f, ""   Version:       %d\n"", inf->comp_units [i].hdr.version);
		fprintf (f, ""   Abbrev Offset: 0x%x\n"", inf->comp_units [i].hdr.abbrev_offset);
		fprintf (f, ""   Pointer Size:  %d\n"", inf->comp_units [i].hdr.pointer_size);

		dies = inf->comp_units[i].dies;

		for (j = 0; j < inf->comp_units[i].length; j++) {
			fprintf (f, ""    Abbrev Number: %""PFMT64u"" "", dies[j].abbrev_code);

			if (dies[j].tag && dies[j].tag <= DW_TAG_volatile_type &&
				       dwarf_tag_name_encodings[dies[j].tag]) {
				fprintf (f, ""(%s)\n"", dwarf_tag_name_encodings[dies[j].tag]);
			} else {
				fprintf (f, ""(Unknown abbrev tag)\n"");
			}

			if (!dies[j].abbrev_code) {
				continue;
			}
 			values = dies[j].attr_values;
 
 			for (k = 0; k < dies[j].length; k++) {
				if (!values[k].name) {
 					continue;
				}
 
 				if (values[k].name < DW_AT_vtable_elem_location &&
 						dwarf_attr_encodings[values[k].name]) {
					fprintf (f, ""     %-18s : "", dwarf_attr_encodings[values[k].name]);
				} else {
					fprintf (f, ""     TODO\t"");
				}
				r_bin_dwarf_dump_attr_value (&values[k], f);
				fprintf (f, ""\n"");
			}
		}
	}
}
","1. for (i = 0; i < inf->length; i++) {
2. for (k = 0; k < dies[j].length; k++) {","13
37","CWE-190,CWE-415"
__ip_select_ident," void __ip_select_ident(struct iphdr *iph, int segs)
 {
 	static u32 ip_idents_hashrnd __read_mostly;
	static u32 ip_idents_hashrnd_extra __read_mostly;
 	u32 hash, id;
 
 	net_get_random_once(&ip_idents_hashrnd, sizeof(ip_idents_hashrnd));
	net_get_random_once(&ip_idents_hashrnd_extra, sizeof(ip_idents_hashrnd_extra));
 
 	hash = jhash_3words((__force u32)iph->daddr,
 			    (__force u32)iph->saddr,
			    iph->protocol ^ ip_idents_hashrnd_extra,
 			    ip_idents_hashrnd);
 	id = ip_idents_reserve(hash, segs);
 	iph->id = htons(id);
}
","1. u32 hash, id;
2. net_get_random_once(&ip_idents_hashrnd, sizeof(ip_idents_hashrnd));
net_get_random_once(&ip_idents_hashrnd_extra, sizeof(ip_idents_hashrnd_extra));","5
7-8","CWE-310,CWE-20,CWE-200,CWE-400,CWE-399"
__get_data_block,"static int __get_data_block(struct inode *inode, sector_t iblock,
			struct buffer_head *bh, int create, int flag,
			pgoff_t *next_pgofs)
{
	struct f2fs_map_blocks map;
	int err;

	map.m_lblk = iblock;
	map.m_len = bh->b_size >> inode->i_blkbits;
	map.m_next_pgofs = next_pgofs;

	err = f2fs_map_blocks(inode, &map, create, flag);
 	if (!err) {
 		map_bh(bh, inode->i_sb, map.m_pblk);
 		bh->b_state = (bh->b_state & ~F2FS_MAP_FLAGS) | map.m_flags;
		bh->b_size = (u64)map.m_len << inode->i_blkbits;
 	}
 	return err;
 }
","1. static int __get_data_block(struct inode *inode, sector_t iblock,
2. struct f2fs_map_blocks map;
int err;
3. map.m_lblk = iblock;
map.m_len = bh->b_size >> inode->i_blkbits;
4. err = f2fs_map_blocks(inode, &map, create, flag);
if (!err) {
5. bh->b_size = (u64)map.m_len << inode->i_blkbits;
6. return err;","1
5-6
8-9
12-13
16
18","CWE-190,CWE-200,CWE-17"
track_header-271876308828286,"
#define AVFormatContext
#define VividasDemuxContext

static int track_header(VividasDemuxContext *viv, AVFormatContext *s,  uint8_t *buf, int size)
{
    int i, j, ret;
    int64_t off;
    int val_1;
    int num_video;
    AVIOContext pb0, *pb = &pb0;

    ffio_init_context(pb, buf, size, 0, NULL, NULL, NULL, NULL);

    ffio_read_varlen(pb); 
    avio_r8(pb); 

    val_1 = ffio_read_varlen(pb);

    for (i=0;i<val_1;i++) {
        int c = avio_r8(pb);
        if (avio_feof(pb))
            return AVERROR_EOF;
        for (j=0;j<c;j++) {
            if (avio_feof(pb))
                return AVERROR_EOF;
            avio_r8(pb); 
            avio_r8(pb); 
        }
    }

    avio_r8(pb); 

    off = avio_tell(pb);
    off += ffio_read_varlen(pb); 

    avio_r8(pb); 
    num_video = avio_r8(pb);

    avio_seek(pb, off, SEEK_SET);
    if (num_video != 1) {
        av_log(s, AV_LOG_ERROR, ""number of video tracks %d is not 1\n"", num_video);
        return AVERROR_PATCHWELCOME;
    }

    for (i = 0; i < num_video; i++) {
        AVStream *st = avformat_new_stream(s, NULL);
        int num, den;

        if (!st)
            return AVERROR(ENOMEM);

        st->id = i;

        st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;
        st->codecpar->codec_id = AV_CODEC_ID_VP6;

        off = avio_tell(pb);
        off += ffio_read_varlen(pb);
        avio_r8(pb); 
        avio_r8(pb); 
        num = avio_rl32(pb); 
        den = avio_rl32(pb); 
        avpriv_set_pts_info(st, 64, num, den);
        st->nb_frames = avio_rl32(pb); 
        st->codecpar->width = avio_rl16(pb); 
        st->codecpar->height = avio_rl16(pb); 
        avio_r8(pb); 
        avio_rl32(pb); 

        avio_seek(pb, off, SEEK_SET);
    }

    off = avio_tell(pb);
    off += ffio_read_varlen(pb); 
    avio_r8(pb); 
    viv->num_audio = avio_r8(pb);
    avio_seek(pb, off, SEEK_SET);

    if (viv->num_audio != 1)
        av_log(s, AV_LOG_WARNING, ""number of audio tracks %d is not 1\n"", viv->num_audio);

    for(i=0;i<viv->num_audio;i++) {
        int q;
        AVStream *st = avformat_new_stream(s, NULL);
        if (!st)
            return AVERROR(ENOMEM);

        st->id = num_video + i;

        st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;
        st->codecpar->codec_id = AV_CODEC_ID_VORBIS;

        off = avio_tell(pb);
        off += ffio_read_varlen(pb); 
        avio_r8(pb); 
        avio_r8(pb); 
        avio_rl16(pb); 
        st->codecpar->channels = avio_rl16(pb); 
        st->codecpar->sample_rate = avio_rl32(pb); 
        avio_seek(pb, 10, SEEK_CUR); 
        q = avio_r8(pb);
        avio_seek(pb, q, SEEK_CUR); 
        avio_r8(pb); 

        if (avio_tell(pb) < off) {
            int num_data;
            int xd_size = 1;
            int data_len[256];
            int offset = 1;
            uint8_t *p;
            ffio_read_varlen(pb); 
            avio_r8(pb); 
            ffio_read_varlen(pb); 
            num_data = avio_r8(pb);
            for (j = 0; j < num_data; j++) {
                uint64_t len = ffio_read_varlen(pb);
                if (len > INT_MAX/2 - xd_size) {
                    return AVERROR_INVALIDDATA;
                }
                data_len[j] = len;
                xd_size += len + 1 + len/255;
            }

            ret = ff_alloc_extradata(st->codecpar, xd_size);
            if (ret < 0)
                return ret;

            p = st->codecpar->extradata;
            p[0] = 2;

            for (j = 0; j < num_data - 1; j++) {
                unsigned delta = av_xiphlacing(&p[offset], data_len[j]);
                av_assert0(delta <= xd_size - offset);
                offset += delta;
            }

            for (j = 0; j < num_data; j++) {
                int ret = avio_read(pb, &p[offset], data_len[j]);
                if (ret < data_len[j]) {
                    st->codecpar->extradata_size = 0;
                    av_freep(&st->codecpar->extradata);
                    break;
                }
                av_assert0(data_len[j] <= xd_size - offset);
                offset += data_len[j];
            }

            if (offset < st->codecpar->extradata_size)
                st->codecpar->extradata_size = offset;
        }
    }

    return 0;
}
","1. static int track_header(VividasDemuxContext *viv, AVFormatContext *s,  uint8_t *buf, int size)
2. AVIOContext pb0, *pb = &pb0;
3. avio_r8(pb);
4. return AVERROR_PATCHWELCOME;
5. den = avio_rl32(pb);
6. st->nb_frames = avio_rl32(pb);
7. AVStream *st = avformat_new_stream(s, NULL);
8. off = avio_tell(pb);
9. return ret;","5
11
27
43
63
65
85
94
127","CWE-362,CWE-125,CWE-19,CWE-119"
list_devices-171748317334841,"static int list_devices(struct file *filp, struct dm_ioctl *param, size_t param_size)
{
	unsigned int i;
	struct hash_cell *hc;
	size_t len, needed = 0;
	struct gendisk *disk;
	struct dm_name_list *orig_nl, *nl, *old_nl = NULL;
	uint32_t *event_nr;

	down_write(&_hash_lock);

	
	for (i = 0; i < NUM_BUCKETS; i++) {
		list_for_each_entry (hc, _name_buckets + i, name_list) {
			needed += align_val(offsetof(struct dm_name_list, name) + strlen(hc->name) + 1);
			needed += align_val(sizeof(uint32_t));
		}
	}

	
	nl = orig_nl = get_result_buffer(param, param_size, &len);
	if (len < needed || len < sizeof(nl->dev)) {
		param->flags |= DM_BUFFER_FULL_FLAG;
		goto out;
	}
	param->data_size = param->data_start + needed;

	nl->dev = 0;	

	
	for (i = 0; i < NUM_BUCKETS; i++) {
		list_for_each_entry (hc, _name_buckets + i, name_list) {
			if (old_nl)
				old_nl->next = (uint32_t) ((void *) nl -
							   (void *) old_nl);
			disk = dm_disk(hc->md);
			nl->dev = huge_encode_dev(disk_devt(disk));
			nl->next = 0;
			strcpy(nl->name, hc->name);

			old_nl = nl;
			event_nr = align_ptr(nl->name + strlen(hc->name) + 1);
			*event_nr = dm_get_event_nr(hc->md);
			nl = align_ptr(event_nr + 1);
		}
	}
	
	BUG_ON((char *)nl - (char *)orig_nl != needed);

 out:
	up_write(&_hash_lock);
	return 0;
}
","1. static int list_devices(struct file *filp, struct dm_ioctl *param, size_t param_size)
2. struct hash_cell *hc;
size_t len, needed = 0;
3. uint32_t *event_nr;
4. down_write(&_hash_lock);
5. list_for_each_entry (hc, _name_buckets + i, name_list) {
6. nl = orig_nl = get_result_buffer(param, param_size, &len);
7. list_for_each_entry (hc, _name_buckets + i, name_list) {
8. old_nl->next = (uint32_t) ((void *) nl -
9. nl->next = 0;
10. event_nr = align_ptr(nl->name + strlen(hc->name) + 1);
11. BUG_ON((char *)nl - (char *)orig_nl != needed);
12. out:","1
4-5
8
10
17
26
39
41
45
49
58
60","CWE-476,CWE-362,CWE-134,CWE-399"
Sys_LoadDll,"void *Sys_LoadDll(const char *name, qboolean useSystemLib)
 {
 	void *dllhandle;
 	
	
	if (COM_CompareExtension(name, "".pk3""))
	{
		Com_Printf(""Rejecting DLL named \""%s\"""", name);
		return NULL;
	}

 	if(useSystemLib)
 		Com_Printf(""Trying to load \""%s\""...\n"", name);
 	
	if(!useSystemLib || !(dllhandle = Sys_LoadLibrary(name)))
	{
		const char *topDir;
		char libPath[MAX_OSPATH];

		topDir = Sys_BinaryPath();

		if(!*topDir)
			topDir = ""."";

		Com_Printf(""Trying to load \""%s\"" from \""%s\""...\n"", name, topDir);
		Com_sprintf(libPath, sizeof(libPath), ""%s%c%s"", topDir, PATH_SEP, name);

		if(!(dllhandle = Sys_LoadLibrary(libPath)))
		{
			const char *basePath = Cvar_VariableString(""fs_basepath"");
			
			if(!basePath || !*basePath)
				basePath = ""."";
			
			if(FS_FilenameCompare(topDir, basePath))
			{
				Com_Printf(""Trying to load \""%s\"" from \""%s\""...\n"", name, basePath);
				Com_sprintf(libPath, sizeof(libPath), ""%s%c%s"", basePath, PATH_SEP, name);
				dllhandle = Sys_LoadLibrary(libPath);
			}
			
			if(!dllhandle)
				Com_Printf(""Loading \""%s\"" failed\n"", name);
		}
	}
	
	return dllhandle;
}
","1. void *Sys_LoadDll(const char *name, qboolean useSystemLib)
2. void *dllhandle;
3. if (COM_CompareExtension(name, "".pk3""))
4. Com_Printf(""Trying to load \""%s\""...\n"", name);
5. if(!*topDir)
6. if(!basePath || !*basePath)
7. Com_Printf(""Trying to load \""%s\"" from \""%s\""...\n"", name, basePath);
Com_sprintf(libPath, sizeof(libPath), ""%s%c%s"", basePath, PATH_SEP, name);
dllhandle = Sys_LoadLibrary(libPath);","1
3
6
13
22
32
37-39","CWE-190,CWE-269,CWE-264,CWE-125"
do_mq_notify,"static int do_mq_notify(mqd_t mqdes, const struct sigevent *notification)
{
	int ret;
	struct fd f;
	struct sock *sock;
	struct inode *inode;
	struct mqueue_inode_info *info;
	struct sk_buff *nc;

	audit_mq_notify(mqdes, notification);

	nc = NULL;
	sock = NULL;
	if (notification != NULL) {
		if (unlikely(notification->sigev_notify != SIGEV_NONE &&
			     notification->sigev_notify != SIGEV_SIGNAL &&
			     notification->sigev_notify != SIGEV_THREAD))
			return -EINVAL;
		if (notification->sigev_notify == SIGEV_SIGNAL &&
			!valid_signal(notification->sigev_signo)) {
			return -EINVAL;
		}
		if (notification->sigev_notify == SIGEV_THREAD) {
			long timeo;

			
			nc = alloc_skb(NOTIFY_COOKIE_LEN, GFP_KERNEL);
			if (!nc) {
				ret = -ENOMEM;
				goto out;
			}
			if (copy_from_user(nc->data,
					notification->sigev_value.sival_ptr,
					NOTIFY_COOKIE_LEN)) {
				ret = -EFAULT;
				goto out;
			}

			
			skb_put(nc, NOTIFY_COOKIE_LEN);
			
retry:
			f = fdget(notification->sigev_signo);
			if (!f.file) {
				ret = -EBADF;
				goto out;
			}
			sock = netlink_getsockbyfilp(f.file);
			fdput(f);
			if (IS_ERR(sock)) {
				ret = PTR_ERR(sock);
				sock = NULL;
				goto out;
			}
 
 			timeo = MAX_SCHEDULE_TIMEOUT;
 			ret = netlink_attachskb(sock, nc, &timeo, NULL);
			if (ret == 1) {
				sock = NULL;
 				goto retry;
			}
 			if (ret) {
 				sock = NULL;
 				nc = NULL;
				goto out;
			}
		}
	}

	f = fdget(mqdes);
	if (!f.file) {
		ret = -EBADF;
		goto out;
	}

	inode = file_inode(f.file);
	if (unlikely(f.file->f_op != &mqueue_file_operations)) {
		ret = -EBADF;
		goto out_fput;
	}
	info = MQUEUE_I(inode);

	ret = 0;
	spin_lock(&info->lock);
	if (notification == NULL) {
		if (info->notify_owner == task_tgid(current)) {
			remove_notification(info);
			inode->i_atime = inode->i_ctime = current_time(inode);
		}
	} else if (info->notify_owner != NULL) {
		ret = -EBUSY;
	} else {
		switch (notification->sigev_notify) {
		case SIGEV_NONE:
			info->notify.sigev_notify = SIGEV_NONE;
			break;
		case SIGEV_THREAD:
			info->notify_sock = sock;
			info->notify_cookie = nc;
			sock = NULL;
			nc = NULL;
			info->notify.sigev_notify = SIGEV_THREAD;
			break;
		case SIGEV_SIGNAL:
			info->notify.sigev_signo = notification->sigev_signo;
			info->notify.sigev_value = notification->sigev_value;
			info->notify.sigev_notify = SIGEV_SIGNAL;
			break;
		}

		info->notify_owner = get_pid(task_tgid(current));
		info->notify_user_ns = get_user_ns(current_user_ns());
		inode->i_atime = inode->i_ctime = current_time(inode);
	}
	spin_unlock(&info->lock);
out_fput:
	fdput(f);
out:
	if (sock)
		netlink_detachskb(sock, nc);
	else if (nc)
		dev_kfree_skb(nc);

	return ret;
}
","1. struct fd f;
2. nc = NULL;
3. if (notification->sigev_notify == SIGEV_SIGNAL &&
4. ret = -EBADF;
5. goto retry;
6. if (ret) {
sock = NULL;
7. info = MQUEUE_I(inode);
8. case SIGEV_NONE:
9. break;
case SIGEV_THREAD:
10. out:","4
12
19
45
60
62-63
81
94
96-97
118","CWE-476,CWE-401,CWE-362,CWE-78"
usage_exit_3,"void usage_exit_3() {
void usage_exit_3(void) {
   fprintf(stderr, ""Usage: %s <infile> <outfile> <N-M|N/M>\n"", exec_name);
   exit(EXIT_FAILURE);
 }
","1. fprintf(stderr, ""Usage: %s <infile> <outfile> <N-M|N/M>\n"", exec_name);",3,"CWE-399,CWE-119"
__nla_validate_parse-78390484117772,"static int __nla_validate_parse(const struct nlattr *head, int len, int maxtype,
				const struct nla_policy *policy,
				unsigned int validate,
				struct netlink_ext_ack *extack,
				struct nlattr **tb, unsigned int depth);
","1. static int __nla_validate_parse(const struct nlattr *head, int len, int maxtype,
const struct nla_policy *policy,
unsigned int validate,
2. struct nlattr **tb, unsigned int depth);","1-3
5","CWE-269,CWE-189,CWE-200,CWE-276,CWE-17"
hostlist_matches_int-231808920660700,"static int
hostlist_matches_int(const struct sudoers_parse_tree *parse_tree,
    const struct passwd *pw, const char *lhost, const char *shost,
    const struct member_list *list)
{
    struct member *m;
    int matched = UNSPEC;
    debug_decl(hostlist_matches, SUDOERS_DEBUG_MATCH);

    TAILQ_FOREACH_REVERSE(m, list, member_list, entries) {
	matched = host_matches(parse_tree, pw, lhost, shost, m);
	if (SPECIFIED(matched))
	    break;
    }
    debug_return_int(matched);
}
","1. static int
2. debug_decl(hostlist_matches, SUDOERS_DEBUG_MATCH);
3. TAILQ_FOREACH_REVERSE(m, list, member_list, entries) {
4. break;","1
8
10
13","CWE-125,CWE-284,CWE-189"
sctp_inq_pop-222291965614377,"struct sctp_chunk *sctp_inq_pop(struct sctp_inq *queue)
{
	struct sctp_chunk *chunk;
	sctp_chunkhdr_t *ch = NULL;

	

	if ((chunk = queue->in_progress)) {
		
		if (chunk->singleton ||
		    chunk->end_of_packet ||
		    chunk->pdiscard) {
			sctp_chunk_free(chunk);
			chunk = queue->in_progress = NULL;
		} else {
			
			ch = (sctp_chunkhdr_t *) chunk->chunk_end;
			
			skb_pull(chunk->skb, chunk->chunk_end - chunk->skb->data);
			
		}
	}

	
	if (!chunk) {
		struct list_head *entry;

		
		if (list_empty(&queue->in_chunk_list))
			return NULL;

		entry = queue->in_chunk_list.next;
		chunk = queue->in_progress =
			list_entry(entry, struct sctp_chunk, list);
		list_del_init(entry);

		
		chunk->singleton = 1;
		ch = (sctp_chunkhdr_t *) chunk->skb->data;
		chunk->data_accepted = 0;
	}

	chunk->chunk_hdr = ch;
	chunk->chunk_end = ((__u8 *)ch) + WORD_ROUND(ntohs(ch->length));
	
	if (unlikely(skb_is_nonlinear(chunk->skb))) {
		if (chunk->chunk_end > skb_tail_pointer(chunk->skb))
			chunk->chunk_end = skb_tail_pointer(chunk->skb);
	}
	skb_pull(chunk->skb, sizeof(sctp_chunkhdr_t));
	chunk->subh.v = NULL; 

	if (chunk->chunk_end + sizeof(sctp_chunkhdr_t) <
	    skb_tail_pointer(chunk->skb)) {
		
		chunk->singleton = 0;
	} else if (chunk->chunk_end > skb_tail_pointer(chunk->skb)) {
		
		chunk->pdiscard = 1;
		chunk->chunk_end = skb_tail_pointer(chunk->skb);
	} else {
		
		chunk->end_of_packet = 1;
	}

	pr_debug(""+++sctp_inq_pop+++ chunk:%p[%s], length:%d, skb->len:%d\n"",
		 chunk, sctp_cname(SCTP_ST_CHUNK(chunk->chunk_hdr->type)),
		 ntohs(chunk->chunk_hdr->length), chunk->skb->len);

	return chunk;
}
","1. struct sctp_chunk *chunk;
sctp_chunkhdr_t *ch = NULL;
2. if ((chunk = queue->in_progress)) {
3. if (chunk->singleton ||
chunk->end_of_packet ||
4. chunk = queue->in_progress = NULL;
5. ch = (sctp_chunkhdr_t *) chunk->chunk_end;
6. skb_pull(chunk->skb, chunk->chunk_end - chunk->skb->data);
7. if (!chunk) {
8. if (list_empty(&queue->in_chunk_list))
9. entry = queue->in_chunk_list.next;
10. list_del_init(entry);
11. chunk->singleton = 1;
ch = (sctp_chunkhdr_t *) chunk->skb->data;
chunk->data_accepted = 0;
12. chunk->chunk_hdr = ch;
chunk->chunk_end = ((__u8 *)ch) + WORD_ROUND(ntohs(ch->length));
13. if (unlikely(skb_is_nonlinear(chunk->skb))) {
if (chunk->chunk_end > skb_tail_pointer(chunk->skb))
14. skb_pull(chunk->skb, sizeof(sctp_chunkhdr_t));
chunk->subh.v = NULL;
15. skb_tail_pointer(chunk->skb)) {
16. chunk->singleton = 0;
} else if (chunk->chunk_end > skb_tail_pointer(chunk->skb)) {
17. chunk->pdiscard = 1;
18. chunk->end_of_packet = 1;
19. pr_debug(""+++sctp_inq_pop+++ chunk:%p[%s], length:%d, skb->len:%d\n"",
chunk, sctp_cname(SCTP_ST_CHUNK(chunk->chunk_hdr->type)),
ntohs(chunk->chunk_hdr->length), chunk->skb->len);
20. return chunk;","3-4
10
14-15
18
21
23
29
33
36
39
42-44
47-48
53-54
57-58
61
63-64
66
72
75-77
79","CWE-190,CWE-17,CWE-399,CWE-416"
gf_dump_vrml_simple_field_1-274354210572500,"
#define GF_FieldInfo
#define GF_Node
#define GF_SceneDumper

static void gf_dump_vrml_simple_field_1(GF_SceneDumper *sdump, GF_FieldInfo field, GF_Node *parent)
{
	u32 i, sf_type;
	GF_ChildNodeItem *list;
	void *slot_ptr;

	switch (field.fieldType) {
	case GF_SG_VRML_SFNODE:
		gf_dump_vrml_node(sdump, field.far_ptr ? *(GF_Node **)field.far_ptr : NULL, 0, NULL);
		return;
	case GF_SG_VRML_MFNODE:
		list = * ((GF_ChildNodeItem **) field.far_ptr);
		assert( list );
		sdump->indent++;
		while (list) {
			gf_dump_vrml_node(sdump, list->node, 1, NULL);
			list = list->next;
		}
		sdump->indent--;
		return;
	case GF_SG_VRML_SFCOMMANDBUFFER:
		return;
	}
	if (gf_sg_vrml_is_sf_field(field.fieldType)) {
		if (sdump->XMLDump) StartAttribute(sdump, ""value"");
		gf_dump_vrml_sffield(sdump, field.fieldType, field.far_ptr, 0, parent);
		if (sdump->XMLDump) EndAttribute(sdump);
	} else {
		GenMFField *mffield;
		mffield = (GenMFField *) field.far_ptr;
		sf_type = gf_sg_vrml_get_sf_type(field.fieldType);
		if (!sdump->XMLDump) {
			gf_fprintf(sdump->trace, ""["");
		} else if (sf_type==GF_SG_VRML_SFSTRING) {
			gf_fprintf(sdump->trace, "" value=\'"");
		} else {
			StartAttribute(sdump, ""value"");
		}
		for (i=0; mffield && (i<mffield->count); i++) {
			if (i) gf_fprintf(sdump->trace, "" "");
			gf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);
			
			gf_dump_vrml_sffield(sdump, sf_type, slot_ptr, 1, parent);
		}
		if (!sdump->XMLDump) {
			gf_fprintf(sdump->trace, ""]"");
		} else if (sf_type==GF_SG_VRML_SFSTRING) {
			gf_fprintf(sdump->trace, ""\'"");
		} else {
			EndAttribute(sdump);
		}
	}
}
","1. static void gf_dump_vrml_simple_field_1(GF_SceneDumper *sdump, GF_FieldInfo field, GF_Node *parent)
2. assert( list );
3. mffield = (GenMFField *) field.far_ptr;","6
18
35","CWE-20,CWE-78,CWE-120,CWE-863,CWE-399"
usb_get_bos_descriptor-103588486865511,"int usb_get_bos_descriptor(struct usb_device *dev)
{
	struct device *ddev = &dev->dev;
	struct usb_bos_descriptor *bos;
	struct usb_dev_cap_header *cap;
	unsigned char *buffer;
	int length, total_len, num, i;
	int ret;

	bos = kzalloc(sizeof(struct usb_bos_descriptor), GFP_KERNEL);
	if (!bos)
		return -ENOMEM;

	
	ret = usb_get_descriptor(dev, USB_DT_BOS, 0, bos, USB_DT_BOS_SIZE);
	if (ret < USB_DT_BOS_SIZE) {
		dev_err(ddev, ""unable to get BOS descriptor\n"");
		if (ret >= 0)
			ret = -ENOMSG;
		kfree(bos);
		return ret;
	}

	length = bos->bLength;
	total_len = le16_to_cpu(bos->wTotalLength);
	num = bos->bNumDeviceCaps;
	kfree(bos);
	if (total_len < length)
		return -EINVAL;

	dev->bos = kzalloc(sizeof(struct usb_host_bos), GFP_KERNEL);
	if (!dev->bos)
		return -ENOMEM;

	
	buffer = kzalloc(total_len, GFP_KERNEL);
	if (!buffer) {
		ret = -ENOMEM;
		goto err;
	}
	dev->bos->desc = (struct usb_bos_descriptor *)buffer;

	ret = usb_get_descriptor(dev, USB_DT_BOS, 0, buffer, total_len);
	if (ret < total_len) {
		dev_err(ddev, ""unable to get BOS descriptor set\n"");
		if (ret >= 0)
			ret = -ENOMSG;
		goto err;
	}
	total_len -= length;

	for (i = 0; i < num; i++) {
		buffer += length;
		cap = (struct usb_dev_cap_header *)buffer;

		if (total_len < sizeof(*cap) || total_len < cap->bLength) {
			dev->bos->desc->bNumDeviceCaps = i;
			break;
		}
		length = cap->bLength;
		total_len -= length;

		if (cap->bDescriptorType != USB_DT_DEVICE_CAPABILITY) {
			dev_warn(ddev, ""descriptor type invalid, skip\n"");
			continue;
		}

		switch (cap->bDevCapabilityType) {
		case USB_CAP_TYPE_WIRELESS_USB:
			
			break;
		case USB_CAP_TYPE_EXT:
			dev->bos->ext_cap =
				(struct usb_ext_cap_descriptor *)buffer;
			break;
		case USB_SS_CAP_TYPE:
			dev->bos->ss_cap =
				(struct usb_ss_cap_descriptor *)buffer;
			break;
		case USB_SSP_CAP_TYPE:
			dev->bos->ssp_cap =
				(struct usb_ssp_cap_descriptor *)buffer;
			break;
		case CONTAINER_ID_TYPE:
			dev->bos->ss_id =
				(struct usb_ss_container_id_descriptor *)buffer;
			break;
		case USB_PTM_CAP_TYPE:
			dev->bos->ptm_cap =
				(struct usb_ptm_cap_descriptor *)buffer;
		default:
			break;
		}
	}

	return 0;

err:
	usb_release_bos_descriptor(dev);
	return ret;
}
","1. struct device *ddev = &dev->dev;
2. if (!bos)
3. ret = usb_get_descriptor(dev, USB_DT_BOS, 0, bos, USB_DT_BOS_SIZE);
4. length = bos->bLength;
5. return -ENOMEM;
6. dev->bos->desc = (struct usb_bos_descriptor *)buffer;
7. goto err;
8. if (total_len < sizeof(*cap) || total_len < cap->bLength) {
9. case USB_CAP_TYPE_WIRELESS_USB:
10. break;
11. break;","3
11
15
24
33
41
48
56
69
75
87","CWE-787,CWE-125,CWE-19,CWE-189"
f2fs_put_super,"static void f2fs_put_super(struct super_block *sb)
{
	struct f2fs_sb_info *sbi = F2FS_SB(sb);
	int i;

	f2fs_quota_off_umount(sb);

	
	mutex_lock(&sbi->umount_mutex);

	
	if (is_sbi_flag_set(sbi, SBI_IS_DIRTY) ||
			!is_set_ckpt_flags(sbi, CP_UMOUNT_FLAG)) {
		struct cp_control cpc = {
			.reason = CP_UMOUNT,
		};
		write_checkpoint(sbi, &cpc);
 	}
 
 	
	f2fs_wait_discard_bios(sbi, true);
 
 	if (f2fs_discard_en(sbi) && !sbi->discard_blks) {
 		struct cp_control cpc = {
			.reason = CP_UMOUNT | CP_TRIMMED,
		};
		write_checkpoint(sbi, &cpc);
	}

	
	f2fs_destroy_stats(sbi);

	
	release_ino_entry(sbi, true);

	f2fs_leave_shrinker(sbi);
	mutex_unlock(&sbi->umount_mutex);

	
	f2fs_flush_merged_writes(sbi);

	iput(sbi->node_inode);
	iput(sbi->meta_inode);

	
	destroy_node_manager(sbi);
	destroy_segment_manager(sbi);

	kfree(sbi->ckpt);

	f2fs_unregister_sysfs(sbi);

	sb->s_fs_info = NULL;
	if (sbi->s_chksum_driver)
		crypto_free_shash(sbi->s_chksum_driver);
	kfree(sbi->raw_super);

	destroy_device_list(sbi);
	mempool_destroy(sbi->write_io_dummy);
#ifdef CONFIG_QUOTA
	for (i = 0; i < MAXQUOTAS; i++)
		kfree(sbi->s_qf_names[i]);
#endif
	destroy_percpu_info(sbi);
	for (i = 0; i < NR_PAGE_TYPE; i++)
		kfree(sbi->write_io[i]);
	kfree(sbi);
}
","1. struct f2fs_sb_info *sbi = F2FS_SB(sb);
2. mutex_unlock(&sbi->umount_mutex);
3. iput(sbi->node_inode);
4. destroy_node_manager(sbi);
5. f2fs_unregister_sysfs(sbi);
6. destroy_device_list(sbi);
mempool_destroy(sbi->write_io_dummy);
7. kfree(sbi->write_io[i]);","3
44
49
53
58
65-66
73","CWE-20,CWE-287,CWE-269,CWE-476,CWE-399"
pdf_read_old_xref,"pdf_read_old_xref(fz_context *ctx, pdf_document *doc, pdf_lexbuf *buf)
{
	fz_stream *file = doc->file;

	int64_t ofs;
	int len;
	char *s;
	size_t n;
	pdf_token tok;
	int64_t i;
	int c;
	int xref_len = pdf_xref_size_from_old_trailer(ctx, doc, buf);
	pdf_xref_entry *table;
	int carried;

	fz_skip_space(ctx, doc->file);
	if (fz_skip_string(ctx, doc->file, ""xref""))
		fz_throw(ctx, FZ_ERROR_GENERIC, ""cannot find xref marker"");
	fz_skip_space(ctx, doc->file);

	while (1)
	{
		c = fz_peek_byte(ctx, file);
		if (!(c >= '0' && c <= '9'))
			break;

		fz_read_line(ctx, file, buf->scratch, buf->size);
		s = buf->scratch;
		ofs = fz_atoi64(fz_strsep(&s, "" ""));
		len = fz_atoi(fz_strsep(&s, "" ""));

		
		if (s && *s != '\0')
		{
			fz_warn(ctx, ""broken xref section. proceeding anyway."");
                        fz_seek(ctx, file, -(2 + (int)strlen(s)), SEEK_CUR);
                }
 
               if (ofs < 0 || ofs > PDF_MAX_OBJECT_NUMBER
                               || len < 0 || len > PDF_MAX_OBJECT_NUMBER
                               || ofs + len - 1 > PDF_MAX_OBJECT_NUMBER)
               {
                       fz_throw(ctx, FZ_ERROR_GENERIC, ""xref subsection object numbers are out of range"");
               }
                
                if (ofs + len > xref_len)
                {
		}

		table = pdf_xref_find_subsection(ctx, doc, ofs, len);

		
		carried = 0;
		for (i = ofs; i < ofs + len; i++)
		{
			pdf_xref_entry *entry = &table[i-ofs];
			n = fz_read(ctx, file, (unsigned char *) buf->scratch + carried, 20-carried);
			if (n != 20-carried)
				fz_throw(ctx, FZ_ERROR_GENERIC, ""unexpected EOF in xref table"");
			n += carried;
			if (!entry->type)
			{
				s = buf->scratch;

				
				while (*s != '\0' && iswhite(*s))
					s++;

				entry->ofs = fz_atoi64(s);
				entry->gen = fz_atoi(s + 11);
				entry->num = (int)i;
				entry->type = s[17];
				if (s[17] != 'f' && s[17] != 'n' && s[17] != 'o')
					fz_throw(ctx, FZ_ERROR_GENERIC, ""unexpected xref type: 0x%x (%d %d R)"", s[17], entry->num, entry->gen);
				
				carried = s[19] > 32;
				if (carried)
					s[0] = s[19];
			}
		}
		if (carried)
			fz_unread_byte(ctx, file);
	}

	tok = pdf_lex(ctx, file, buf);
	if (tok != PDF_TOK_TRAILER)
		fz_throw(ctx, FZ_ERROR_GENERIC, ""expected trailer marker"");

	tok = pdf_lex(ctx, file, buf);
	if (tok != PDF_TOK_OPEN_DICT)
		fz_throw(ctx, FZ_ERROR_GENERIC, ""expected trailer dictionary"");

	return pdf_parse_dict(ctx, doc, file, buf);
}
","1. pdf_read_old_xref(fz_context *ctx, pdf_document *doc, pdf_lexbuf *buf)
2. char *s;
3. int c;
4. fz_skip_space(ctx, doc->file);
5. break;
6. if (ofs + len > xref_len)
7. if (carried)
8. if (tok != PDF_TOK_OPEN_DICT)","1
7
11
16
25
46
83
92","CWE-125,CWE-787,CWE-119"
ext3_blkdev_get,"static struct block_device *ext3_blkdev_get(dev_t dev, struct super_block *sb)
{
	struct block_device *bdev;
	char b[BDEVNAME_SIZE];

	bdev = blkdev_get_by_dev(dev, FMODE_READ|FMODE_WRITE|FMODE_EXCL, sb);
	if (IS_ERR(bdev))
		goto fail;
 	return bdev;
 
 fail:
	ext3_msg(sb, KERN_ERR, ""error: failed to open journal device %s: %ld"",
 		__bdevname(dev, b), PTR_ERR(bdev));
 
 	return NULL;
}
","1. static struct block_device *ext3_blkdev_get(dev_t dev, struct super_block *sb)
2. struct block_device *bdev;
3. bdev = blkdev_get_by_dev(dev, FMODE_READ|FMODE_WRITE|FMODE_EXCL, sb);
if (IS_ERR(bdev))
4. fail:
5. __bdevname(dev, b), PTR_ERR(bdev));","1
3
6-7
11
13","CWE-122,CWE-20,CWE-787,CWE-119"
fit_image_load-110446850168708,"int fit_image_load(bootm_headers_t *images, ulong addr,
		   const char **fit_unamep, const char **fit_uname_configp,
		   int arch, int image_type, int bootstage_id,
		   enum fit_load_op load_op, ulong *datap, ulong *lenp)
{
	int cfg_noffset, noffset;
	const char *fit_uname;
	const char *fit_uname_config;
	const char *fit_base_uname_config;
	const void *fit;
	void *buf;
	void *loadbuf;
	size_t size;
	int type_ok, os_ok;
	ulong load, load_end, data, len;
	uint8_t os, comp;
#ifndef USE_HOSTCC
	uint8_t os_arch;
#endif
	const char *prop_name;
	int ret;

	fit = map_sysmem(addr, 0);
	fit_uname = fit_unamep ? *fit_unamep : NULL;
	fit_uname_config = fit_uname_configp ? *fit_uname_configp : NULL;
	fit_base_uname_config = NULL;
	prop_name = fit_get_image_type_property(image_type);
	printf(""## Loading %s from FIT Image at %08lx ...\n"", prop_name, addr);

	bootstage_mark(bootstage_id + BOOTSTAGE_SUB_FORMAT);
	ret = fit_check_format(fit, IMAGE_SIZE_INVAL);
	if (ret) {
		printf(""Bad FIT %s image format! (err=%d)\n"", prop_name, ret);
		if (CONFIG_IS_ENABLED(FIT_SIGNATURE) && ret == -EADDRNOTAVAIL)
			printf(""Signature checking prevents use of unit addresses (@) in nodes\n"");
		bootstage_error(bootstage_id + BOOTSTAGE_SUB_FORMAT);
		return ret;
	}
	bootstage_mark(bootstage_id + BOOTSTAGE_SUB_FORMAT_OK);
	if (fit_uname) {
		
		bootstage_mark(bootstage_id + BOOTSTAGE_SUB_UNIT_NAME);
		noffset = fit_image_get_node(fit, fit_uname);
	} else {
		
		bootstage_mark(bootstage_id + BOOTSTAGE_SUB_NO_UNIT_NAME);
		if (IMAGE_ENABLE_BEST_MATCH && !fit_uname_config) {
			cfg_noffset = fit_conf_find_compat(fit, gd_fdt_blob());
		} else {
			cfg_noffset = fit_conf_get_node(fit,
							fit_uname_config);
		}
		if (cfg_noffset < 0) {
			puts(""Could not find configuration node\n"");
			bootstage_error(bootstage_id +
					BOOTSTAGE_SUB_NO_UNIT_NAME);
			return -ENOENT;
		}

		fit_base_uname_config = fdt_get_name(fit, cfg_noffset, NULL);
		printf(""   Using '%s' configuration\n"", fit_base_uname_config);
		
		if (image_type == IH_TYPE_KERNEL)
			images->fit_uname_cfg = fit_base_uname_config;

		if (FIT_IMAGE_ENABLE_VERIFY && images->verify) {
			puts(""   Verifying Hash Integrity ... "");
			if (fit_config_verify(fit, cfg_noffset)) {
				puts(""Bad Data Hash\n"");
				bootstage_error(bootstage_id +
					BOOTSTAGE_SUB_HASH);
				return -EACCES;
			}
			puts(""OK\n"");
		}

		bootstage_mark(BOOTSTAGE_ID_FIT_CONFIG);

		noffset = fit_conf_get_prop_node(fit, cfg_noffset,
						 prop_name);
		fit_uname = fit_get_name(fit, noffset, NULL);
	}
	if (noffset < 0) {
		printf(""Could not find subimage node type '%s'\n"", prop_name);
		bootstage_error(bootstage_id + BOOTSTAGE_SUB_SUBNODE);
		return -ENOENT;
	}

	printf(""   Trying '%s' %s subimage\n"", fit_uname, prop_name);

	ret = fit_image_select(fit, noffset, images->verify);
	if (ret) {
		bootstage_error(bootstage_id + BOOTSTAGE_SUB_HASH);
		return ret;
	}

	bootstage_mark(bootstage_id + BOOTSTAGE_SUB_CHECK_ARCH);
	if (!host_build() && IS_ENABLED(CONFIG_SANDBOX)) {
		if (!fit_image_check_target_arch(fit, noffset)) {
			puts(""Unsupported Architecture\n"");
			bootstage_error(bootstage_id + BOOTSTAGE_SUB_CHECK_ARCH);
			return -ENOEXEC;
		}
	}

#ifndef USE_HOSTCC
	fit_image_get_arch(fit, noffset, &os_arch);
	images->os.arch = os_arch;
#endif

	bootstage_mark(bootstage_id + BOOTSTAGE_SUB_CHECK_ALL);
	type_ok = fit_image_check_type(fit, noffset, image_type) ||
		  fit_image_check_type(fit, noffset, IH_TYPE_FIRMWARE) ||
		  (image_type == IH_TYPE_KERNEL &&
		   fit_image_check_type(fit, noffset, IH_TYPE_KERNEL_NOLOAD));

	os_ok = image_type == IH_TYPE_FLATDT ||
		image_type == IH_TYPE_FPGA ||
		fit_image_check_os(fit, noffset, IH_OS_LINUX) ||
		fit_image_check_os(fit, noffset, IH_OS_U_BOOT) ||
		fit_image_check_os(fit, noffset, IH_OS_OPENRTOS) ||
		fit_image_check_os(fit, noffset, IH_OS_EFI) ||
		fit_image_check_os(fit, noffset, IH_OS_VXWORKS);

	
	if ((!type_ok || !os_ok) && image_type != IH_TYPE_LOADABLE) {
		fit_image_get_os(fit, noffset, &os);
		printf(""No %s %s %s Image\n"",
		       genimg_get_os_name(os),
		       genimg_get_arch_name(arch),
		       genimg_get_type_name(image_type));
		bootstage_error(bootstage_id + BOOTSTAGE_SUB_CHECK_ALL);
		return -EIO;
	}

	bootstage_mark(bootstage_id + BOOTSTAGE_SUB_CHECK_ALL_OK);

	
	if (fit_image_get_data_and_size(fit, noffset,
					(const void **)&buf, &size)) {
		printf(""Could not find %s subimage data!\n"", prop_name);
		bootstage_error(bootstage_id + BOOTSTAGE_SUB_GET_DATA);
		return -ENOENT;
	}

	
	if (IS_ENABLED(CONFIG_FIT_CIPHER) && IMAGE_ENABLE_DECRYPT) {
		puts(""   Decrypting Data ... "");
		if (fit_image_uncipher(fit, noffset, &buf, &size)) {
			puts(""Error\n"");
			return -EACCES;
		}
		puts(""OK\n"");
	}

	
	if (!host_build() && IS_ENABLED(CONFIG_FIT_IMAGE_POST_PROCESS))
		board_fit_image_post_process(&buf, &size);

	len = (ulong)size;

	bootstage_mark(bootstage_id + BOOTSTAGE_SUB_GET_DATA_OK);

	data = map_to_sysmem(buf);
	load = data;
	if (load_op == FIT_LOAD_IGNORED) {
		
	} else if (fit_image_get_load(fit, noffset, &load)) {
		if (load_op == FIT_LOAD_REQUIRED) {
			printf(""Can't get %s subimage load address!\n"",
			       prop_name);
			bootstage_error(bootstage_id + BOOTSTAGE_SUB_LOAD);
			return -EBADF;
		}
	} else if (load_op != FIT_LOAD_OPTIONAL_NON_ZERO || load) {
		ulong image_start, image_end;

		
		image_start = addr;
		image_end = addr + fit_get_size(fit);

		load_end = load + len;
		if (image_type != IH_TYPE_KERNEL &&
		    load < image_end && load_end > image_start) {
			printf(""Error: %s overwritten\n"", prop_name);
			return -EXDEV;
		}

		printf(""   Loading %s from 0x%08lx to 0x%08lx\n"",
		       prop_name, data, load);
	} else {
		load = data;	
	}

	comp = IH_COMP_NONE;
	loadbuf = buf;
	
	if (!fit_image_get_comp(fit, noffset, &comp) &&
	    comp != IH_COMP_NONE &&
	    !(image_type == IH_TYPE_KERNEL ||
	      image_type == IH_TYPE_KERNEL_NOLOAD ||
	      image_type == IH_TYPE_RAMDISK)) {
		ulong max_decomp_len = len * 20;
		if (load == data) {
			loadbuf = malloc(max_decomp_len);
			load = map_to_sysmem(loadbuf);
		} else {
			loadbuf = map_sysmem(load, max_decomp_len);
		}
		if (image_decomp(comp, load, data, image_type,
				loadbuf, buf, len, max_decomp_len, &load_end)) {
			printf(""Error decompressing %s\n"", prop_name);

			return -ENOEXEC;
		}
		len = load_end - load;
	} else if (load != data) {
		loadbuf = map_sysmem(load, len);
		memcpy(loadbuf, buf, len);
	}

	if (image_type == IH_TYPE_RAMDISK && comp != IH_COMP_NONE)
		puts(""WARNING: 'compression' nodes for ramdisks are deprecated,""
		     "" please fix your .its file!\n"");

	
	if (image_type == IH_TYPE_FLATDT && fdt_check_header(loadbuf)) {
		puts(""Subimage data is not a FDT"");
		return -ENOEXEC;
	}

	bootstage_mark(bootstage_id + BOOTSTAGE_SUB_LOAD);

	*datap = load;
	*lenp = len;
	if (fit_unamep)
		*fit_unamep = (char *)fit_uname;
	if (fit_uname_configp)
		*fit_uname_configp = (char *)(fit_uname_config ? :
					      fit_base_uname_config);

	return noffset;
}
","1. int cfg_noffset, noffset;
2. void *buf;
void *loadbuf;
size_t size;
3. uint8_t os_arch;
4. int ret;
5. fit_base_uname_config = NULL;
6. bootstage_mark(bootstage_id + BOOTSTAGE_SUB_FORMAT);
7. printf(""Signature checking prevents use of unit addresses (@) in nodes\n"");
8. bootstage_mark(bootstage_id + BOOTSTAGE_SUB_FORMAT_OK);
9. } else {
10. fit_uname_config);
11. if (image_type == IH_TYPE_KERNEL)
12. puts(""   Verifying Hash Integrity ... "");
13. bootstage_mark(BOOTSTAGE_ID_FIT_CONFIG);
14. return ret;
15. bootstage_error(bootstage_id + BOOTSTAGE_SUB_CHECK_ARCH);
16. bootstage_mark(bootstage_id + BOOTSTAGE_SUB_CHECK_ALL);
17. bootstage_error(bootstage_id + BOOTSTAGE_SUB_GET_DATA);
18. if (IS_ENABLED(CONFIG_FIT_CIPHER) && IMAGE_ENABLE_DECRYPT) {
19. board_fit_image_post_process(&buf, &size);
20. } else if (fit_image_get_load(fit, noffset, &load)) {
if (load_op == FIT_LOAD_REQUIRED) {
21. bootstage_error(bootstage_id + BOOTSTAGE_SUB_LOAD);
22. ulong image_start, image_end;
23. load_end = load + len;
if (image_type != IH_TYPE_KERNEL &&
24. printf(""Error: %s overwritten\n"", prop_name);
25. comp = IH_COMP_NONE;
26. image_type == IH_TYPE_RAMDISK)) {
27. return noffset;","6
11-13
18
21
26
30
35
39
44
55
67
71
81
98
105
115
150
155
166
176-177
180
184
193-194
196
206
213
253","CWE-17,CWE-264,CWE-399,CWE-119"
ieee80211_parse_tx_radiotap-252258945730322,"bool ieee80211_parse_tx_radiotap(struct sk_buff *skb,
				 struct net_device *dev)
{
	struct ieee80211_local *local = wdev_priv(dev->ieee80211_ptr);
	struct ieee80211_radiotap_iterator iterator;
	struct ieee80211_radiotap_header *rthdr =
		(struct ieee80211_radiotap_header *) skb->data;
	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
	int ret = ieee80211_radiotap_iterator_init(&iterator, rthdr, skb->len,
						   NULL);
	u16 txflags;
	u16 rate = 0;
	bool rate_found = false;
	u8 rate_retries = 0;
	u16 rate_flags = 0;
	u8 mcs_known, mcs_flags, mcs_bw;
	u16 vht_known;
	u8 vht_mcs = 0, vht_nss = 0;
	int i;

	if (!ieee80211_validate_radiotap_len(skb))
		return false;

	info->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT |
		       IEEE80211_TX_CTL_DONTFRAG;

	

	while (!ret) {
		ret = ieee80211_radiotap_iterator_next(&iterator);

		if (ret)
			continue;

		
		switch (iterator.this_arg_index) {
		
		case IEEE80211_RADIOTAP_FLAGS:
			if (*iterator.this_arg & IEEE80211_RADIOTAP_F_FCS) {
				
				if (skb->len < (iterator._max_length + FCS_LEN))
					return false;

				skb_trim(skb, skb->len - FCS_LEN);
			}
			if (*iterator.this_arg & IEEE80211_RADIOTAP_F_WEP)
				info->flags &= ~IEEE80211_TX_INTFL_DONT_ENCRYPT;
			if (*iterator.this_arg & IEEE80211_RADIOTAP_F_FRAG)
				info->flags &= ~IEEE80211_TX_CTL_DONTFRAG;
			break;

		case IEEE80211_RADIOTAP_TX_FLAGS:
			txflags = get_unaligned_le16(iterator.this_arg);
			if (txflags & IEEE80211_RADIOTAP_F_TX_NOACK)
				info->flags |= IEEE80211_TX_CTL_NO_ACK;
			if (txflags & IEEE80211_RADIOTAP_F_TX_NOSEQNO)
				info->control.flags |= IEEE80211_TX_CTRL_NO_SEQNO;
			if (txflags & IEEE80211_RADIOTAP_F_TX_ORDER)
				info->control.flags |=
					IEEE80211_TX_CTRL_DONT_REORDER;
			break;

		case IEEE80211_RADIOTAP_RATE:
			rate = *iterator.this_arg;
			rate_flags = 0;
			rate_found = true;
			break;

		case IEEE80211_RADIOTAP_DATA_RETRIES:
			rate_retries = *iterator.this_arg;
			break;

		case IEEE80211_RADIOTAP_MCS:
			mcs_known = iterator.this_arg[0];
			mcs_flags = iterator.this_arg[1];
			if (!(mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_MCS))
				break;

			rate_found = true;
			rate = iterator.this_arg[2];
			rate_flags = IEEE80211_TX_RC_MCS;

			if (mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_GI &&
			    mcs_flags & IEEE80211_RADIOTAP_MCS_SGI)
				rate_flags |= IEEE80211_TX_RC_SHORT_GI;

			mcs_bw = mcs_flags & IEEE80211_RADIOTAP_MCS_BW_MASK;
			if (mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_BW &&
			    mcs_bw == IEEE80211_RADIOTAP_MCS_BW_40)
				rate_flags |= IEEE80211_TX_RC_40_MHZ_WIDTH;

			if (mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_FEC &&
			    mcs_flags & IEEE80211_RADIOTAP_MCS_FEC_LDPC)
				info->flags |= IEEE80211_TX_CTL_LDPC;

			if (mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_STBC) {
				u8 stbc = u8_get_bits(mcs_flags,
						      IEEE80211_RADIOTAP_MCS_STBC_MASK);

				info->flags |=
					u32_encode_bits(stbc,
							IEEE80211_TX_CTL_STBC);
			}
			break;

		case IEEE80211_RADIOTAP_VHT:
			vht_known = get_unaligned_le16(iterator.this_arg);
			rate_found = true;

			rate_flags = IEEE80211_TX_RC_VHT_MCS;
			if ((vht_known & IEEE80211_RADIOTAP_VHT_KNOWN_GI) &&
			    (iterator.this_arg[2] &
			     IEEE80211_RADIOTAP_VHT_FLAG_SGI))
				rate_flags |= IEEE80211_TX_RC_SHORT_GI;
			if (vht_known &
			    IEEE80211_RADIOTAP_VHT_KNOWN_BANDWIDTH) {
				if (iterator.this_arg[3] == 1)
					rate_flags |=
						IEEE80211_TX_RC_40_MHZ_WIDTH;
				else if (iterator.this_arg[3] == 4)
					rate_flags |=
						IEEE80211_TX_RC_80_MHZ_WIDTH;
				else if (iterator.this_arg[3] == 11)
					rate_flags |=
						IEEE80211_TX_RC_160_MHZ_WIDTH;
			}

			vht_mcs = iterator.this_arg[4] >> 4;
			vht_nss = iterator.this_arg[4] & 0xF;
			break;

		

		default:
			break;
		}
	}

	if (ret != -ENOENT) 
		return false;

	if (rate_found) {
		struct ieee80211_supported_band *sband =
			local->hw.wiphy->bands[info->band];

		info->control.flags |= IEEE80211_TX_CTRL_RATE_INJECT;

		for (i = 0; i < IEEE80211_TX_MAX_RATES; i++) {
			info->control.rates[i].idx = -1;
			info->control.rates[i].flags = 0;
			info->control.rates[i].count = 0;
		}

		if (rate_flags & IEEE80211_TX_RC_MCS) {
			info->control.rates[0].idx = rate;
		} else if (rate_flags & IEEE80211_TX_RC_VHT_MCS) {
			ieee80211_rate_set_vht(info->control.rates, vht_mcs,
					       vht_nss);
		} else if (sband) {
			for (i = 0; i < sband->n_bitrates; i++) {
				if (rate * 5 != sband->bitrates[i].bitrate)
					continue;

				info->control.rates[0].idx = i;
				break;
			}
		}

		if (info->control.rates[0].idx < 0)
			info->control.flags &= ~IEEE80211_TX_CTRL_RATE_INJECT;

		info->control.rates[0].flags = rate_flags;
		info->control.rates[0].count = min_t(u8, rate_retries + 1,
						     local->hw.max_rate_tries);
	}

	return true;
}
","1. struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
2. while (!ret) {
3. skb_trim(skb, skb->len - FCS_LEN);
4. if (txflags & IEEE80211_RADIOTAP_F_TX_NOSEQNO)
5. if (txflags & IEEE80211_RADIOTAP_F_TX_ORDER)
6. break;
7. mcs_flags & IEEE80211_RADIOTAP_MCS_SGI)
8. if (mcs_known & IEEE80211_RADIOTAP_MCS_HAVE_STBC) {
9. IEEE80211_RADIOTAP_MCS_STBC_MASK);
10. vht_nss = iterator.this_arg[4] & 0xF;
11. if (info->control.rates[0].idx < 0)
12. local->hw.max_rate_tries);","8
33
59
71
73
86
99
111
113
144
188
193","CWE-362,CWE-295,CWE-20,CWE-90"
ProcXIChangeHierarchy,"
#define ClientPtr

ProcXIChangeHierarchy(ClientPtr client)
{
    xXIAnyHierarchyChangeInfo *any;
    size_t len;			
    int rc = Success;
    int flags[MAXDEVICES] = { 0 };

    REQUEST(xXIChangeHierarchyReq);
    REQUEST_AT_LEAST_SIZE(xXIChangeHierarchyReq);

     if (!stuff->num_changes)
         return rc;
 
    len = ((size_t)stuff->length << 2) - sizeof(xXIChangeHierarchyReq);
 
     any = (xXIAnyHierarchyChangeInfo *) &stuff[1];
     while (stuff->num_changes--) {
        if (len < sizeof(xXIAnyHierarchyChangeInfo)) {
            rc = BadLength;
            goto unwind;
        }

        SWAPIF(swaps(&any->type));
        SWAPIF(swaps(&any->length));

        if (len < ((size_t)any->length << 2))
            return BadLength;

#define CHANGE_SIZE_MATCH(type) \
    do { \
        if ((len < sizeof(type)) || (any->length != (sizeof(type) >> 2))) { \
            rc = BadLength; \
            goto unwind; \
        } \
    } while(0)

        switch (any->type) {
        case XIAddMaster:
        {
            xXIAddMasterInfo *c = (xXIAddMasterInfo *) any;

            
            if (len < sizeof(xXIAddMasterInfo)) {
                rc = BadLength;
                goto unwind;
            }
            SWAPIF(swaps(&c->name_len));
            if (c->name_len > (len - sizeof(xXIAddMasterInfo))) {
                rc = BadLength;
                goto unwind;
            }

            rc = add_master(client, c, flags);
            if (rc != Success)
                goto unwind;
        }
            break;
        case XIRemoveMaster:
        {
            xXIRemoveMasterInfo *r = (xXIRemoveMasterInfo *) any;

            CHANGE_SIZE_MATCH(xXIRemoveMasterInfo);
            rc = remove_master(client, r, flags);
            if (rc != Success)
                goto unwind;
        }
            break;
        case XIDetachSlave:
        {
            xXIDetachSlaveInfo *c = (xXIDetachSlaveInfo *) any;

            CHANGE_SIZE_MATCH(xXIDetachSlaveInfo);
            rc = detach_slave(client, c, flags);
            if (rc != Success)
                goto unwind;
        }
            break;
        case XIAttachSlave:
        {
            xXIAttachSlaveInfo *c = (xXIAttachSlaveInfo *) any;

            CHANGE_SIZE_MATCH(xXIAttachSlaveInfo);
            rc = attach_slave(client, c, flags);
            if (rc != Success)
                goto unwind;
        }
            break;
        }

        len -= any->length * 4;
        any = (xXIAnyHierarchyChangeInfo *) ((char *) any + any->length * 4);
    }

 unwind:

    XISendDeviceHierarchyEvent(flags);
    return rc;
}
","1. xXIAnyHierarchyChangeInfo *any;
size_t len;
2. REQUEST_AT_LEAST_SIZE(xXIChangeHierarchyReq);
3. return rc;
4. any = (xXIAnyHierarchyChangeInfo *) &stuff[1];
5. return BadLength;
6. switch (any->type) {
7. xXIAddMasterInfo *c = (xXIAddMasterInfo *) any;
8. rc = BadLength;
goto unwind;
9. if (c->name_len > (len - sizeof(xXIAddMasterInfo))) {
rc = BadLength;
goto unwind;
10. goto unwind;
11. xXIRemoveMasterInfo *r = (xXIRemoveMasterInfo *) any;
12. if (rc != Success)
13. CHANGE_SIZE_MATCH(xXIDetachSlaveInfo);
rc = detach_slave(client, c, flags);
14. goto unwind;
15. return rc;","6-7
12
15
19
30
40
43
47-48
51-53
58
63
67
75-76
88
100","CWE-476,CWE-119,CWE-823,CWE-189"
app_initialize-167341731787894,"int app_initialize(const char *const argv[])
{
    const char *argv_out[OGS_ARG_MAX];
    bool user_config = false;
    int i = 0;

    for (i = 0; argv[i] && i < OGS_ARG_MAX-3; i++) {
        if (strcmp(""-c"", argv[i]) == 0) {
            user_config = true; 
        }
        argv_out[i] = argv[i];
    }
    argv_out[i] = NULL;

    if (!user_config) {
        argv_out[i++] = ""-c"";
        argv_out[i++] = DEFAULT_CONFIG_FILENAME;
        argv_out[i] = NULL;
    }

    if (ogs_app()->parameter.no_nrf == 0)
        nrf_thread = test_child_create(""nrf"", argv_out);
    if (ogs_app()->parameter.no_scp == 0)
        scp_thread = test_child_create(""scp"", argv_out);

    if (ogs_app()->parameter.no_upf == 0)
        upf_thread = test_child_create(""upf"", argv_out);
    if (ogs_app()->parameter.no_smf == 0)
        smf_thread = test_child_create(""smf"", argv_out);

    if (ogs_app()->parameter.no_amf == 0)
        amf_thread = test_child_create(""amf"", argv_out);

    if (ogs_app()->parameter.no_ausf == 0)
        ausf_thread = test_child_create(""ausf"", argv_out);
    if (ogs_app()->parameter.no_udm == 0)
        udm_thread = test_child_create(""udm"", argv_out);
    if (ogs_app()->parameter.no_pcf == 0)
        pcf_thread = test_child_create(""pcf"", argv_out);
    if (ogs_app()->parameter.no_nssf == 0)
        nssf_thread = test_child_create(""nssf"", argv_out);
    if (ogs_app()->parameter.no_bsf == 0)
        bsf_thread = test_child_create(""bsf"", argv_out);
    if (ogs_app()->parameter.no_udr == 0)
        udr_thread = test_child_create(""udr"", argv_out);

    
    ogs_msleep(300);

    return OGS_OK;;
}
","1. const char *argv_out[OGS_ARG_MAX];
2. nrf_thread = test_child_create(""nrf"", argv_out);
3. if (ogs_app()->parameter.no_amf == 0)
4. ausf_thread = test_child_create(""ausf"", argv_out);
if (ogs_app()->parameter.no_udm == 0)
5. if (ogs_app()->parameter.no_pcf == 0)
6. if (ogs_app()->parameter.no_nssf == 0)
7. return OGS_OK;;","3
22
31
35-36
38
40
54","CWE-362,CWE-787,CWE-330,CWE-59"
link_pipe,"static int link_pipe(struct pipe_inode_info *ipipe,
		     struct pipe_inode_info *opipe,
		     size_t len, unsigned int flags)
{
	struct pipe_buffer *ibuf, *obuf;
	int ret = 0, i = 0, nbuf;

	
	pipe_double_lock(ipipe, opipe);

	do {
		if (!opipe->readers) {
			send_sig(SIGPIPE, current, 0);
			if (!ret)
				ret = -EPIPE;
			break;
		}

		
		if (i >= ipipe->nrbufs || opipe->nrbufs >= opipe->buffers)
			break;

		ibuf = ipipe->bufs + ((ipipe->curbuf + i) & (ipipe->buffers-1));
		nbuf = (opipe->curbuf + opipe->nrbufs) & (opipe->buffers - 1);

		
		if (!pipe_buf_get(ipipe, ibuf)) {
			if (ret == 0)
				ret = -EFAULT;
			break;
		}
 
 		obuf = opipe->bufs + nbuf;
 		*obuf = *ibuf;

		
		obuf->flags &= ~PIPE_BUF_FLAG_GIFT;

		pipe_buf_mark_unmergeable(obuf);

		if (obuf->len > len)
			obuf->len = len;

		opipe->nrbufs++;
		ret += obuf->len;
		len -= obuf->len;
		i++;
	} while (len);

	
	if (!ret && ipipe->waiting_writers && (flags & SPLICE_F_NONBLOCK))
		ret = -EAGAIN;

	pipe_unlock(ipipe);
	pipe_unlock(opipe);

	
	if (ret > 0)
		wakeup_pipe_readers(opipe);

	return ret;
}
","1. static int link_pipe(struct pipe_inode_info *ipipe,
2. size_t len, unsigned int flags)
3. pipe_double_lock(ipipe, opipe);
4. if (!opipe->readers) {
send_sig(SIGPIPE, current, 0);
if (!ret)
5. break;
6. if (i >= ipipe->nrbufs || opipe->nrbufs >= opipe->buffers)
break;
7. nbuf = (opipe->curbuf + opipe->nrbufs) & (opipe->buffers - 1);
8. if (!pipe_buf_get(ipipe, ibuf)) {
9. break;
10. *obuf = *ibuf;
11. if (obuf->len > len)
obuf->len = len;
12. opipe->nrbufs++;
13. i++;
} while (len);
14. pipe_unlock(opipe);
15. if (ret > 0)
wakeup_pipe_readers(opipe);","1
3
13
16-18
20
27-28
31
37
40
44
54-55
57
60-61
71
76-77","CWE-17,CWE-416"
pkinit_server_verify_padata-271734510412088,"static void
pkinit_server_verify_padata(krb5_context context,
                            krb5_data *req_pkt,
                            krb5_kdc_req * request,
                            krb5_enc_tkt_part * enc_tkt_reply,
                            krb5_pa_data * data,
                            krb5_kdcpreauth_callbacks cb,
                            krb5_kdcpreauth_rock rock,
                            krb5_kdcpreauth_moddata moddata,
                            krb5_kdcpreauth_verify_respond_fn respond,
                            void *arg)
{
    krb5_error_code retval = 0;
    krb5_data authp_data = {0, 0, NULL}, krb5_authz = {0, 0, NULL};
    krb5_pa_pk_as_req *reqp = NULL;
    krb5_pa_pk_as_req_draft9 *reqp9 = NULL;
    krb5_auth_pack *auth_pack = NULL;
    krb5_auth_pack_draft9 *auth_pack9 = NULL;
    pkinit_kdc_context plgctx = NULL;
    pkinit_kdc_req_context reqctx = NULL;
    krb5_checksum cksum = {0, 0, 0, NULL};
    krb5_data *der_req = NULL;
    int valid_eku = 0, valid_san = 0;
    krb5_data k5data;
    int is_signed = 1;
    krb5_pa_data **e_data = NULL;
    krb5_kdcpreauth_modreq modreq = NULL;

    pkiDebug(""pkinit_verify_padata: entered!\n"");
    if (data == NULL || data->length <= 0 || data->contents == NULL) {
        (*respond)(arg, EINVAL, NULL, NULL, NULL);
        return;
    }


    if (moddata == NULL) {
        (*respond)(arg, EINVAL, NULL, NULL, NULL);
        return;
    }

    plgctx = pkinit_find_realm_context(context, moddata, request->server);
    if (plgctx == NULL) {
        (*respond)(arg, EINVAL, NULL, NULL, NULL);
        return;
    }

#ifdef DEBUG_ASN1
    print_buffer_bin(data->contents, data->length, ""/tmp/kdc_as_req"");
#endif
    
    retval = pkinit_init_kdc_req_context(context, &reqctx);
    if (retval)
        goto cleanup;
    reqctx->pa_type = data->pa_type;

    PADATA_TO_KRB5DATA(data, &k5data);

    switch ((int)data->pa_type) {
    case KRB5_PADATA_PK_AS_REQ:
        pkiDebug(""processing KRB5_PADATA_PK_AS_REQ\n"");
        retval = k5int_decode_krb5_pa_pk_as_req(&k5data, &reqp);
        if (retval) {
            pkiDebug(""decode_krb5_pa_pk_as_req failed\n"");
            goto cleanup;
        }
#ifdef DEBUG_ASN1
        print_buffer_bin(reqp->signedAuthPack.data,
                         reqp->signedAuthPack.length,
                         ""/tmp/kdc_signed_data"");
#endif
        retval = cms_signeddata_verify(context, plgctx->cryptoctx,
                                       reqctx->cryptoctx, plgctx->idctx, CMS_SIGN_CLIENT,
                                       plgctx->opts->require_crl_checking,
                                       (unsigned char *)
                                       reqp->signedAuthPack.data, reqp->signedAuthPack.length,
                                       (unsigned char **)&authp_data.data,
                                       &authp_data.length,
                                       (unsigned char **)&krb5_authz.data,
                                       &krb5_authz.length, &is_signed);
        break;
    case KRB5_PADATA_PK_AS_REP_OLD:
    case KRB5_PADATA_PK_AS_REQ_OLD:
        pkiDebug(""processing KRB5_PADATA_PK_AS_REQ_OLD\n"");
        retval = k5int_decode_krb5_pa_pk_as_req_draft9(&k5data, &reqp9);
        if (retval) {
            pkiDebug(""decode_krb5_pa_pk_as_req_draft9 failed\n"");
            goto cleanup;
        }
#ifdef DEBUG_ASN1
        print_buffer_bin(reqp9->signedAuthPack.data,
                         reqp9->signedAuthPack.length,
                         ""/tmp/kdc_signed_data_draft9"");
#endif

        retval = cms_signeddata_verify(context, plgctx->cryptoctx,
                                       reqctx->cryptoctx, plgctx->idctx, CMS_SIGN_DRAFT9,
                                       plgctx->opts->require_crl_checking,
                                       (unsigned char *)
                                       reqp9->signedAuthPack.data, reqp9->signedAuthPack.length,
                                       (unsigned char **)&authp_data.data,
                                       &authp_data.length,
                                       (unsigned char **)&krb5_authz.data,
                                       &krb5_authz.length, NULL);
        break;
    default:
        pkiDebug(""unrecognized pa_type = %d\n"", data->pa_type);
        retval = EINVAL;
        goto cleanup;
    }
    if (retval) {
        pkiDebug(""pkcs7_signeddata_verify failed\n"");
        goto cleanup;
    }
    if (is_signed) {

        retval = verify_client_san(context, plgctx, reqctx, request->client,
                                   &valid_san);
        if (retval)
            goto cleanup;
        if (!valid_san) {
            pkiDebug(""%s: did not find an acceptable SAN in user ""
                     ""certificate\n"", __FUNCTION__);
            retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;
            goto cleanup;
        }
        retval = verify_client_eku(context, plgctx, reqctx, &valid_eku);
        if (retval)
            goto cleanup;

        if (!valid_eku) {
            pkiDebug(""%s: did not find an acceptable EKU in user ""
                     ""certificate\n"", __FUNCTION__);
            retval = KRB5KDC_ERR_INCONSISTENT_KEY_PURPOSE;
            goto cleanup;
        }
    } else { 
        if (!krb5_principal_compare(context, request->client,
                                    krb5_anonymous_principal())) {
            retval = KRB5KDC_ERR_PREAUTH_FAILED;
            krb5_set_error_message(context, retval,
                                   _(""Pkinit request not signed, but client ""
                                     ""not anonymous.""));
            goto cleanup;
        }
    }
#ifdef DEBUG_ASN1
    print_buffer_bin(authp_data.data, authp_data.length, ""/tmp/kdc_auth_pack"");
#endif

    OCTETDATA_TO_KRB5DATA(&authp_data, &k5data);
    switch ((int)data->pa_type) {
    case KRB5_PADATA_PK_AS_REQ:
        retval = k5int_decode_krb5_auth_pack(&k5data, &auth_pack);
        if (retval) {
            pkiDebug(""failed to decode krb5_auth_pack\n"");
            goto cleanup;
        }

        retval = krb5_check_clockskew(context,
                                      auth_pack->pkAuthenticator.ctime);
        if (retval)
            goto cleanup;

        
        if (auth_pack->clientPublicValue != NULL) {
            retval = server_check_dh(context, plgctx->cryptoctx,
                                     reqctx->cryptoctx, plgctx->idctx,
                                     &auth_pack->clientPublicValue->algorithm.parameters,
                                     plgctx->opts->dh_min_bits);

            if (retval) {
                pkiDebug(""bad dh parameters\n"");
                goto cleanup;
            }
        } else if (!is_signed) {
            
            retval = KRB5KDC_ERR_PREAUTH_FAILED;
            krb5_set_error_message(context, retval,
                                   _(""Anonymous pkinit without DH public ""
                                     ""value not supported.""));
            goto cleanup;
        }
        der_req = cb->request_body(context, rock);
        retval = krb5_c_make_checksum(context, CKSUMTYPE_NIST_SHA, NULL,
                                      0, der_req, &cksum);
        if (retval) {
            pkiDebug(""unable to calculate AS REQ checksum\n"");
            goto cleanup;
        }
        if (cksum.length != auth_pack->pkAuthenticator.paChecksum.length ||
            k5_bcmp(cksum.contents,
                    auth_pack->pkAuthenticator.paChecksum.contents,
                    cksum.length) != 0) {
            pkiDebug(""failed to match the checksum\n"");
#ifdef DEBUG_CKSUM
            pkiDebug(""calculating checksum on buf size (%d)\n"",
                     req_pkt->length);
            print_buffer(req_pkt->data, req_pkt->length);
            pkiDebug(""received checksum type=%d size=%d "",
                     auth_pack->pkAuthenticator.paChecksum.checksum_type,
                     auth_pack->pkAuthenticator.paChecksum.length);
            print_buffer(auth_pack->pkAuthenticator.paChecksum.contents,
                         auth_pack->pkAuthenticator.paChecksum.length);
            pkiDebug(""expected checksum type=%d size=%d "",
                     cksum.checksum_type, cksum.length);
            print_buffer(cksum.contents, cksum.length);
#endif

            retval = KRB5KDC_ERR_PA_CHECKSUM_MUST_BE_INCLUDED;
            goto cleanup;
        }

        
        if (reqp->kdcPkId.data != NULL) {
            int valid_kdcPkId = 0;
            retval = pkinit_check_kdc_pkid(context, plgctx->cryptoctx,
                                           reqctx->cryptoctx, plgctx->idctx,
                                           (unsigned char *)reqp->kdcPkId.data,
                                           reqp->kdcPkId.length, &valid_kdcPkId);
            if (retval)
                goto cleanup;
            if (!valid_kdcPkId)
                pkiDebug(""kdcPkId in AS_REQ does not match KDC's cert""
                         ""RFC says to ignore and proceed\n"");

        }
        
        reqctx->rcv_auth_pack = auth_pack;
        auth_pack = NULL;
        break;
    case KRB5_PADATA_PK_AS_REP_OLD:
    case KRB5_PADATA_PK_AS_REQ_OLD:
        retval = k5int_decode_krb5_auth_pack_draft9(&k5data, &auth_pack9);
        if (retval) {
            pkiDebug(""failed to decode krb5_auth_pack_draft9\n"");
            goto cleanup;
        }
        if (auth_pack9->clientPublicValue != NULL) {
            retval = server_check_dh(context, plgctx->cryptoctx,
                                     reqctx->cryptoctx, plgctx->idctx,
                                     &auth_pack9->clientPublicValue->algorithm.parameters,
                                     plgctx->opts->dh_min_bits);

            if (retval) {
                pkiDebug(""bad dh parameters\n"");
                goto cleanup;
            }
        }
        
        reqctx->rcv_auth_pack9 = auth_pack9;
        auth_pack9 = NULL;
        break;
    }

    
    enc_tkt_reply->flags |= TKT_FLG_PRE_AUTH;
    modreq = (krb5_kdcpreauth_modreq)reqctx;
    reqctx = NULL;

cleanup:
    if (retval && data->pa_type == KRB5_PADATA_PK_AS_REQ) {
        pkiDebug(""pkinit_verify_padata failed: creating e-data\n"");
        if (pkinit_create_edata(context, plgctx->cryptoctx, reqctx->cryptoctx,
                                plgctx->idctx, plgctx->opts, retval, &e_data))
            pkiDebug(""pkinit_create_edata failed\n"");
    }

    switch ((int)data->pa_type) {
    case KRB5_PADATA_PK_AS_REQ:
        free_krb5_pa_pk_as_req(&reqp);
        free(cksum.contents);
        break;
    case KRB5_PADATA_PK_AS_REP_OLD:
    case KRB5_PADATA_PK_AS_REQ_OLD:
        free_krb5_pa_pk_as_req_draft9(&reqp9);
    }
    free(authp_data.data);
    free(krb5_authz.data);
    if (reqctx != NULL)
        pkinit_fini_kdc_req_context(context, reqctx);
    free_krb5_auth_pack(&auth_pack);
    free_krb5_auth_pack_draft9(context, &auth_pack9);

    (*respond)(arg, retval, modreq, e_data, NULL);
}
","1. krb5_kdcpreauth_verify_respond_fn respond,
2. return;
3. (unsigned char *)
4. (unsigned char **)&authp_data.data,
5. ""certificate\n"", __FUNCTION__);
6. retval = verify_client_eku(context, plgctx, reqctx, &valid_eku);
7. pkiDebug(""%s: did not find an acceptable EKU in user ""
8. reqp->kdcPkId.length, &valid_kdcPkId);
9. goto cleanup;
10. break;","10
38
74
76
122
126
131
219
221
252","CWE-252,CWE-264,CWE-611"
modbus_reply,"int modbus_reply(modbus_t *ctx, const uint8_t *req,
                 int req_length, modbus_mapping_t *mb_mapping)
{
    int offset;
    int slave;
    int function;
    uint16_t address;
    uint8_t rsp[MAX_MESSAGE_LENGTH];
    int rsp_length = 0;
    sft_t sft;

    if (ctx == NULL) {
        errno = EINVAL;
        return -1;
    }

    offset = ctx->backend->header_length;
    slave = req[offset - 1];
    function = req[offset];
    address = (req[offset + 1] << 8) + req[offset + 2];

    sft.slave = slave;
    sft.function = function;
    sft.t_id = ctx->backend->prepare_response_tid(req, &req_length);

    
    switch (function) {
    case MODBUS_FC_READ_COILS:
    case MODBUS_FC_READ_DISCRETE_INPUTS: {
        unsigned int is_input = (function == MODBUS_FC_READ_DISCRETE_INPUTS);
        int start_bits = is_input ? mb_mapping->start_input_bits : mb_mapping->start_bits;
        int nb_bits = is_input ? mb_mapping->nb_input_bits : mb_mapping->nb_bits;
        uint8_t *tab_bits = is_input ? mb_mapping->tab_input_bits : mb_mapping->tab_bits;
        const char * const name = is_input ? ""read_input_bits"" : ""read_bits"";
        int nb = (req[offset + 3] << 8) + req[offset + 4];
        
        int mapping_address = address - start_bits;

        if (nb < 1 || MODBUS_MAX_READ_BITS < nb) {
            rsp_length = response_exception(
                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,
                ""Illegal nb of values %d in %s (max %d)\n"",
                nb, name, MODBUS_MAX_READ_BITS);
        } else if (mapping_address < 0 || (mapping_address + nb) > nb_bits) {
            rsp_length = response_exception(
                ctx, &sft,
                MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,
                ""Illegal data address 0x%0X in %s\n"",
                mapping_address < 0 ? address : address + nb, name);
        } else {
            rsp_length = ctx->backend->build_response_basis(&sft, rsp);
            rsp[rsp_length++] = (nb / 8) + ((nb % 8) ? 1 : 0);
            rsp_length = response_io_status(tab_bits, mapping_address, nb,
                                            rsp, rsp_length);
        }
    }
        break;
    case MODBUS_FC_READ_HOLDING_REGISTERS:
    case MODBUS_FC_READ_INPUT_REGISTERS: {
        unsigned int is_input = (function == MODBUS_FC_READ_INPUT_REGISTERS);
        int start_registers = is_input ? mb_mapping->start_input_registers : mb_mapping->start_registers;
        int nb_registers = is_input ? mb_mapping->nb_input_registers : mb_mapping->nb_registers;
        uint16_t *tab_registers = is_input ? mb_mapping->tab_input_registers : mb_mapping->tab_registers;
        const char * const name = is_input ? ""read_input_registers"" : ""read_registers"";
        int nb = (req[offset + 3] << 8) + req[offset + 4];
        
        int mapping_address = address - start_registers;

        if (nb < 1 || MODBUS_MAX_READ_REGISTERS < nb) {
            rsp_length = response_exception(
                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,
                ""Illegal nb of values %d in %s (max %d)\n"",
                nb, name, MODBUS_MAX_READ_REGISTERS);
        } else if (mapping_address < 0 || (mapping_address + nb) > nb_registers) {
            rsp_length = response_exception(
                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,
                ""Illegal data address 0x%0X in %s\n"",
                mapping_address < 0 ? address : address + nb, name);
        } else {
            int i;

            rsp_length = ctx->backend->build_response_basis(&sft, rsp);
            rsp[rsp_length++] = nb << 1;
            for (i = mapping_address; i < mapping_address + nb; i++) {
                rsp[rsp_length++] = tab_registers[i] >> 8;
                rsp[rsp_length++] = tab_registers[i] & 0xFF;
            }
        }
    }
        break;
    case MODBUS_FC_WRITE_SINGLE_COIL: {
        int mapping_address = address - mb_mapping->start_bits;

        if (mapping_address < 0 || mapping_address >= mb_mapping->nb_bits) {
            rsp_length = response_exception(
                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,
                ""Illegal data address 0x%0X in write_bit\n"",
                address);
        } else {
            int data = (req[offset + 3] << 8) + req[offset + 4];

            if (data == 0xFF00 || data == 0x0) {
                mb_mapping->tab_bits[mapping_address] = data ? ON : OFF;
                memcpy(rsp, req, req_length);
                rsp_length = req_length;
            } else {
                rsp_length = response_exception(
                    ctx, &sft,
                    MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, FALSE,
                    ""Illegal data value 0x%0X in write_bit request at address %0X\n"",
                    data, address);
            }
        }
    }
        break;
    case MODBUS_FC_WRITE_SINGLE_REGISTER: {
        int mapping_address = address - mb_mapping->start_registers;

        if (mapping_address < 0 || mapping_address >= mb_mapping->nb_registers) {
            rsp_length = response_exception(
                ctx, &sft,
                MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,
                ""Illegal data address 0x%0X in write_register\n"",
                address);
        } else {
            int data = (req[offset + 3] << 8) + req[offset + 4];

            mb_mapping->tab_registers[mapping_address] = data;
            memcpy(rsp, req, req_length);
            rsp_length = req_length;
        }
    }
         break;
     case MODBUS_FC_WRITE_MULTIPLE_COILS: {
         int nb = (req[offset + 3] << 8) + req[offset + 4];
        int nb_bits = req[offset + 5];
         int mapping_address = address - mb_mapping->start_bits;
 
        if (nb < 1 || MODBUS_MAX_WRITE_BITS < nb || nb_bits * 8 < nb) {
             
            rsp_length = response_exception(
                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,
                ""Illegal number of values %d in write_bits (max %d)\n"",
                nb, MODBUS_MAX_WRITE_BITS);
        } else if (mapping_address < 0 ||
                   (mapping_address + nb) > mb_mapping->nb_bits) {
            rsp_length = response_exception(
                ctx, &sft,
                MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,
                ""Illegal data address 0x%0X in write_bits\n"",
                mapping_address < 0 ? address : address + nb);
        } else {
            
            modbus_set_bits_from_bytes(mb_mapping->tab_bits, mapping_address, nb,
                                       &req[offset + 6]);

            rsp_length = ctx->backend->build_response_basis(&sft, rsp);
            
            memcpy(rsp + rsp_length, req + rsp_length, 4);
            rsp_length += 4;
        }
    }
         break;
     case MODBUS_FC_WRITE_MULTIPLE_REGISTERS: {
         int nb = (req[offset + 3] << 8) + req[offset + 4];
        int nb_bytes = req[offset + 5];
         int mapping_address = address - mb_mapping->start_registers;
 
        if (nb < 1 || MODBUS_MAX_WRITE_REGISTERS < nb || nb_bytes * 8 < nb) {
             rsp_length = response_exception(
                 ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,
                 ""Illegal number of values %d in write_registers (max %d)\n"",
                nb, MODBUS_MAX_WRITE_REGISTERS);
        } else if (mapping_address < 0 ||
                   (mapping_address + nb) > mb_mapping->nb_registers) {
            rsp_length = response_exception(
                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,
                ""Illegal data address 0x%0X in write_registers\n"",
                mapping_address < 0 ? address : address + nb);
        } else {
            int i, j;
            for (i = mapping_address, j = 6; i < mapping_address + nb; i++, j += 2) {
                
                mb_mapping->tab_registers[i] =
                    (req[offset + j] << 8) + req[offset + j + 1];
            }

            rsp_length = ctx->backend->build_response_basis(&sft, rsp);
            
            memcpy(rsp + rsp_length, req + rsp_length, 4);
            rsp_length += 4;
        }
    }
        break;
    case MODBUS_FC_REPORT_SLAVE_ID: {
        int str_len;
        int byte_count_pos;

        rsp_length = ctx->backend->build_response_basis(&sft, rsp);
        
        byte_count_pos = rsp_length++;
        rsp[rsp_length++] = _REPORT_SLAVE_ID;
        
        rsp[rsp_length++] = 0xFF;
        
        str_len = 3 + strlen(LIBMODBUS_VERSION_STRING);
        memcpy(rsp + rsp_length, ""LMB"" LIBMODBUS_VERSION_STRING, str_len);
        rsp_length += str_len;
        rsp[byte_count_pos] = rsp_length - byte_count_pos - 1;
    }
        break;
    case MODBUS_FC_READ_EXCEPTION_STATUS:
        if (ctx->debug) {
            fprintf(stderr, ""FIXME Not implemented\n"");
        }
        errno = ENOPROTOOPT;
        return -1;
        break;
    case MODBUS_FC_MASK_WRITE_REGISTER: {
        int mapping_address = address - mb_mapping->start_registers;

        if (mapping_address < 0 || mapping_address >= mb_mapping->nb_registers) {
            rsp_length = response_exception(
                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,
                ""Illegal data address 0x%0X in write_register\n"",
                address);
        } else {
            uint16_t data = mb_mapping->tab_registers[mapping_address];
            uint16_t and = (req[offset + 3] << 8) + req[offset + 4];
            uint16_t or = (req[offset + 5] << 8) + req[offset + 6];

            data = (data & and) | (or & (~and));
            mb_mapping->tab_registers[mapping_address] = data;
            memcpy(rsp, req, req_length);
            rsp_length = req_length;
        }
    }
        break;
    case MODBUS_FC_WRITE_AND_READ_REGISTERS: {
        int nb = (req[offset + 3] << 8) + req[offset + 4];
        uint16_t address_write = (req[offset + 5] << 8) + req[offset + 6];
        int nb_write = (req[offset + 7] << 8) + req[offset + 8];
        int nb_write_bytes = req[offset + 9];
        int mapping_address = address - mb_mapping->start_registers;
        int mapping_address_write = address_write - mb_mapping->start_registers;

        if (nb_write < 1 || MODBUS_MAX_WR_WRITE_REGISTERS < nb_write ||
            nb < 1 || MODBUS_MAX_WR_READ_REGISTERS < nb ||
            nb_write_bytes != nb_write * 2) {
            rsp_length = response_exception(
                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,
                ""Illegal nb of values (W%d, R%d) in write_and_read_registers (max W%d, R%d)\n"",
                nb_write, nb, MODBUS_MAX_WR_WRITE_REGISTERS, MODBUS_MAX_WR_READ_REGISTERS);
        } else if (mapping_address < 0 ||
                   (mapping_address + nb) > mb_mapping->nb_registers ||
                   mapping_address < 0 ||
                   (mapping_address_write + nb_write) > mb_mapping->nb_registers) {
            rsp_length = response_exception(
                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,
                ""Illegal data read address 0x%0X or write address 0x%0X write_and_read_registers\n"",
                mapping_address < 0 ? address : address + nb,
                mapping_address_write < 0 ? address_write : address_write + nb_write);
        } else {
            int i, j;
            rsp_length = ctx->backend->build_response_basis(&sft, rsp);
            rsp[rsp_length++] = nb << 1;

            
            for (i = mapping_address_write, j = 10;
                 i < mapping_address_write + nb_write; i++, j += 2) {
                mb_mapping->tab_registers[i] =
                    (req[offset + j] << 8) + req[offset + j + 1];
            }

            
            for (i = mapping_address; i < mapping_address + nb; i++) {
                rsp[rsp_length++] = mb_mapping->tab_registers[i] >> 8;
                rsp[rsp_length++] = mb_mapping->tab_registers[i] & 0xFF;
            }
        }
    }
        break;

    default:
        rsp_length = response_exception(
            ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_FUNCTION, rsp, TRUE,
            ""Unknown Modbus function code: 0x%0X\n"", function);
        break;
    }

    
    return (ctx->backend->backend_type == _MODBUS_BACKEND_TYPE_RTU &&
            slave == MODBUS_BROADCAST_ADDRESS) ? 0 : send_msg(ctx, rsp, rsp_length);
}
","1. if (ctx == NULL) {
2. address = (req[offset + 1] << 8) + req[offset + 2];
3. sft.slave = slave;
4. case MODBUS_FC_READ_DISCRETE_INPUTS: {
5. if (nb < 1 || MODBUS_MAX_READ_BITS < nb) {
6. mapping_address < 0 ? address : address + nb, name);
7. break;
8. uint16_t *tab_registers = is_input ? mb_mapping->tab_input_registers : mb_mapping->tab_registers;
const char * const name = is_input ? ""read_input_registers"" : ""read_registers"";
9. if (nb < 1 || MODBUS_MAX_READ_REGISTERS < nb) {
10. ""Illegal nb of values %d in %s (max %d)\n"",
nb, name, MODBUS_MAX_READ_REGISTERS);
11. address);
12. case MODBUS_FC_WRITE_SINGLE_REGISTER: {
13. rsp_length = response_exception(
14. memcpy(rsp + rsp_length, req + rsp_length, 4);
15. int i, j;
for (i = mapping_address, j = 6; i < mapping_address + nb; i++, j += 2) {
16. int byte_count_pos;
17. ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,
18. } else if (mapping_address < 0 ||
(mapping_address + nb) > mb_mapping->nb_registers ||
19. rsp_length = response_exception(
20. mapping_address_write < 0 ? address_write : address_write + nb_write);
21. int i, j;
22. rsp_length = response_exception(
ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_FUNCTION, rsp, TRUE,","12
20
22
29
40
50
58
64-65
71
74-75
100
118
151
163
185-186
201
228
258-259
262
266
268
290-291","CWE-787,CWE-399,CWE-400"
cp_rsa_gen-281431987612496,"int cp_rsa_gen(rsa_t pub, rsa_t prv, size_t bits) {
	bn_t t, r;
	int result = RLC_OK;

	if (pub == NULL || prv == NULL || bits == 0) {
		return RLC_ERR;
	}

	bn_null(t);
	bn_null(r);

	RLC_TRY {
		bn_new(t);
		bn_new(r);

		
		do {
			bn_gen_prime(prv->crt->p, bits / 2);
			bn_gen_prime(prv->crt->q, bits / 2);
		} while (bn_cmp(prv->crt->p, prv->crt->q) == RLC_EQ);

		
		if (bn_cmp(prv->crt->p, prv->crt->q) != RLC_LT) {
			bn_copy(t, prv->crt->p);
			bn_copy(prv->crt->p, prv->crt->q);
			bn_copy(prv->crt->q, t);
		}

		
		bn_mul(pub->crt->n, prv->crt->p, prv->crt->q);
		bn_copy(prv->crt->n, pub->crt->n);
		bn_sub_dig(prv->crt->p, prv->crt->p, 1);
		bn_sub_dig(prv->crt->q, prv->crt->q, 1);

		
		bn_mul(t, prv->crt->p, prv->crt->q);

		bn_set_2b(pub->e, 16);
		bn_add_dig(pub->e, pub->e, 1);

#if !defined(CP_CRT)
		
		bn_gcd_ext(r, prv->d, NULL, pub->e, t);
		if (bn_sign(prv->d) == RLC_NEG) {
			bn_add(prv->d, prv->d, t);
		}
		if (bn_cmp_dig(r, 1) == RLC_EQ) {
			
			bn_add_dig(prv->crt->p, prv->crt->p, 1);
			bn_add_dig(prv->crt->q, prv->crt->q, 1);
			result = RLC_OK;
		}
#else
		
		bn_gcd_ext(r, prv->d, NULL, pub->e, t);
		if (bn_sign(prv->d) == RLC_NEG) {
			bn_add(prv->d, prv->d, t);
		}

		if (bn_cmp_dig(r, 1) == RLC_EQ) {
			
			bn_mod(prv->crt->dp, prv->d, prv->crt->p);
			
			bn_mod(prv->crt->dq, prv->d, prv->crt->q);
			
			bn_add_dig(prv->crt->p, prv->crt->p, 1);
			bn_add_dig(prv->crt->q, prv->crt->q, 1);
			
			bn_mod_inv(prv->crt->qi, prv->crt->q, prv->crt->p);

			result = RLC_OK;
		}
#endif 
	}
	RLC_CATCH_ANY {
		result = RLC_ERR;
	}
	RLC_FINALLY {
		bn_free(t);
		bn_free(r);
	}

	return result;
}
","1. bn_t t, r;
int result = RLC_OK;
2. if (pub == NULL || prv == NULL || bits == 0) {
3. bn_null(r);
4. bn_new(t);
bn_new(r);
5. bn_gen_prime(prv->crt->q, bits / 2);
} while (bn_cmp(prv->crt->p, prv->crt->q) == RLC_EQ);
6. if (bn_cmp(prv->crt->p, prv->crt->q) != RLC_LT) {
7. bn_copy(prv->crt->n, pub->crt->n);
8. bn_mul(t, prv->crt->p, prv->crt->q);
9. bn_add_dig(pub->e, pub->e, 1);
10. if (bn_sign(prv->d) == RLC_NEG) {
11. bn_add_dig(prv->crt->p, prv->crt->p, 1);
bn_add_dig(prv->crt->q, prv->crt->q, 1);
result = RLC_OK;
12. result = RLC_ERR;
13. RLC_FINALLY {
14. return result;","2-3
5
10
13-14
19-20
23
31
36
39
44
49-51
76
78
83","CWE-190,CWE-285,CWE-125,CWE-347"
pop_fetch_headers-126430662140370,"
#define CONTEXT

static int pop_fetch_headers (CONTEXT *ctx)
{
  int i, ret, old_count, new_count, deleted;
  unsigned short hcached = 0, bcached;
  POP_DATA *pop_data = (POP_DATA *)ctx->data;
  progress_t progress;

#ifdef USE_HCACHE
  header_cache_t *hc = NULL;
  void *data;

  hc = pop_hcache_open (pop_data, ctx->path);
#endif

  time (&pop_data->check_time);
  pop_data->clear_cache = 0;

  for (i = 0; i < ctx->msgcount; i++)
    ctx->hdrs[i]->refno = -1;

  old_count = ctx->msgcount;
  ret = pop_fetch_data (pop_data, ""UIDL\r\n"", NULL, fetch_uidl, ctx);
  new_count = ctx->msgcount;
  ctx->msgcount = old_count;

  if (pop_data->cmd_uidl == 2)
  {
    if (ret == 0)
    {
      pop_data->cmd_uidl = 1;

      dprint (1, (debugfile, ""pop_fetch_headers: set UIDL capability\n""));
    }

    if (ret == -2 && pop_data->cmd_uidl == 2)
    {
      pop_data->cmd_uidl = 0;

      dprint (1, (debugfile, ""pop_fetch_headers: unset UIDL capability\n""));
      snprintf (pop_data->err_msg, sizeof (pop_data->err_msg), ""%s"",
	      _(""Command UIDL is not supported by server.""));
    }
  }

  if (!ctx->quiet)
    mutt_progress_init (&progress, _(""Fetching message headers...""),
                        MUTT_PROGRESS_MSG, ReadInc, new_count - old_count);

  if (ret == 0)
  {
    for (i = 0, deleted = 0; i < old_count; i++)
    {
      if (ctx->hdrs[i]->refno == -1)
      {
	ctx->hdrs[i]->deleted = 1;
	deleted++;
      }
    }
    if (deleted > 0)
    {
      mutt_error (_(""%d messages have been lost. Try reopening the mailbox.""),
		  deleted);
      mutt_sleep (2);
    }

    for (i = old_count; i < new_count; i++)
    {
      if (!ctx->quiet)
	mutt_progress_update (&progress, i + 1 - old_count, -1);
#if USE_HCACHE
      if ((data = mutt_hcache_fetch (hc, ctx->hdrs[i]->data, strlen)))
      {
	char *uidl = safe_strdup (ctx->hdrs[i]->data);
	int refno = ctx->hdrs[i]->refno;
	int index = ctx->hdrs[i]->index;
	
	HEADER *h = mutt_hcache_restore ((unsigned char *) data, NULL);
	mutt_free_header (&ctx->hdrs[i]);
	ctx->hdrs[i] = h;
	ctx->hdrs[i]->refno = refno;
	ctx->hdrs[i]->index = index;
	ctx->hdrs[i]->data = uidl;
	ret = 0;
	hcached = 1;
      }
      else
#endif
      if ((ret = pop_read_header (pop_data, ctx->hdrs[i])) < 0)
	break;
#if USE_HCACHE
      else
      {
	mutt_hcache_store (hc, ctx->hdrs[i]->data, ctx->hdrs[i], 0, strlen, MUTT_GENERATE_UIDVALIDITY);
      }

      mutt_hcache_free (&data);
#endif

      
      bcached = mutt_bcache_exists (pop_data->bcache, cache_id (ctx->hdrs[i]->data)) == 0;
      ctx->hdrs[i]->old = 0;
      ctx->hdrs[i]->read = 0;
      if (hcached)
      {
        if (bcached)
          ctx->hdrs[i]->read = 1;
        else if (option (OPTMARKOLD))
          ctx->hdrs[i]->old = 1;
      }
      else
      {
        if (bcached)
          ctx->hdrs[i]->read = 1;
      }

      ctx->msgcount++;
    }

    if (i > old_count)
      mx_update_context (ctx, i - old_count);
  }

#if USE_HCACHE
    mutt_hcache_close (hc);
#endif

  if (ret < 0)
  {
    for (i = ctx->msgcount; i < new_count; i++)
      mutt_free_header (&ctx->hdrs[i]);
    return ret;
  }

  
  if (option (OPTMESSAGECACHECLEAN))
    mutt_bcache_list (pop_data->bcache, msg_cache_check, (void*)ctx);

  mutt_clear_error ();
  return (new_count - old_count);
}
","1. int i, ret, old_count, new_count, deleted;
2. ctx->msgcount = old_count;
3. pop_data->cmd_uidl = 1;
4. dprint (1, (debugfile, ""pop_fetch_headers: unset UIDL capability\n""));
5. mutt_progress_init (&progress, _(""Fetching message headers...""),
MUTT_PROGRESS_MSG, ReadInc, new_count - old_count);
6. mutt_error (_(""%d messages have been lost. Try reopening the mailbox.""),
7. ctx->hdrs[i]->read = 1;
8. if (i > old_count)
9. mutt_clear_error ();
return (new_count - old_count);","6
27
33
42
49-50
64
135
141
163-164","CWE-476,CWE-20,CWE-119"
exitcode_proc_write,"
#define __user

static ssize_t exitcode_proc_write(struct file *file,
 		const char __user *buffer, size_t count, loff_t *pos)
 {
 	char *end, buf[sizeof(""nnnnn\0"")];
	size_t size;
 	int tmp;
 
	size = min(count, sizeof(buf));
	if (copy_from_user(buf, buffer, size))
 		return -EFAULT;
 
 	tmp = simple_strtol(buf, &end, 0);
	if ((*end != '\0') && !isspace(*end))
		return -EINVAL;

	uml_exitcode = tmp;
	return count;
}
","1. const char __user *buffer, size_t count, loff_t *pos)
2. char *end, buf[sizeof(""nnnnn\0"")];
size_t size;
int tmp;
3. return -EFAULT;
4. tmp = simple_strtol(buf, &end, 0);
if ((*end != '\0') && !isspace(*end))
5. uml_exitcode = tmp;
return count;","5
7-9
13
15-16
19-20","CWE-190,CWE-20,CWE-125,CWE-119"
compile_tree-28202969127614,"size_t compile_tree(struct filter_op **fop)
{
   int i = 1;
   struct filter_op *array = NULL;
   struct unfold_elm *ue;

   
   if (tree_root == NULL)
      return 0;
  
   fprintf(stdout, "" Unfolding the meta-tree "");
   fflush(stdout);
     
   
   unfold_blk(&tree_root);

   fprintf(stdout, "" done.\n\n"");

   
   labels_to_offsets();
   
   
   TAILQ_FOREACH(ue, &unfolded_tree, next) {

      
      if (ue->label == 0) {
         SAFE_REALLOC(array, i * sizeof(struct filter_op));
         memcpy(&array[i - 1], &ue->fop, sizeof(struct filter_op));
         i++;
      }
   }
   
   
   SAFE_REALLOC(array, i * sizeof(struct filter_op));
   array[i - 1].opcode = FOP_EXIT;
   
   
   *fop = array;
   
   return (i);
}
","1. struct filter_op *array = NULL;
2. return 0;
3. SAFE_REALLOC(array, i * sizeof(struct filter_op));
4. return (i);","4
9
34
40","CWE-835,CWE-190,CWE-119"
socket_accept_1," socket_t *socket_accept_1(const socket_t *socket) {
   assert(socket != NULL);
 
  int fd = TEMP_FAILURE_RETRY(accept(socket->fd, NULL, NULL));
   if (fd == INVALID_FD) {
     LOG_ERROR(""%s unable to accept socket: %s"", __func__, strerror(errno));
     return NULL;
 }

 socket_t *ret = (socket_t *)osi_calloc(sizeof(socket_t));
 if (!ret) {
    close(fd);
    LOG_ERROR(""%s unable to allocate memory for socket."", __func__);
 return NULL;
 }

  ret->fd = fd;
 return ret;
}
","1. socket_t *socket_accept_1(const socket_t *socket) {
assert(socket != NULL);
2. if (fd == INVALID_FD) {
3. socket_t *ret = (socket_t *)osi_calloc(sizeof(socket_t));
4. return NULL;
5. ret->fd = fd;
return ret;","1-2
5
10
14
17-18","CWE-190,CWE-787,CWE-552,CWE-119"
flattenSubquery-188614084089389,"
#define Parse
#define Select

static int flattenSubquery(
  Parse *pParse,       
  Select *p,           
  int iFrom,           
  int isAgg            
){
  const char *zSavedAuthContext = pParse->zAuthContext;
  Select *pParent;    
  Select *pSub;       
  Select *pSub1;      
  SrcList *pSrc;      
  SrcList *pSubSrc;   
  int iParent;        
  int iNewParent = -1;
  int isLeftJoin = 0;     
  int i;              
  Expr *pWhere;                    
  struct SrcList_item *pSubitem;   
  sqlite3 *db = pParse->db;

  
  assert( p!=0 );
  assert( p->pPrior==0 );
  if( OptimizationDisabled(db, SQLITE_QueryFlattener) ) return 0;
  pSrc = p->pSrc;
  assert( pSrc && iFrom>=0 && iFrom<pSrc->nSrc );
  pSubitem = &pSrc->a[iFrom];
  iParent = pSubitem->iCursor;
  pSub = pSubitem->pSelect;
  assert( pSub!=0 );

#ifndef SQLITE_OMIT_WINDOWFUNC
  if( p->pWin || pSub->pWin ) return 0;                  
#endif

  pSubSrc = pSub->pSrc;
  assert( pSubSrc );
  
  if( pSub->pLimit && p->pLimit ) return 0;              
  if( pSub->pLimit && pSub->pLimit->pRight ) return 0;   
  if( (p->selFlags & SF_Compound)!=0 && pSub->pLimit ){
    return 0;                                            
  }
  if( pSubSrc->nSrc==0 ) return 0;                       
  if( pSub->selFlags & SF_Distinct ) return 0;           
  if( pSub->pLimit && (pSrc->nSrc>1 || isAgg) ){
     return 0;         
  }
  if( p->pOrderBy && pSub->pOrderBy ){
     return 0;                                           
  }
  if( isAgg && pSub->pOrderBy ) return 0;                
  if( pSub->pLimit && p->pWhere ) return 0;              
  if( pSub->pLimit && (p->selFlags & SF_Distinct)!=0 ){
     return 0;         
  }
  if( pSub->selFlags & (SF_Recursive) ){
    return 0; 
  }

  
  if( (pSubitem->fg.jointype & JT_OUTER)!=0 ){
    isLeftJoin = 1;
    if( pSubSrc->nSrc>1                   
     || isAgg                             
     || IsVirtual(pSubSrc->a[0].pTab)     
     || (p->selFlags & SF_Distinct)!=0    
    ){
      return 0;
    }
  }
#ifdef SQLITE_EXTRA_IFNULLROW
  else if( iFrom>0 && !isAgg ){
    
    isLeftJoin = -1;
  }
#endif

  
  if( pSub->pPrior ){
    if( pSub->pOrderBy ){
      return 0;  
    }
    if( isAgg || (p->selFlags & SF_Distinct)!=0 || pSrc->nSrc!=1 ){
      return 0; 
    }
    for(pSub1=pSub; pSub1; pSub1=pSub1->pPrior){
      testcase( (pSub1->selFlags & (SF_Distinct|SF_Aggregate))==SF_Distinct );
      testcase( (pSub1->selFlags & (SF_Distinct|SF_Aggregate))==SF_Aggregate );
      assert( pSub->pSrc!=0 );
      assert( pSub->pEList->nExpr==pSub1->pEList->nExpr );
      if( (pSub1->selFlags & (SF_Distinct|SF_Aggregate))!=0    
       || (pSub1->pPrior && pSub1->op!=TK_ALL)                 
       || pSub1->pSrc->nSrc<1                                  
      ){
        return 0;
      }
      testcase( pSub1->pSrc->nSrc>1 );
    }

    
    if( p->pOrderBy ){
      int ii;
      for(ii=0; ii<p->pOrderBy->nExpr; ii++){
        if( p->pOrderBy->a[ii].u.x.iOrderByCol==0 ) return 0;
      }
    }
  }

  
  assert( (p->selFlags & SF_Recursive)==0 || pSub->pPrior==0 );

  
  SELECTTRACE(1,pParse,p,(""flatten %u.%p from term %d\n"",
                   pSub->selId, pSub, iFrom));

  
  pParse->zAuthContext = pSubitem->zName;
  TESTONLY(i =) sqlite3AuthCheck(pParse, SQLITE_SELECT, 0, 0, 0);
  testcase( i==SQLITE_DENY );
  pParse->zAuthContext = zSavedAuthContext;

  
  for(pSub=pSub->pPrior; pSub; pSub=pSub->pPrior){
    Select *pNew;
    ExprList *pOrderBy = p->pOrderBy;
    Expr *pLimit = p->pLimit;
    Select *pPrior = p->pPrior;
    p->pOrderBy = 0;
    p->pSrc = 0;
    p->pPrior = 0;
    p->pLimit = 0;
    pNew = sqlite3SelectDup(db, p, 0);
    p->pLimit = pLimit;
    p->pOrderBy = pOrderBy;
    p->pSrc = pSrc;
    p->op = TK_ALL;
    if( pNew==0 ){
      p->pPrior = pPrior;
    }else{
      pNew->pPrior = pPrior;
      if( pPrior ) pPrior->pNext = pNew;
      pNew->pNext = p;
      p->pPrior = pNew;
      SELECTTRACE(2,pParse,p,(""compound-subquery flattener""
                              "" creates %u as peer\n"",pNew->selId));
    }
    if( db->mallocFailed ) return 1;
  }

  
  pSub = pSub1 = pSubitem->pSelect;

  
  sqlite3DbFree(db, pSubitem->zDatabase);
  sqlite3DbFree(db, pSubitem->zName);
  sqlite3DbFree(db, pSubitem->zAlias);
  pSubitem->zDatabase = 0;
  pSubitem->zName = 0;
  pSubitem->zAlias = 0;
  pSubitem->pSelect = 0;

  
  if( ALWAYS(pSubitem->pTab!=0) ){
    Table *pTabToDel = pSubitem->pTab;
    if( pTabToDel->nTabRef==1 ){
      Parse *pToplevel = sqlite3ParseToplevel(pParse);
      pTabToDel->pNextZombie = pToplevel->pZombieTab;
      pToplevel->pZombieTab = pTabToDel;
    }else{
      pTabToDel->nTabRef--;
    }
    pSubitem->pTab = 0;
  }

  
  for(pParent=p; pParent; pParent=pParent->pPrior, pSub=pSub->pPrior){
    int nSubSrc;
    u8 jointype = 0;
    assert( pSub!=0 );
    pSubSrc = pSub->pSrc;     
    nSubSrc = pSubSrc->nSrc;  
    pSrc = pParent->pSrc;     

    if( pSrc ){
      assert( pParent==p );  
      jointype = pSubitem->fg.jointype;
    }else{
      assert( pParent!=p );  
      pSrc = sqlite3SrcListAppend(pParse, 0, 0, 0);
      if( pSrc==0 ) break;
      pParent->pSrc = pSrc;
    }

    
    if( nSubSrc>1 ){
      pSrc = sqlite3SrcListEnlarge(pParse, pSrc, nSubSrc-1,iFrom+1);
      if( pSrc==0 ) break;
      pParent->pSrc = pSrc;
    }

    
    for(i=0; i<nSubSrc; i++){
      sqlite3IdListDelete(db, pSrc->a[i+iFrom].pUsing);
      assert( pSrc->a[i+iFrom].fg.isTabFunc==0 );
      pSrc->a[i+iFrom] = pSubSrc->a[i];
      iNewParent = pSubSrc->a[i].iCursor;
      memset(&pSubSrc->a[i], 0, sizeof(pSubSrc->a[i]));
    }
    pSrc->a[iFrom].fg.jointype = jointype;
  
    
    if( pSub->pOrderBy ){
      
      ExprList *pOrderBy = pSub->pOrderBy;
      for(i=0; i<pOrderBy->nExpr; i++){
        pOrderBy->a[i].u.x.iOrderByCol = 0;
      }
      assert( pParent->pOrderBy==0 );
      pParent->pOrderBy = pOrderBy;
      pSub->pOrderBy = 0;
    }
    pWhere = pSub->pWhere;
    pSub->pWhere = 0;
    if( isLeftJoin>0 ){
      sqlite3SetJoinExpr(pWhere, iNewParent);
    }
    pParent->pWhere = sqlite3ExprAnd(pParse, pWhere, pParent->pWhere);
    if( db->mallocFailed==0 ){
      SubstContext x;
      x.pParse = pParse;
      x.iTable = iParent;
      x.iNewTable = iNewParent;
      x.isLeftJoin = isLeftJoin;
      x.pEList = pSub->pEList;
      substSelect(&x, pParent, 0);
    }
  
    
    pParent->selFlags |= pSub->selFlags & SF_Compound;
    assert( (pSub->selFlags & SF_Distinct)==0 ); 
  
    
    if( pSub->pLimit ){
      pParent->pLimit = pSub->pLimit;
      pSub->pLimit = 0;
    }
  }

  
  sqlite3SelectDelete(db, pSub1);

#if SELECTTRACE_ENABLED
  if( sqlite3SelectTrace & 0x100 ){
    SELECTTRACE(0x100,pParse,p,(""After flattening:\n""));
    sqlite3TreeViewSelect(0, p, 0);
  }
#endif

  return 1;
}
","1. int iFrom,
2. Select *pParent;
3. Select *pSub1;
4. SrcList *pSubSrc;
5. if( (p->selFlags & SF_Compound)!=0 && pSub->pLimit ){
return 0;
6. return 0;
7. testcase( (pSub1->selFlags & (SF_Distinct|SF_Aggregate))==SF_Aggregate );
8. return 0;
9. testcase( pSub1->pSrc->nSrc>1 );
10. if( db->mallocFailed ) return 1;
11. pSubitem->pSelect = 0;
12. assert( pSub!=0 );
13. pParent->pSrc = pSrc;
14. assert( pSrc->a[i+iFrom].fg.isTabFunc==0 );
15. if( pSub->pOrderBy ){
16. ExprList *pOrderBy = pSub->pOrderBy;
17. SubstContext x;
18. x.pEList = pSub->pEList;","8
12
14
16
50-51
59
124
131
133
220
237
274
286
315
334
345
360
365","CWE-190,CWE-347,CWE-125,CWE-119,CWE-732"
ext4_ext_grow_indepth,"static int ext4_ext_grow_indepth(handle_t *handle, struct inode *inode,
				 unsigned int flags)
{
	struct ext4_extent_header *neh;
	struct buffer_head *bh;
 	ext4_fsblk_t newblock, goal = 0;
 	struct ext4_super_block *es = EXT4_SB(inode->i_sb)->s_es;
 	int err = 0;
	size_t ext_size = 0;
 
 	
 	if (ext_depth(inode))
		goal = ext4_idx_pblock(EXT_FIRST_INDEX(ext_inode_hdr(inode)));
	if (goal > le32_to_cpu(es->s_first_data_block)) {
		flags |= EXT4_MB_HINT_TRY_GOAL;
		goal--;
	} else
		goal = ext4_inode_to_goal_block(inode);
	newblock = ext4_new_meta_blocks(handle, inode, goal, flags,
					NULL, &err);
	if (newblock == 0)
		return err;

	bh = sb_getblk_gfp(inode->i_sb, newblock, __GFP_MOVABLE | GFP_NOFS);
	if (unlikely(!bh))
		return -ENOMEM;
	lock_buffer(bh);

	err = ext4_journal_get_create_access(handle, bh);
	if (err) {
		unlock_buffer(bh);
 		goto out;
 	}
 
	ext_size = sizeof(EXT4_I(inode)->i_data);
 	
	memmove(bh->b_data, EXT4_I(inode)->i_data, ext_size);
	
	memset(bh->b_data + ext_size, 0, inode->i_sb->s_blocksize - ext_size);
 
 	
 	neh = ext_block_hdr(bh);
	
	if (ext_depth(inode))
		neh->eh_max = cpu_to_le16(ext4_ext_space_block_idx(inode, 0));
	else
		neh->eh_max = cpu_to_le16(ext4_ext_space_block(inode, 0));
	neh->eh_magic = EXT4_EXT_MAGIC;
	ext4_extent_block_csum_set(inode, neh);
	set_buffer_uptodate(bh);
	unlock_buffer(bh);

	err = ext4_handle_dirty_metadata(handle, inode, bh);
	if (err)
		goto out;

	
	neh = ext_inode_hdr(inode);
	neh->eh_entries = cpu_to_le16(1);
	ext4_idx_store_pblock(EXT_FIRST_INDEX(neh), newblock);
	if (neh->eh_depth == 0) {
		
		neh->eh_max = cpu_to_le16(ext4_ext_space_root_idx(inode, 0));
		EXT_FIRST_INDEX(neh)->ei_block =
			EXT_FIRST_EXTENT(neh)->ee_block;
	}
	ext_debug(""new root: num %d(%d), lblock %d, ptr %llu\n"",
		  le16_to_cpu(neh->eh_entries), le16_to_cpu(neh->eh_max),
		  le32_to_cpu(EXT_FIRST_INDEX(neh)->ei_block),
		  ext4_idx_pblock(EXT_FIRST_INDEX(neh)));

	le16_add_cpu(&neh->eh_depth, 1);
	ext4_mark_inode_dirty(handle, inode);
out:
	brelse(bh);

	return err;
}
","1. static int ext4_ext_grow_indepth(handle_t *handle, struct inode *inode,
2. struct ext4_extent_header *neh;
3. size_t ext_size = 0;
4. if (ext_depth(inode))
5. if (goal > le32_to_cpu(es->s_first_data_block)) {
6. goal--;
7. NULL, &err);
8. if (unlikely(!bh))
9. unlock_buffer(bh);
10. ext_size = sizeof(EXT4_I(inode)->i_data);
11. memset(bh->b_data + ext_size, 0, inode->i_sb->s_blocksize - ext_size);
12. neh->eh_max = cpu_to_le16(ext4_ext_space_block(inode, 0));
13. unlock_buffer(bh);
14. EXT_FIRST_INDEX(neh)->ei_block =
EXT_FIRST_EXTENT(neh)->ee_block;
15. le32_to_cpu(EXT_FIRST_INDEX(neh)->ei_block),
16. out:","1
4
9
12
14
16
20
25
31
35
39
48
52
65-66
70
75","CWE-908,CWE-200,CWE-19,CWE-119"
vmci_transport_dgram_dequeue,"static int vmci_transport_dgram_dequeue(struct kiocb *kiocb,
					struct vsock_sock *vsk,
					struct msghdr *msg, size_t len,
					int flags)
{
	int err;
	int noblock;
	struct vmci_datagram *dg;
	size_t payload_len;
	struct sk_buff *skb;

	noblock = flags & MSG_DONTWAIT;

 	if (flags & MSG_OOB || flags & MSG_ERRQUEUE)
 		return -EOPNOTSUPP;
 
 	
 	err = 0;
 	skb = skb_recv_datagram(&vsk->sk, flags, noblock, &err);
	if (err)
		return err;

	if (!skb)
		return -EAGAIN;

	dg = (struct vmci_datagram *)skb->data;
	if (!dg)
		
		goto out;

	payload_len = dg->payload_size;
	
	if (payload_len != skb->len - sizeof(*dg)) {
		err = -EINVAL;
		goto out;
	}

	if (payload_len > len) {
		payload_len = len;
		msg->msg_flags |= MSG_TRUNC;
	}

	
	err = skb_copy_datagram_iovec(skb, sizeof(*dg), msg->msg_iov,
		payload_len);
	if (err)
		goto out;

	if (msg->msg_name) {
		struct sockaddr_vm *vm_addr;

		
		vm_addr = (struct sockaddr_vm *)msg->msg_name;
		vsock_addr_init(vm_addr, dg->src.context, dg->src.resource);
		msg->msg_namelen = sizeof(*vm_addr);
	}
	err = payload_len;

out:
	skb_free_datagram(&vsk->sk, skb);
	return err;
}
","1. return -EOPNOTSUPP;
2. if (payload_len > len) {","15
38","CWE-362,CWE-20,CWE-125,CWE-78"
userauth_pubkey,"userauth_pubkey(struct ssh *ssh)
 {
 	Authctxt *authctxt = ssh->authctxt;
 	struct passwd *pw = authctxt->pw;
	struct sshbuf *b = NULL;
 	struct sshkey *key = NULL;
	char *pkalg = NULL, *userstyle = NULL, *key_s = NULL, *ca_s = NULL;
	u_char *pkblob = NULL, *sig = NULL, have_sig;
 	size_t blen, slen;
 	int r, pktype;
 	int authenticated = 0;
 	struct sshauthopt *authopts = NULL;
 
 	if ((r = sshpkt_get_u8(ssh, &have_sig)) != 0 ||
 	    (r = sshpkt_get_cstring(ssh, &pkalg, NULL)) != 0 ||
 	    (r = sshpkt_get_string(ssh, &pkblob, &blen)) != 0)
		fatal(""%s: parse request failed: %s"", __func__, ssh_err(r));
	pktype = sshkey_type_from_name(pkalg);
	if (pktype == KEY_UNSPEC) {
		
		verbose(""%s: unsupported public key algorithm: %s"",
		    __func__, pkalg);
		goto done;
	}
	if ((r = sshkey_from_blob(pkblob, blen, &key)) != 0) {
		error(""%s: could not parse key: %s"", __func__, ssh_err(r));
		goto done;
	}
	if (key == NULL) {
		error(""%s: cannot decode key: %s"", __func__, pkalg);
		goto done;
	}
	if (key->type != pktype) {
		error(""%s: type mismatch for decoded key ""
		    ""(received %d, expected %d)"", __func__, key->type, pktype);
		goto done;
	}
	if (sshkey_type_plain(key->type) == KEY_RSA &&
	    (ssh->compat & SSH_BUG_RSASIGMD5) != 0) {
		logit(""Refusing RSA key because client uses unsafe ""
		    ""signature scheme"");
		goto done;
	}
	if (auth2_key_already_used(authctxt, key)) {
		logit(""refusing previously-used %s key"", sshkey_type(key));
		goto done;
	}
	if (match_pattern_list(pkalg, options.pubkey_key_types, 0) != 1) {
		logit(""%s: key type %s not in PubkeyAcceptedKeyTypes"",
		    __func__, sshkey_ssh_name(key));
		goto done;
	}

	key_s = format_key(key);
	if (sshkey_is_cert(key))
		ca_s = format_key(key->cert->signature_key);

	if (have_sig) {
		debug3(""%s: have %s signature for %s%s%s"",
		    __func__, pkalg, key_s,
		    ca_s == NULL ? """" : "" CA "",
		    ca_s == NULL ? """" : ca_s);
		if ((r = sshpkt_get_string(ssh, &sig, &slen)) != 0 ||
		    (r = sshpkt_get_end(ssh)) != 0)
			fatal(""%s: %s"", __func__, ssh_err(r));
		if ((b = sshbuf_new()) == NULL)
			fatal(""%s: sshbuf_new failed"", __func__);
		if (ssh->compat & SSH_OLD_SESSIONID) {
			if ((r = sshbuf_put(b, session_id2,
			    session_id2_len)) != 0)
				fatal(""%s: sshbuf_put session id: %s"",
				    __func__, ssh_err(r));
		} else {
			if ((r = sshbuf_put_string(b, session_id2,
			    session_id2_len)) != 0)
 				fatal(""%s: sshbuf_put_string session id: %s"",
 				    __func__, ssh_err(r));
 		}
		if (!authctxt->valid || authctxt->user == NULL) {
			debug2(""%s: disabled because of invalid user"",
			    __func__);
			goto done;
		}
 		
 		xasprintf(&userstyle, ""%s%s%s"", authctxt->user,
 		    authctxt->style ? "":"" : """",
		    authctxt->style ? authctxt->style : """");
		if ((r = sshbuf_put_u8(b, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||
		    (r = sshbuf_put_cstring(b, userstyle)) != 0 ||
		    (r = sshbuf_put_cstring(b, authctxt->service)) != 0 ||
		    (r = sshbuf_put_cstring(b, ""publickey"")) != 0 ||
		    (r = sshbuf_put_u8(b, have_sig)) != 0 ||
		    (r = sshbuf_put_cstring(b, pkalg) != 0) ||
		    (r = sshbuf_put_string(b, pkblob, blen)) != 0)
			fatal(""%s: build packet failed: %s"",
			    __func__, ssh_err(r));
 #ifdef DEBUG_PK
 		sshbuf_dump(b, stderr);
 #endif
 		
 		authenticated = 0;
 		if (PRIVSEP(user_key_allowed(ssh, pw, key, 1, &authopts)) &&
		    PRIVSEP(sshkey_verify(key, sig, slen,
		    sshbuf_ptr(b), sshbuf_len(b),
		    (ssh->compat & SSH_BUG_SIGTYPE) == 0 ? pkalg : NULL,
		    ssh->compat)) == 0) {
 			authenticated = 1;
 		}
 		sshbuf_free(b);
 		auth2_record_key(authctxt, authenticated, key);
 	} else {
 		debug(""%s: test pkalg %s pkblob %s%s%s"",
		    __func__, pkalg, key_s,
		    ca_s == NULL ? """" : "" CA "",
		    ca_s == NULL ? """" : ca_s);

 		if ((r = sshpkt_get_end(ssh)) != 0)
 			fatal(""%s: %s"", __func__, ssh_err(r));
 
		if (!authctxt->valid || authctxt->user == NULL) {
			debug2(""%s: disabled because of invalid user"",
			    __func__);
			goto done;
		}
 		
 		
		if (PRIVSEP(user_key_allowed(ssh, pw, key, 0, NULL))) {
			if ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_PK_OK))
			    != 0 ||
			    (r = sshpkt_put_cstring(ssh, pkalg)) != 0 ||
			    (r = sshpkt_put_string(ssh, pkblob, blen)) != 0 ||
			    (r = sshpkt_send(ssh)) != 0 ||
			    (r = ssh_packet_write_wait(ssh)) != 0)
				fatal(""%s: %s"", __func__, ssh_err(r));
			authctxt->postponed = 1;
		}
	}
done:
	if (authenticated == 1 && auth_activate_options(ssh, authopts) != 0) {
		debug(""%s: key options inconsistent with existing"", __func__);
		authenticated = 0;
	}
	debug2(""%s: authenticated %d pkalg %s"", __func__, authenticated, pkalg);

	sshauthopt_free(authopts);
	sshkey_free(key);
	free(userstyle);
	free(pkalg);
 	free(pkblob);
 	free(key_s);
 	free(ca_s);
	free(sig);
 	return authenticated;
 }
","1. if ((r = sshpkt_get_u8(ssh, &have_sig)) != 0 ||
2. if (pktype == KEY_UNSPEC) {
3. verbose(""%s: unsupported public key algorithm: %s"",
4. error(""%s: cannot decode key: %s"", __func__, pkalg);
5. logit(""%s: key type %s not in PubkeyAcceptedKeyTypes"",
6. key_s = format_key(key);
7. ca_s = format_key(key->cert->signature_key);
8. session_id2_len)) != 0)
fatal(""%s: sshbuf_put session id: %s"",
9. goto done;
10. (r = sshbuf_put_string(b, pkblob, blen)) != 0)
11. (ssh->compat & SSH_BUG_SIGTYPE) == 0 ? pkalg : NULL,
12. sshbuf_free(b);
auth2_record_key(authctxt, authenticated, key);
13. debug2(""%s: disabled because of invalid user"",
14. if ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_PK_OK))
!= 0 ||","14
19
21
30
49
54
56
70-71
82
94
105
109-110
121
134-135","CWE-310,CWE-20,CWE-362,CWE-200,CWE-399"
mconvert,"mconvert(struct magic_set *ms, struct magic *m, int flip)
{
	union VALUETYPE *p = &ms->ms_value;
	uint8_t type;

	switch (type = cvt_flip(m->type, flip)) {
	case FILE_BYTE:
		cvt_8(p, m);
		return 1;
	case FILE_SHORT:
		cvt_16(p, m);
		return 1;
	case FILE_LONG:
	case FILE_DATE:
	case FILE_LDATE:
		cvt_32(p, m);
		return 1;
	case FILE_QUAD:
	case FILE_QDATE:
	case FILE_QLDATE:
	case FILE_QWDATE:
		cvt_64(p, m);
		return 1;
	case FILE_STRING:
	case FILE_BESTRING16:
	case FILE_LESTRING16: {
		
		p->s[sizeof(p->s) - 1] = '\0';
		return 1;
	}
	case FILE_PSTRING: {
 		size_t sz = file_pstring_length_size(m);
 		char *ptr1 = p->s, *ptr2 = ptr1 + sz;
 		size_t len = file_pstring_get_length(m, ptr1);
		sz = sizeof(p->s) - sz; 
		if (len >= sz) {
 			 
			len = sz;
 		}
 		while (len--)
 			*ptr1++ = *ptr2++;
		*ptr1 = '\0';
		return 1;
	}
	case FILE_BESHORT:
		p->h = (short)((p->hs[0]<<8)|(p->hs[1]));
		cvt_16(p, m);
		return 1;
	case FILE_BELONG:
	case FILE_BEDATE:
	case FILE_BELDATE:
		p->l = (int32_t)
		    ((p->hl[0]<<24)|(p->hl[1]<<16)|(p->hl[2]<<8)|(p->hl[3]));
		if (type == FILE_BELONG)
			cvt_32(p, m);
		return 1;
	case FILE_BEQUAD:
	case FILE_BEQDATE:
	case FILE_BEQLDATE:
	case FILE_BEQWDATE:
		p->q = (uint64_t)
		    (((uint64_t)p->hq[0]<<56)|((uint64_t)p->hq[1]<<48)|
		     ((uint64_t)p->hq[2]<<40)|((uint64_t)p->hq[3]<<32)|
		     ((uint64_t)p->hq[4]<<24)|((uint64_t)p->hq[5]<<16)|
		     ((uint64_t)p->hq[6]<<8)|((uint64_t)p->hq[7]));
		if (type == FILE_BEQUAD)
			cvt_64(p, m);
		return 1;
	case FILE_LESHORT:
		p->h = (short)((p->hs[1]<<8)|(p->hs[0]));
		cvt_16(p, m);
		return 1;
	case FILE_LELONG:
	case FILE_LEDATE:
	case FILE_LELDATE:
		p->l = (int32_t)
		    ((p->hl[3]<<24)|(p->hl[2]<<16)|(p->hl[1]<<8)|(p->hl[0]));
		if (type == FILE_LELONG)
			cvt_32(p, m);
		return 1;
	case FILE_LEQUAD:
	case FILE_LEQDATE:
	case FILE_LEQLDATE:
	case FILE_LEQWDATE:
		p->q = (uint64_t)
		    (((uint64_t)p->hq[7]<<56)|((uint64_t)p->hq[6]<<48)|
		     ((uint64_t)p->hq[5]<<40)|((uint64_t)p->hq[4]<<32)|
		     ((uint64_t)p->hq[3]<<24)|((uint64_t)p->hq[2]<<16)|
		     ((uint64_t)p->hq[1]<<8)|((uint64_t)p->hq[0]));
		if (type == FILE_LEQUAD)
			cvt_64(p, m);
		return 1;
	case FILE_MELONG:
	case FILE_MEDATE:
	case FILE_MELDATE:
		p->l = (int32_t)
		    ((p->hl[1]<<24)|(p->hl[0]<<16)|(p->hl[3]<<8)|(p->hl[2]));
		if (type == FILE_MELONG)
			cvt_32(p, m);
		return 1;
	case FILE_FLOAT:
		cvt_float(p, m);
		return 1;
	case FILE_BEFLOAT:
		p->l =  ((uint32_t)p->hl[0]<<24)|((uint32_t)p->hl[1]<<16)|
			((uint32_t)p->hl[2]<<8) |((uint32_t)p->hl[3]);
		cvt_float(p, m);
		return 1;
	case FILE_LEFLOAT:
		p->l =  ((uint32_t)p->hl[3]<<24)|((uint32_t)p->hl[2]<<16)|
			((uint32_t)p->hl[1]<<8) |((uint32_t)p->hl[0]);
		cvt_float(p, m);
		return 1;
	case FILE_DOUBLE:
		cvt_double(p, m);
		return 1;
	case FILE_BEDOUBLE:
		p->q =  ((uint64_t)p->hq[0]<<56)|((uint64_t)p->hq[1]<<48)|
			((uint64_t)p->hq[2]<<40)|((uint64_t)p->hq[3]<<32)|
			((uint64_t)p->hq[4]<<24)|((uint64_t)p->hq[5]<<16)|
			((uint64_t)p->hq[6]<<8) |((uint64_t)p->hq[7]);
		cvt_double(p, m);
		return 1;
	case FILE_LEDOUBLE:
		p->q =  ((uint64_t)p->hq[7]<<56)|((uint64_t)p->hq[6]<<48)|
			((uint64_t)p->hq[5]<<40)|((uint64_t)p->hq[4]<<32)|
			((uint64_t)p->hq[3]<<24)|((uint64_t)p->hq[2]<<16)|
			((uint64_t)p->hq[1]<<8) |((uint64_t)p->hq[0]);
		cvt_double(p, m);
		return 1;
	case FILE_REGEX:
	case FILE_SEARCH:
	case FILE_DEFAULT:
	case FILE_CLEAR:
	case FILE_NAME:
	case FILE_USE:
		return 1;
	default:
		file_magerror(ms, ""invalid type %d in mconvert()"", m->type);
		return 0;
	}
}
","1. union VALUETYPE *p = &ms->ms_value;
2. case FILE_SHORT:
3. case FILE_DATE:
4. case FILE_BESHORT:
5. cvt_16(p, m);
6. p->q = (uint64_t)
7. cvt_64(p, m);
8. return 1;
9. ((uint64_t)p->hq[3]<<24)|((uint64_t)p->hq[2]<<16)|
10. case FILE_DOUBLE:
11. ((uint64_t)p->hq[1]<<8) |((uint64_t)p->hq[0]);","3
10
14
52
54
68
74
87
95
121
135","CWE-120,CWE-190,CWE-119,CWE-125,CWE-399"
lexer_process_char_literal,"lexer_process_char_literal (parser_context_t *context_p, 
                            const uint8_t *char_p, 
                            size_t length, 
                            uint8_t literal_type, 
                            bool has_escape) 
{
  parser_list_iterator_t literal_iterator;
  lexer_literal_t *literal_p;
  uint32_t literal_index = 0;

  JERRY_ASSERT (literal_type == LEXER_IDENT_LITERAL
                || literal_type == LEXER_STRING_LITERAL);

  JERRY_ASSERT (literal_type != LEXER_IDENT_LITERAL || length <= PARSER_MAXIMUM_IDENT_LENGTH);
  JERRY_ASSERT (literal_type != LEXER_STRING_LITERAL || length <= PARSER_MAXIMUM_STRING_LENGTH);

  parser_list_iterator_init (&context_p->literal_pool, &literal_iterator);

  while ((literal_p = (lexer_literal_t *) parser_list_iterator_next (&literal_iterator)) != NULL)
  {
    if (literal_p->type == literal_type
        && literal_p->prop.length == length
        && memcmp (literal_p->u.char_p, char_p, length) == 0)
    {
      context_p->lit_object.literal_p = literal_p;
      context_p->lit_object.index = (uint16_t) literal_index;
      literal_p->status_flags = (uint8_t) (literal_p->status_flags & ~LEXER_FLAG_UNUSED_IDENT);
      return;
    }

    literal_index++;
  }

  JERRY_ASSERT (literal_index == context_p->literal_count);

  if (literal_index >= PARSER_MAXIMUM_NUMBER_OF_LITERALS)
  {
     parser_raise_error (context_p, PARSER_ERR_LITERAL_LIMIT_REACHED);
   }
 
  if (length == 0)
  {
    has_escape = false;
  }

   literal_p = (lexer_literal_t *) parser_list_append (context_p, &context_p->literal_pool);
   literal_p->prop.length = (uint16_t) length;
   literal_p->type = literal_type;
  literal_p->status_flags = has_escape ? 0 : LEXER_FLAG_SOURCE_PTR;

  if (has_escape)
  {
    literal_p->u.char_p = (uint8_t *) jmem_heap_alloc_block (length);
    memcpy ((uint8_t *) literal_p->u.char_p, char_p, length);
  }
  else
  {
    literal_p->u.char_p = char_p;
  }

  context_p->lit_object.literal_p = literal_p;
  context_p->lit_object.index = (uint16_t) literal_index;
  context_p->literal_count++;
} 
","1. size_t length,
2. parser_list_iterator_t literal_iterator;
3. if (literal_index >= PARSER_MAXIMUM_NUMBER_OF_LITERALS)","3
7
36","CWE-119,CWE-193,CWE-399,CWE-416"
iw_process_rows_intermediate_to_final," static int iw_process_rows_intermediate_to_final(struct iw_context *ctx, int intermed_channel,
 	const struct iw_csdescr *out_csdescr)
 {
	int i,j;
	int z;
	int k;
	int retval=0;
	iw_tmpsample tmpsamp;
	iw_tmpsample alphasamp = 0.0;
	iw_tmpsample *inpix_tofree = NULL; 
	iw_tmpsample *outpix_tofree = NULL; 
	int using_errdiffdither = 0;
	int output_channel;
	int is_alpha_channel;
	int bkgd_has_transparency;
	double tmpbkgdalpha=0.0;
	int alt_bkgd = 0; 
	struct iw_resize_settings *rs = NULL;
	int ditherfamily, dithersubtype;
	struct iw_channelinfo_intermed *int_ci;
	struct iw_channelinfo_out *out_ci;

	iw_tmpsample *in_pix = NULL;
 	iw_tmpsample *out_pix = NULL;
 	int num_in_pix;
 	int num_out_pix;
	struct iw_channelinfo_out default_ci_out;
 
 	num_in_pix = ctx->intermed_canvas_width;
 	num_out_pix = ctx->img2.width;
 
 	int_ci = &ctx->intermed_ci[intermed_channel];
 	output_channel = int_ci->corresponding_output_channel;
	if(output_channel>=0) {
		out_ci = &ctx->img2_ci[output_channel];
	}
	else {
		
		
		
		
		
		iw_zeromem(&default_ci_out, sizeof(struct iw_channelinfo_out));
		default_ci_out.channeltype = IW_CHANNELTYPE_NONALPHA;
		out_ci = &default_ci_out;
	}

 	is_alpha_channel = (int_ci->channeltype==IW_CHANNELTYPE_ALPHA);
 	bkgd_has_transparency = iw_bkgd_has_transparency(ctx);
 
	inpix_tofree = (iw_tmpsample*)iw_malloc(ctx, num_in_pix * sizeof(iw_tmpsample));
	in_pix = inpix_tofree;

	outpix_tofree = (iw_tmpsample*)iw_malloc(ctx, num_out_pix * sizeof(iw_tmpsample));
	if(!outpix_tofree) goto done;
	out_pix = outpix_tofree;

	if(ctx->nearest_color_table && !is_alpha_channel &&
	   out_ci->ditherfamily==IW_DITHERFAMILY_NONE &&
	   out_ci->color_count==0)
	{
		out_ci->use_nearest_color_table = 1;
	}
	else {
		out_ci->use_nearest_color_table = 0;
	}

	ditherfamily = out_ci->ditherfamily;
	dithersubtype = out_ci->dithersubtype;
	if(ditherfamily==IW_DITHERFAMILY_RANDOM) {
		if(dithersubtype==IW_DITHERSUBTYPE_SAMEPATTERN && out_ci->channeltype!=IW_CHANNELTYPE_ALPHA)
		{
			iwpvt_prng_set_random_seed(ctx->prng,ctx->random_seed);
		}
		else {
			iwpvt_prng_set_random_seed(ctx->prng,ctx->random_seed+out_ci->channeltype);
		}
	}

	if(output_channel>=0 && out_ci->ditherfamily==IW_DITHERFAMILY_ERRDIFF) {
		using_errdiffdither = 1;
		for(i=0;i<ctx->img2.width;i++) {
			for(k=0;k<IW_DITHER_MAXROWS;k++) {
				ctx->dither_errors[k][i] = 0.0;
			}
		}
	}

	rs=&ctx->resize_settings[IW_DIMENSION_H];

	if(!rs->rrctx) {
		rs->rrctx = iwpvt_resize_rows_init(ctx,rs,int_ci->channeltype,
			num_in_pix, num_out_pix);
		if(!rs->rrctx) goto done;
	}

	for(j=0;j<ctx->intermed_canvas_height;j++) {

		if(is_alpha_channel) {
			for(i=0;i<num_in_pix;i++) {
				inpix_tofree[i] = ctx->intermediate_alpha32[((size_t)j)*ctx->intermed_canvas_width+i];
			}
		}
		else {
			for(i=0;i<num_in_pix;i++) {
				inpix_tofree[i] = ctx->intermediate32[((size_t)j)*ctx->intermed_canvas_width+i];
			}
		}

		iwpvt_resize_row_main(rs->rrctx,in_pix,out_pix);

		if(ctx->intclamp)
			clamp_output_samples(ctx,out_pix,num_out_pix);

		if(is_alpha_channel && outpix_tofree && ctx->final_alpha32) {
			for(i=0;i<num_out_pix;i++) {
				ctx->final_alpha32[((size_t)j)*ctx->img2.width+i] = (iw_float32)outpix_tofree[i];
			}
		}


		if(output_channel == -1) {
			goto here;
		}

		for(z=0;z<ctx->img2.width;z++) {
			if(using_errdiffdither && (j%2))
				i=ctx->img2.width-1-z;
			else
				i=z;

			tmpsamp = out_pix[i];

			if(ctx->bkgd_checkerboard) {
				alt_bkgd = (((ctx->bkgd_check_origin[IW_DIMENSION_H]+i)/ctx->bkgd_check_size)%2) !=
					(((ctx->bkgd_check_origin[IW_DIMENSION_V]+j)/ctx->bkgd_check_size)%2);
			}

			if(bkgd_has_transparency) {
				tmpbkgdalpha = alt_bkgd ? ctx->bkgd2alpha : ctx->bkgd1alpha;
			}

			if(int_ci->need_unassoc_alpha_processing) {
				alphasamp = ctx->final_alpha32[((size_t)j)*ctx->img2.width + i];

				if(alphasamp!=0.0) {
					tmpsamp /= alphasamp;
				}

				if(ctx->apply_bkgd && ctx->apply_bkgd_strategy==IW_BKGD_STRATEGY_LATE) {
					double bkcolor;
					bkcolor = alt_bkgd ? out_ci->bkgd2_color_lin : out_ci->bkgd1_color_lin;

					if(bkgd_has_transparency) {
						tmpsamp = tmpsamp*alphasamp + bkcolor*tmpbkgdalpha*(1.0-alphasamp);
					}
					else {
						tmpsamp = tmpsamp*alphasamp + bkcolor*(1.0-alphasamp);
					}
				}
			}
			else if(is_alpha_channel && bkgd_has_transparency) {
				tmpsamp = tmpsamp + tmpbkgdalpha*(1.0-tmpsamp);
			}

			if(ctx->img2.sampletype==IW_SAMPLETYPE_FLOATINGPOINT)
				put_sample_convert_from_linear_flt(ctx,tmpsamp,i,j,output_channel,out_csdescr);
			else
				put_sample_convert_from_linear(ctx,tmpsamp,i,j,output_channel,out_csdescr);

		}

		if(using_errdiffdither) {
			for(i=0;i<ctx->img2.width;i++) {
				for(k=0;k<IW_DITHER_MAXROWS-1;k++) {
					ctx->dither_errors[k][i] = ctx->dither_errors[k+1][i];
				}
				ctx->dither_errors[IW_DITHER_MAXROWS-1][i] = 0.0;
			}
		}

here:
		;
	}

	retval=1;

done:
	if(rs && rs->disable_rrctx_cache && rs->rrctx) {
		iwpvt_resize_rows_done(rs->rrctx);
		rs->rrctx = NULL;
	}
	if(inpix_tofree) iw_free(ctx,inpix_tofree);
	if(outpix_tofree) iw_free(ctx,outpix_tofree);

	return retval;
}
","1. iw_tmpsample alphasamp = 0.0;
2. int output_channel;
3. num_out_pix = ctx->img2.width;
4. if(output_channel>=0) {
5. inpix_tofree = (iw_tmpsample*)iw_malloc(ctx, num_in_pix * sizeof(iw_tmpsample));
6. if(dithersubtype==IW_DITHERSUBTYPE_SAMEPATTERN && out_ci->channeltype!=IW_CHANNELTYPE_ALPHA)
7. else {
8. (((ctx->bkgd_check_origin[IW_DIMENSION_V]+j)/ctx->bkgd_check_size)%2);
9. if(bkgd_has_transparency) {
10. if(using_errdiffdither) {
11. done:","9
13
30
34
51
71
75
136
154
173
188","CWE-369,CWE-362,CWE-190,CWE-200,CWE-119"
kvm_vm_ioctl_assign_device," static int kvm_vm_ioctl_assign_device(struct kvm *kvm,
 				      struct kvm_assigned_pci_dev *assigned_dev)
 {
 	int r = 0, idx;
 	struct kvm_assigned_dev_kernel *match;
 	struct pci_dev *dev;
	u8 header_type;
 
 	if (!(assigned_dev->flags & KVM_DEV_ASSIGN_ENABLE_IOMMU))
 		return -EINVAL;

	mutex_lock(&kvm->lock);
	idx = srcu_read_lock(&kvm->srcu);

	match = kvm_find_assigned_dev(&kvm->arch.assigned_dev_head,
				      assigned_dev->assigned_dev_id);
	if (match) {
		
		r = -EEXIST;
		goto out;
	}

	match = kzalloc(sizeof(struct kvm_assigned_dev_kernel), GFP_KERNEL);
	if (match == NULL) {
		printk(KERN_INFO ""%s: Couldn't allocate memory\n"",
		       __func__);
		r = -ENOMEM;
		goto out;
	}
	dev = pci_get_domain_bus_and_slot(assigned_dev->segnr,
				   assigned_dev->busnr,
				   assigned_dev->devfn);
	if (!dev) {
		printk(KERN_INFO ""%s: host device not found\n"", __func__);
 		r = -EINVAL;
 		goto out_free;
 	}

	
	pci_read_config_byte(dev, PCI_HEADER_TYPE, &header_type);
	if ((header_type & PCI_HEADER_TYPE) != PCI_HEADER_TYPE_NORMAL) {
		r = -EPERM;
		goto out_put;
	}

	r = probe_sysfs_permissions(dev);
	if (r)
		goto out_put;

 	if (pci_enable_device(dev)) {
 		printk(KERN_INFO ""%s: Could not enable PCI device\n"", __func__);
 		r = -EBUSY;
		goto out_put;
	}
	r = pci_request_regions(dev, ""kvm_assigned_device"");
	if (r) {
		printk(KERN_INFO ""%s: Could not get access to device regions\n"",
		       __func__);
		goto out_disable;
	}

	pci_reset_function(dev);
	pci_save_state(dev);
	match->pci_saved_state = pci_store_saved_state(dev);
	if (!match->pci_saved_state)
		printk(KERN_DEBUG ""%s: Couldn't store %s saved state\n"",
		       __func__, dev_name(&dev->dev));
	match->assigned_dev_id = assigned_dev->assigned_dev_id;
	match->host_segnr = assigned_dev->segnr;
	match->host_busnr = assigned_dev->busnr;
	match->host_devfn = assigned_dev->devfn;
	match->flags = assigned_dev->flags;
	match->dev = dev;
	spin_lock_init(&match->intx_lock);
	match->irq_source_id = -1;
	match->kvm = kvm;
	match->ack_notifier.irq_acked = kvm_assigned_dev_ack_irq;

	list_add(&match->list, &kvm->arch.assigned_dev_head);

	if (!kvm->arch.iommu_domain) {
		r = kvm_iommu_map_guest(kvm);
		if (r)
			goto out_list_del;
	}
	r = kvm_assign_device(kvm, match);
	if (r)
		goto out_list_del;

out:
	srcu_read_unlock(&kvm->srcu, idx);
	mutex_unlock(&kvm->lock);
	return r;
out_list_del:
	if (pci_load_and_free_saved_state(dev, &match->pci_saved_state))
		printk(KERN_INFO ""%s: Couldn't reload %s saved state\n"",
		       __func__, dev_name(&dev->dev));
	list_del(&match->list);
	pci_release_regions(dev);
out_disable:
	pci_disable_device(dev);
out_put:
	pci_dev_put(dev);
out_free:
	kfree(match);
	srcu_read_unlock(&kvm->srcu, idx);
	mutex_unlock(&kvm->lock);
	return r;
}
","1. if (!(assigned_dev->flags & KVM_DEV_ASSIGN_ENABLE_IOMMU))
2. idx = srcu_read_lock(&kvm->srcu);
3. assigned_dev->assigned_dev_id);
4. goto out;
5. r = -ENOMEM;
6. dev = pci_get_domain_bus_and_slot(assigned_dev->segnr,
7. goto out_put;
8. match->pci_saved_state = pci_store_saved_state(dev);
9. match->assigned_dev_id = assigned_dev->assigned_dev_id;
match->host_segnr = assigned_dev->segnr;
10. match->flags = assigned_dev->flags;
match->dev = dev;
11. match->kvm = kvm;
match->ack_notifier.irq_acked = kvm_assigned_dev_ack_irq;
12. if (r)
13. srcu_read_unlock(&kvm->srcu, idx);
mutex_unlock(&kvm->lock);
14. pci_release_regions(dev);
15. pci_disable_device(dev);
16. mutex_unlock(&kvm->lock);
return r;","9
13
16
20
27
30
43
64
68-69
72-73
76-77
87
91-92
99
101
107-108","CWE-20,CWE-17,CWE-787,CWE-416"
icmp_send,"
#define __be32

void icmp_send(struct sk_buff *skb_in, int type, int code, __be32 info)
{
	struct iphdr *iph;
	int room;
	struct icmp_bxm icmp_param;
	struct rtable *rt = skb_rtable(skb_in);
	struct ipcm_cookie ipc;
	__be32 saddr;
	u8  tos;
	struct net *net;
	struct sock *sk;

	if (!rt)
		goto out;
	net = dev_net(rt->dst.dev);

	
	iph = ip_hdr(skb_in);

	if ((u8 *)iph < skb_in->head ||
	    (skb_in->network_header + sizeof(*iph)) > skb_in->tail)
		goto out;

	
	if (skb_in->pkt_type != PACKET_HOST)
		goto out;

	
	if (rt->rt_flags & (RTCF_BROADCAST | RTCF_MULTICAST))
		goto out;

	
	if (iph->frag_off & htons(IP_OFFSET))
		goto out;

	
	if (icmp_pointers[type].error) {
		
		if (iph->protocol == IPPROTO_ICMP) {
			u8 _inner_type, *itp;

			itp = skb_header_pointer(skb_in,
						 skb_network_header(skb_in) +
						 (iph->ihl << 2) +
						 offsetof(struct icmphdr,
							  type) -
						 skb_in->data,
						 sizeof(_inner_type),
						 &_inner_type);
			if (itp == NULL)
				goto out;

			
			if (*itp > NR_ICMP_TYPES ||
			    icmp_pointers[*itp].error)
				goto out;
		}
	}

	sk = icmp_xmit_lock(net);
	if (sk == NULL)
		return;

	

	saddr = iph->daddr;
	if (!(rt->rt_flags & RTCF_LOCAL)) {
		struct net_device *dev = NULL;

		rcu_read_lock();
		if (rt_is_input_route(rt) &&
		    net->ipv4.sysctl_icmp_errors_use_inbound_ifaddr)
			dev = dev_get_by_index_rcu(net, rt->rt_iif);

		if (dev)
			saddr = inet_select_addr(dev, 0, RT_SCOPE_LINK);
		else
			saddr = 0;
		rcu_read_unlock();
	}

	tos = icmp_pointers[type].error ? ((iph->tos & IPTOS_TOS_MASK) |
 					   IPTOS_PREC_INTERNETCONTROL) :
 					  iph->tos;
 
	if (ip_options_echo(&icmp_param.replyopts.opt.opt, skb_in))
 		goto out_unlock;
 
 
	

	icmp_param.data.icmph.type	 = type;
	icmp_param.data.icmph.code	 = code;
	icmp_param.data.icmph.un.gateway = info;
	icmp_param.data.icmph.checksum	 = 0;
	icmp_param.skb	  = skb_in;
 	icmp_param.offset = skb_network_offset(skb_in);
 	inet_sk(sk)->tos = tos;
 	ipc.addr = iph->saddr;
	ipc.opt = &icmp_param.replyopts.opt;
 	ipc.tx_flags = 0;
 
 	rt = icmp_route_lookup(net, skb_in, iph, saddr, tos,
			       type, code, &icmp_param);
	if (IS_ERR(rt))
		goto out_unlock;

	if (!icmpv4_xrlim_allow(net, rt, type, code))
		goto ende;

	

 	room = dst_mtu(&rt->dst);
 	if (room > 576)
 		room = 576;
	room -= sizeof(struct iphdr) + icmp_param.replyopts.opt.opt.optlen;
 	room -= sizeof(struct icmphdr);
 
 	icmp_param.data_len = skb_in->len - icmp_param.offset;
	if (icmp_param.data_len > room)
		icmp_param.data_len = room;
	icmp_param.head_len = sizeof(struct icmphdr);

	icmp_push_reply(&icmp_param, &ipc, &rt);
ende:
	ip_rt_put(rt);
out_unlock:
	icmp_xmit_unlock(sk);
out:;
}
","1. struct sock *sk;
2. if (!rt)
3. goto out;
4. goto out;
5. if (iph->frag_off & htons(IP_OFFSET))
goto out;
6. if (icmp_pointers[type].error) {
7. if (iph->protocol == IPPROTO_ICMP) {
u8 _inner_type, *itp;
8. if (*itp > NR_ICMP_TYPES ||
icmp_pointers[*itp].error)
9. sk = icmp_xmit_lock(net);
10. return;
11. saddr = iph->daddr;
if (!(rt->rt_flags & RTCF_LOCAL)) {
12. if (rt_is_input_route(rt) &&
13. dev = dev_get_by_index_rcu(net, rt->rt_iif);
14. saddr = inet_select_addr(dev, 0, RT_SCOPE_LINK);
15. saddr = 0;
16. icmp_param.skb	  = skb_in;
17. ipc.addr = iph->saddr;
18. if (IS_ERR(rt))
goto out_unlock;
19. if (!icmpv4_xrlim_allow(net, rt, type, code))
20. room = dst_mtu(&rt->dst);
21. room = 576;
room -= sizeof(struct iphdr) + icmp_param.replyopts.opt.opt.optlen;
22. icmp_param.data_len = room;
23. icmp_push_reply(&icmp_param, &ipc, &rt);
24. ip_rt_put(rt);","14
16
29
41
47-48
53
58-59
76-77
82
84
90-91
95
97
100
102
122
125
131-132
134
139
141-142
147
150
152","CWE-362,CWE-1284,CWE-476,CWE-20"
r_bin_wasm_get_element_entries-220160615899994,"
#define RBinWasmObj
#define RBinWasmSection

static RList *r_bin_wasm_get_element_entries (RBinWasmObj *bin, RBinWasmSection *sec) {
	RList *ret = NULL;
	RBinWasmElementEntry *ptr = NULL;

	if (!(ret = r_list_newf ((RListFree)free))) {
		return NULL;
	}

	ut8* buf = bin->buf->buf + (ut32)sec->payload_data;
	int buflen = bin->buf->length - (ut32)sec->payload_data;
	ut32 len =  sec->payload_len;
	ut32 count = sec->count;
	ut32 i = 0, r = 0;

	while (i < len && len < buflen && r < count) {
		if (!(ptr = R_NEW0 (RBinWasmElementEntry))) {
			return ret;
		}
		if (!(consume_u32 (buf + i, buf + len, &ptr->index, &i))) {
			goto beach;
		}
		if (!(consume_init_expr (buf + i, buf + len, R_BIN_WASM_END_OF_CODE, NULL, &i))) {
			goto beach;
		}
		if (!(consume_u32 (buf + i, buf + len, &ptr->num_elem, &i))) {
			goto beach;
		}
		ut32 j = 0;
		while (i < len && j < ptr->num_elem) {
			
			ut32 e;
			if (!(consume_u32 (buf + i, buf + len, &e, &i))) {
				free (ptr);
				return ret;
			}
		}
		r_list_append (ret, ptr);

		r += 1;
	}
	return ret;
beach:
	free (ptr);
	return ret;
}
","1. static RList *r_bin_wasm_get_element_entries (RBinWasmObj *bin, RBinWasmSection *sec) {
2. int buflen = bin->buf->length - (ut32)sec->payload_data;
3. while (i < len && len < buflen && r < count) {
4. goto beach;
5. ut32 j = 0;
while (i < len && j < ptr->num_elem) {
6. ut32 e;
if (!(consume_u32 (buf + i, buf + len, &e, &i))) {
7. r_list_append (ret, ptr);
8. return ret;","5
14
19
27
32-33
35-36
41
45","CWE-119,CWE-400,CWE-125,CWE-189"
bzrtp_packetParser,"int bzrtp_packetParser(bzrtpContext_t *zrtpContext, bzrtpChannelContext_t *zrtpChannelContext, const uint8_t * input, uint16_t inputLength, bzrtpPacket_t *zrtpPacket) {

	int i;

	
	
	uint8_t *messageContent = (uint8_t *)(input+ZRTP_PACKET_HEADER_LENGTH+ZRTP_MESSAGE_HEADER_LENGTH);

	switch (zrtpPacket->messageType) {
		case MSGTYPE_HELLO : 
			{
				
				bzrtpHelloMessage_t *messageData;
				messageData = (bzrtpHelloMessage_t *)malloc(sizeof(bzrtpHelloMessage_t));

				
				memcpy(messageData->version, messageContent, 4);
				messageContent +=4;
				memcpy(messageData->clientIdentifier, messageContent, 16);
				messageContent +=16;
				memcpy(messageData->H3, messageContent, 32);
				messageContent +=32;
				memcpy(messageData->ZID, messageContent, 12);
				messageContent +=12;
				messageData->S = ((*messageContent)>>6)&0x01;
				messageData->M = ((*messageContent)>>5)&0x01;
				messageData->P = ((*messageContent)>>4)&0x01;
				messageContent +=1;
				messageData->hc = MIN((*messageContent)&0x0F, 7);
				messageContent +=1;
				messageData->cc = MIN(((*messageContent)>>4)&0x0F, 7);
				messageData->ac = MIN((*messageContent)&0x0F, 7);
				messageContent +=1;
				messageData->kc = MIN(((*messageContent)>>4)&0x0F, 7);
				messageData->sc = MIN((*messageContent)&0x0F, 7);
				messageContent +=1;

				
				if (zrtpPacket->messageLength != ZRTP_HELLOMESSAGE_FIXED_LENGTH + 4*((uint16_t)(messageData->hc)+(uint16_t)(messageData->cc)+(uint16_t)(messageData->ac)+(uint16_t)(messageData->kc)+(uint16_t)(messageData->sc))) {
					free(messageData);
					return BZRTP_PARSER_ERROR_INVALIDMESSAGE;
				}

				
				for (i=0; i<messageData->hc; i++) {
					messageData->supportedHash[i] = cryptoAlgoTypeStringToInt(messageContent, ZRTP_HASH_TYPE);
					messageContent +=4;
				}
				for (i=0; i<messageData->cc; i++) {
					messageData->supportedCipher[i] = cryptoAlgoTypeStringToInt(messageContent, ZRTP_CIPHERBLOCK_TYPE);
					messageContent +=4;
				}
				for (i=0; i<messageData->ac; i++) {
					messageData->supportedAuthTag[i] = cryptoAlgoTypeStringToInt(messageContent, ZRTP_AUTHTAG_TYPE);
					messageContent +=4;
				}
				for (i=0; i<messageData->kc; i++) {
					messageData->supportedKeyAgreement[i] = cryptoAlgoTypeStringToInt(messageContent, ZRTP_KEYAGREEMENT_TYPE);
					messageContent +=4;
				}
				for (i=0; i<messageData->sc; i++) {
					messageData->supportedSas[i] = cryptoAlgoTypeStringToInt(messageContent, ZRTP_SAS_TYPE);
					messageContent +=4;
				}

				addMandatoryCryptoTypesIfNeeded(ZRTP_HASH_TYPE, messageData->supportedHash, &messageData->hc);
				addMandatoryCryptoTypesIfNeeded(ZRTP_CIPHERBLOCK_TYPE, messageData->supportedCipher, &messageData->cc);
				addMandatoryCryptoTypesIfNeeded(ZRTP_AUTHTAG_TYPE, messageData->supportedAuthTag, &messageData->ac);
				addMandatoryCryptoTypesIfNeeded(ZRTP_KEYAGREEMENT_TYPE, messageData->supportedKeyAgreement, &messageData->kc);
				addMandatoryCryptoTypesIfNeeded(ZRTP_SAS_TYPE, messageData->supportedSas, &messageData->sc);

				memcpy(messageData->MAC, messageContent, 8);
				
				
				zrtpPacket->messageData = (void *)messageData;

				
				zrtpPacket->packetString = (uint8_t *)malloc(inputLength*sizeof(uint8_t));
				memcpy(zrtpPacket->packetString, input, inputLength); 
			}
			break; 

		case MSGTYPE_HELLOACK :
			{
				
				if (zrtpPacket->messageLength != ZRTP_HELLOACKMESSAGE_FIXED_LENGTH) {
					return BZRTP_PARSER_ERROR_INVALIDMESSAGE;
				}


			}
			break; 

		case MSGTYPE_COMMIT:
			{
				uint8_t checkH3[32];
				uint8_t checkMAC[32];
				bzrtpHelloMessage_t *peerHelloMessageData;
				uint16_t variableLength = 0;

				
				bzrtpCommitMessage_t *messageData;
				messageData = (bzrtpCommitMessage_t *)malloc(sizeof(bzrtpCommitMessage_t));

				
				memcpy(messageData->H2, messageContent, 32);
				messageContent +=32;

				
				if (zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID] == NULL) {
					free (messageData);
					
					return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;
				}
				peerHelloMessageData = (bzrtpHelloMessage_t *)zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageData;
				
				bctoolbox_sha256(messageData->H2, 32, 32, checkH3);
				if (memcmp(checkH3, peerHelloMessageData->H3, 32) != 0) {
					free (messageData);
					return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;
				}
				
				bctoolbox_hmacSha256(messageData->H2, 32, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);
				if (memcmp(checkMAC, peerHelloMessageData->MAC, 8) != 0) {
					free (messageData);
					return BZRTP_PARSER_ERROR_UNMATCHINGMAC;
				}

				memcpy(messageData->ZID, messageContent, 12);
				messageContent +=12;
				messageData->hashAlgo = cryptoAlgoTypeStringToInt(messageContent, ZRTP_HASH_TYPE);
				messageContent += 4;
				messageData->cipherAlgo = cryptoAlgoTypeStringToInt(messageContent, ZRTP_CIPHERBLOCK_TYPE);
				messageContent += 4;
				messageData->authTagAlgo = cryptoAlgoTypeStringToInt(messageContent, ZRTP_AUTHTAG_TYPE);
				messageContent += 4;
				messageData->keyAgreementAlgo = cryptoAlgoTypeStringToInt(messageContent, ZRTP_KEYAGREEMENT_TYPE);
				messageContent += 4;
				
				switch(messageData->keyAgreementAlgo) {
					case ZRTP_KEYAGREEMENT_DH2k :
					case ZRTP_KEYAGREEMENT_EC25 :
					case ZRTP_KEYAGREEMENT_DH3k :
					case ZRTP_KEYAGREEMENT_EC38 :
					case ZRTP_KEYAGREEMENT_EC52 :
						variableLength = 32; 
						break;
					case ZRTP_KEYAGREEMENT_Prsh :
						variableLength = 24; 
						break;
					case ZRTP_KEYAGREEMENT_Mult :
						variableLength = 16; 
						break;
					default:
						free(messageData);
						return BZRTP_PARSER_ERROR_INVALIDMESSAGE;
				}

				if (zrtpPacket->messageLength != ZRTP_COMMITMESSAGE_FIXED_LENGTH + variableLength) {
					free(messageData);
					return BZRTP_PARSER_ERROR_INVALIDMESSAGE;
				}
				messageData->sasAlgo = cryptoAlgoTypeStringToInt(messageContent, ZRTP_SAS_TYPE);
				messageContent += 4;

				
				if ((messageData->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Prsh) || (messageData->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Mult)) {
					memcpy(messageData->nonce, messageContent, 16);
					messageContent +=16;

					
					if (messageData->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Prsh) {
						memcpy(messageData->keyID, messageContent, 8);
						messageContent +=8;
					}
				} else { 
					memcpy(messageData->hvi, messageContent, 32);
					messageContent +=32;
				}

				
				memcpy(messageData->MAC, messageContent, 8);
				zrtpPacket->messageData = (void *)messageData;

				
				zrtpPacket->packetString = (uint8_t *)malloc(inputLength*sizeof(uint8_t));
				memcpy(zrtpPacket->packetString, input, inputLength); 
			}
			break; 
		case MSGTYPE_DHPART1 :
		case MSGTYPE_DHPART2 :
			{
				bzrtpDHPartMessage_t *messageData;

				
				uint16_t pvLength = computeKeyAgreementPrivateValueLength(zrtpChannelContext->keyAgreementAlgo);
				if (pvLength == 0) {
					return BZRTP_PARSER_ERROR_INVALIDCONTEXT;
				}

				if (zrtpPacket->messageLength != ZRTP_DHPARTMESSAGE_FIXED_LENGTH+pvLength) {
					return BZRTP_PARSER_ERROR_INVALIDMESSAGE;
				}

				
				messageData = (bzrtpDHPartMessage_t *)malloc(sizeof(bzrtpDHPartMessage_t));
				messageData->pv = (uint8_t *)malloc(pvLength*sizeof(uint8_t));

				
				memcpy(messageData->H1, messageContent, 32);
				messageContent +=32;

				
				if ( zrtpChannelContext->role == RESPONDER) { 
					uint8_t checkH2[32];
					uint8_t checkMAC[32];
					bzrtpCommitMessage_t *peerCommitMessageData;

					if (zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID] == NULL) {
						free (messageData);
						
						return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;
					}
					peerCommitMessageData = (bzrtpCommitMessage_t *)zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->messageData;
					
					bctoolbox_sha256(messageData->H1, 32, 32, checkH2);
					if (memcmp(checkH2, peerCommitMessageData->H2, 32) != 0) {
						free (messageData);
						return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;
					}
					
					bctoolbox_hmacSha256(messageData->H1, 32, zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);
					if (memcmp(checkMAC, peerCommitMessageData->MAC, 8) != 0) {
 						free (messageData);
 						return BZRTP_PARSER_ERROR_UNMATCHINGMAC;
 					}

					
					
					
					
					{
						uint8_t computedHvi[32];
						uint16_t HelloMessageLength = zrtpChannelContext->selfPackets[HELLO_MESSAGE_STORE_ID]->messageLength;
						uint16_t DHPartHelloMessageStringLength = zrtpPacket->messageLength + HelloMessageLength;

						uint8_t *DHPartHelloMessageString = (uint8_t *)malloc(DHPartHelloMessageStringLength*sizeof(uint8_t));

						memcpy(DHPartHelloMessageString, input+ZRTP_PACKET_HEADER_LENGTH, zrtpPacket->messageLength);
						memcpy(DHPartHelloMessageString+zrtpPacket->messageLength, zrtpChannelContext->selfPackets[HELLO_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, HelloMessageLength);

						zrtpChannelContext->hashFunction(DHPartHelloMessageString, DHPartHelloMessageStringLength, 32, computedHvi);

						free(DHPartHelloMessageString);

						
						if (memcmp(computedHvi, peerCommitMessageData->hvi, 32)!=0) {
							free (messageData);
							return BZRTP_PARSER_ERROR_UNMATCHINGHVI;
						}
					}

 				} else { 
 					uint8_t checkH2[32];
 					uint8_t checkH3[32];
					uint8_t checkMAC[32];
					bzrtpHelloMessage_t *peerHelloMessageData;

					if (zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID] == NULL) {
						free (messageData);
						
						return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;
					}
					peerHelloMessageData = (bzrtpHelloMessage_t *)zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageData;
					
					bctoolbox_sha256(messageData->H1, 32, 32, checkH2);
					bctoolbox_sha256(checkH2, 32, 32, checkH3);
					if (memcmp(checkH3, peerHelloMessageData->H3, 32) != 0) {
						free (messageData);
						return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;
					}
					
					bctoolbox_hmacSha256(checkH2, 32, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);
					if (memcmp(checkMAC, peerHelloMessageData->MAC, 8) != 0) {
						free (messageData);
						return BZRTP_PARSER_ERROR_UNMATCHINGMAC;
					}

				}

				memcpy(messageData->rs1ID, messageContent, 8);
				messageContent +=8;
				memcpy(messageData->rs2ID, messageContent, 8);
				messageContent +=8;
				memcpy(messageData->auxsecretID, messageContent, 8);
				messageContent +=8;
				memcpy(messageData->pbxsecretID, messageContent, 8);
				messageContent +=8;
				memcpy(messageData->pv, messageContent, pvLength);
				messageContent +=pvLength;
				memcpy(messageData->MAC, messageContent, 8);

 				
 				zrtpPacket->messageData = (void *)messageData;
 
				
 				zrtpPacket->packetString = (uint8_t *)malloc(inputLength*sizeof(uint8_t));
 				memcpy(zrtpPacket->packetString, input, inputLength); 
 			}
			break; 
		case MSGTYPE_CONFIRM1:
		case MSGTYPE_CONFIRM2:
			{
				uint8_t *confirmMessageKey = NULL;
				uint8_t *confirmMessageMacKey = NULL;
				bzrtpConfirmMessage_t *messageData;
				uint16_t cipherTextLength;
				uint8_t computedHmac[8];
				uint8_t *confirmPlainMessageBuffer;
				uint8_t *confirmPlainMessage;

				
				if (zrtpChannelContext->role == RESPONDER) { 
					if ((zrtpChannelContext->zrtpkeyi == NULL) || (zrtpChannelContext->mackeyi == NULL)) {
						return BZRTP_PARSER_ERROR_INVALIDCONTEXT;
					}
					confirmMessageKey = zrtpChannelContext->zrtpkeyi;
					confirmMessageMacKey = zrtpChannelContext->mackeyi;
				}

				if (zrtpChannelContext->role == INITIATOR) { 
					if ((zrtpChannelContext->zrtpkeyr == NULL) || (zrtpChannelContext->mackeyr == NULL)) {
						return BZRTP_PARSER_ERROR_INVALIDCONTEXT;
					}
					confirmMessageKey = zrtpChannelContext->zrtpkeyr;
					confirmMessageMacKey = zrtpChannelContext->mackeyr;
				}
				
				
				messageData = (bzrtpConfirmMessage_t *)malloc(sizeof(bzrtpConfirmMessage_t));

				
				memcpy(messageData->confirm_mac, messageContent, 8);
				messageContent +=8;
				memcpy(messageData->CFBIV, messageContent, 16);
				messageContent +=16;


				
				
				cipherTextLength = zrtpPacket->messageLength - ZRTP_MESSAGE_HEADER_LENGTH - 24; 

				
				zrtpChannelContext->hmacFunction(confirmMessageMacKey, zrtpChannelContext->hashLength, messageContent, cipherTextLength, 8, computedHmac);
				
				if (memcmp(computedHmac, messageData->confirm_mac, 8) != 0) { 
					free(messageData);
					return BZRTP_PARSER_ERROR_UNMATCHINGCONFIRMMAC;
				}

				
				confirmPlainMessageBuffer = (uint8_t *)malloc(cipherTextLength*sizeof(uint8_t));
				zrtpChannelContext->cipherDecryptionFunction(confirmMessageKey, messageData->CFBIV, messageContent, cipherTextLength, confirmPlainMessageBuffer);
				confirmPlainMessage = confirmPlainMessageBuffer; 

				
				memcpy(messageData->H0, confirmPlainMessage, 32);
				confirmPlainMessage +=33; 

				
				if (zrtpChannelContext->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Prsh || zrtpChannelContext->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Mult) {
					
					uint8_t checkH1[32];
					bctoolbox_sha256(messageData->H0, 32, 32, checkH1);

					
					if ( zrtpChannelContext->role == RESPONDER) {
						uint8_t checkH2[32];
						uint8_t checkMAC[32];
						bzrtpCommitMessage_t *peerCommitMessageData;

						if (zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID] == NULL) {
							free (messageData);
							
							return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;
						}
						peerCommitMessageData = (bzrtpCommitMessage_t *)zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->messageData;
						
						bctoolbox_sha256(checkH1, 32, 32, checkH2);
						if (memcmp(checkH2, peerCommitMessageData->H2, 32) != 0) {
							free (messageData);
							return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;
						}
						
						bctoolbox_hmacSha256(checkH1, 32, zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);
						if (memcmp(checkMAC, peerCommitMessageData->MAC, 8) != 0) {
							free (messageData);
							return BZRTP_PARSER_ERROR_UNMATCHINGMAC;
						}
					} else { 
						uint8_t checkH2[32];
						uint8_t checkH3[32];
						uint8_t checkMAC[32];
						bzrtpHelloMessage_t *peerHelloMessageData;

						if (zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID] == NULL) {
							free (messageData);
							
							return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;
						}
						peerHelloMessageData = (bzrtpHelloMessage_t *)zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageData;
						
						bctoolbox_sha256(checkH1, 32, 32, checkH2);
						bctoolbox_sha256(checkH2, 32, 32, checkH3);
						if (memcmp(checkH3, peerHelloMessageData->H3, 32) != 0) {
							free (messageData);
							return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;
						}
						
						bctoolbox_hmacSha256(checkH2, 32, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);
						if (memcmp(checkMAC, peerHelloMessageData->MAC, 8) != 0) {
							free (messageData);
							return BZRTP_PARSER_ERROR_UNMATCHINGMAC;
						}
	
					}
				} else { 
					
					uint8_t checkH1[32];
					uint8_t checkMAC[32];
					bzrtpDHPartMessage_t *peerDHPartMessageData;

					if (zrtpChannelContext->peerPackets[DHPART_MESSAGE_STORE_ID] == NULL) {
						free (messageData);
						
						return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;
					}
					peerDHPartMessageData = (bzrtpDHPartMessage_t *)zrtpChannelContext->peerPackets[DHPART_MESSAGE_STORE_ID]->messageData;
					
					bctoolbox_sha256(messageData->H0, 32, 32, checkH1);
					if (memcmp(checkH1, peerDHPartMessageData->H1, 32) != 0) {
						free (messageData);
						return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;
					}
					
					bctoolbox_hmacSha256(messageData->H0, 32, zrtpChannelContext->peerPackets[DHPART_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[DHPART_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);
					if (memcmp(checkMAC, peerDHPartMessageData->MAC, 8) != 0) {
						free (messageData);
						return BZRTP_PARSER_ERROR_UNMATCHINGMAC;
					}
				}

				messageData->sig_len = ((uint16_t)(confirmPlainMessage[0]&0x01))<<8 | (((uint16_t)confirmPlainMessage[1])&0x00FF);
				confirmPlainMessage += 2;
				messageData->E = ((*confirmPlainMessage)&0x08)>>3;
				messageData->V = ((*confirmPlainMessage)&0x04)>>2;
				messageData->A = ((*confirmPlainMessage)&0x02)>>1;
				messageData->D = (*confirmPlainMessage)&0x01;
				confirmPlainMessage += 1;

				messageData->cacheExpirationInterval = (((uint32_t)confirmPlainMessage[0])<<24) | (((uint32_t)confirmPlainMessage[1])<<16) | (((uint32_t)confirmPlainMessage[2])<<8) | ((uint32_t)confirmPlainMessage[3]);
				confirmPlainMessage += 4;


				
				if (messageData->sig_len>0) {
					memcpy(messageData->signatureBlockType, confirmPlainMessage, 4);
					confirmPlainMessage += 4;
					
					messageData->signatureBlock = (uint8_t *)malloc(4*(messageData->sig_len-1)*sizeof(uint8_t));
					memcpy(messageData->signatureBlock, confirmPlainMessage, 4*(messageData->sig_len-1));
				} else {
					messageData->signatureBlock  = NULL;
				}

				
				free(confirmPlainMessageBuffer);

				
				zrtpPacket->packetString = (uint8_t *)malloc(inputLength*sizeof(uint8_t));
				memcpy(zrtpPacket->packetString, input, inputLength); 

				
				zrtpPacket->messageData = (void *)messageData;
			}
			break; 

		case MSGTYPE_CONF2ACK:
			
			break; 
		
		case MSGTYPE_PING:
			{
				
				bzrtpPingMessage_t *messageData;
				messageData = (bzrtpPingMessage_t *)malloc(sizeof(bzrtpPingMessage_t));

				
				memcpy(messageData->version, messageContent, 4);
				messageContent +=4;
				memcpy(messageData->endpointHash, messageContent, 8);

				
				zrtpPacket->messageData = (void *)messageData;
			}
			break; 

	}

	return 0;
}
","1. case MSGTYPE_HELLO :
2. memcpy(messageData->ZID, messageContent, 12);
3. messageData->supportedCipher[i] = cryptoAlgoTypeStringToInt(messageContent, ZRTP_CIPHERBLOCK_TYPE);
4. break;
5. case ZRTP_KEYAGREEMENT_Prsh :
6. memcpy(messageData->keyID, messageContent, 8);
7. memcpy(DHPartHelloMessageString, input+ZRTP_PACKET_HEADER_LENGTH, zrtpPacket->messageLength);
memcpy(DHPartHelloMessageString+zrtpPacket->messageLength, zrtpChannelContext->selfPackets[HELLO_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, HelloMessageLength);
8. free (messageData);
9. return BZRTP_PARSER_ERROR_UNMATCHINGMAC;
10. memcpy(messageData->rs1ID, messageContent, 8);
11. messageContent +=8;
12. messageContent +=pvLength;
13. zrtpPacket->packetString = (uint8_t *)malloc(inputLength*sizeof(uint8_t));
14. break;
15. messageData = (bzrtpConfirmMessage_t *)malloc(sizeof(bzrtpConfirmMessage_t));
16. free (messageData);
17. messageData->cacheExpirationInterval = (((uint32_t)confirmPlainMessage[0])<<24) | (((uint32_t)confirmPlainMessage[1])<<16) | (((uint32_t)confirmPlainMessage[2])<<8) | ((uint32_t)confirmPlainMessage[3]);","10
23
50
92
149
174
251-252
281
289
294
301
303
310
313
343
427
467","CWE-190,CWE-125,CWE-119"
eap_print-71392597435141,"void
eap_print(netdissect_options *ndo,
          register const u_char *cp,
          u_int length)
{
    const struct eap_frame_t *eap;
    const u_char *tptr;
    u_int tlen, type, subtype;
    int count=0, len;

    tptr = cp;
    tlen = length;
    eap = (const struct eap_frame_t *)cp;
    ND_TCHECK(*eap);

    
    if (ndo->ndo_vflag < 1) {
	ND_PRINT((ndo, ""%s (%u) v%u, len %u"",
               tok2str(eap_frame_type_values, ""unknown"", eap->type),
               eap->type,
               eap->version,
               EXTRACT_16BITS(eap->length)));
	return;
    }

    ND_PRINT((ndo, ""%s (%u) v%u, len %u"",
           tok2str(eap_frame_type_values, ""unknown"", eap->type),
           eap->type,
           eap->version,
           EXTRACT_16BITS(eap->length)));

    tptr += sizeof(const struct eap_frame_t);
    tlen -= sizeof(const struct eap_frame_t);

    switch (eap->type) {
    case EAP_FRAME_TYPE_PACKET:
        ND_TCHECK_8BITS(tptr);
        type = *(tptr);
        ND_TCHECK_16BITS(tptr+2);
        len = EXTRACT_16BITS(tptr+2);
        ND_PRINT((ndo, "", %s (%u), id %u, len %u"",
               tok2str(eap_code_values, ""unknown"", type),
               type,
               *(tptr+1),
               len));

        ND_TCHECK2(*tptr, len);

        if (type <= 2) { 
            ND_TCHECK_8BITS(tptr+4);
            subtype = *(tptr+4);
            ND_PRINT((ndo, ""\n\t\t Type %s (%u)"",
                   tok2str(eap_type_values, ""unknown"", subtype),
                   subtype));

            switch (subtype) {
            case EAP_TYPE_IDENTITY:
                if (len - 5 > 0) {
                    ND_PRINT((ndo, "", Identity: ""));
                    safeputs(ndo, tptr + 5, len - 5);
                }
                break;

            case EAP_TYPE_NOTIFICATION:
                if (len - 5 > 0) {
                    ND_PRINT((ndo, "", Notification: ""));
                    safeputs(ndo, tptr + 5, len - 5);
                }
                break;

            case EAP_TYPE_NAK:
                count = 5;

                
                while (count < len) {
                    ND_TCHECK_8BITS(tptr+count);
                    ND_PRINT((ndo, "" %s (%u),"",
                           tok2str(eap_type_values, ""unknown"", *(tptr+count)),
                           *(tptr + count)));
                    count++;
                }
                break;

            case EAP_TYPE_TTLS:
            case EAP_TYPE_TLS:
                ND_TCHECK_8BITS(tptr + 5);
                if (subtype == EAP_TYPE_TTLS)
                    ND_PRINT((ndo, "" TTLSv%u"",
                           EAP_TTLS_VERSION(*(tptr + 5))));
                ND_PRINT((ndo, "" flags [%s] 0x%02x,"",
                       bittok2str(eap_tls_flags_values, ""none"", *(tptr+5)),
                       *(tptr + 5)));

                if (EAP_TLS_EXTRACT_BIT_L(*(tptr+5))) {
                    ND_TCHECK_32BITS(tptr + 6);
		    ND_PRINT((ndo, "" len %u"", EXTRACT_32BITS(tptr + 6)));
                }
                break;

            case EAP_TYPE_FAST:
                ND_TCHECK_8BITS(tptr + 5);
                ND_PRINT((ndo, "" FASTv%u"",
                       EAP_TTLS_VERSION(*(tptr + 5))));
                ND_PRINT((ndo, "" flags [%s] 0x%02x,"",
                       bittok2str(eap_tls_flags_values, ""none"", *(tptr+5)),
                       *(tptr + 5)));

                if (EAP_TLS_EXTRACT_BIT_L(*(tptr+5))) {
                    ND_TCHECK_32BITS(tptr + 6);
                    ND_PRINT((ndo, "" len %u"", EXTRACT_32BITS(tptr + 6)));
                }

                
                break;

            case EAP_TYPE_AKA:
            case EAP_TYPE_SIM:
                ND_TCHECK_8BITS(tptr + 5);
                ND_PRINT((ndo, "" subtype [%s] 0x%02x,"",
                       tok2str(eap_aka_subtype_values, ""unknown"", *(tptr+5)),
                       *(tptr + 5)));

                
                break;

            case EAP_TYPE_MD5_CHALLENGE:
            case EAP_TYPE_OTP:
            case EAP_TYPE_GTC:
            case EAP_TYPE_EXPANDED_TYPES:
            case EAP_TYPE_EXPERIMENTAL:
            default:
                break;
            }
        }
        break;

    case EAP_FRAME_TYPE_LOGOFF:
    case EAP_FRAME_TYPE_ENCAP_ASF_ALERT:
    default:
        break;
    }
    return;

 trunc:
    ND_PRINT((ndo, ""\n\t[|EAP]""));
}
","1. void
eap_print(netdissect_options *ndo,
2. const u_char *tptr;
u_int tlen, type, subtype;
int count=0, len;
3. tptr = cp;
4. return;
5. ND_PRINT((ndo, ""%s (%u) v%u, len %u"",
tok2str(eap_frame_type_values, ""unknown"", eap->type),
6. ND_TCHECK_16BITS(tptr+2);
len = EXTRACT_16BITS(tptr+2);
ND_PRINT((ndo, "", %s (%u), id %u, len %u"",
7. type,
8. len));
9. ND_TCHECK2(*tptr, len);
10. if (type <= 2) {
ND_TCHECK_8BITS(tptr+4);
subtype = *(tptr+4);
ND_PRINT((ndo, ""\n\t\t Type %s (%u)"",
tok2str(eap_type_values, ""unknown"", subtype),
subtype));
11. case EAP_TYPE_IDENTITY:
if (len - 5 > 0) {
12. safeputs(ndo, tptr + 5, len - 5);
13. ND_PRINT((ndo, "" %s (%u),"",
14. count++;
15. break;
16. ND_TCHECK_8BITS(tptr + 5);
if (subtype == EAP_TYPE_TTLS)
17. ND_PRINT((ndo, "" len %u"", EXTRACT_32BITS(tptr + 6)));
18. EAP_TTLS_VERSION(*(tptr + 5))));
ND_PRINT((ndo, "" flags [%s] 0x%02x,"",
19. *(tptr + 5)));
20. ND_PRINT((ndo, "" len %u"", EXTRACT_32BITS(tptr + 6)));
21. break;
22. *(tptr + 5)));
23. break;
24. case EAP_TYPE_EXPANDED_TYPES:
25. case EAP_FRAME_TYPE_ENCAP_ASF_ALERT:
26. return;","1-2
7-9
11
23
26-27
39-41
43
45
47
49-54
57-58
67
81
84
86
90-91
100
107-108
110
114
118
125
128
133
142
146","CWE-125,CWE-787,CWE-119"
RunMemCheck_1,"   void RunMemCheck_1() {
     ACMRandom rnd(ACMRandom::DeterministicSeed());
     const int count_test_block = 1000;
    DECLARE_ALIGNED(16, int16_t, input_extreme_block[kNumCoeffs]);
    DECLARE_ALIGNED(16, tran_low_t, output_ref_block[kNumCoeffs]);
    DECLARE_ALIGNED(16, tran_low_t, output_block[kNumCoeffs]);
 
     for (int i = 0; i < count_test_block; ++i) {
      
       for (int j = 0; j < kNumCoeffs; ++j) {
        input_extreme_block[j] = rnd.Rand8() % 2 ? mask_ : -mask_;
       }
      if (i == 0) {
         for (int j = 0; j < kNumCoeffs; ++j)
          input_extreme_block[j] = mask_;
      } else if (i == 1) {
         for (int j = 0; j < kNumCoeffs; ++j)
          input_extreme_block[j] = -mask_;
      }
 
       fwd_txfm_ref(input_extreme_block, output_ref_block, pitch_, tx_type_);
      ASM_REGISTER_STATE_CHECK(RunFwdTxfm(input_extreme_block,
                                          output_block, pitch_));
 
       for (int j = 0; j < kNumCoeffs; ++j) {
         EXPECT_EQ(output_block[j], output_ref_block[j]);
        EXPECT_GE(4 * DCT_MAX_VALUE << (bit_depth_ - 8), abs(output_block[j]))
             << ""Error: 16x16 FDCT has coefficient larger than 4*DCT_MAX_VALUE"";
       }
     }
   }
","1. void RunMemCheck_1() {
2. const int count_test_block = 1000;
DECLARE_ALIGNED(16, int16_t, input_extreme_block[kNumCoeffs]);
3. DECLARE_ALIGNED(16, tran_low_t, output_block[kNumCoeffs]);
4. for (int i = 0; i < count_test_block; ++i) {
5. for (int j = 0; j < kNumCoeffs; ++j) {
6. for (int j = 0; j < kNumCoeffs; ++j)
input_extreme_block[j] = mask_;
} else if (i == 1) {
for (int j = 0; j < kNumCoeffs; ++j)
input_extreme_block[j] = -mask_;
7. fwd_txfm_ref(input_extreme_block, output_ref_block, pitch_, tx_type_);
ASM_REGISTER_STATE_CHECK(RunFwdTxfm(input_extreme_block,
8. for (int j = 0; j < kNumCoeffs; ++j) {","1
3-4
6
8
10
14-18
21-22
25",CWE-119
parse_object,"static const char *parse_object( cJSON *item, const char *value )
static const char *parse_object(cJSON *item,const char *value,const char **ep)
 {
 	cJSON *child;
	if (*value!='{')	{*ep=value;return 0;}	
 	
	item->type=cJSON_Object;
	value=skip(value+1);
	if (*value=='}') return value+1;	
 	
	item->child=child=cJSON_New_Item();
	if (!item->child) return 0;
	value=skip(parse_string(child,skip(value),ep));
	if (!value) return 0;
	child->string=child->valuestring;child->valuestring=0;
	if (*value!=':') {*ep=value;return 0;}	
	value=skip(parse_value(child,skip(value+1),ep));	
	if (!value) return 0;
 	
	while (*value==',')
	{
 		cJSON *new_item;
		if (!(new_item=cJSON_New_Item()))	return 0; 
		child->next=new_item;new_item->prev=child;child=new_item;
		value=skip(parse_string(child,skip(value+1),ep));
		if (!value) return 0;
		child->string=child->valuestring;child->valuestring=0;
		if (*value!=':') {*ep=value;return 0;}	
		value=skip(parse_value(child,skip(value+1),ep));	
		if (!value) return 0;
 	}
 	
","1. static const char *parse_object(cJSON *item,const char *value,const char **ep)
2. value=skip(parse_string(child,skip(value),ep));
if (!value) return 0;
3. if (!value) return 0;
4. cJSON *new_item;
5. value=skip(parse_string(child,skip(value+1),ep));
6. if (*value!=':') {*ep=value;return 0;}","2
13-14
18
22
25
28",CWE-119
XListFonts,"
#define Display
#define _Xconst

XListFonts(
register Display *dpy,
_Xconst char *pattern,  
int maxNames,
int *actualCount)	
{
    register long nbytes;
    register unsigned i;
    register int length;
    char **flist = NULL;
    char *ch = NULL;
    char *chstart;
    char *chend;
    int count = 0;
    xListFontsReply rep;
    register xListFontsReq *req;
    unsigned long rlen = 0;

    LockDisplay(dpy);
    GetReq(ListFonts, req);
    req->maxNames = maxNames;
    nbytes = req->nbytes = pattern ? strlen (pattern) : 0;
    req->length += (nbytes + 3) >> 2;
    _XSend (dpy, pattern, nbytes);
    

    if (!_XReply (dpy, (xReply *)&rep, 0, xFalse)) {
	*actualCount = 0;
	UnlockDisplay(dpy);
	SyncHandle();
	return (char **) NULL;
    }

    if (rep.nFonts) {
	flist = Xmalloc (rep.nFonts * sizeof(char *));
	if (rep.length > 0 && rep.length < (INT_MAX >> 2)) {
	    rlen = rep.length << 2;
	    ch = Xmalloc(rlen + 1);
	    
	}

	if ((! flist) || (! ch)) {
	    Xfree(flist);
	    Xfree(ch);
	    _XEatDataWords(dpy, rep.length);
	    *actualCount = 0;
	    UnlockDisplay(dpy);
	    SyncHandle();
	    return (char **) NULL;
	}

	_XReadPad (dpy, ch, rlen);
	
 	chstart = ch;
	chend = ch + rlen;
 	length = *(unsigned char *)ch;
 	*ch = 1; 
 	for (i = 0; i < rep.nFonts; i++) {
 	    if (ch + length < chend) {
 		flist[i] = ch + 1;  
 		ch += length + 1;  
		length = *(unsigned char *)ch;
		*ch = '\0';  
		count++;
 	    } else {
                 Xfree(chstart);
                 Xfree(flist);
                    Xfree(flist);
                    flist = NULL;
                    count = 0;
                    break;
		}
	    } else {
                Xfree(chstart);
                Xfree(flist);
                flist = NULL;
                count = 0;
                break;
            }
	}
    }
","1. register int length;
2. char *chstart;
3. int count = 0;
4. nbytes = req->nbytes = pattern ? strlen (pattern) : 0;
5. UnlockDisplay(dpy);
SyncHandle();
6. if (rep.nFonts) {
7. rlen = rep.length << 2;
8. Xfree(ch);
9. UnlockDisplay(dpy);
10. return (char **) NULL;
11. _XReadPad (dpy, ch, rlen);
12. length = *(unsigned char *)ch;
13. } else {
Xfree(chstart);","13
16
18
26
33-34
38
41
48
51
53
56
62
71-72","CWE-682,CWE-190,CWE-787,CWE-400"
config_save,"bool config_save(const config_t *config, const char *filename) {
  assert(config != NULL);

   assert(filename != NULL);
   assert(*filename != '\0');
 
  
  
  
  
  
  
  
  
  int dir_fd = -1;
  FILE *fp = NULL;

  
  static const char *temp_file_ext = "".new"";
  const int filename_len = strlen(filename);
  const int temp_filename_len = filename_len + strlen(temp_file_ext) + 1;
  char *temp_filename = osi_calloc(temp_filename_len);
  snprintf(temp_filename, temp_filename_len, ""%s%s"", filename, temp_file_ext);

  
  char *temp_dirname = osi_strdup(filename);
  const char *directoryname = dirname(temp_dirname);
  if (!directoryname) {
    LOG_ERROR(""%s error extracting directory from '%s': %s"", __func__, filename, strerror(errno));
    goto error;
   }
 
  dir_fd = TEMP_FAILURE_RETRY(open(directoryname, O_RDONLY));
  if (dir_fd < 0) {
    LOG_ERROR(""%s unable to open dir '%s': %s"", __func__, directoryname, strerror(errno));
    goto error;
  }
 
  fp = fopen(temp_filename, ""wt"");
   if (!fp) {
     LOG_ERROR(""%s unable to write file '%s': %s"", __func__, temp_filename, strerror(errno));
     goto error;
 }

 
   for (const list_node_t *node = list_begin(config->sections); node != list_end(config->sections); node = list_next(node)) {
     const section_t *section = (const section_t *)list_node(node);
    if (fprintf(fp, ""[%s]\n"", section->name) < 0) {
      LOG_ERROR(""%s unable to write to file '%s': %s"", __func__, temp_filename, strerror(errno));
      goto error;
    }
 
     for (const list_node_t *enode = list_begin(section->entries); enode != list_end(section->entries); enode = list_next(enode)) {
       const entry_t *entry = (const entry_t *)list_node(enode);
      if (fprintf(fp, ""%s = %s\n"", entry->key, entry->value) < 0) {
        LOG_ERROR(""%s unable to write to file '%s': %s"", __func__, temp_filename, strerror(errno));
        goto error;
      }
     }
 
    if (list_next(node) != list_end(config->sections)) {
      if (fputc('\n', fp) == EOF) {
        LOG_ERROR(""%s unable to write to file '%s': %s"", __func__, temp_filename, strerror(errno));
        goto error;
      }
    }
   }
 
  
  if (fsync(fileno(fp)) < 0) {
    LOG_WARN(""%s unable to fsync file '%s': %s"", __func__, temp_filename, strerror(errno));
  }

  if (fclose(fp) == EOF) {
    LOG_ERROR(""%s unable to close file '%s': %s"", __func__, temp_filename, strerror(errno));
    goto error;
  }
  fp = NULL;
 
   if (chmod(temp_filename, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP) == -1) {
    LOG_ERROR(""%s unable to change file permissions '%s': %s"", __func__, filename, strerror(errno));

     goto error;
   }
 
  
   if (rename(temp_filename, filename) == -1) {
     LOG_ERROR(""%s unable to commit file '%s': %s"", __func__, filename, strerror(errno));
     goto error;
   }
 
  
  if (fsync(dir_fd) < 0) {
    LOG_WARN(""%s unable to fsync dir '%s': %s"", __func__, directoryname, strerror(errno));
  }

  if (close(dir_fd) < 0) {
    LOG_ERROR(""%s unable to close dir '%s': %s"", __func__, directoryname, strerror(errno));
    goto error;
  }

   osi_free(temp_filename);
  osi_free(temp_dirname);
   return true;
 
error:
  
   unlink(temp_filename);
  if (fp)
    fclose(fp);
  if (dir_fd != -1)
    close(dir_fd);
   osi_free(temp_filename);
  osi_free(temp_dirname);
   return false;
 }
","1. FILE *fp = NULL;
2. const int filename_len = strlen(filename);
3. char *temp_filename = osi_calloc(temp_filename_len);
snprintf(temp_filename, temp_filename_len, ""%s%s"", filename, temp_file_ext);
4. LOG_ERROR(""%s error extracting directory from '%s': %s"", __func__, filename, strerror(errno));
goto error;
5. dir_fd = TEMP_FAILURE_RETRY(open(directoryname, O_RDONLY));
6. fp = fopen(temp_filename, ""wt"");
if (!fp) {
7. LOG_ERROR(""%s unable to write to file '%s': %s"", __func__, temp_filename, strerror(errno));
8. const entry_t *entry = (const entry_t *)list_node(enode);
9. if (list_next(node) != list_end(config->sections)) {
10. LOG_ERROR(""%s unable to write to file '%s': %s"", __func__, temp_filename, strerror(errno));
11. goto error;
12. fp = NULL;
13. if (chmod(temp_filename, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP) == -1) {
14. goto error;
15. if (fsync(dir_fd) < 0) {
LOG_WARN(""%s unable to fsync dir '%s': %s"", __func__, directoryname, strerror(errno));
16. LOG_ERROR(""%s unable to close dir '%s': %s"", __func__, directoryname, strerror(errno));
goto error;
17. osi_free(temp_dirname);
18. error:
19. if (fp)
20. if (dir_fd != -1)
21. osi_free(temp_filename);","16
20
22-23
29-30
33
39-40
49
54
61
63
76
78
80
83
93-94
98-99
103
106
109
111
113","CWE-22,CWE-78,CWE-264,CWE-89,CWE-119"
prefetch_dec-174058680389396,"static void prefetch_dec(void)
{
  
  dec_tables.counter_head++;
  dec_tables.counter_tail++;

  
  prefetch_table((const void *)&dec_tables, sizeof(dec_tables));
}
","1. static void prefetch_dec(void)
2. dec_tables.counter_head++;
dec_tables.counter_tail++;
3. prefetch_table((const void *)&dec_tables, sizeof(dec_tables));","1
7-8
11","CWE-310,CWE-668,CWE-189"
parse_single_header-23272463724168,"static int parse_single_header(server *srv, connection *con, parse_header_state *state, data_string *ds) {
	int cmp = 0;

	
	if (buffer_string_is_empty(ds->value)) {
		goto drop_header;
	}

	

	if (0 == (cmp = buffer_caseless_compare(CONST_BUF_LEN(ds->key), CONST_STR_LEN(""Connection"")))) {
		array *vals;
		size_t vi;

		

		vals = srv->split_vals;

		array_reset(vals);

		http_request_split_value(vals, ds->value);

		for (vi = 0; vi < vals->used; vi++) {
			data_string *dsv = (data_string *)vals->data[vi];

			if (0 == buffer_caseless_compare(CONST_BUF_LEN(dsv->value), CONST_STR_LEN(""keep-alive""))) {
				state->keep_alive_set = HTTP_CONNECTION_KEEPALIVE;

				break;
			} else if (0 == buffer_caseless_compare(CONST_BUF_LEN(dsv->value), CONST_STR_LEN(""close""))) {
				state->keep_alive_set = HTTP_CONNECTION_CLOSE;

				break;
			}
		}

	} else if (cmp > 0 && 0 == (cmp = buffer_caseless_compare(CONST_BUF_LEN(ds->key), CONST_STR_LEN(""Content-Length"")))) {
		char *err;
		off_t r;

		if (state->con_length_set) {
			if (srv->srvconf.log_request_header_on_error) {
				log_error_write(srv, __FILE__, __LINE__, ""s"",
						""duplicate Content-Length-header -> 400"");
				log_error_write(srv, __FILE__, __LINE__, ""Sb"",
						""request-header:\n"",
						con->request.request);
			}
			goto invalid_header;
		}

		r = strtoll(ds->value->ptr, &err, 10);

		if (*err == '\0' && r >= 0) {
			state->con_length_set = 1;
			con->request.content_length = r;
		} else {
			log_error_write(srv, __FILE__, __LINE__, ""sbs"",
					""content-length broken:"", ds->value, ""-> 400"");
			goto invalid_header;
		}
	} else if (cmp > 0 && 0 == (cmp = buffer_caseless_compare(CONST_BUF_LEN(ds->key), CONST_STR_LEN(""Content-Type"")))) {
		
		if (!con->request.http_content_type) {
			con->request.http_content_type = ds->value->ptr;
		} else {
			if (srv->srvconf.log_request_header_on_error) {
				log_error_write(srv, __FILE__, __LINE__, ""s"",
						""duplicate Content-Type-header -> 400"");
				log_error_write(srv, __FILE__, __LINE__, ""Sb"",
						""request-header:\n"",
						con->request.request);
			}
			goto invalid_header;
		}
	} else if (cmp > 0 && 0 == (cmp = buffer_caseless_compare(CONST_BUF_LEN(ds->key), CONST_STR_LEN(""Host"")))) {
		if (state->reqline_host) {
			
			goto drop_header;
		} else if (!con->request.http_host) {
			con->request.http_host = ds->value;
		} else {
			if (srv->srvconf.log_request_header_on_error) {
				log_error_write(srv, __FILE__, __LINE__, ""s"",
						""duplicate Host-header -> 400"");
				log_error_write(srv, __FILE__, __LINE__, ""Sb"",
						""request-header:\n"",
						con->request.request);
			}
			goto invalid_header;
		}
	} else if (cmp > 0 && 0 == (cmp = buffer_caseless_compare(CONST_BUF_LEN(ds->key), CONST_STR_LEN(""If-Modified-Since"")))) {
		
		if (!con->request.http_if_modified_since) {
			con->request.http_if_modified_since = ds->value->ptr;
		} else if (0 == strcasecmp(con->request.http_if_modified_since, ds->value->ptr)) {
			
			goto drop_header;
		} else {
			if (srv->srvconf.log_request_header_on_error) {
				log_error_write(srv, __FILE__, __LINE__, ""s"",
						""duplicate If-Modified-Since header -> 400"");
				log_error_write(srv, __FILE__, __LINE__, ""Sb"",
						""request-header:\n"",
						con->request.request);
			}
			goto invalid_header;
		}
	} else if (cmp > 0 && 0 == (cmp = buffer_caseless_compare(CONST_BUF_LEN(ds->key), CONST_STR_LEN(""If-None-Match"")))) {
		
		if (!con->request.http_if_none_match) {
			con->request.http_if_none_match = ds->value->ptr;
		} else {
			goto drop_header;
		}
	}

	array_insert_unique(con->request.headers, (data_unset *)ds);
	return 1;

drop_header:
	ds->free((data_unset *)ds);
	return 1;

invalid_header:
	ds->free((data_unset *)ds);
	return 0;
}
","1. data_string *dsv = (data_string *)vals->data[vi];
2. if (0 == buffer_caseless_compare(CONST_BUF_LEN(dsv->value), CONST_STR_LEN(""keep-alive""))) {
3. log_error_write(srv, __FILE__, __LINE__, ""Sb"",
4. log_error_write(srv, __FILE__, __LINE__, ""sbs"",
5. con->request.request);
6. if (!con->request.http_if_modified_since) {
7. } else if (cmp > 0 && 0 == (cmp = buffer_caseless_compare(CONST_BUF_LEN(ds->key), CONST_STR_LEN(""If-None-Match"")))) {
8. if (!con->request.http_if_none_match) {
9. drop_header:
10. ds->free((data_unset *)ds);","28
30
49
62
92
100
115
117
127
132","CWE-20,CWE-264,CWE-190,CWE-119,CWE-399"
atusb_get_and_show_build-114451637020344,"static int atusb_get_and_show_build(struct atusb *atusb)
{
	struct usb_device *usb_dev = atusb->usb_dev;
	char *build;
	int ret;

	build = kmalloc(ATUSB_BUILD_SIZE + 1, GFP_KERNEL);
	if (!build)
		return -ENOMEM;

	ret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),
				ATUSB_BUILD, ATUSB_REQ_FROM_DEV, 0, 0,
				build, ATUSB_BUILD_SIZE, 1000);
	if (ret >= 0) {
		build[ret] = 0;
		dev_info(&usb_dev->dev, ""Firmware: build %s\n"", build);
	}

	kfree(build);
	return ret;
}
","1. int ret;
2. build = kmalloc(ATUSB_BUILD_SIZE + 1, GFP_KERNEL);
if (!build)
return -ENOMEM;
3. ret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),
ATUSB_BUILD, ATUSB_REQ_FROM_DEV, 0, 0,
build, ATUSB_BUILD_SIZE, 1000);
if (ret >= 0) {
build[ret] = 0;
dev_info(&usb_dev->dev, ""Firmware: build %s\n"", build);
4. kfree(build);
return ret;","5
7-9
11-16
19-20",CWE-119
ppp_hdlc-38820977698476,"static void
ppp_hdlc(netdissect_options *ndo,
         const u_char *p, int length)
{
	u_char *b, *t, c;
	const u_char *s;
	int i, proto;
	const void *se;

        if (length <= 0)
                return;

	b = (u_char *)malloc(length);
	if (b == NULL)
		return;

	
	for (s = p, t = b, i = length; i > 0 && ND_TTEST(*s); i--) {
		c = *s++;
		if (c == 0x7d) {
			if (i <= 1 || !ND_TTEST(*s))
				break;
			i--;
			c = *s++ ^ 0x20;
		}
		*t++ = c;
	}

	se = ndo->ndo_snapend;
	ndo->ndo_snapend = t;
	length = t - b;

        
        if (length < 1)
                goto trunc;
        proto = *b; 

        switch (proto) {
        case PPP_IP:
		ip_print(ndo, b + 1, length - 1);
		goto cleanup;
        case PPP_IPV6:
		ip6_print(ndo, b + 1, length - 1);
		goto cleanup;
        default: 
		break;
        }

        if (length < 2)
                goto trunc;
        proto = EXTRACT_16BITS(b); 

        switch (proto) {
        case (PPP_ADDRESS << 8 | PPP_CONTROL): 
            if (length < 4)
                goto trunc;
            proto = EXTRACT_16BITS(b+2); 
            handle_ppp(ndo, proto, b + 4, length - 4);
            break;
        default: 
            handle_ppp(ndo, proto, b + 2, length - 2);
            break;
        }

cleanup:
	ndo->ndo_snapend = se;
	free(b);
        return;

trunc:
	ndo->ndo_snapend = se;
	free(b);
	ND_PRINT((ndo, ""[|ppp]""));
}
","1. const u_char *p, int length)
2. const void *se;
3. if (length <= 0)
4. return;
5. c = *s++;
if (c == 0x7d) {
if (i <= 1 || !ND_TTEST(*s))
6. ndo->ndo_snapend = t;
7. if (length < 1)
8. switch (proto) {
case PPP_IP:
9. case PPP_IPV6:
10. default:
11. goto trunc;
12. handle_ppp(ndo, proto, b + 4, length - 4);
break;
13. handle_ppp(ndo, proto, b + 2, length - 2);
break;
14. free(b);","3
8
10
15
23-25
34
38
42-43
46
49
54
62-63
65-66
71","CWE-835,CWE-1284,CWE-119"
addMultiArrayContentJSON-149079352238571,"
#define CtxJson
#define UA_DataType
#define UA_UInt32

static status
addMultiArrayContentJSON(CtxJson *ctx, void* array, const UA_DataType *type, 
                         size_t *index, UA_UInt32 *arrayDimensions, size_t dimensionIndex, 
                         size_t dimensionSize) {
    
    if(ctx->depth >= UA_JSON_ENCODING_MAX_RECURSION)
        return UA_STATUSCODE_BADENCODINGERROR;
    
    
    status ret;
    if(dimensionIndex == (dimensionSize - 1)) {
        ret = encodeJsonArray(ctx, ((u8*)array) + (type->memSize * *index),
                              arrayDimensions[dimensionIndex], type);
        (*index) += arrayDimensions[dimensionIndex];
        return ret;
    }

    
    ret = writeJsonArrStart(ctx);
    for(size_t i = 0; i < arrayDimensions[dimensionIndex]; i++) {
        ret |= writeJsonCommaIfNeeded(ctx);
        ret |= addMultiArrayContentJSON(ctx, array, type, index, arrayDimensions,
                                        dimensionIndex + 1, dimensionSize);
        ctx->commaNeeded[ctx->depth] = true;
        if(ret != UA_STATUSCODE_GOOD)
            return ret;
    }
    ret |= writeJsonArrEnd(ctx);
    return ret;
}
","1. static status
2. size_t dimensionSize) {
3. status ret;
4. return ret;
5. ret |= writeJsonCommaIfNeeded(ctx);
ret |= addMultiArrayContentJSON(ctx, array, type, index, arrayDimensions,
dimensionIndex + 1, dimensionSize);","6
9
15
20
26-28","CWE-400,CWE-787,CWE-119"
CIFSFindNext-21575138212881,"
#define __u16

int CIFSFindNext(const int xid, struct cifs_tcon *tcon,
		 __u16 searchHandle, struct cifs_search_info *psrch_inf)
{
	TRANSACTION2_FNEXT_REQ *pSMB = NULL;
	TRANSACTION2_FNEXT_RSP *pSMBr = NULL;
	T2_FNEXT_RSP_PARMS *parms;
	char *response_data;
	int rc = 0;
	int bytes_returned;
	unsigned int name_len;
	__u16 params, byte_count;

	cFYI(1, ""In FindNext"");

	if (psrch_inf->endOfSearch)
		return -ENOENT;

	rc = smb_init(SMB_COM_TRANSACTION2, 15, tcon, (void **) &pSMB,
		(void **) &pSMBr);
	if (rc)
		return rc;

	params = 14; 
	byte_count = 0;
	pSMB->TotalDataCount = 0;       
	pSMB->MaxParameterCount = cpu_to_le16(8);
	pSMB->MaxDataCount =
		cpu_to_le16((tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE) &
				0xFFFFFF00);
	pSMB->MaxSetupCount = 0;
	pSMB->Reserved = 0;
	pSMB->Flags = 0;
	pSMB->Timeout = 0;
	pSMB->Reserved2 = 0;
	pSMB->ParameterOffset =  cpu_to_le16(
	      offsetof(struct smb_com_transaction2_fnext_req,SearchHandle) - 4);
	pSMB->DataCount = 0;
	pSMB->DataOffset = 0;
	pSMB->SetupCount = 1;
	pSMB->Reserved3 = 0;
	pSMB->SubCommand = cpu_to_le16(TRANS2_FIND_NEXT);
	pSMB->SearchHandle = searchHandle;      
	pSMB->SearchCount =
		cpu_to_le16(CIFSMaxBufSize / sizeof(FILE_UNIX_INFO));
	pSMB->InformationLevel = cpu_to_le16(psrch_inf->info_level);
	pSMB->ResumeKey = psrch_inf->resume_key;
	pSMB->SearchFlags =
	      cpu_to_le16(CIFS_SEARCH_CLOSE_AT_END | CIFS_SEARCH_RETURN_RESUME);

	name_len = psrch_inf->resume_name_len;
	params += name_len;
	if (name_len < PATH_MAX) {
		memcpy(pSMB->ResumeFileName, psrch_inf->presume_name, name_len);
		byte_count += name_len;
		
		pSMB->ResumeFileName[name_len] = 0;
		pSMB->ResumeFileName[name_len+1] = 0;
	} else {
		rc = -EINVAL;
		goto FNext2_err_exit;
	}
	byte_count = params + 1  ;
	pSMB->TotalParameterCount = cpu_to_le16(params);
	pSMB->ParameterCount = pSMB->TotalParameterCount;
	inc_rfc1001_len(pSMB, byte_count);
	pSMB->ByteCount = cpu_to_le16(byte_count);

	rc = SendReceive(xid, tcon->ses, (struct smb_hdr *) pSMB,
			(struct smb_hdr *) pSMBr, &bytes_returned, 0);
	cifs_stats_inc(&tcon->num_fnext);
	if (rc) {
		if (rc == -EBADF) {
			psrch_inf->endOfSearch = true;
			cifs_buf_release(pSMB);
			rc = 0; 
		} else
			cFYI(1, ""FindNext returned = %d"", rc);
	} else {                
		rc = validate_t2((struct smb_t2_rsp *)pSMBr);

		if (rc == 0) {
			unsigned int lnoff;

			
			if (pSMBr->hdr.Flags2 & SMBFLG2_UNICODE)
				psrch_inf->unicode = true;
			else
				psrch_inf->unicode = false;
			response_data = (char *) &pSMBr->hdr.Protocol +
			       le16_to_cpu(pSMBr->t2.ParameterOffset);
			parms = (T2_FNEXT_RSP_PARMS *)response_data;
			response_data = (char *)&pSMBr->hdr.Protocol +
				le16_to_cpu(pSMBr->t2.DataOffset);
			if (psrch_inf->smallBuf)
				cifs_small_buf_release(
					psrch_inf->ntwrk_buf_start);
			else
				cifs_buf_release(psrch_inf->ntwrk_buf_start);
			psrch_inf->srch_entries_start = response_data;
			psrch_inf->ntwrk_buf_start = (char *)pSMB;
			psrch_inf->smallBuf = 0;
			if (parms->EndofSearch)
				psrch_inf->endOfSearch = true;
			else
				psrch_inf->endOfSearch = false;
			psrch_inf->entries_in_buffer =
						le16_to_cpu(parms->SearchCount);
			psrch_inf->index_of_last_entry +=
				psrch_inf->entries_in_buffer;
			lnoff = le16_to_cpu(parms->LastNameOffset);
			if (tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE <
			      lnoff) {
				cERROR(1, ""ignoring corrupt resume name"");
				psrch_inf->last_entry = NULL;
				return rc;
			} else
				psrch_inf->last_entry =
					psrch_inf->srch_entries_start + lnoff;



			
		}

	}

	

	
FNext2_err_exit:
	if (rc != 0)
		cifs_buf_release(pSMB);
	return rc;
}
","1. cpu_to_le16((tcon->ses->server->maxBuf - MAX_CIFS_HDR_SIZE) &
2. if (pSMBr->hdr.Flags2 & SMBFLG2_UNICODE)","31
88","CWE-119,CWE-190,CWE-264,CWE-189"
ASN1_item_verify_2,"
#define ASN1_BIT_STRING
#define ASN1_ITEM
#define EVP_PKEY
#define X509_ALGOR

int ASN1_item_verify_2(const ASN1_ITEM *it, X509_ALGOR *a,
		ASN1_BIT_STRING *signature, void *asn, EVP_PKEY *pkey)
	{
	EVP_MD_CTX ctx;
	unsigned char *buf_in=NULL;
	int ret= -1,inl;
 
        int mdnid, pknid;
 
       if (!pkey)
               {
               ASN1err(ASN1_F_ASN1_ITEM_VERIFY, ERR_R_PASSED_NULL_PARAMETER);
               return -1;
               }

        EVP_MD_CTX_init(&ctx);
 
        
		{
		if (!pkey->ameth || !pkey->ameth->item_verify)
			{
			ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM);
			goto err;
			}
		ret = pkey->ameth->item_verify(&ctx, it, asn, a,
							signature, pkey);
		
		if (ret != 2)
			goto err;
		ret = -1;
		}
	else
		{
		const EVP_MD *type;
		type=EVP_get_digestbynid(mdnid);
		if (type == NULL)
			{
			ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM);
			goto err;
			}

		
		if (EVP_PKEY_type(pknid) != pkey->ameth->pkey_id)
			{
			ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_WRONG_PUBLIC_KEY_TYPE);
			goto err;
			}

		if (!EVP_DigestVerifyInit(&ctx, NULL, type, NULL, pkey))
			{
			ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);
			ret=0;
			goto err;
			}

		}

	inl = ASN1_item_i2d(asn, &buf_in, it);
	
	if (buf_in == NULL)
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_MALLOC_FAILURE);
		goto err;
		}

	if (!EVP_DigestVerifyUpdate(&ctx,buf_in,inl))
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);
		ret=0;
		goto err;
		}

	OPENSSL_cleanse(buf_in,(unsigned int)inl);
	OPENSSL_free(buf_in);

	if (EVP_DigestVerifyFinal(&ctx,signature->data,
			(size_t)signature->length) <= 0)
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);
		ret=0;
		goto err;
		}
	
	
	ret=1;
err:
	EVP_MD_CTX_cleanup(&ctx);
	return(ret);
	}
","1. int ASN1_item_verify_2(const ASN1_ITEM *it, X509_ALGOR *a,
2. if (!pkey)
3. if (!pkey->ameth || !pkey->ameth->item_verify)
4. ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM);
goto err;
5. ret = pkey->ameth->item_verify(&ctx, it, asn, a,
6. if (buf_in == NULL)
7. ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);
8. OPENSSL_free(buf_in);
9. (size_t)signature->length) <= 0)
10. goto err;
11. return(ret);","7
16
26
28-29
31
69
77
83
86
90
98","CWE-17,CWE-310,CWE-125,CWE-119"
user_matches-231808920660700,"int
user_matches(const struct sudoers_parse_tree *parse_tree,
    const struct passwd *pw, const struct member *m)
{
    const struct sudoers_context *ctx = parse_tree->ctx;
    const char *lhost = parse_tree->lhost ? parse_tree->lhost : ctx->runas.host;
    const char *shost = parse_tree->shost ? parse_tree->shost : ctx->runas.shost;
    int matched = UNSPEC;
    struct alias *a;
    debug_decl(user_matches, SUDOERS_DEBUG_MATCH);

    switch (m->type) {
	case ALL:
	    matched = m->negated ? DENY : ALLOW;
	    break;
	case NETGROUP:
	    if (netgr_matches(parse_tree->nss, m->name,
		def_netgroup_tuple ? lhost : NULL,
		def_netgroup_tuple ? shost : NULL, pw->pw_name))
		matched = m->negated ? DENY : ALLOW;
	    break;
	case USERGROUP:
	    if (usergr_matches(m->name, pw->pw_name, pw))
		matched = m->negated ? DENY : ALLOW;
	    break;
	case ALIAS:
	    if ((a = alias_get(parse_tree, m->name, USERALIAS)) != NULL) {
		
		const int rc = userlist_matches(parse_tree, pw, &a->members);
		if (SPECIFIED(rc)) {
		    if (m->negated) {
			matched = rc == ALLOW ? DENY : ALLOW;
		    } else {
			matched = rc;
		    }
		}
		alias_put(a);
		break;
	    }
	    FALLTHROUGH;
	case WORD:
	    if (userpw_matches(m->name, pw->pw_name, pw))
		matched = m->negated ? DENY : ALLOW;
	    break;
    }
    debug_return_int(matched);
}
","1. const struct passwd *pw, const struct member *m)
2. struct alias *a;
3. matched = m->negated ? DENY : ALLOW;
4. if (netgr_matches(parse_tree->nss, m->name,
5. break;
case USERGROUP:
6. matched = m->negated ? DENY : ALLOW;
7. case ALIAS:
8. } else {","3
9
14
17
21-22
24
26
33","CWE-362,CWE-20,CWE-116,CWE-399"
_php_curl_setopt,"static int _php_curl_setopt(php_curl *ch, zend_long option, zval *zvalue) 
{
	CURLcode error = CURLE_OK;

	switch (option) {
		
		case CURLOPT_SSL_VERIFYHOST:
			convert_to_long(zvalue);
			if (Z_LVAL_P(zvalue) == 1) {
#if LIBCURL_VERSION_NUM <= 0x071c00 
				php_error_docref(NULL, E_NOTICE, ""CURLOPT_SSL_VERIFYHOST with value 1 is deprecated and will be removed as of libcurl 7.28.1. It is recommended to use value 2 instead"");
#else
				php_error_docref(NULL, E_NOTICE, ""CURLOPT_SSL_VERIFYHOST no longer accepts the value 1, value 2 will be used instead"");
				error = curl_easy_setopt(ch->cp, option, 2);
				break;
#endif
			}
		case CURLOPT_AUTOREFERER:
		case CURLOPT_BUFFERSIZE:
		case CURLOPT_CONNECTTIMEOUT:
		case CURLOPT_COOKIESESSION:
		case CURLOPT_CRLF:
		case CURLOPT_DNS_CACHE_TIMEOUT:
		case CURLOPT_DNS_USE_GLOBAL_CACHE:
		case CURLOPT_FAILONERROR:
		case CURLOPT_FILETIME:
		case CURLOPT_FORBID_REUSE:
		case CURLOPT_FRESH_CONNECT:
		case CURLOPT_FTP_USE_EPRT:
		case CURLOPT_FTP_USE_EPSV:
		case CURLOPT_HEADER:
		case CURLOPT_HTTPGET:
		case CURLOPT_HTTPPROXYTUNNEL:
		case CURLOPT_HTTP_VERSION:
		case CURLOPT_INFILESIZE:
		case CURLOPT_LOW_SPEED_LIMIT:
		case CURLOPT_LOW_SPEED_TIME:
		case CURLOPT_MAXCONNECTS:
		case CURLOPT_MAXREDIRS:
		case CURLOPT_NETRC:
		case CURLOPT_NOBODY:
		case CURLOPT_NOPROGRESS:
		case CURLOPT_NOSIGNAL:
		case CURLOPT_PORT:
		case CURLOPT_POST:
		case CURLOPT_PROXYPORT:
		case CURLOPT_PROXYTYPE:
		case CURLOPT_PUT:
		case CURLOPT_RESUME_FROM:
		case CURLOPT_SSLVERSION:
		case CURLOPT_SSL_VERIFYPEER:
		case CURLOPT_TIMECONDITION:
		case CURLOPT_TIMEOUT:
		case CURLOPT_TIMEVALUE:
		case CURLOPT_TRANSFERTEXT:
		case CURLOPT_UNRESTRICTED_AUTH:
		case CURLOPT_UPLOAD:
		case CURLOPT_VERBOSE:
#if LIBCURL_VERSION_NUM >= 0x070a06 
		case CURLOPT_HTTPAUTH:
#endif
#if LIBCURL_VERSION_NUM >= 0x070a07 
		case CURLOPT_FTP_CREATE_MISSING_DIRS:
		case CURLOPT_PROXYAUTH:
#endif
#if LIBCURL_VERSION_NUM >= 0x070a08 
		case CURLOPT_FTP_RESPONSE_TIMEOUT:
		case CURLOPT_IPRESOLVE:
		case CURLOPT_MAXFILESIZE:
#endif
#if LIBCURL_VERSION_NUM >= 0x070b02 
		case CURLOPT_TCP_NODELAY:
#endif
#if LIBCURL_VERSION_NUM >= 0x070c02 
		case CURLOPT_FTPSSLAUTH:
#endif
#if LIBCURL_VERSION_NUM >= 0x070e01 
		case CURLOPT_IGNORE_CONTENT_LENGTH:
#endif
#if LIBCURL_VERSION_NUM >= 0x070f00 
		case CURLOPT_FTP_SKIP_PASV_IP:
#endif
#if LIBCURL_VERSION_NUM >= 0x070f01 
		case CURLOPT_FTP_FILEMETHOD:
#endif
#if LIBCURL_VERSION_NUM >= 0x070f02 
		case CURLOPT_CONNECT_ONLY:
		case CURLOPT_LOCALPORT:
		case CURLOPT_LOCALPORTRANGE:
#endif
#if LIBCURL_VERSION_NUM >= 0x071000 
		case CURLOPT_SSL_SESSIONID_CACHE:
#endif
#if LIBCURL_VERSION_NUM >= 0x071001 
		case CURLOPT_FTP_SSL_CCC:
		case CURLOPT_SSH_AUTH_TYPES:
#endif
#if LIBCURL_VERSION_NUM >= 0x071002 
		case CURLOPT_CONNECTTIMEOUT_MS:
		case CURLOPT_HTTP_CONTENT_DECODING:
		case CURLOPT_HTTP_TRANSFER_DECODING:
		case CURLOPT_TIMEOUT_MS:
#endif
#if LIBCURL_VERSION_NUM >= 0x071004 
		case CURLOPT_NEW_DIRECTORY_PERMS:
		case CURLOPT_NEW_FILE_PERMS:
#endif
#if LIBCURL_VERSION_NUM >= 0x071100 
		case CURLOPT_USE_SSL:
#elif LIBCURL_VERSION_NUM >= 0x070b00 
		case CURLOPT_FTP_SSL:
#endif
#if LIBCURL_VERSION_NUM >= 0x071100 
		case CURLOPT_APPEND:
		case CURLOPT_DIRLISTONLY:
#else
		case CURLOPT_FTPAPPEND:
		case CURLOPT_FTPLISTONLY:
#endif
#if LIBCURL_VERSION_NUM >= 0x071200 
		case CURLOPT_PROXY_TRANSFER_MODE:
#endif
#if LIBCURL_VERSION_NUM >= 0x071300 
		case CURLOPT_ADDRESS_SCOPE:
#endif
#if LIBCURL_VERSION_NUM >  0x071301 
		case CURLOPT_CERTINFO:
#endif
#if LIBCURL_VERSION_NUM >= 0x071304 
		case CURLOPT_NOPROXY:
		case CURLOPT_PROTOCOLS:
		case CURLOPT_REDIR_PROTOCOLS:
		case CURLOPT_SOCKS5_GSSAPI_NEC:
		case CURLOPT_TFTP_BLKSIZE:
#endif
#if LIBCURL_VERSION_NUM >= 0x071400 
		case CURLOPT_FTP_USE_PRET:
		case CURLOPT_RTSP_CLIENT_CSEQ:
		case CURLOPT_RTSP_REQUEST:
		case CURLOPT_RTSP_SERVER_CSEQ:
#endif
#if LIBCURL_VERSION_NUM >= 0x071500 
		case CURLOPT_WILDCARDMATCH:
#endif
#if LIBCURL_VERSION_NUM >= 0x071504 
		case CURLOPT_TLSAUTH_TYPE:
#endif
#if LIBCURL_VERSION_NUM >= 0x071600 
		case CURLOPT_GSSAPI_DELEGATION:
#endif
#if LIBCURL_VERSION_NUM >= 0x071800 
		case CURLOPT_ACCEPTTIMEOUT_MS:
#endif
#if LIBCURL_VERSION_NUM >= 0x071900 
		case CURLOPT_SSL_OPTIONS:
		case CURLOPT_TCP_KEEPALIVE:
		case CURLOPT_TCP_KEEPIDLE:
		case CURLOPT_TCP_KEEPINTVL:
#endif
#if CURLOPT_MUTE != 0
		case CURLOPT_MUTE:
#endif
			convert_to_long_ex(zvalue);
#if LIBCURL_VERSION_NUM >= 0x71304
			if ((option == CURLOPT_PROTOCOLS || option == CURLOPT_REDIR_PROTOCOLS) &&
				(PG(open_basedir) && *PG(open_basedir)) && (Z_LVAL_P(zvalue) & CURLPROTO_FILE)) {
					php_error_docref(NULL, E_WARNING, ""CURLPROTO_FILE cannot be activated when an open_basedir is set"");
					return 1;
			}
#endif
			error = curl_easy_setopt(ch->cp, option, Z_LVAL_P(zvalue));
			break;
		case CURLOPT_SAFE_UPLOAD:
			convert_to_long_ex(zvalue);
			ch->safe_upload = (Z_LVAL_P(zvalue) != 0);
			break;

		
		case CURLOPT_CAINFO:
		case CURLOPT_CAPATH:
		case CURLOPT_COOKIE:
		case CURLOPT_EGDSOCKET:
		case CURLOPT_INTERFACE:
		case CURLOPT_PROXY:
		case CURLOPT_PROXYUSERPWD:
		case CURLOPT_REFERER:
		case CURLOPT_SSLCERTTYPE:
		case CURLOPT_SSLENGINE:
		case CURLOPT_SSLENGINE_DEFAULT:
		case CURLOPT_SSLKEY:
		case CURLOPT_SSLKEYPASSWD:
		case CURLOPT_SSLKEYTYPE:
		case CURLOPT_SSL_CIPHER_LIST:
		case CURLOPT_USERAGENT:
		case CURLOPT_USERPWD:
#if LIBCURL_VERSION_NUM >= 0x070e01 
		case CURLOPT_COOKIELIST:
#endif
#if LIBCURL_VERSION_NUM >= 0x070f05 
		case CURLOPT_FTP_ALTERNATIVE_TO_USER:
#endif
#if LIBCURL_VERSION_NUM >= 0x071101 
		case CURLOPT_SSH_HOST_PUBLIC_KEY_MD5:
#endif
#if LIBCURL_VERSION_NUM >= 0x071301 
		case CURLOPT_PASSWORD:
		case CURLOPT_PROXYPASSWORD:
		case CURLOPT_PROXYUSERNAME:
		case CURLOPT_USERNAME:
#endif
#if LIBCURL_VERSION_NUM >= 0x071304 
		case CURLOPT_SOCKS5_GSSAPI_SERVICE:
#endif
#if LIBCURL_VERSION_NUM >= 0x071400 
		case CURLOPT_MAIL_FROM:
		case CURLOPT_RTSP_STREAM_URI:
		case CURLOPT_RTSP_TRANSPORT:
#endif
#if LIBCURL_VERSION_NUM >= 0x071504 
		case CURLOPT_TLSAUTH_PASSWORD:
		case CURLOPT_TLSAUTH_USERNAME:
#endif
#if LIBCURL_VERSION_NUM >= 0x071506 
		case CURLOPT_ACCEPT_ENCODING:
		case CURLOPT_TRANSFER_ENCODING:
#else
		case CURLOPT_ENCODING:
#endif
#if LIBCURL_VERSION_NUM >= 0x071800 
		case CURLOPT_DNS_SERVERS:
#endif
#if LIBCURL_VERSION_NUM >= 0x071900 
		case CURLOPT_MAIL_AUTH:
#endif
		{
			convert_to_string_ex(zvalue);
			return php_curl_option_str(ch, option, Z_STRVAL_P(zvalue), Z_STRLEN_P(zvalue), 0);
		}

		
		case CURLOPT_CUSTOMREQUEST:
		case CURLOPT_FTPPORT:
		case CURLOPT_RANGE:
#if LIBCURL_VERSION_NUM >= 0x070d00 
		case CURLOPT_FTP_ACCOUNT:
#endif
#if LIBCURL_VERSION_NUM >= 0x071400 
		case CURLOPT_RTSP_SESSION_ID:
#endif
#if LIBCURL_VERSION_NUM >= 0x071004 
		case CURLOPT_KRBLEVEL:
#else
		case CURLOPT_KRB4LEVEL:
#endif
		{
			if (Z_ISNULL_P(zvalue)) {
				error = curl_easy_setopt(ch->cp, option, NULL);
			} else {
				convert_to_string_ex(zvalue);
				return php_curl_option_str(ch, option, Z_STRVAL_P(zvalue), Z_STRLEN_P(zvalue), 0);
			}
			break;
		}

		
		case CURLOPT_PRIVATE:
			convert_to_string_ex(zvalue);
			return php_curl_option_str(ch, option, Z_STRVAL_P(zvalue), Z_STRLEN_P(zvalue), 1);

		
		case CURLOPT_URL:
			convert_to_string_ex(zvalue);
			return php_curl_option_url(ch, Z_STRVAL_P(zvalue), Z_STRLEN_P(zvalue));

		
		case CURLOPT_FILE:
		case CURLOPT_INFILE:
		case CURLOPT_STDERR:
		case CURLOPT_WRITEHEADER: {
			FILE *fp = NULL;
			int type;
			php_stream *what = NULL;

			if (Z_TYPE_P(zvalue) != IS_NULL) {
				what = zend_fetch_resource(zvalue, -1, ""File-Handle"", &type, 1, php_file_le_stream(), php_file_le_pstream());
				if (!what) {
					return FAILURE;
				}

				if (FAILURE == php_stream_cast(what, PHP_STREAM_AS_STDIO, (void *) &fp, REPORT_ERRORS)) {
					return FAILURE;
				}

				if (!fp) {
					return FAILURE;
				}
			}

			error = CURLE_OK;
			switch (option) {
				case CURLOPT_FILE:
					if (!what) {
						if (!Z_ISUNDEF(ch->handlers->write->stream)) {
							zval_ptr_dtor(&ch->handlers->write->stream);
							ZVAL_UNDEF(&ch->handlers->write->stream);
						}
						ch->handlers->write->fp = NULL;
						ch->handlers->write->method = PHP_CURL_STDOUT;
					} else if (what->mode[0] != 'r' || what->mode[1] == '+') {
						zval_ptr_dtor(&ch->handlers->write->stream);
						ch->handlers->write->fp = fp;
						ch->handlers->write->method = PHP_CURL_FILE;
						ZVAL_COPY(&ch->handlers->write->stream, zvalue);
					} else {
						php_error_docref(NULL, E_WARNING, ""the provided file handle is not writable"");
						return FAILURE;
					}
					break;
				case CURLOPT_WRITEHEADER:
					if (!what) {
						if (!Z_ISUNDEF(ch->handlers->write_header->stream)) {
							zval_ptr_dtor(&ch->handlers->write_header->stream);
							ZVAL_UNDEF(&ch->handlers->write_header->stream);
						}
						ch->handlers->write_header->fp = NULL;
						ch->handlers->write_header->method = PHP_CURL_IGNORE;
					} else if (what->mode[0] != 'r' || what->mode[1] == '+') {
						zval_ptr_dtor(&ch->handlers->write_header->stream);
						ch->handlers->write_header->fp = fp;
						ch->handlers->write_header->method = PHP_CURL_FILE;
						ZVAL_COPY(&ch->handlers->write_header->stream, zvalue);;
					} else {
						php_error_docref(NULL, E_WARNING, ""the provided file handle is not writable"");
						return FAILURE;
					}
					break;
				case CURLOPT_INFILE:
					if (!what) {
						if (!Z_ISUNDEF(ch->handlers->read->stream)) {
							zval_ptr_dtor(&ch->handlers->read->stream);
							ZVAL_UNDEF(&ch->handlers->read->stream);
						}
						ch->handlers->read->fp = NULL;
						ch->handlers->read->res = NULL;
					} else {
						zval_ptr_dtor(&ch->handlers->read->stream);
						ch->handlers->read->fp = fp;
						ch->handlers->read->res = Z_RES_P(zvalue);
						ZVAL_COPY(&ch->handlers->read->stream, zvalue);
					}
					break;
				case CURLOPT_STDERR:
					if (!what) {
						if (!Z_ISUNDEF(ch->handlers->std_err)) {
							zval_ptr_dtor(&ch->handlers->std_err);
							ZVAL_UNDEF(&ch->handlers->std_err);
						}
					} else if (what->mode[0] != 'r' || what->mode[1] == '+') {
						zval_ptr_dtor(&ch->handlers->std_err);
						ZVAL_COPY(&ch->handlers->std_err, zvalue);
					} else {
						php_error_docref(NULL, E_WARNING, ""the provided file handle is not writable"");
						return FAILURE;
					}
					
				default:
					error = curl_easy_setopt(ch->cp, option, fp);
					break;
			}
			break;
		}

		
		case CURLOPT_HTTP200ALIASES:
		case CURLOPT_HTTPHEADER:
		case CURLOPT_POSTQUOTE:
		case CURLOPT_PREQUOTE:
		case CURLOPT_QUOTE:
		case CURLOPT_TELNETOPTIONS:
#if LIBCURL_VERSION_NUM >= 0x071400 
		case CURLOPT_MAIL_RCPT:
#endif
#if LIBCURL_VERSION_NUM >= 0x071503 
		case CURLOPT_RESOLVE:
#endif
		{
			zval *current;
			HashTable *ph;
			struct curl_slist *slist = NULL;

			ph = HASH_OF(zvalue);
			if (!ph) {
				char *name = NULL;
				switch (option) {
					case CURLOPT_HTTPHEADER:
						name = ""CURLOPT_HTTPHEADER"";
						break;
					case CURLOPT_QUOTE:
						name = ""CURLOPT_QUOTE"";
						break;
					case CURLOPT_HTTP200ALIASES:
						name = ""CURLOPT_HTTP200ALIASES"";
						break;
					case CURLOPT_POSTQUOTE:
						name = ""CURLOPT_POSTQUOTE"";
						break;
					case CURLOPT_PREQUOTE:
						name = ""CURLOPT_PREQUOTE"";
						break;
					case CURLOPT_TELNETOPTIONS:
						name = ""CURLOPT_TELNETOPTIONS"";
						break;
#if LIBCURL_VERSION_NUM >= 0x071400 
					case CURLOPT_MAIL_RCPT:
						name = ""CURLOPT_MAIL_RCPT"";
						break;
#endif
#if LIBCURL_VERSION_NUM >= 0x071503 
					case CURLOPT_RESOLVE:
						name = ""CURLOPT_RESOLVE"";
						break;
#endif
				}
				php_error_docref(NULL, E_WARNING, ""You must pass either an object or an array with the %s argument"", name);
				return FAILURE;
			}

			ZEND_HASH_FOREACH_VAL(ph, current) {
				SEPARATE_ZVAL(current);
				convert_to_string_ex(current);

				slist = curl_slist_append(slist, Z_STRVAL_P(current));
				if (!slist) {
					php_error_docref(NULL, E_WARNING, ""Could not build curl_slist"");
					return 1;
				}
			} ZEND_HASH_FOREACH_END();

			zend_hash_index_update_ptr(ch->to_free->slist, option, slist);

			error = curl_easy_setopt(ch->cp, option, slist);

			break;
		}

		case CURLOPT_BINARYTRANSFER:
			
			break;

		case CURLOPT_FOLLOWLOCATION:
			convert_to_long_ex(zvalue);
#if LIBCURL_VERSION_NUM < 0x071304
			if (PG(open_basedir) && *PG(open_basedir)) {
				if (Z_LVAL_P(zvalue) != 0) {
					php_error_docref(NULL, E_WARNING, ""CURLOPT_FOLLOWLOCATION cannot be activated when an open_basedir is set"");
					return FAILURE;
				}
			}
#endif
			error = curl_easy_setopt(ch->cp, option, Z_LVAL_P(zvalue));
			break;

		case CURLOPT_HEADERFUNCTION:
			if (!Z_ISUNDEF(ch->handlers->write_header->func_name)) {
				zval_ptr_dtor(&ch->handlers->write_header->func_name);
				ch->handlers->write_header->fci_cache = empty_fcall_info_cache;
			}
			ZVAL_COPY(&ch->handlers->write_header->func_name, zvalue);
			ch->handlers->write_header->method = PHP_CURL_USER;
			break;

		case CURLOPT_POSTFIELDS:
			if (Z_TYPE_P(zvalue) == IS_ARRAY || Z_TYPE_P(zvalue) == IS_OBJECT) {
				zval *current;
				HashTable *postfields;
				zend_string *string_key;
				zend_ulong  num_key;
				struct HttpPost *first = NULL;
				struct HttpPost *last  = NULL;

				postfields = HASH_OF(zvalue);
				if (!postfields) {
					php_error_docref(NULL, E_WARNING, ""Couldn't get HashTable in CURLOPT_POSTFIELDS"");
					return FAILURE;
				}

				ZEND_HASH_FOREACH_KEY_VAL(postfields, num_key, string_key, current) {
					char *postval;
					
					if (!string_key) {
						string_key = zend_long_to_str(num_key);
					} else {
						zend_string_addref(string_key);
					}

					if (Z_TYPE_P(current) == IS_OBJECT &&
							instanceof_function(Z_OBJCE_P(current), curl_CURLFile_class)) {
						
						zval *prop;
						char *type = NULL, *filename = NULL;

						prop = zend_read_property(curl_CURLFile_class, current, ""name"", sizeof(""name"")-1, 0);
						if (Z_TYPE_P(prop) != IS_STRING) {
							php_error_docref(NULL, E_WARNING, ""Invalid filename for key %s"", string_key->val);
						} else {
							postval = Z_STRVAL_P(prop);

							if (php_check_open_basedir(postval)) {
								return 1;
							}

							prop = zend_read_property(curl_CURLFile_class, current, ""mime"", sizeof(""mime"")-1, 0);
							if (Z_TYPE_P(prop) == IS_STRING && Z_STRLEN_P(prop) > 0) {
								type = Z_STRVAL_P(prop);
							}
							prop = zend_read_property(curl_CURLFile_class, current, ""postname"", sizeof(""postname"")-1, 0);
							if (Z_TYPE_P(prop) == IS_STRING && Z_STRLEN_P(prop) > 0) {
								filename = Z_STRVAL_P(prop);
							}
							error = curl_formadd(&first, &last,
											CURLFORM_COPYNAME, string_key->val,
											CURLFORM_NAMELENGTH, string_key->len,
											CURLFORM_FILENAME, filename ? filename : postval,
											CURLFORM_CONTENTTYPE, type ? type : ""application/octet-stream"",
											CURLFORM_FILE, postval,
											CURLFORM_END);
						}

						zend_string_release(string_key);
						continue;
					}

					SEPARATE_ZVAL(current);
					convert_to_string_ex(current);

					postval = Z_STRVAL_P(current);

					
					if (!ch->safe_upload && *postval == '@') {
						char *name, *type, *filename;
						++postval;

						php_error_docref(""curl.curlfile"", E_DEPRECATED,
								""The usage of the @filename API for file uploading is deprecated. Please use the CURLFile class instead"");

						name = estrndup(postval, Z_STRLEN_P(current));
						if ((type = (char *)php_memnstr(name, "";type="", sizeof("";type="") - 1,
										name + Z_STRLEN_P(current)))) {
							*type = '\0';
						}
						if ((filename = (char *)php_memnstr(name, "";filename="", sizeof("";filename="") - 1,
										name + Z_STRLEN_P(current)))) {
							*filename = '\0';
						}
						
						if (php_check_open_basedir(name)) {
							efree(name);
							return FAILURE;
						}
						error = curl_formadd(&first, &last,
										CURLFORM_COPYNAME, string_key->val,
										CURLFORM_NAMELENGTH, string_key->len,
										CURLFORM_FILENAME, filename ? filename + sizeof("";filename="") - 1 : name,
										CURLFORM_CONTENTTYPE, type ? type + sizeof("";type="") - 1 : ""application/octet-stream"",
										CURLFORM_FILE, name,
										CURLFORM_END);
						efree(name);
					} else {
						error = curl_formadd(&first, &last,
											 CURLFORM_COPYNAME, string_key->val,
											 CURLFORM_NAMELENGTH, (zend_long)string_key->len,
											 CURLFORM_COPYCONTENTS, postval,
											 CURLFORM_CONTENTSLENGTH, (zend_long)Z_STRLEN_P(current),
											 CURLFORM_END);
					}

					zend_string_release(string_key);
				} ZEND_HASH_FOREACH_END();

				SAVE_CURL_ERROR(ch, error);
				if (error != CURLE_OK) {
					return FAILURE;
				}

				if (ch->clone == 0) {
					zend_llist_clean(&ch->to_free->post);
				} 
				zend_llist_add_element(&ch->to_free->post, &first);
				error = curl_easy_setopt(ch->cp, CURLOPT_HTTPPOST, first);
			} else {
#if LIBCURL_VERSION_NUM >= 0x071101
				convert_to_string_ex(zvalue);
				
				error = curl_easy_setopt(ch->cp, CURLOPT_POSTFIELDSIZE, Z_STRLEN_P(zvalue));
				error = curl_easy_setopt(ch->cp, CURLOPT_COPYPOSTFIELDS, Z_STRVAL_P(zvalue));
#else
				char *post = NULL;

				convert_to_string_ex(zvalue);
				post = estrndup(Z_STRVAL_P(zvalue), Z_STRLEN_P(zvalue));
				zend_llist_add_element(&ch->to_free->str, &post);

				curl_easy_setopt(ch->cp, CURLOPT_POSTFIELDS, post);
				error = curl_easy_setopt(ch->cp, CURLOPT_POSTFIELDSIZE, Z_STRLEN_P(zvalue));
#endif
			}
			break;

		case CURLOPT_PROGRESSFUNCTION:
			curl_easy_setopt(ch->cp, CURLOPT_PROGRESSFUNCTION,	curl_progress);
			curl_easy_setopt(ch->cp, CURLOPT_PROGRESSDATA, ch);
			if (ch->handlers->progress == NULL) {
				ch->handlers->progress = ecalloc(1, sizeof(php_curl_progress));
			} else if (!Z_ISUNDEF(ch->handlers->progress->func_name)) {
				zval_ptr_dtor(&ch->handlers->progress->func_name);
				ch->handlers->progress->fci_cache = empty_fcall_info_cache;
			}
			ZVAL_COPY(&ch->handlers->progress->func_name, zvalue);
			ch->handlers->progress->method = PHP_CURL_USER;
			break;

		case CURLOPT_READFUNCTION:
			if (!Z_ISUNDEF(ch->handlers->read->func_name)) {
				zval_ptr_dtor(&ch->handlers->read->func_name);
				ch->handlers->read->fci_cache = empty_fcall_info_cache;
			}
			ZVAL_COPY(&ch->handlers->read->func_name, zvalue);
			ch->handlers->read->method = PHP_CURL_USER;
			break;

		case CURLOPT_RETURNTRANSFER:
			convert_to_long_ex(zvalue);
			if (Z_LVAL_P(zvalue)) {
				ch->handlers->write->method = PHP_CURL_RETURN;
			} else {
				ch->handlers->write->method = PHP_CURL_STDOUT;
			}
			break;

		case CURLOPT_WRITEFUNCTION:
			if (!Z_ISUNDEF(ch->handlers->write->func_name)) {
				zval_ptr_dtor(&ch->handlers->write->func_name);
				ch->handlers->write->fci_cache = empty_fcall_info_cache;
			}
			ZVAL_COPY(&ch->handlers->write->func_name, zvalue);
			ch->handlers->write->method = PHP_CURL_USER;
			break;

#if LIBCURL_VERSION_NUM >= 0x070f05 
		case CURLOPT_MAX_RECV_SPEED_LARGE:
		case CURLOPT_MAX_SEND_SPEED_LARGE:
			convert_to_long_ex(zvalue);
			error = curl_easy_setopt(ch->cp, option, (curl_off_t)Z_LVAL_P(zvalue));
			break;
#endif

#if LIBCURL_VERSION_NUM >= 0x071301 
		case CURLOPT_POSTREDIR:
			convert_to_long_ex(zvalue);
			error = curl_easy_setopt(ch->cp, CURLOPT_POSTREDIR, Z_LVAL_P(zvalue) & CURL_REDIR_POST_ALL);
			break;
#endif

#if CURLOPT_PASSWDFUNCTION != 0
		case CURLOPT_PASSWDFUNCTION:
			zval_ptr_dtor(&ch->handlers->passwd);
			ZVAL_COPY(&ch->handlers->passwd, zvalue);
			error = curl_easy_setopt(ch->cp, CURLOPT_PASSWDFUNCTION, curl_passwd);
			error = curl_easy_setopt(ch->cp, CURLOPT_PASSWDDATA,     (void *) ch);
			break;
#endif

		
		case CURLOPT_COOKIEFILE:
		case CURLOPT_COOKIEJAR:
		case CURLOPT_RANDOM_FILE:
		case CURLOPT_SSLCERT:
#if LIBCURL_VERSION_NUM >= 0x070b00 
		case CURLOPT_NETRC_FILE:
#endif
#if LIBCURL_VERSION_NUM >= 0x071001 
		case CURLOPT_SSH_PRIVATE_KEYFILE:
		case CURLOPT_SSH_PUBLIC_KEYFILE:
#endif
#if LIBCURL_VERSION_NUM >= 0x071300 
		case CURLOPT_CRLFILE:
		case CURLOPT_ISSUERCERT:
#endif
#if LIBCURL_VERSION_NUM >= 0x071306 
		case CURLOPT_SSH_KNOWNHOSTS:
#endif
		{
			convert_to_string_ex(zvalue);

			if (Z_STRLEN_P(zvalue) && php_check_open_basedir(Z_STRVAL_P(zvalue))) {
				return FAILURE;
			}

			return php_curl_option_str(ch, option, Z_STRVAL_P(zvalue), Z_STRLEN_P(zvalue), 0);
		}

		case CURLINFO_HEADER_OUT:
			convert_to_long_ex(zvalue);
			if (Z_LVAL_P(zvalue) == 1) {
				curl_easy_setopt(ch->cp, CURLOPT_DEBUGFUNCTION, curl_debug);
				curl_easy_setopt(ch->cp, CURLOPT_DEBUGDATA, (void *)ch);
				curl_easy_setopt(ch->cp, CURLOPT_VERBOSE, 1);
			} else {
				curl_easy_setopt(ch->cp, CURLOPT_DEBUGFUNCTION, NULL);
				curl_easy_setopt(ch->cp, CURLOPT_DEBUGDATA, NULL);
				curl_easy_setopt(ch->cp, CURLOPT_VERBOSE, 0);
			}
			break;

		case CURLOPT_SHARE:
			{
				php_curlsh *sh = NULL;
				ZEND_FETCH_RESOURCE_NO_RETURN(sh, php_curlsh *, zvalue, -1, le_curl_share_handle_name, le_curl_share_handle);
				if (sh) {
                                        curl_easy_setopt(ch->cp, CURLOPT_SHARE, sh->share);
                                }
                        }
                       break;
 
 #if LIBCURL_VERSION_NUM >= 0x071500 
                case CURLOPT_FNMATCH_FUNCTION:
			curl_easy_setopt(ch->cp, CURLOPT_FNMATCH_DATA, ch);
			if (ch->handlers->fnmatch == NULL) {
				ch->handlers->fnmatch = ecalloc(1, sizeof(php_curl_fnmatch));
			} else if (!Z_ISUNDEF(ch->handlers->fnmatch->func_name)) {
				zval_ptr_dtor(&ch->handlers->fnmatch->func_name);
				ch->handlers->fnmatch->fci_cache = empty_fcall_info_cache;
			}
			ZVAL_COPY(&ch->handlers->fnmatch->func_name, zvalue);
			ch->handlers->fnmatch->method = PHP_CURL_USER;
			break;
#endif

	}

	SAVE_CURL_ERROR(ch, error);
	if (error != CURLE_OK) {
		return FAILURE;
	} else {
		return SUCCESS;
	}
}

","1. switch (option) {
2. case CURLOPT_AUTOREFERER:
3. break;
4. case CURLOPT_PRIVATE:
convert_to_string_ex(zvalue);
5. ZVAL_UNDEF(&ch->handlers->read->stream);
6. case CURLOPT_HTTPHEADER:
7. php_error_docref(NULL, E_WARNING, ""You must pass either an object or an array with the %s argument"", name);
8. error = curl_easy_setopt(ch->cp, option, Z_LVAL_P(zvalue));
9. ZEND_HASH_FOREACH_KEY_VAL(postfields, num_key, string_key, current) {
10. if (!string_key) {
11. CURLFORM_FILENAME, filename ? filename : postval,
12. } else {
13. } ZEND_HASH_FOREACH_END();
14. curl_easy_setopt(ch->cp, CURLOPT_PROGRESSDATA, ch);","5
18
262
266-267
341
395
424
460
487
490
523
570
580
613","CWE-20,CWE-416,CWE-476,CWE-189,CWE-17"
main_45-138647301763359,"l_int32 main_45(int    argc,
             char **argv)
{
L_DEWARP   *dew1, *dew2;
L_DEWARPA  *dewa;
PIX        *pixs, *pixn, *pixg, *pixb, *pixd, *pixt1, *pixt2;
PIX        *pixs2, *pixn2, *pixg2, *pixb2, *pixd2;

    setLeptDebugOK(1);
    lept_mkdir(""lept/model"");
    lept_rmdir(""lept/dewmod"");
    lept_mkdir(""lept/dewmod"");


    pixs = pixRead(""cat.035.jpg"");


        
    pixn = pixBackgroundNormSimple(pixs, NULL, NULL);
    pixg = pixConvertRGBToGray(pixn, 0.5, 0.3, 0.2);
    pixb = pixThresholdToBinary(pixg, 130);

        
    dewa = dewarpaCreate(2, 30, 1, 10, 30);
    dewarpaUseBothArrays(dewa, 1);
    dew1 = dewarpCreate(pixb, 35);
    dewarpaInsertDewarp(dewa, dew1);
    dewarpBuildPageModel(dew1, ""/tmp/lept/model/dewarp_model1.pdf"");
    dewarpaApplyDisparity(dewa, 35, pixg, 200, 0, 0, &pixd,
                          ""/tmp/lept/model/dewarp_apply1.pdf"");

         
    lept_rmdir(""lept/dewtest"");
    lept_mkdir(""lept/dewtest"");
    pixWrite(""/tmp/lept/dewtest/001.jpg"", pixs, IFF_JFIF_JPEG);
    pixWrite(""/tmp/lept/dewtest/002.jpg"", pixn, IFF_JFIF_JPEG);
    pixWrite(""/tmp/lept/dewtest/003.jpg"", pixg, IFF_JFIF_JPEG);
    pixWrite(""/tmp/lept/dewtest/004.png"", pixb, IFF_TIFF_G4);
    pixWrite(""/tmp/lept/dewtest/005.jpg"", pixd, IFF_JFIF_JPEG);
    pixt1 = pixRead(""/tmp/lept/dewmod/0020.png"");
    pixWrite(""/tmp/lept/dewtest/006.png"", pixt1, IFF_PNG);
    pixDestroy(&pixt1);
    pixt1 = pixRead(""/tmp/lept/dewmod/0030.png"");
    pixWrite(""/tmp/lept/dewtest/007.png"", pixt1, IFF_PNG);
    pixDestroy(&pixt1);
    pixt1 = pixRead(""/tmp/lept/dewmod/0060.png"");
    pixWrite(""/tmp/lept/dewtest/008.png"", pixt1, IFF_PNG);
    pixDestroy(&pixt1);
    pixt1 = pixRead(""/tmp/lept/dewmod/0070.png"");
    pixWrite(""/tmp/lept/dewtest/009.png"", pixt1, IFF_PNG);
    pixDestroy(&pixt1);
    pixt1 = pixRead(""/tmp/lept/dewapply/002.png"");
    pixWrite(""/tmp/lept/dewtest/010.png"", pixt1, IFF_PNG);
    pixDestroy(&pixt1);
    pixt1 = pixRead(""/tmp/lept/dewapply/003.png"");
    pixWrite(""/tmp/lept/dewtest/011.png"", pixt1, IFF_PNG);
    pixt2 = pixThresholdToBinary(pixt1, 130);
    pixWrite(""/tmp/lept/dewtest/012.png"", pixt2, IFF_TIFF_G4);
    pixDestroy(&pixt1);
    pixDestroy(&pixt2);
    pixt1 = pixRead(""/tmp/lept/dewmod/0041.png"");
    pixWrite(""/tmp/lept/dewtest/013.png"", pixt1, IFF_PNG);
    pixDestroy(&pixt1);
    pixt1 = pixRead(""/tmp/lept/dewmod/0042.png"");
    pixWrite(""/tmp/lept/dewtest/014.png"", pixt1, IFF_PNG);
    pixDestroy(&pixt1);
    pixt1 = pixRead(""/tmp/lept/dewmod/0051.png"");
    pixWrite(""/tmp/lept/dewtest/015.png"", pixt1, IFF_PNG);
    pixDestroy(&pixt1);
    pixt1 = pixRead(""/tmp/lept/dewmod/0052.png"");
    pixWrite(""/tmp/lept/dewtest/016.png"", pixt1, IFF_PNG);
    pixDestroy(&pixt1);

        

    pixs2 = pixRead(""cat.007.jpg"");

    pixn2 = pixBackgroundNormSimple(pixs2, NULL, NULL);
    pixg2 = pixConvertRGBToGray(pixn2, 0.5, 0.3, 0.2);
    pixb2 = pixThresholdToBinary(pixg2, 130);

        
    dew2 = dewarpCreate(pixb2, 7);
    dewarpaInsertDewarp(dewa, dew2);
    dewarpaInsertRefModels(dewa, 0, 1);
    dewarpaInfo(stderr, dewa);
    dewarpaApplyDisparity(dewa, 7, pixg2, 200, 0, 0, &pixd2,
                          ""/tmp/lept/model/dewarp_apply2.pdf"");
    dewarpaDestroy(&dewa);

        
    pixWrite(""/tmp/lept/dewtest/017.jpg"", pixs2, IFF_JFIF_JPEG);
    pixWrite(""/tmp/lept/dewtest/018.jpg"", pixg2, IFF_JFIF_JPEG);
    pixWrite(""/tmp/lept/dewtest/019.png"", pixb2, IFF_TIFF_G4);
    pixWrite(""/tmp/lept/dewtest/020.jpg"", pixd2, IFF_JFIF_JPEG);
    pixt1 = pixRead(""/tmp/lept/dewmod/0060.png"");
    pixWrite(""/tmp/lept/dewtest/021.png"", pixt1, IFF_PNG);
    pixDestroy(&pixt1);
    pixt1 = pixRead(""/tmp/lept/dewapply/002.png"");
    pixWrite(""/tmp/lept/dewtest/022.png"", pixt1, IFF_PNG);
    pixt2 = pixThresholdToBinary(pixt1, 130);
    pixWrite(""/tmp/lept/dewtest/023.png"", pixt2, IFF_TIFF_G4);
    pixDestroy(&pixt1);
    pixDestroy(&pixt2);
    pixt1 = pixRead(""/tmp/lept/dewmod/0070.png"");
    pixWrite(""/tmp/lept/dewtest/024.png"", pixt1, IFF_PNG);
    pixDestroy(&pixt1);
    pixt1 = pixRead(""/tmp/lept/dewapply/003.png"");
    pixWrite(""/tmp/lept/dewtest/025.png"", pixt1, IFF_PNG);
    pixt2 = pixThresholdToBinary(pixt1, 130);
    pixWrite(""/tmp/lept/dewtest/026.png"", pixt2, IFF_TIFF_G4);
    pixDestroy(&pixt1);
    pixDestroy(&pixt2);

        
    convertFilesToPdf(""/tmp/lept/dewtest"", NULL, 135, 1.0, 0, 0, ""Dewarp Test"",
                      ""/tmp/lept/dewarptest1.pdf"");
    lept_stderr(""pdf file made: /tmp/lept/model/dewarptest1.pdf\n"");

    pixDestroy(&pixs);
    pixDestroy(&pixn);
    pixDestroy(&pixg);
    pixDestroy(&pixb);
    pixDestroy(&pixd);
    pixDestroy(&pixs2);
    pixDestroy(&pixn2);
    pixDestroy(&pixg2);
    pixDestroy(&pixb2);
    pixDestroy(&pixd2);
    return 0;
}
","1. PIX        *pixs, *pixn, *pixg, *pixb, *pixd, *pixt1, *pixt2;
2. pixn = pixBackgroundNormSimple(pixs, NULL, NULL);
3. dewa = dewarpaCreate(2, 30, 1, 10, 30);
4. pixWrite(""/tmp/lept/dewtest/002.jpg"", pixn, IFF_JFIF_JPEG);
5. pixWrite(""/tmp/lept/dewtest/004.png"", pixb, IFF_TIFF_G4);
pixWrite(""/tmp/lept/dewtest/005.jpg"", pixd, IFF_JFIF_JPEG);
6. pixt1 = pixRead(""/tmp/lept/dewmod/0060.png"");
7. pixWrite(""/tmp/lept/dewtest/016.png"", pixt1, IFF_PNG);
8. pixn2 = pixBackgroundNormSimple(pixs2, NULL, NULL);
9. dew2 = dewarpCreate(pixb2, 7);
10. pixWrite(""/tmp/lept/dewtest/019.png"", pixb2, IFF_TIFF_G4);
11. pixt1 = pixRead(""/tmp/lept/dewapply/002.png"");
12. pixDestroy(&pixt2);
13. pixt1 = pixRead(""/tmp/lept/dewapply/003.png"");
14. pixWrite(""/tmp/lept/dewtest/026.png"", pixt2, IFF_TIFF_G4);
15. pixDestroy(&pixg2);","6
19
24
36
38-39
46
71
79
84
95
100
105
109
112
128","CWE-20,CWE-200,CWE-787,CWE-125,CWE-17"
gmm_state_authentication-173704791293822,"void gmm_state_authentication(ogs_fsm_t *s, amf_event_t *e)
{
    int r, rv;
    ogs_nas_5gmm_cause_t gmm_cause;

    amf_ue_t *amf_ue = NULL;
    amf_sess_t *sess = NULL;

    ogs_nas_5gs_message_t *nas_message = NULL;
    ogs_nas_security_header_type_t h;

    ogs_nas_5gs_authentication_failure_t *authentication_failure = NULL;
    ogs_nas_authentication_failure_parameter_t
        *authentication_failure_parameter = NULL;

    ogs_sbi_message_t *sbi_message = NULL;

    ogs_assert(s);
    ogs_assert(e);

    amf_sm_debug(e);

    if (e->sess) {
        sess = e->sess;
        amf_ue = sess->amf_ue;
        ogs_assert(amf_ue);
    } else {
        amf_ue = e->amf_ue;
        ogs_assert(amf_ue);
    }

    switch (e->h.id) {
    case OGS_FSM_ENTRY_SIG:
        break;
    case OGS_FSM_EXIT_SIG:
        break;
    case AMF_EVENT_5GMM_MESSAGE:
        nas_message = e->nas.message;
        ogs_assert(nas_message);

        h.type = e->nas.type;

        switch (nas_message->gmm.h.message_type) {
        case OGS_NAS_5GS_AUTHENTICATION_RESPONSE:
            rv = gmm_handle_authentication_response(
                    amf_ue, &nas_message->gmm.authentication_response);

            if (rv != OGS_OK) {
                r = nas_5gs_send_authentication_reject(amf_ue);
                ogs_expect(r == OGS_OK);
                ogs_assert(r != OGS_ERROR);
                OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);
            }
            break;

        case OGS_NAS_5GS_AUTHENTICATION_FAILURE:
            authentication_failure = &nas_message->gmm.authentication_failure;
            ogs_assert(authentication_failure);
            authentication_failure_parameter = &authentication_failure->
                authentication_failure_parameter;
            ogs_assert(authentication_failure_parameter);

            ogs_debug(""[%s] Authentication failure [%d]"", amf_ue->suci,
                    authentication_failure->gmm_cause);

            amf_metrics_inst_by_cause_add(authentication_failure->gmm_cause,
                    AMF_METR_CTR_AMF_AUTH_FAIL, 1);

            CLEAR_AMF_UE_TIMER(amf_ue->t3560);

            switch (authentication_failure->gmm_cause) {
            case OGS_5GMM_CAUSE_MAC_FAILURE:
                ogs_warn(""Authentication failure(MAC failure)"");
                break;

            case OGS_5GMM_CAUSE_NON_5G_AUTHENTICATION_UNACCEPTABLE:
                ogs_error(""Authentication failure""
                        ""(Non-5GS authentication unacceptable)"");
                break;

            case OGS_5GMM_CAUSE_NGKSI_ALREADY_IN_USE:
                ogs_warn(""Authentication failure(ngKSI already in use)"");
                r = amf_ue_sbi_discover_and_send(
                        OGS_SBI_SERVICE_TYPE_NAUSF_AUTH, NULL,
                        amf_nausf_auth_build_authenticate,
                        amf_ue, 0, NULL);
                ogs_expect(r == OGS_OK);
                ogs_assert(r != OGS_ERROR);
                return;

            case OGS_5GMM_CAUSE_SYNCH_FAILURE:
                ogs_warn(""Authentication failure(Synch failure)"");
                if (authentication_failure_parameter->length != OGS_AUTS_LEN) {
                    ogs_error(""Invalid AUTS Length [%d]"",
                            authentication_failure_parameter->length);
                    break;
                }
                r = amf_ue_sbi_discover_and_send(
                        OGS_SBI_SERVICE_TYPE_NAUSF_AUTH, NULL,
                        amf_nausf_auth_build_authenticate,
                        amf_ue, 0, authentication_failure_parameter->auts);
                ogs_expect(r == OGS_OK);
                ogs_assert(r != OGS_ERROR);
                return;

            default:
                ogs_error(""Unknown GMM_CAUSE{%d] in Authentication""
                        "" failure"",
                        authentication_failure->gmm_cause);
                break;
            }

            r = nas_5gs_send_authentication_reject(amf_ue);
            ogs_expect(r == OGS_OK);
            ogs_assert(r != OGS_ERROR);
            OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);

            break;
        case OGS_NAS_5GS_REGISTRATION_REQUEST:
            ogs_warn(""Registration request"");
            gmm_cause = gmm_handle_registration_request(
                    amf_ue, h, e->ngap.code,
                    &nas_message->gmm.registration_request);
            if (gmm_cause != OGS_5GMM_CAUSE_REQUEST_ACCEPTED) {
                ogs_error(""[%s] gmm_handle_registration_request() failed [%d]"",
                            amf_ue->suci, gmm_cause);
                r = nas_5gs_send_registration_reject(amf_ue, gmm_cause);
                ogs_expect(r == OGS_OK);
                ogs_assert(r != OGS_ERROR);
                OGS_FSM_TRAN(s, gmm_state_exception);
                break;
            }

            r = amf_ue_sbi_discover_and_send(
                    OGS_SBI_SERVICE_TYPE_NAUSF_AUTH, NULL,
                    amf_nausf_auth_build_authenticate, amf_ue, 0, NULL);
            ogs_expect(r == OGS_OK);
            ogs_assert(r != OGS_ERROR);
            break;

        case OGS_NAS_5GS_5GMM_STATUS:
            ogs_warn(""[%s] 5GMM STATUS : Cause[%d]"",
                    amf_ue->suci, nas_message->gmm.gmm_status.gmm_cause);
            OGS_FSM_TRAN(s, &gmm_state_exception);
            break;

        case OGS_NAS_5GS_DEREGISTRATION_REQUEST_FROM_UE:
            ogs_warn(""[%s] Deregistration request"", amf_ue->supi);

            gmm_handle_deregistration_request(
                    amf_ue, &nas_message->gmm.deregistration_request_from_ue);
            OGS_FSM_TRAN(s, &gmm_state_de_registered);
            break;

        default:
            ogs_error(""Unknown message[%d]"", nas_message->gmm.h.message_type);
            break;
        }
        break;
    case AMF_EVENT_5GMM_TIMER:
        switch (e->h.timer_id) {
        case AMF_TIMER_T3560:
            if (amf_ue->t3560.retry_count >=
                    amf_timer_cfg(AMF_TIMER_T3560)->max_count) {
                ogs_warn(""[%s] Retransmission failed. Stop retransmission"",
                        amf_ue->suci);
                r = nas_5gs_send_authentication_reject(amf_ue);
                ogs_expect(r == OGS_OK);
                ogs_assert(r != OGS_ERROR);
                OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);
            } else {
                amf_ue->t3560.retry_count++;
                r = nas_5gs_send_authentication_request(amf_ue);
                ogs_expect(r == OGS_OK);
                ogs_assert(r != OGS_ERROR);
            }
            break;
        default:
            ogs_error(""[%s] Unknown timer[%s:%d]"", amf_ue->suci,
                    amf_timer_get_name(e->h.timer_id), e->h.timer_id);
            break;
        }
        break;
    case OGS_EVENT_SBI_CLIENT:
        sbi_message = e->h.sbi.message;
        ogs_assert(sbi_message);

        SWITCH(sbi_message->h.service.name)
        CASE(OGS_SBI_SERVICE_NAME_NAUSF_AUTH)
            SWITCH(sbi_message->h.resource.component[0])
            CASE(OGS_SBI_RESOURCE_NAME_UE_AUTHENTICATIONS)

                if (sbi_message->res_status != OGS_SBI_HTTP_STATUS_CREATED &&
                    sbi_message->res_status != OGS_SBI_HTTP_STATUS_OK) {
                    if (sbi_message->res_status ==
                            OGS_SBI_HTTP_STATUS_NOT_FOUND) {
                        ogs_warn(""[%s] Cannot find SUCI [%d]"",
                            amf_ue->suci, sbi_message->res_status);
                    } else {
                        ogs_error(""[%s] HTTP response error [%d]"",
                            amf_ue->suci, sbi_message->res_status);
                    }
                    r = nas_5gs_send_gmm_reject_from_sbi(
                            amf_ue, sbi_message->res_status);
                    ogs_expect(r == OGS_OK);
                    ogs_assert(r != OGS_ERROR);
                    OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);
                    break;
                }

                SWITCH(sbi_message->h.method)
                CASE(OGS_SBI_HTTP_METHOD_POST)
                    rv = amf_nausf_auth_handle_authenticate(
                            amf_ue, sbi_message);
                    if (rv != OGS_OK) {
                        ogs_error(""[%s] Cannot handle SBI message"",
                                amf_ue->suci);
                        r = nas_5gs_send_authentication_reject(amf_ue);
                        ogs_expect(r == OGS_OK);
                        ogs_assert(r != OGS_ERROR);
                        OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);
                    }
                    break;
                CASE(OGS_SBI_HTTP_METHOD_PUT)
                    rv = amf_nausf_auth_handle_authenticate_confirmation(
                            amf_ue, sbi_message);
                    if (rv != OGS_OK) {
                        ogs_error(""[%s] Cannot handle SBI message"",
                                amf_ue->suci);
                        r = nas_5gs_send_authentication_reject(amf_ue);
                        ogs_expect(r == OGS_OK);
                        ogs_assert(r != OGS_ERROR);
                        OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);
                    } else {
                        OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_security_mode);
                    }
                    break;
                DEFAULT
                    ogs_error(""[%s] Invalid HTTP method [%s]"",
                            amf_ue->suci, sbi_message->h.method);
                    ogs_assert_if_reached();
                END
                break;

            DEFAULT
                ogs_error(""Invalid resource name [%s]"",
                        sbi_message->h.resource.component[0]);
                ogs_assert_if_reached();
            END
            break;

        CASE(OGS_SBI_SERVICE_NAME_NUDM_UECM)
            if (sbi_message->res_status != OGS_SBI_HTTP_STATUS_CREATED &&
                sbi_message->res_status != OGS_SBI_HTTP_STATUS_NO_CONTENT &&
                sbi_message->res_status != OGS_SBI_HTTP_STATUS_OK) {
                ogs_error(""[%s] HTTP response error [%d]"",
                        amf_ue->supi, sbi_message->res_status);
            }

            SWITCH(sbi_message->h.resource.component[1])
            CASE(OGS_SBI_RESOURCE_NAME_REGISTRATIONS)
                SWITCH(sbi_message->h.method)
                CASE(OGS_SBI_HTTP_METHOD_PUT)
                    
                    ogs_error(""[%s] Ignore SBI message"", amf_ue->supi);
                    break;
                DEFAULT
                    ogs_error(""[%s] Invalid HTTP method [%s]"",
                            amf_ue->suci, sbi_message->h.method);
                    ogs_assert_if_reached();
                END
                break;

            DEFAULT
                ogs_error(""Invalid resource name [%s]"",
                        sbi_message->h.resource.component[1]);
                ogs_assert_if_reached();
            END
            break;

        DEFAULT
            ogs_error(""Invalid service name [%s]"", sbi_message->h.service.name);
            ogs_assert_if_reached();
        END
        break;

    default:
        ogs_error(""Unknown event[%s]"", amf_event_get_name(e));
        break;
    }
}
","1. ogs_expect(r == OGS_OK);
2. ogs_expect(r == OGS_OK);
3. SWITCH(sbi_message->h.resource.component[0])
4. if (sbi_message->res_status != OGS_SBI_HTTP_STATUS_CREATED &&
5. OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_exception);
6. OGS_FSM_TRAN(&amf_ue->sm, &gmm_state_security_mode);
7. DEFAULT
8. ogs_error(""[%s] Ignore SBI message"", amf_ue->supi);","50
137
190
193
207
235
238
269","CWE-200,CWE-20,CWE-125"
main_70-175119447431513,"int main_70(int argc, char * argv[]) {
    int mode = MODE_ENCODE;

    
    char *input = NULL, *output = NULL;
    char *f1 = NULL, *f2 = NULL;
    int force = 0;

    
    int force_stdstreams = 0, workers = 0, batch = 0, verbose = 0;

    
    u32 block_size = MiB(16);

#ifdef PTHREAD
    const char * short_options = ""Bb:cdefhj:ktvVz"";
#else
    const char * short_options = ""Bb:cdefhktvVz"";
#endif

    static struct option long_options[] = { { ""encode"", no_argument, 0, 'e' },
                                            { ""decode"", no_argument, 0, 'd' },
                                            { ""test"", no_argument, 0, 't' },
                                            { ""stdout"", no_argument, 0, 'c' },
                                            { ""force"", no_argument, 0, 'f' },
                                            { ""help"", no_argument, 0, 'h' },
                                            { ""keep"", no_argument, 0, 'k' },
                                            { ""version"", no_argument, 0, 'V' },
                                            { ""verbose"", no_argument, 0, 'v' },
                                            { ""block"", required_argument, 0, 'b' },
                                            { ""batch"", no_argument, 0, 'B' },
#ifdef PTHREAD
                                            { ""jobs"", required_argument, 0, 'j' },
#endif
                                            { 0, 0, 0, 0 } };

    while (1) {
        int option_index = 0;
        int c = getopt_long(argc, argv, short_options, long_options, &option_index);
        if (c == -1) break;

        switch (c) {
            case '?':
                fprintf(stderr, ""Try 'bzip3 --help' for more information.\n"");
                return 1;
            case 'e': case 'z':
                mode = MODE_ENCODE;
                break;
            case 'd':
                mode = MODE_DECODE;
                break;
            case 't':
                mode = MODE_TEST;
                break;
            case 'c':
                force_stdstreams = 1;
                break;
            case 'f':
                force = 1;
                break;
            case 'k':
                break;
            case 'h':
                help();
                return 0;
            case 'V':
                version();
                return 0;
            case 'B':
                batch = 1;
                break;
            case 'v':
                verbose = 1;
                break;
            case 'b':
                if (!is_numeric(optarg)) {
                    fprintf(stderr, ""bzip3: invalid block size: %s\n"", optarg);
                    return 1;
                }
                block_size = MiB(atoi(optarg));
                break;
#ifdef PTHREAD
            case 'j':
                if (!is_numeric(optarg)) {
                    fprintf(stderr, ""bzip3: invalid amount of jobs: %s\n"", optarg);
                    return 1;
                }
                workers = atoi(optarg);
                break;
#endif
        }
    }

#if defined(__MSVCRT__)
    setmode(STDIN_FILENO, O_BINARY);
    setmode(STDOUT_FILENO, O_BINARY);
#endif

    if (block_size < KiB(65) || block_size > MiB(511)) {
        fprintf(stderr, ""Block size must be between 65 KiB and 511 MiB.\n"");
        return 1;
    }

    if (batch) {
        switch (mode) {
            case MODE_ENCODE:
                
                while (optind < argc) {
                    char * arg = argv[optind++];

                    FILE * input_des = open_input(arg);
                    char * output_name;
                    if (force_stdstreams)
                        output_name = NULL;
                    else {
                        output_name = malloc(strlen(arg) + 5);
                        strcpy(output_name, arg);
                        strcat(output_name, "".bz3"");
                    }

                    FILE * output_des = open_output(output_name, force);
                    process(input_des, output_des, mode, block_size, workers, verbose, arg);

                    fclose(input_des);
                    close_out_file(output_des);
                    if (!force_stdstreams) free(output_name);
                }
                break;
            case MODE_DECODE:
                
                while (optind < argc) {
                    char * arg = argv[optind++];

                    FILE * input_des = open_input(arg);
                    char * output_name;
                    if (force_stdstreams)
                        output_name = NULL;
                    else {
                        output_name = malloc(strlen(arg) + 1);
                        strcpy(output_name, arg);
                        if (strlen(output_name) > 4 && !strcmp(output_name + strlen(output_name) - 4, "".bz3""))
                            output_name[strlen(output_name) - 4] = 0;
                        else {
                            fprintf(stderr, ""Warning: file %s has an unknown extension, skipping.\n"", arg);
                            return 1;
                        }
                    }

                    FILE * output_des = open_output(output_name, force);
                    process(input_des, output_des, mode, block_size, workers, verbose, arg);

                    fclose(input_des);
                    close_out_file(output_des);
                    if (!force_stdstreams) free(output_name);
                }
                break;
            case MODE_TEST:
                
                while (optind < argc) {
                    char * arg = argv[optind++];

                    FILE * input_des = open_input(arg);
                    process(input_des, NULL, mode, block_size, workers, verbose, arg);
                    fclose(input_des);
                }
                break;
        }

        if (fclose(stdout)) {
            fprintf(stderr, ""Error: Failed on fclose(stdout): %s\n"", strerror(errno));
            return 1;
        }

        return 0;
    }

    while (optind < argc) {
        
        char * arg = argv[optind++];

        if (f1 != NULL && f2 != NULL) {
            fprintf(stderr, ""Error: too many files specified.\n"");
            return 1;
        }

        if (f1 == NULL)
            f1 = arg;
        else
            f2 = arg;
    }

    if (f1 == NULL && f2 == NULL)
        input = NULL, output = NULL;
    else if (mode == MODE_TEST)
        input = f1;
    else {
        if (mode == MODE_ENCODE) {
            if (f2 == NULL) {
                
                input = f1;
                if (force_stdstreams)
                    output = NULL;
                else {
                    output = malloc(strlen(f1) + 5);
                    strcpy(output, f1);
                    strcat(output, "".bz3"");
                }
            } else {
                
                input = f1;
                output = f2;
            }
        } else if (mode == MODE_DECODE) {
            if (f2 == NULL) {
                
                input = f1;
                if (force_stdstreams)
                    output = NULL;
                else {
                    output = malloc(strlen(f1) + 1);
                    strcpy(output, f1);
                    if (strlen(output) > 4 && !strcmp(output + strlen(output) - 4, "".bz3""))
                        output[strlen(output) - 4] = 0;
                    else {
                        fprintf(stderr, ""Warning: file %s has an unknown extension, skipping.\n"", f1);
                        return 1;
                    }
                }
            } else {
                
                input = f1;
                output = f2;
            }
        }
    }

    FILE *input_des = NULL, *output_des = NULL;

    output_des = mode != MODE_TEST ? open_output(output, force) : NULL;
    input_des = open_input(input);

    if(output != f2)
        free(output);

    int r = process(input_des, output_des, mode, block_size, workers, verbose, input);

    fclose(input_des);
    close_out_file(output_des);
    if (fclose(stdout)) {
        fprintf(stderr, ""Error: Failed on fclose(stdout): %s\n"", strerror(errno));
        return 1;
    }

    return r;
}
","1. int force = 0;
2. { ""keep"", no_argument, 0, 'k' },
3. { ""block"", required_argument, 0, 'b' },
4. case 'e': case 'z':
5. break;
6. return 0;
7. return 1;
8. break;
9. fprintf(stderr, ""Block size must be between 65 KiB and 511 MiB.\n"");
10. char * arg = argv[optind++];
11. case MODE_DECODE:
12. else {
13. if (f2 == NULL) {
14. input = f1;
15. else {
16. return r;","7
27
30
46
57
68
78
81
100
109
129
196
198
216
219
254","CWE-200,CWE-20,CWE-399,CWE-416"
netlink_recvmsg,"static int netlink_recvmsg(struct kiocb *kiocb, struct socket *sock,
			   struct msghdr *msg, size_t len,
			   int flags)
{
	struct sock_iocb *siocb = kiocb_to_siocb(kiocb);
	struct scm_cookie scm;
	struct sock *sk = sock->sk;
	struct netlink_sock *nlk = nlk_sk(sk);
	int noblock = flags&MSG_DONTWAIT;
	size_t copied;
	struct sk_buff *skb, *data_skb;
	int err, ret;

	if (flags&MSG_OOB)
		return -EOPNOTSUPP;

	copied = 0;

	skb = skb_recv_datagram(sk, flags, noblock, &err);
	if (skb == NULL)
		goto out;

	data_skb = skb;

#ifdef CONFIG_COMPAT_NETLINK_MESSAGES
	if (unlikely(skb_shinfo(skb)->frag_list)) {
		
		if (flags & MSG_CMSG_COMPAT)
			data_skb = skb_shinfo(skb)->frag_list;
 	}
 #endif
 
 	copied = data_skb->len;
 	if (len < copied) {
 		msg->msg_flags |= MSG_TRUNC;
		copied = len;
	}

	skb_reset_transport_header(data_skb);
	err = skb_copy_datagram_iovec(data_skb, 0, msg->msg_iov, copied);

	if (msg->msg_name) {
		struct sockaddr_nl *addr = (struct sockaddr_nl *)msg->msg_name;
		addr->nl_family = AF_NETLINK;
		addr->nl_pad    = 0;
		addr->nl_pid	= NETLINK_CB(skb).portid;
		addr->nl_groups	= netlink_group_mask(NETLINK_CB(skb).dst_group);
		msg->msg_namelen = sizeof(*addr);
	}

	if (nlk->flags & NETLINK_RECV_PKTINFO)
		netlink_cmsg_recv_pktinfo(msg, skb);

	if (NULL == siocb->scm) {
		memset(&scm, 0, sizeof(scm));
		siocb->scm = &scm;
	}
	siocb->scm->creds = *NETLINK_CREDS(skb);
	if (flags & MSG_TRUNC)
		copied = data_skb->len;

	skb_free_datagram(sk, skb);

	if (nlk->cb_running &&
	    atomic_read(&sk->sk_rmem_alloc) <= sk->sk_rcvbuf / 2) {
		ret = netlink_dump(sk);
		if (ret) {
			sk->sk_err = ret;
			sk->sk_error_report(sk);
		}
	}

	scm_recv(sock, msg, siocb->scm, flags);
out:
	netlink_rcv_wake(sk);
	return err ? : copied;
}
","1. int err, ret;
2. goto out;
3. err = skb_copy_datagram_iovec(data_skb, 0, msg->msg_iov, copied);
4. msg->msg_namelen = sizeof(*addr);
5. skb_free_datagram(sk, skb);","12
21
49
57
71","CWE-200,CWE-190,CWE-20,CWE-400"
config_delete-157707476381662,"void
config_delete(struct config_file* cfg)
{
	if(!cfg) return;
	free(cfg->username);
	free(cfg->chrootdir);
	free(cfg->directory);
	free(cfg->logfile);
	free(cfg->pidfile);
	free(cfg->if_automatic_ports);
	free(cfg->target_fetch_policy);
	free(cfg->ssl_service_key);
	free(cfg->ssl_service_pem);
	free(cfg->tls_cert_bundle);
	config_delstrlist(cfg->tls_additional_port);
	config_delstrlist(cfg->tls_session_ticket_keys.first);
	free(cfg->tls_ciphers);
	free(cfg->tls_ciphersuites);
	free(cfg->http_endpoint);
	if(cfg->log_identity) {
		log_ident_revert_to_default();
		free(cfg->log_identity);
	}
	config_del_strarray(cfg->ifs, cfg->num_ifs);
	config_del_strarray(cfg->out_ifs, cfg->num_out_ifs);
	config_delstubs(cfg->stubs);
	config_delstubs(cfg->forwards);
	config_delauths(cfg->auths);
	config_delviews(cfg->views);
	config_delstrlist(cfg->donotqueryaddrs);
	config_delstrlist(cfg->root_hints);
#ifdef CLIENT_SUBNET
	config_delstrlist(cfg->client_subnet);
	config_delstrlist(cfg->client_subnet_zone);
#endif
	free(cfg->identity);
	free(cfg->version);
	free(cfg->http_user_agent);
	free(cfg->nsid_cfg_str);
	free(cfg->nsid);
	free(cfg->module_conf);
	free(cfg->outgoing_avail_ports);
	config_delstrlist(cfg->caps_whitelist);
	config_delstrlist(cfg->private_address);
	config_delstrlist(cfg->private_domain);
	config_delstrlist(cfg->auto_trust_anchor_file_list);
	config_delstrlist(cfg->trust_anchor_file_list);
	config_delstrlist(cfg->trusted_keys_file_list);
	config_delstrlist(cfg->trust_anchor_list);
	config_delstrlist(cfg->domain_insecure);
	config_deldblstrlist(cfg->acls);
	config_deldblstrlist(cfg->tcp_connection_limits);
	free(cfg->val_nsec3_key_iterations);
	config_deldblstrlist(cfg->local_zones);
	config_delstrlist(cfg->local_zones_nodefault);
#ifdef USE_IPSET
	config_delstrlist(cfg->local_zones_ipset);
#endif
	config_delstrlist(cfg->local_data);
	config_deltrplstrlist(cfg->local_zone_overrides);
	config_del_strarray(cfg->tagname, cfg->num_tags);
	config_del_strbytelist(cfg->local_zone_tags);
	config_del_strbytelist(cfg->respip_tags);
	config_deldblstrlist(cfg->acl_view);
	config_del_strbytelist(cfg->acl_tags);
	config_deltrplstrlist(cfg->acl_tag_actions);
	config_deltrplstrlist(cfg->acl_tag_datas);
	config_deldblstrlist(cfg->interface_actions);
	config_deldblstrlist(cfg->interface_view);
	config_del_strbytelist(cfg->interface_tags);
	config_deltrplstrlist(cfg->interface_tag_actions);
	config_deltrplstrlist(cfg->interface_tag_datas);
	config_delstrlist(cfg->control_ifs.first);
	config_deldblstrlist(cfg->wait_limit_netblock);
	config_deldblstrlist(cfg->wait_limit_cookie_netblock);
	free(cfg->server_key_file);
	free(cfg->server_cert_file);
	free(cfg->control_key_file);
	free(cfg->control_cert_file);
	free(cfg->nat64_prefix);
	free(cfg->dns64_prefix);
	config_delstrlist(cfg->dns64_ignore_aaaa);
	free(cfg->dnstap_socket_path);
	free(cfg->dnstap_ip);
	free(cfg->dnstap_tls_server_name);
	free(cfg->dnstap_tls_cert_bundle);
	free(cfg->dnstap_tls_client_key_file);
	free(cfg->dnstap_tls_client_cert_file);
	free(cfg->dnstap_identity);
	free(cfg->dnstap_version);
	config_deldblstrlist(cfg->ratelimit_for_domain);
	config_deldblstrlist(cfg->ratelimit_below_domain);
	config_delstrlist(cfg->python_script);
	config_delstrlist(cfg->dynlib_file);
	config_deldblstrlist(cfg->edns_client_strings);
	config_delstrlist(cfg->proxy_protocol_port);
#ifdef USE_IPSECMOD
	free(cfg->ipsecmod_hook);
	config_delstrlist(cfg->ipsecmod_whitelist);
#endif
#ifdef USE_CACHEDB
	free(cfg->cachedb_backend);
	free(cfg->cachedb_secret);
#ifdef USE_REDIS
	free(cfg->redis_server_host);
	free(cfg->redis_server_path);
	free(cfg->redis_server_password);
#endif  
#endif  
#ifdef USE_IPSET
	free(cfg->ipset_name_v4);
	free(cfg->ipset_name_v6);
#endif
	free(cfg);
}
","1. free(cfg->http_endpoint);
2. free(cfg->http_user_agent);
3. free(cfg->module_conf);
4. config_deldblstrlist(cfg->acls);
5. config_deltrplstrlist(cfg->local_zone_overrides);
6. config_deldblstrlist(cfg->interface_view);
7. free(cfg->dnstap_tls_client_key_file);","19
38
41
51
60
69
87","CWE-78,CWE-264,CWE-416,CWE-119,CWE-125"
jsi_ArrayPopCmd-193003959558535,"
#define Jsi_Func
#define Jsi_Interp
#define Jsi_Value
#define _this

static Jsi_RC jsi_ArrayPopCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) {
        Jsi_ValueMakeNumber(interp, ret, 0);
        return JSI_OK;
    }
    Jsi_Value *v;
    Jsi_Obj *obj;
    obj = _this->d.obj;
    int i = jsi_SizeOfArray(interp, obj) - 1;

    if (i < 0) {
        Jsi_ValueMakeUndef(interp, ret);
        return JSI_OK;
    }
    
    if (obj->arr) {
        if ((v = obj->arr[i])) {
            obj->arr[i] = NULL;
            obj->arrCnt--;
        }
    } else {
        v = Jsi_ValueArrayIndex(interp, _this, i);
    }
    if (v) {
        Jsi_DecrRefCount(interp, *ret);
        *ret = v;
    }
    Jsi_ObjSetLength(interp, obj, i);
    return JSI_OK;
}
","1. if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) {
2. return JSI_OK;
3. Jsi_Obj *obj;
4. return JSI_OK;
5. *ret = v;
6. return JSI_OK;","10
12
15
21
34
37","CWE-732,CWE-125"
cypress_generic_port_probe,"static int cypress_generic_port_probe(struct usb_serial_port *port)
{
 	struct usb_serial *serial = port->serial;
 	struct cypress_private *priv;
 
	if (!port->interrupt_out_urb || !port->interrupt_in_urb) {
		dev_err(&port->dev, ""required endpoint is missing\n"");
		return -ENODEV;
	}

 	priv = kzalloc(sizeof(struct cypress_private), GFP_KERNEL);
 	if (!priv)
 		return -ENOMEM;

	priv->comm_is_ok = !0;
	spin_lock_init(&priv->lock);
	if (kfifo_alloc(&priv->write_fifo, CYPRESS_BUF_SIZE, GFP_KERNEL)) {
		kfree(priv);
		return -ENOMEM;
	}

	
	if (!is_frwd(serial->dev))
		usb_reset_configuration(serial->dev);

	priv->cmd_ctrl = 0;
	priv->line_control = 0;
	priv->termios_initialized = 0;
	priv->rx_flags = 0;
	
	if (port->interrupt_out_size > 9)
		priv->pkt_fmt = packet_format_1;
	else
		priv->pkt_fmt = packet_format_2;

	if (interval > 0) {
		priv->write_urb_interval = interval;
		priv->read_urb_interval = interval;
		dev_dbg(&port->dev, ""%s - read & write intervals forced to %d\n"",
			__func__, interval);
	} else {
		priv->write_urb_interval = port->interrupt_out_urb->interval;
		priv->read_urb_interval = port->interrupt_in_urb->interval;
		dev_dbg(&port->dev, ""%s - intervals: read=%d write=%d\n"",
			__func__, priv->read_urb_interval,
			priv->write_urb_interval);
	}
	usb_set_serial_port_data(port, priv);

	port->port.drain_delay = 256;

	return 0;
}
","1. return -ENODEV;
2. if (!priv)
3. spin_lock_init(&priv->lock);
4. kfree(priv);
5. priv->termios_initialized = 0;
6. if (interval > 0) {
priv->write_urb_interval = interval;
7. dev_dbg(&port->dev, ""%s - intervals: read=%d write=%d\n"",","8
12
16
18
30
43-44
51","CWE-476,CWE-310,CWE-134,CWE-416"
FindStartOffsetOfFileInZipFile,"int FindStartOffsetOfFileInZipFile(const char* zip_file, const char* filename) {
  FileDescriptor fd;
  if (!fd.OpenReadOnly(zip_file)) {
    LOG_ERRNO(""%s: open failed trying to open zip file %s\n"",
              __FUNCTION__, zip_file);
    return CRAZY_OFFSET_FAILED;
  }

  struct stat stat_buf;
  if (stat(zip_file, &stat_buf) == -1) {
    LOG_ERRNO(""%s: stat failed trying to stat zip file %s\n"",
              __FUNCTION__, zip_file);
    return CRAZY_OFFSET_FAILED;
  }

  if (stat_buf.st_size > kMaxZipFileLength) {
    LOG(""%s: The size %ld of %s is too large to map\n"",
        __FUNCTION__, stat_buf.st_size, zip_file);
    return CRAZY_OFFSET_FAILED;
  }

  void* mem = fd.Map(NULL, stat_buf.st_size, PROT_READ, MAP_PRIVATE, 0);
  if (mem == MAP_FAILED) {
    LOG_ERRNO(""%s: mmap failed trying to mmap zip file %s\n"",
              __FUNCTION__, zip_file);
    return CRAZY_OFFSET_FAILED;
  }
   ScopedMMap scoped_mmap(mem, stat_buf.st_size);
 
  
  
  
   uint8_t* mem_bytes = static_cast<uint8_t*>(mem);
  int off = stat_buf.st_size - kEndOfCentralDirectoryRecordSize;
  for (; off >= 0; --off) {
     if (ReadUInt32(mem_bytes, off) == kEndOfCentralDirectoryMarker) {
       break;
     }
  }
  if (off == -1) {
    LOG(""%s: Failed to find end of central directory in %s\n"",
        __FUNCTION__, zip_file);
    return CRAZY_OFFSET_FAILED;
  }


  uint32_t length_of_central_dir = ReadUInt32(
      mem_bytes, off + kOffsetOfCentralDirLengthInEndOfCentralDirectory);
  uint32_t start_of_central_dir = ReadUInt32(
      mem_bytes, off + kOffsetOfStartOfCentralDirInEndOfCentralDirectory);

  if (start_of_central_dir > off) {
    LOG(""%s: Found out of range offset %u for start of directory in %s\n"",
        __FUNCTION__, start_of_central_dir, zip_file);
    return CRAZY_OFFSET_FAILED;
  }

  uint32_t end_of_central_dir = start_of_central_dir + length_of_central_dir;
  if (end_of_central_dir > off) {
    LOG(""%s: Found out of range offset %u for end of directory in %s\n"",
        __FUNCTION__, end_of_central_dir, zip_file);
    return CRAZY_OFFSET_FAILED;
  }

  uint32_t num_entries = ReadUInt16(
      mem_bytes, off + kOffsetNumOfEntriesInEndOfCentralDirectory);

  off = start_of_central_dir;
  const int target_len = strlen(filename);
  int n = 0;
  for (; n < num_entries && off < end_of_central_dir; ++n) {
    uint32_t marker = ReadUInt32(mem_bytes, off);
    if (marker != kCentralDirHeaderMarker) {
      LOG(""%s: Failed to find central directory header marker in %s. ""
          ""Found 0x%x but expected 0x%x\n"", __FUNCTION__,
          zip_file, marker, kCentralDirHeaderMarker);
      return CRAZY_OFFSET_FAILED;
    }
    uint32_t file_name_length =
        ReadUInt16(mem_bytes, off + kOffsetFilenameLengthInCentralDirectory);
    uint32_t extra_field_length =
        ReadUInt16(mem_bytes, off + kOffsetExtraFieldLengthInCentralDirectory);
    uint32_t comment_field_length =
        ReadUInt16(mem_bytes, off + kOffsetCommentLengthInCentralDirectory);
    uint32_t header_length = kOffsetFilenameInCentralDirectory +
        file_name_length + extra_field_length + comment_field_length;

    uint32_t local_header_offset =
        ReadUInt32(mem_bytes, off + kOffsetLocalHeaderOffsetInCentralDirectory);

    uint8_t* filename_bytes =
        mem_bytes + off + kOffsetFilenameInCentralDirectory;

    if (file_name_length == target_len &&
        memcmp(filename_bytes, filename, target_len) == 0) {
      uint32_t marker = ReadUInt32(mem_bytes, local_header_offset);
      if (marker != kLocalHeaderMarker) {
        LOG(""%s: Failed to find local file header marker in %s. ""
            ""Found 0x%x but expected 0x%x\n"", __FUNCTION__,
            zip_file, marker, kLocalHeaderMarker);
        return CRAZY_OFFSET_FAILED;
      }

      uint32_t compression_method =
          ReadUInt16(
              mem_bytes,
              local_header_offset + kOffsetCompressionMethodInLocalHeader);
      if (compression_method != kCompressionMethodStored) {
        LOG(""%s: %s is compressed within %s. ""
            ""Found compression method %u but expected %u\n"", __FUNCTION__,
            filename, zip_file, compression_method, kCompressionMethodStored);
        return CRAZY_OFFSET_FAILED;
      }

      uint32_t file_name_length =
          ReadUInt16(
              mem_bytes,
              local_header_offset + kOffsetFilenameLengthInLocalHeader);
      uint32_t extra_field_length =
          ReadUInt16(
              mem_bytes,
              local_header_offset + kOffsetExtraFieldLengthInLocalHeader);
      uint32_t header_length =
          kOffsetFilenameInLocalHeader + file_name_length + extra_field_length;

      return local_header_offset + header_length;
    }

    off += header_length;
  }

  if (n < num_entries) {
    LOG(""%s: Did not find all the expected entries in the central directory. ""
        ""Found %d but expected %d\n"", __FUNCTION__, n, num_entries);
  }

  if (off < end_of_central_dir) {
    LOG(""%s: There are %d extra bytes at the end of the central directory.\n"",
        __FUNCTION__, end_of_central_dir - off);
  }

  LOG(""%s: Did not find %s in %s\n"", __FUNCTION__, filename, zip_file);
  return CRAZY_OFFSET_FAILED;
}
","1. if (!fd.OpenReadOnly(zip_file)) {
2. if (stat(zip_file, &stat_buf) == -1) {
3. LOG(""%s: Found out of range offset %u for start of directory in %s\n"",
4. int n = 0;
5. ""Found 0x%x but expected 0x%x\n"", __FUNCTION__,
6. memcmp(filename_bytes, filename, target_len) == 0) {
7. zip_file, marker, kLocalHeaderMarker);
8. filename, zip_file, compression_method, kCompressionMethodStored);
return CRAZY_OFFSET_FAILED;
9. ReadUInt16(
mem_bytes,
10. uint32_t header_length =
kOffsetFilenameInLocalHeader + file_name_length + extra_field_length;
11. __FUNCTION__, end_of_central_dir - off);","3
10
53
70
75
95
100
111-112
120-121
123-124
139","CWE-362,CWE-17,CWE-787"
ppp_hdlc_1-32694785727302,"static void
ppp_hdlc_1(netdissect_options *ndo,
         const u_char *p, u_int length)
{
	u_int caplen = ND_BYTES_AVAILABLE_AFTER(p);
	u_char *b, *t, c;
	const u_char *s;
	u_int i, proto;

	if (caplen == 0)
		return;

        if (length == 0)
                return;

	b = (u_char *)malloc(caplen);
	if (b == NULL) {
		(*ndo->ndo_error)(ndo, S_ERR_ND_MEM_ALLOC,
			""%s: malloc"", __func__);
	}

	
	for (s = p, t = b, i = caplen; i != 0; i--) {
		c = GET_U_1(s);
		s++;
		if (c == 0x7d) {
			if (i <= 1)
				break;
			i--;
			c = GET_U_1(s) ^ 0x20;
			s++;
		}
		*t++ = c;
	}

	
	if (!nd_push_buffer(ndo, b, b, (u_int)(t - b))) {
		free(b);
		(*ndo->ndo_error)(ndo, S_ERR_ND_MEM_ALLOC,
			""%s: can't push buffer on buffer stack"", __func__);
	}
	length = ND_BYTES_AVAILABLE_AFTER(b);

        
        if (length < 1)
                goto trunc;
        proto = GET_U_1(b); 

        switch (proto) {
        case PPP_IP:
		ip_print(ndo, b + 1, length - 1);
		goto cleanup;
        case PPP_IPV6:
		ip6_print(ndo, b + 1, length - 1);
		goto cleanup;
        default: 
		break;
        }

        if (length < 2)
                goto trunc;
        proto = GET_BE_U_2(b); 

        switch (proto) {
        case (PPP_ADDRESS << 8 | PPP_CONTROL): 
            if (length < 4)
                goto trunc;
            proto = GET_BE_U_2(b + 2); 
            if ((proto & 0xff00) == 0x7e00)
                ND_PRINT(""(protocol 0x%04x invalid)"", proto);
            else
                handle_ppp(ndo, proto, b + 4, length - 4);
            break;
        default: 
            if ((proto & 0xff00) == 0x7e00)
                ND_PRINT(""(protocol 0x%04x invalid)"", proto);
            else
                handle_ppp(ndo, proto, b + 2, length - 2);
            break;
        }

cleanup:
	nd_pop_packet_info(ndo);
        return;

trunc:
	nd_pop_packet_info(ndo);
	nd_print_trunc(ndo);
}
","1. const u_char *p, u_int length)
2. u_char *b, *t, c;
const u_char *s;
3. if (caplen == 0)
4. c = GET_U_1(s);
5. *t++ = c;
6. free(b);
7. if (length < 1)
8. proto = GET_BE_U_2(b + 2);
if ((proto & 0xff00) == 0x7e00)
9. return;
10. trunc:","3
6-7
10
28
37
46
53
76-77
92
94","CWE-835,CWE-200,CWE-1284,CWE-119"
ReadSGIImage,"
#define ExceptionInfo
#define ImageInfo

static Image *ReadSGIImage(const ImageInfo *image_info,ExceptionInfo *exception)
{
  Image
    *image;

  MagickBooleanType
    status;

  MagickSizeType
    number_pixels;

  MemoryInfo
    *pixel_info;

  register Quantum
    *q;

  register ssize_t
    i,
    x;

  register unsigned char
    *p;

  SGIInfo
    iris_info;

  size_t
    bytes_per_pixel,
    quantum;

  ssize_t
    count,
    y,
    z;

  unsigned char
    *pixels;

  
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  image=AcquireImage(image_info,exception);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  
  iris_info.magic=ReadBlobMSBShort(image);
  do
  {
    
    if (iris_info.magic != 0x01DA)
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    iris_info.storage=(unsigned char) ReadBlobByte(image);
    switch (iris_info.storage)
    {
      case 0x00: image->compression=NoCompression; break;
      case 0x01: image->compression=RLECompression; break;
      default:
        ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    }
    iris_info.bytes_per_pixel=(unsigned char) ReadBlobByte(image);
    if ((iris_info.bytes_per_pixel == 0) || (iris_info.bytes_per_pixel > 2))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
    iris_info.dimension=ReadBlobMSBShort(image);
    iris_info.columns=ReadBlobMSBShort(image);
    iris_info.rows=ReadBlobMSBShort(image);
    iris_info.depth=ReadBlobMSBShort(image);
    if ((iris_info.depth == 0) || (iris_info.depth > 4))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
     iris_info.minimum_value=ReadBlobMSBLong(image);
     iris_info.maximum_value=ReadBlobMSBLong(image);
     iris_info.sans=ReadBlobMSBLong(image);
    count=ReadBlob(image,sizeof(iris_info.name),(unsigned char *)
       iris_info.name);
    if (count != sizeof(iris_info.name))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
     iris_info.name[sizeof(iris_info.name)-1]='\0';
     if (*iris_info.name != '\0')
       (void) SetImageProperty(image,""label"",iris_info.name,exception);
     iris_info.pixel_format=ReadBlobMSBLong(image);
     if (iris_info.pixel_format != 0)
       ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
     count=ReadBlob(image,sizeof(iris_info.filler),iris_info.filler);
    if (count != sizeof(iris_info.filler))
      ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
     image->columns=iris_info.columns;
     image->rows=iris_info.rows;
     image->depth=(size_t) MagickMin(iris_info.depth,MAGICKCORE_QUANTUM_DEPTH);
    if (iris_info.pixel_format == 0)
      image->depth=(size_t) MagickMin((size_t) 8*iris_info.bytes_per_pixel,
        MAGICKCORE_QUANTUM_DEPTH);
    if (iris_info.depth < 3)
      {
         image->storage_class=PseudoClass;
         image->colors=iris_info.bytes_per_pixel > 1 ? 65535 : 256;
       }
    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))
       if (image->scene >= (image_info->scene+image_info->number_scenes-1))
         break;
     status=SetImageExtent(image,image->columns,image->rows,exception);
    if (status == MagickFalse)
      return(DestroyImageList(image));
    
    bytes_per_pixel=(size_t) iris_info.bytes_per_pixel;
    number_pixels=(MagickSizeType) iris_info.columns*iris_info.rows;
    if ((4*bytes_per_pixel*number_pixels) != ((MagickSizeType) (size_t)
        (4*bytes_per_pixel*number_pixels)))
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    pixel_info=AcquireVirtualMemory(iris_info.columns,iris_info.rows*4*
      bytes_per_pixel*sizeof(*pixels));
    if (pixel_info == (MemoryInfo *) NULL)
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
    if ((int) iris_info.storage != 0x01)
      {
        unsigned char
          *scanline;

        
        scanline=(unsigned char *) AcquireQuantumMemory(iris_info.columns,
          bytes_per_pixel*sizeof(*scanline));
        if (scanline == (unsigned char *) NULL)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        for (z=0; z < (ssize_t) iris_info.depth; z++)
        {
          p=pixels+bytes_per_pixel*z;
          for (y=0; y < (ssize_t) iris_info.rows; y++)
          {
            count=ReadBlob(image,bytes_per_pixel*iris_info.columns,scanline);
            if (EOFBlob(image) != MagickFalse)
              break;
            if (bytes_per_pixel == 2)
              for (x=0; x < (ssize_t) iris_info.columns; x++)
              {
                *p=scanline[2*x];
                *(p+1)=scanline[2*x+1];
                p+=8;
              }
            else
              for (x=0; x < (ssize_t) iris_info.columns; x++)
              {
                *p=scanline[x];
                p+=4;
              }
          }
        }
        scanline=(unsigned char *) RelinquishMagickMemory(scanline);
      }
    else
      {
        MemoryInfo
          *packet_info;

        size_t
          *runlength;

        ssize_t
          offset,
          *offsets;

        unsigned char
          *packets;

        unsigned int
          data_order;

        
        offsets=(ssize_t *) AcquireQuantumMemory((size_t) iris_info.rows,
          iris_info.depth*sizeof(*offsets));
        runlength=(size_t *) AcquireQuantumMemory(iris_info.rows,
          iris_info.depth*sizeof(*runlength));
        packet_info=AcquireVirtualMemory((size_t) iris_info.columns+10UL,4UL*
          sizeof(*packets));
        if ((offsets == (ssize_t *) NULL) ||
            (runlength == (size_t *) NULL) ||
            (packet_info == (MemoryInfo *) NULL))
          {
            if (offsets == (ssize_t *) NULL)
              offsets=(ssize_t *) RelinquishMagickMemory(offsets);
            if (runlength == (size_t *) NULL)
              runlength=(size_t *) RelinquishMagickMemory(runlength);
            if (packet_info == (MemoryInfo *) NULL)
              packet_info=RelinquishVirtualMemory(packet_info);
            ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
          }
        packets=(unsigned char *) GetVirtualMemoryBlob(packet_info);
        for (i=0; i < (ssize_t) (iris_info.rows*iris_info.depth); i++)
          offsets[i]=ReadBlobMSBSignedLong(image);
        for (i=0; i < (ssize_t) (iris_info.rows*iris_info.depth); i++)
        {
          runlength[i]=ReadBlobMSBLong(image);
          if (runlength[i] > (4*(size_t) iris_info.columns+10))
            ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
        }
        
        offset=0;
        data_order=0;
        for (y=0; ((y < (ssize_t) iris_info.rows) && (data_order == 0)); y++)
          for (z=0; ((z < (ssize_t) iris_info.depth) && (data_order == 0)); z++)
          {
            if (offsets[y+z*iris_info.rows] < offset)
              data_order=1;
            offset=offsets[y+z*iris_info.rows];
          }
        offset=(ssize_t) TellBlob(image);
        if (data_order == 1)
          {
            for (z=0; z < (ssize_t) iris_info.depth; z++)
            {
              p=pixels;
              for (y=0; y < (ssize_t) iris_info.rows; y++)
              {
                if (offset != offsets[y+z*iris_info.rows])
                  {
                    offset=offsets[y+z*iris_info.rows];
                    offset=(ssize_t) SeekBlob(image,(ssize_t) offset,SEEK_SET);
                  }
                count=ReadBlob(image,(size_t) runlength[y+z*iris_info.rows],
                  packets);
                if (EOFBlob(image) != MagickFalse)
                  break;
                offset+=(ssize_t) runlength[y+z*iris_info.rows];
                status=SGIDecode(bytes_per_pixel,(ssize_t)
                  (runlength[y+z*iris_info.rows]/bytes_per_pixel),packets,
                  1L*iris_info.columns,p+bytes_per_pixel*z);
                if (status == MagickFalse)
                  ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
                p+=(iris_info.columns*4*bytes_per_pixel);
              }
            }
          }
        else
          {
            MagickOffsetType
              position;
           
            position=TellBlob(image);
            p=pixels;
            for (y=0; y < (ssize_t) iris_info.rows; y++)
            {
              for (z=0; z < (ssize_t) iris_info.depth; z++)
              {
                if (offset != offsets[y+z*iris_info.rows])
                  {
                    offset=offsets[y+z*iris_info.rows];
                    offset=(ssize_t) SeekBlob(image,(ssize_t) offset,SEEK_SET);
                  }
                count=ReadBlob(image,(size_t) runlength[y+z*iris_info.rows],
                  packets);
                if (EOFBlob(image) != MagickFalse)
                  break;
                offset+=(ssize_t) runlength[y+z*iris_info.rows];
                status=SGIDecode(bytes_per_pixel,(ssize_t)
                  (runlength[y+z*iris_info.rows]/bytes_per_pixel),packets,
                  1L*iris_info.columns,p+bytes_per_pixel*z);
                if (status == MagickFalse)
                  ThrowReaderException(CorruptImageError,""ImproperImageHeader"");
              }
              p+=(iris_info.columns*4*bytes_per_pixel);
            }
            offset=(ssize_t) SeekBlob(image,position,SEEK_SET);
          }
        packet_info=RelinquishVirtualMemory(packet_info);
        runlength=(size_t *) RelinquishMagickMemory(runlength);
        offsets=(ssize_t *) RelinquishMagickMemory(offsets);
      }
    
    image->alpha_trait=iris_info.depth == 4 ? BlendPixelTrait : 
      UndefinedPixelTrait;
    image->columns=iris_info.columns;
    image->rows=iris_info.rows;
    
    if (image->storage_class == DirectClass)
      {
        
        if (bytes_per_pixel == 2)
          {
            for (y=0; y < (ssize_t) image->rows; y++)
            {
              p=pixels+(image->rows-y-1)*8*image->columns;
              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
              if (q == (Quantum *) NULL)
                break;
              for (x=0; x < (ssize_t) image->columns; x++)
              {
                SetPixelRed(image,ScaleShortToQuantum((unsigned short)
                  ((*(p+0) << 8) | (*(p+1)))),q);
                SetPixelGreen(image,ScaleShortToQuantum((unsigned short)
                  ((*(p+2) << 8) | (*(p+3)))),q);
                SetPixelBlue(image,ScaleShortToQuantum((unsigned short)
                  ((*(p+4) << 8) | (*(p+5)))),q);
                SetPixelAlpha(image,OpaqueAlpha,q);
                if (image->alpha_trait != UndefinedPixelTrait)
                  SetPixelAlpha(image,ScaleShortToQuantum((unsigned short)
                    ((*(p+6) << 8) | (*(p+7)))),q);
                p+=8;
                q+=GetPixelChannels(image);
              }
              if (SyncAuthenticPixels(image,exception) == MagickFalse)
                break;
              if (image->previous == (Image *) NULL)
                {
                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                    y,image->rows);
                  if (status == MagickFalse)
                    break;
                }
            }
          }
        else
          for (y=0; y < (ssize_t) image->rows; y++)
          {
            p=pixels+(image->rows-y-1)*4*image->columns;
            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
            if (q == (Quantum *) NULL)
              break;
            for (x=0; x < (ssize_t) image->columns; x++)
            {
              SetPixelRed(image,ScaleCharToQuantum(*p),q);
              SetPixelGreen(image,ScaleCharToQuantum(*(p+1)),q);
              SetPixelBlue(image,ScaleCharToQuantum(*(p+2)),q);
              SetPixelAlpha(image,OpaqueAlpha,q);
              if (image->alpha_trait != UndefinedPixelTrait)
                SetPixelAlpha(image,ScaleCharToQuantum(*(p+3)),q);
              p+=4;
              q+=GetPixelChannels(image);
            }
            if (SyncAuthenticPixels(image,exception) == MagickFalse)
              break;
            if (image->previous == (Image *) NULL)
              {
                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                  image->rows);
                if (status == MagickFalse)
                  break;
              }
          }
      }
    else
      {
        
        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)
          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
        
        if (bytes_per_pixel == 2)
          {
            for (y=0; y < (ssize_t) image->rows; y++)
            {
              p=pixels+(image->rows-y-1)*8*image->columns;
              q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
              if (q == (Quantum *) NULL)
                break;
              for (x=0; x < (ssize_t) image->columns; x++)
              {
                quantum=(*p << 8);
                quantum|=(*(p+1));
                SetPixelIndex(image,(Quantum) quantum,q);
                p+=8;
                q+=GetPixelChannels(image);
              }
              if (SyncAuthenticPixels(image,exception) == MagickFalse)
                break;
              if (image->previous == (Image *) NULL)
                {
                  status=SetImageProgress(image,LoadImageTag,(MagickOffsetType)
                    y,image->rows);
                  if (status == MagickFalse)
                    break;
                }
            }
          }
        else
          for (y=0; y < (ssize_t) image->rows; y++)
          {
            p=pixels+(image->rows-y-1)*4*image->columns;
            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);
            if (q == (Quantum *) NULL)
              break;
            for (x=0; x < (ssize_t) image->columns; x++)
            {
              SetPixelIndex(image,*p,q);
              p+=4;
              q+=GetPixelChannels(image);
            }
            if (SyncAuthenticPixels(image,exception) == MagickFalse)
              break;
            if (image->previous == (Image *) NULL)
              {
                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
                image->rows);
                if (status == MagickFalse)
                  break;
              }
          }
        (void) SyncImage(image,exception);
      }
    pixel_info=RelinquishVirtualMemory(pixel_info);
    if (EOFBlob(image) != MagickFalse)
      {
        ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
          image->filename);
        break;
      }
    
    if (image_info->number_scenes != 0)
      if (image->scene >= (image_info->scene+image_info->number_scenes-1))
        break;
    iris_info.magic=ReadBlobMSBShort(image);
    if (iris_info.magic == 0x01DA)
      {
        
        AcquireNextImage(image_info,image,exception);
        if (GetNextImageInList(image) == (Image *) NULL)
          {
            image=DestroyImageList(image);
            return((Image *) NULL);
          }
        image=SyncNextImageInList(image);
        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),
          GetBlobSize(image));
        if (status == MagickFalse)
          break;
      }
  } while (iris_info.magic == 0x01DA);
  (void) CloseBlob(image);
  return(GetFirstImageInList(image));
}
","1. *pixels;
2. image=DestroyImageList(image);
3. iris_info.dimension=ReadBlobMSBShort(image);
4. iris_info.name[sizeof(iris_info.name)-1]='\0';
5. image->colors=iris_info.bytes_per_pixel > 1 ? 65535 : 256;
6. for (x=0; x < (ssize_t) iris_info.columns; x++)
7. packets);
8. SetPixelRed(image,ScaleShortToQuantum((unsigned short)
9. if (image->alpha_trait != UndefinedPixelTrait)
10. if (image->alpha_trait != UndefinedPixelTrait)","42
58
83
96
114
163
276
319
326
356","CWE-835,CWE-190,CWE-119"
set_rmem_param-207041774241599,"static TEE_Result set_rmem_param(const struct optee_msg_param_rmem *rmem,
				 struct param_mem *mem)
{
	size_t req_size = 0;
	uint64_t shm_ref = READ_ONCE(rmem->shm_ref);

	mem->mobj = mobj_reg_shm_get_by_cookie(shm_ref);
	if (!mem->mobj)
		return TEE_ERROR_BAD_PARAMETERS;

	mem->offs = READ_ONCE(rmem->offs);
	mem->size = READ_ONCE(rmem->size);

	
	if (ADD_OVERFLOW(mem->offs, mem->size, &req_size) ||
	    mem->mobj->size < req_size)
		return TEE_ERROR_SECURITY;

	return TEE_SUCCESS;
}
","1. static TEE_Result set_rmem_param(const struct optee_msg_param_rmem *rmem,
struct param_mem *mem)
2. size_t req_size = 0;
uint64_t shm_ref = READ_ONCE(rmem->shm_ref);
3. if (!mem->mobj)
return TEE_ERROR_BAD_PARAMETERS;
4. mem->size = READ_ONCE(rmem->size);
5. if (ADD_OVERFLOW(mem->offs, mem->size, &req_size) ||
mem->mobj->size < req_size)
return TEE_ERROR_SECURITY;
6. return TEE_SUCCESS;","1-2
4-5
8-9
12
18-20
22","CWE-22,CWE-362,CWE-252,CWE-189,CWE-119"
cg_rmdir," static int cg_rmdir(const char *path)
 {
 	struct fuse_context *fc = fuse_get_context();
	char *fpath = NULL, *cgdir = NULL, *controller, *next = NULL;
 	const char *cgroup;
 	int ret;
 
	if (!fc)
		return -EIO;

	controller = pick_controller_from_path(fc, path);
	if (!controller)
		return -EINVAL;

	cgroup = find_cgroup_in_path(path);
	if (!cgroup)
		return -EINVAL;

	get_cgdir_and_path(cgroup, &cgdir, &fpath);
	if (!fpath) {
		ret = -EINVAL;
 		goto out;
 	}
 
	if (!caller_is_in_ancestor(fc->pid, controller, cgroup, &next)) {
		if (!fpath || strcmp(next, fpath) == 0)
			ret = -EBUSY;
		else
			ret = -ENOENT;
		goto out;
	}

 	if (!fc_may_access(fc, controller, cgdir, NULL, O_WRONLY)) {
 		ret = -EACCES;
 		goto out;
	}
	if (!caller_is_in_ancestor(fc->pid, controller, cgroup, NULL)) {
		ret = -EACCES;
		goto out;
	}

	if (!cgfs_remove(controller, cgroup)) {
		ret = -EINVAL;
		goto out;
	}

	ret = 0;
 
 out:
 	free(cgdir);
	free(next);
 	return ret;
 }
","1. const char *cgroup;
int ret;
2. if (!cgroup)
3. goto out;
4. ret = -EBUSY;
5. goto out;
6. if (!fc_may_access(fc, controller, cgdir, NULL, O_WRONLY)) {
ret = -EACCES;
7. ret = -EACCES;
8. ret = -EINVAL;
9. out:
10. free(next);","5-6
16
22
27
30
33-34
38
43
49
51","CWE-362,CWE-190,CWE-264"
ih264d_decode_gaps_in_frame_num,"
#define UWORD16

WORD32 ih264d_decode_gaps_in_frame_num(dec_struct_t *ps_dec,
                                       UWORD16 u2_frame_num)
{
    UWORD32 u4_next_frm_num, u4_start_frm_num;
    UWORD32 u4_max_frm_num;
 pocstruct_t s_tmp_poc;
    WORD32 i4_poc;
 dec_slice_params_t *ps_cur_slice;

 dec_pic_params_t *ps_pic_params;
    WORD8 i1_gap_idx;
    WORD32 *i4_gaps_start_frm_num;
 dpb_manager_t *ps_dpb_mgr;
    WORD32 i4_frame_gaps;
    WORD8 *pi1_gaps_per_seq;
    WORD32 ret;

    ps_cur_slice = ps_dec->ps_cur_slice;
 if(ps_cur_slice->u1_field_pic_flag)
 {
 if(ps_dec->u2_prev_ref_frame_num == u2_frame_num)
 return 0;
 }

    u4_next_frm_num = ps_dec->u2_prev_ref_frame_num + 1;
    u4_max_frm_num = ps_dec->ps_cur_sps->u2_u4_max_pic_num_minus1 + 1;

 if(u4_next_frm_num >= u4_max_frm_num)
 {
        u4_next_frm_num -= u4_max_frm_num;
 }

 if(u4_next_frm_num == u2_frame_num)
 {
 return (0);
 }

 if((ps_dec->u1_nal_unit_type == IDR_SLICE_NAL)
 && (u4_next_frm_num >= u2_frame_num))
 {
 return (0);
 }
    u4_start_frm_num = u4_next_frm_num;

    s_tmp_poc.i4_pic_order_cnt_lsb = 0;
    s_tmp_poc.i4_delta_pic_order_cnt_bottom = 0;
    s_tmp_poc.i4_pic_order_cnt_lsb = 0;
    s_tmp_poc.i4_delta_pic_order_cnt_bottom = 0;
    s_tmp_poc.i4_delta_pic_order_cnt[0] = 0;
    s_tmp_poc.i4_delta_pic_order_cnt[1] = 0;

 
     ps_cur_slice = ps_dec->ps_cur_slice;
     ps_pic_params = ps_dec->ps_cur_pps;
 
     i4_frame_gaps = 0;
     ps_dpb_mgr = ps_dec->ps_dpb_mgr;

 
    i4_gaps_start_frm_num = ps_dpb_mgr->ai4_gaps_start_frm_num;
 for(i1_gap_idx = 0; i1_gap_idx < MAX_FRAMES; i1_gap_idx++)
 {
 if(INVALID_FRAME_NUM == i4_gaps_start_frm_num[i1_gap_idx])
 break;
 }
 if(MAX_FRAMES == i1_gap_idx)
 {
        UWORD32 i4_error_code;
        i4_error_code = ERROR_DBP_MANAGER_T;
 return i4_error_code;
 }

    i4_poc = 0;
    i4_gaps_start_frm_num[i1_gap_idx] = u4_start_frm_num;
    ps_dpb_mgr->ai4_gaps_end_frm_num[i1_gap_idx] = u2_frame_num - 1;
    pi1_gaps_per_seq = ps_dpb_mgr->ai1_gaps_per_seq;
    pi1_gaps_per_seq[i1_gap_idx] = 0;
 while(u4_next_frm_num != u2_frame_num)
 {
        ih264d_delete_nonref_nondisplay_pics(ps_dpb_mgr);
 if(ps_pic_params->ps_sps->u1_pic_order_cnt_type)
 {
 
            ret = ih264d_decode_pic_order_cnt(0, u4_next_frm_num,
 &ps_dec->s_prev_pic_poc,
 &s_tmp_poc, ps_cur_slice,
                                              ps_pic_params, 1, 0, 0,
 &i4_poc);
 if(ret != OK)
 return ret;

 
 if(i4_poc >= ps_dec->i4_max_poc)
                ps_dec->i4_max_poc = i4_poc;
 
 if(i4_poc == 0)
 {
                ps_dec->i4_prev_max_display_seq =
                                ps_dec->i4_prev_max_display_seq
 + ps_dec->i4_max_poc
 + ps_dec->u1_max_dec_frame_buffering
 + 1;
                ps_dec->i4_max_poc = 0;
 }

            ps_cur_slice->u1_mmco_equalto5 = 0;
            ps_cur_slice->u2_frame_num = u4_next_frm_num;
 }

 if(ps_dpb_mgr->i1_poc_buf_id_entries
 >= ps_dec->u1_max_dec_frame_buffering)
 {
            ret = ih264d_assign_display_seq(ps_dec);
 if(ret != OK)
 return ret;
 }

        ret = ih264d_insert_pic_in_display_list(
                        ps_dec->ps_dpb_mgr, (WORD8) DO_NOT_DISP,
 (WORD32)(ps_dec->i4_prev_max_display_seq + i4_poc),
                        u4_next_frm_num);
 if(ret != OK)
 return ret;

        pi1_gaps_per_seq[i1_gap_idx]++;
        ret = ih264d_do_mmco_for_gaps(ps_dpb_mgr,
                                ps_dec->ps_cur_sps->u1_num_ref_frames);
 if(ret != OK)
 return ret;

        ih264d_delete_nonref_nondisplay_pics(ps_dpb_mgr);

        u4_next_frm_num++;
 if(u4_next_frm_num >= u4_max_frm_num)
 {
            u4_next_frm_num -= u4_max_frm_num;
 }

        i4_frame_gaps++;
 }

 return OK;
}
","1. if(MAX_FRAMES == i1_gap_idx)
2. i4_error_code = ERROR_DBP_MANAGER_T;
3. if(ps_dpb_mgr->i1_poc_buf_id_entries
4. return ret;","69
72
113
126","CWE-20,CWE-264,CWE-416,CWE-908,CWE-276"
l2cap_parse_conf_req,"static int l2cap_parse_conf_req(struct sock *sk, void *data)
{
	struct l2cap_pinfo *pi = l2cap_pi(sk);
	struct l2cap_conf_rsp *rsp = data;
	void *ptr = rsp->data;
	void *req = pi->conf_req;
	int len = pi->conf_len;
	int type, hint, olen;
	unsigned long val;
	struct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC };
	u16 mtu = L2CAP_DEFAULT_MTU;
	u16 result = L2CAP_CONF_SUCCESS;

	BT_DBG(""sk %p"", sk);

	while (len >= L2CAP_CONF_OPT_SIZE) {
		len -= l2cap_get_conf_opt(&req, &type, &olen, &val);

		hint  = type & L2CAP_CONF_HINT;
		type &= L2CAP_CONF_MASK;

		switch (type) {
		case L2CAP_CONF_MTU:
			mtu = val;
			break;

		case L2CAP_CONF_FLUSH_TO:
			pi->flush_to = val;
			break;

		case L2CAP_CONF_QOS:
			break;

		case L2CAP_CONF_RFC:
			if (olen == sizeof(rfc))
				memcpy(&rfc, (void *) val, olen);
			break;

		default:
			if (hint)
				break;

			result = L2CAP_CONF_UNKNOWN;
			*((u8 *) ptr++) = type;
			break;
 		}
 	}
 
	if (pi->num_conf_rsp || pi->num_conf_req)
		goto done;

	switch (pi->mode) {
	case L2CAP_MODE_STREAMING:
	case L2CAP_MODE_ERTM:
		pi->conf_state |= L2CAP_CONF_STATE2_DEVICE;
		if (!l2cap_mode_supported(pi->mode, pi->conn->feat_mask))
			return -ECONNREFUSED;
		break;
	default:
		pi->mode = l2cap_select_mode(rfc.mode, pi->conn->feat_mask);
		break;
	}

done:
	if (pi->mode != rfc.mode) {
		result = L2CAP_CONF_UNACCEPT;
		rfc.mode = pi->mode;

		if (pi->num_conf_rsp == 1)
			return -ECONNREFUSED;

		l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,
					sizeof(rfc), (unsigned long) &rfc);
	}


 	if (result == L2CAP_CONF_SUCCESS) {
 		
 
		if (mtu < L2CAP_DEFAULT_MIN_MTU)
			result = L2CAP_CONF_UNACCEPT;
		else {
			pi->omtu = mtu;
			pi->conf_state |= L2CAP_CONF_MTU_DONE;
		}
		l2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, pi->omtu);
 
		switch (rfc.mode) {
		case L2CAP_MODE_BASIC:
			pi->fcs = L2CAP_FCS_NONE;
			pi->conf_state |= L2CAP_CONF_MODE_DONE;
			break;

		case L2CAP_MODE_ERTM:
			pi->remote_tx_win = rfc.txwin_size;
			pi->remote_max_tx = rfc.max_transmit;
			pi->max_pdu_size = rfc.max_pdu_size;

			rfc.retrans_timeout = L2CAP_DEFAULT_RETRANS_TO;
			rfc.monitor_timeout = L2CAP_DEFAULT_MONITOR_TO;

			pi->conf_state |= L2CAP_CONF_MODE_DONE;
			break;

		case L2CAP_MODE_STREAMING:
			pi->remote_tx_win = rfc.txwin_size;
			pi->max_pdu_size = rfc.max_pdu_size;

			pi->conf_state |= L2CAP_CONF_MODE_DONE;
			break;

		default:
 			result = L2CAP_CONF_UNACCEPT;
 
 			memset(&rfc, 0, sizeof(rfc));
			rfc.mode = pi->mode;
		}
 
		l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,
 					sizeof(rfc), (unsigned long) &rfc);
 
		if (result == L2CAP_CONF_SUCCESS)
			pi->conf_state |= L2CAP_CONF_OUTPUT_DONE;
	}
 	rsp->scid   = cpu_to_le16(pi->dcid);
 	rsp->result = cpu_to_le16(result);
 	rsp->flags  = cpu_to_le16(0x0000);
 
 	return ptr - data;
 }
","1. struct l2cap_pinfo *pi = l2cap_pi(sk);
struct l2cap_conf_rsp *rsp = data;
void *ptr = rsp->data;
void *req = pi->conf_req;
2. u16 mtu = L2CAP_DEFAULT_MTU;
u16 result = L2CAP_CONF_SUCCESS;
3. type &= L2CAP_CONF_MASK;
4. mtu = val;
break;
5. pi->flush_to = val;
6. case L2CAP_CONF_QOS:
7. if (olen == sizeof(rfc))
memcpy(&rfc, (void *) val, olen);
break;
8. if (hint)
break;
9. *((u8 *) ptr++) = type;
10. if (pi->num_conf_rsp || pi->num_conf_req)
goto done;
11. switch (pi->mode) {
case L2CAP_MODE_STREAMING:
case L2CAP_MODE_ERTM:
12. if (!l2cap_mode_supported(pi->mode, pi->conn->feat_mask))
return -ECONNREFUSED;
break;
default:
13. break;
14. if (pi->num_conf_rsp == 1)
return -ECONNREFUSED;
15. sizeof(rfc), (unsigned long) &rfc);
16. if (result == L2CAP_CONF_SUCCESS) {
17. if (mtu < L2CAP_DEFAULT_MIN_MTU)
result = L2CAP_CONF_UNACCEPT;
18. pi->conf_state |= L2CAP_CONF_MTU_DONE;
19. l2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, pi->omtu);
20. case L2CAP_MODE_BASIC:
21. pi->conf_state |= L2CAP_CONF_MODE_DONE;
break;
22. case L2CAP_MODE_ERTM:
pi->remote_tx_win = rfc.txwin_size;
23. pi->max_pdu_size = rfc.max_pdu_size;
24. rfc.retrans_timeout = L2CAP_DEFAULT_RETRANS_TO;
rfc.monitor_timeout = L2CAP_DEFAULT_MONITOR_TO;
25. pi->remote_tx_win = rfc.txwin_size;
26. pi->conf_state |= L2CAP_CONF_MODE_DONE;
break;
27. result = L2CAP_CONF_UNACCEPT;
28. rfc.mode = pi->mode;
29. l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,
sizeof(rfc), (unsigned long) &rfc);
30. if (result == L2CAP_CONF_SUCCESS)
31. rsp->flags  = cpu_to_le16(0x0000);","3-6
11-12
20
24-25
28
31
35-37
40-41
44
49-50
52-54
56-59
61
69-70
73
77
81-82
85
87
90
92-93
95-96
98
100-101
107
110-111
114
117
120-121
123
128","CWE-17,CWE-787,CWE-125"
a2dp_command,"static int a2dp_command(struct a2dp_stream_common *common, char cmd)
{
 char ack;


     DEBUG(""A2DP COMMAND %s"", dump_a2dp_ctrl_event(cmd));
 
     
    if (TEMP_FAILURE_RETRY(send(common->ctrl_fd, &cmd, 1, MSG_NOSIGNAL)) == -1)
     {
         ERROR(""cmd failed (%s)"", strerror(errno));
         skt_disconnect(common->ctrl_fd);
        common->ctrl_fd = AUDIO_SKT_DISCONNECTED;
 return -1;
 }

 
 if (a2dp_ctrl_receive(common, &ack, 1) < 0)
 return -1;

    DEBUG(""A2DP COMMAND %s DONE STATUS %d"", dump_a2dp_ctrl_event(cmd), ack);

 if (ack == A2DP_CTRL_ACK_INCALL_FAILURE)
 return ack;
 if (ack != A2DP_CTRL_ACK_SUCCESS)
 return -1;

 return 0;
}
","1. char ack;
2. if (TEMP_FAILURE_RETRY(send(common->ctrl_fd, &cmd, 1, MSG_NOSIGNAL)) == -1)
3. ERROR(""cmd failed (%s)"", strerror(errno));
skt_disconnect(common->ctrl_fd);
common->ctrl_fd = AUDIO_SKT_DISCONNECTED;
return -1;
4. return -1;
5. DEBUG(""A2DP COMMAND %s DONE STATUS %d"", dump_a2dp_ctrl_event(cmd), ack);
6. return ack;","3
9
11-14
19
21
24","CWE-416,CWE-190,CWE-787,CWE-78"
SetUp_7,"   virtual void SetUp_7() {
    StartClient();

    registered_ids_.insert(kBookmarksId_);
    registered_ids_.insert(kPreferencesId_);
    client_.UpdateRegisteredIds(registered_ids_);
   }
","1. StartClient();
2. registered_ids_.insert(kPreferencesId_);","2
5","CWE-200,CWE-284,CWE-119"
find_callno_locked_7-16862460801679,"static int find_callno_locked_7(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {

	return __find_callno(callno, dcallno, sin, new, sockfd, 1, full_frame);
}
","1. static int find_callno_locked_7(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {
2. return __find_callno(callno, dcallno, sin, new, sockfd, 1, full_frame);","1
3",CWE-287
AES_decrypt-158052812421875,"int AES_decrypt(uint8_t *encr_message, uint64_t length, char *message, uint64_t msgLen) {

    if (!message) {
        LOG_ERROR(""Null message in AES_encrypt"");
        return -1;
    }

    if (!encr_message) {
        LOG_ERROR(""Null encr message in AES_encrypt"");
        return -2;
    }


  if (length < SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE) {
      LOG_ERROR(""length < SGX_AESGCM_MAC_SIZE - SGX_AESGCM_IV_SIZE"");
      return -1;
  }



  uint64_t len = length - SGX_AESGCM_MAC_SIZE - SGX_AESGCM_IV_SIZE;

  if (msgLen < len) {
        LOG_ERROR(""Output buffer not large enough"");
        return -2;
  }

  sgx_status_t status = sgx_rijndael128GCM_decrypt(&AES_key,
                                                   encr_message + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE, len,
                                                   (unsigned char*) message,
                                                   encr_message + SGX_AESGCM_MAC_SIZE, SGX_AESGCM_IV_SIZE,
                                                   NULL, 0,
                                                   (sgx_aes_gcm_128bit_tag_t *)encr_message);

  for (int i = 2; i < strlen(message) + 1; i++) {
      message[i - 2 ] = message[i];
  }

  return status;
}
","1. if (!message) {
2. if (!encr_message) {
3. if (msgLen < len) {","3
8
23","CWE-415,CWE-125,CWE-787,CWE-119"
php_handler,"static int php_handler(request_rec *r)
{
	php_struct * volatile ctx;
	void *conf;
	apr_bucket_brigade * volatile brigade;
	apr_bucket *bucket;
	apr_status_t rv;
	request_rec * volatile parent_req = NULL;
	TSRMLS_FETCH();

#define PHPAP_INI_OFF php_apache_ini_dtor(r, parent_req TSRMLS_CC);

	conf = ap_get_module_config(r->per_dir_config, &php5_module);

	
	ctx = SG(server_context);
	if (ctx == NULL || (ctx && ctx->request_processed && !strcmp(r->protocol, ""INCLUDED""))) {
normal:
		ctx = SG(server_context) = apr_pcalloc(r->pool, sizeof(*ctx));
		
		apr_pool_cleanup_register(r->pool, (void *)&SG(server_context), php_server_context_cleanup, apr_pool_cleanup_null);
		ctx->r = r;
		ctx = NULL; 
	} else {
		parent_req = ctx->r;
		ctx->r = r;
	}
	apply_config(conf);

	if (strcmp(r->handler, PHP_MAGIC_TYPE) && strcmp(r->handler, PHP_SOURCE_MAGIC_TYPE) && strcmp(r->handler, PHP_SCRIPT)) {
		
		if (!AP2(xbithack) || strcmp(r->handler, ""text/html"") || !(r->finfo.protection & APR_UEXECUTE)) {
			PHPAP_INI_OFF;
			return DECLINED;
		}
	}

	
	if (r->used_path_info == AP_REQ_REJECT_PATH_INFO
		&& r->path_info && r->path_info[0]) {
		PHPAP_INI_OFF;
		return HTTP_NOT_FOUND;
	}

	
	if (!AP2(engine)) {
		PHPAP_INI_OFF;
		return DECLINED;
	}

	if (r->finfo.filetype == 0) {
		php_apache_sapi_log_message_ex(""script '%s' not found or unable to stat"", r TSRMLS_CC);
		PHPAP_INI_OFF;
		return HTTP_NOT_FOUND;
	}
	if (r->finfo.filetype == APR_DIR) {
		php_apache_sapi_log_message_ex(""attempt to invoke directory '%s' as script"", r TSRMLS_CC);
		PHPAP_INI_OFF;
		return HTTP_FORBIDDEN;
	}

	
	if (r->main == NULL ||
		
		r->subprocess_env != r->main->subprocess_env
	) {
		
		ap_add_common_vars(r);
		ap_add_cgi_vars(r);
	}

zend_first_try {

	if (ctx == NULL) {
		brigade = apr_brigade_create(r->pool, r->connection->bucket_alloc);
		ctx = SG(server_context);
		ctx->brigade = brigade;

		if (php_apache_request_ctor(r, ctx TSRMLS_CC)!=SUCCESS) {
			zend_bailout();
		}
	} else {
		if (!parent_req) {
			parent_req = ctx->r;
		}
		if (parent_req && parent_req->handler &&
				strcmp(parent_req->handler, PHP_MAGIC_TYPE) &&
				strcmp(parent_req->handler, PHP_SOURCE_MAGIC_TYPE) &&
				strcmp(parent_req->handler, PHP_SCRIPT)) {
			if (php_apache_request_ctor(r, ctx TSRMLS_CC)!=SUCCESS) {
				zend_bailout();
			}
		}

		
		if (parent_req && parent_req->status != HTTP_OK && parent_req->status != 413 && strcmp(r->protocol, ""INCLUDED"")) {
			parent_req = NULL;
			goto normal;
		}
		ctx->r = r;
		brigade = ctx->brigade;
	}

	if (AP2(last_modified)) {
		ap_update_mtime(r, r->finfo.mtime);
		ap_set_last_modified(r);
	}

	
	if (strncmp(r->handler, PHP_SOURCE_MAGIC_TYPE, sizeof(PHP_SOURCE_MAGIC_TYPE) - 1) == 0) {
		zend_syntax_highlighter_ini syntax_highlighter_ini;
		php_get_highlight_struct(&syntax_highlighter_ini);
		highlight_file((char *)r->filename, &syntax_highlighter_ini TSRMLS_CC);
	} else {
		zend_file_handle zfd;

		zfd.type = ZEND_HANDLE_FILENAME;
		zfd.filename = (char *) r->filename;
		zfd.free_filename = 0;
		zfd.opened_path = NULL;

		if (!parent_req) {
			php_execute_script(&zfd TSRMLS_CC);
		} else {
			zend_execute_scripts(ZEND_INCLUDE TSRMLS_CC, NULL, 1, &zfd);
		}

		apr_table_set(r->notes, ""mod_php_memory_usage"",
			apr_psprintf(ctx->r->pool, ""%"" APR_SIZE_T_FMT, zend_memory_peak_usage(1 TSRMLS_CC)));
	}

} zend_end_try();

	if (!parent_req) {
		php_apache_request_dtor(r TSRMLS_CC);
		ctx->request_processed = 1;
		bucket = apr_bucket_eos_create(r->connection->bucket_alloc);
		APR_BRIGADE_INSERT_TAIL(brigade, bucket);

		rv = ap_pass_brigade(r->output_filters, brigade);
		if (rv != APR_SUCCESS || r->connection->aborted) {
zend_first_try {
			php_handle_aborted_connection();
 } zend_end_try();
                }
                apr_brigade_cleanup(brigade);
               apr_pool_cleanup_run(r->pool, (void *)&SG(server_context), php_server_context_cleanup);
        } else {
                ctx->r = parent_req;
        }
	return OK;
}
","1. static int php_handler(request_rec *r)
2. if (!AP2(engine)) {
3. PHPAP_INI_OFF;
4. if (!parent_req) {
5. ctx->r = r;
6. apr_brigade_cleanup(brigade);","1
50
57
87
109
155","CWE-824,CWE-20,CWE-79,CWE-134"
cqspi_setup_flash,"static int cqspi_setup_flash(struct cqspi_st *cqspi, struct device_node *np)
{
	struct platform_device *pdev = cqspi->pdev;
	struct device *dev = &pdev->dev;
	struct cqspi_flash_pdata *f_pdata;
	struct spi_nor *nor;
	struct mtd_info *mtd;
	unsigned int cs;
	int i, ret;

	
	for_each_available_child_of_node(dev->of_node, np) {
		if (of_property_read_u32(np, ""reg"", &cs)) {
			dev_err(dev, ""Couldn't determine chip select.\n"");
 			goto err;
 		}
 
		if (cs >= CQSPI_MAX_CHIPSELECT) {
 			dev_err(dev, ""Chip select %d out of range.\n"", cs);
 			goto err;
 		}

		f_pdata = &cqspi->f_pdata[cs];
		f_pdata->cqspi = cqspi;
		f_pdata->cs = cs;

		ret = cqspi_of_get_flash_pdata(pdev, f_pdata, np);
		if (ret)
			goto err;

		nor = &f_pdata->nor;
		mtd = &nor->mtd;

		mtd->priv = nor;

		nor->dev = dev;
		spi_nor_set_flash_node(nor, np);
		nor->priv = f_pdata;

		nor->read_reg = cqspi_read_reg;
		nor->write_reg = cqspi_write_reg;
		nor->read = cqspi_read;
		nor->write = cqspi_write;
		nor->erase = cqspi_erase;
		nor->prepare = cqspi_prep;
		nor->unprepare = cqspi_unprep;

		mtd->name = devm_kasprintf(dev, GFP_KERNEL, ""%s.%d"",
					   dev_name(dev), cs);
		if (!mtd->name) {
			ret = -ENOMEM;
			goto err;
		}

		ret = spi_nor_scan(nor, NULL, SPI_NOR_QUAD);
		if (ret)
			goto err;

		ret = mtd_device_register(mtd, NULL, 0);
		if (ret)
			goto err;

		f_pdata->registered = true;
	}

	return 0;

err:
	for (i = 0; i < CQSPI_MAX_CHIPSELECT; i++)
		if (cqspi->f_pdata[i].registered)
			mtd_device_unregister(&cqspi->f_pdata[i].nor.mtd);
	return ret;
}
","1. struct platform_device *pdev = cqspi->pdev;
struct device *dev = &pdev->dev;
2. for_each_available_child_of_node(dev->of_node, np) {
3. dev_err(dev, ""Couldn't determine chip select.\n"");
4. dev_err(dev, ""Chip select %d out of range.\n"", cs);
5. mtd = &nor->mtd;
6. mtd->priv = nor;
7. nor->priv = f_pdata;
8. nor->prepare = cqspi_prep;
9. mtd->name = devm_kasprintf(dev, GFP_KERNEL, ""%s.%d"",
10. f_pdata->registered = true;
11. if (cqspi->f_pdata[i].registered)","3-4
12
14
19
32
34
38
45
48
63
70","CWE-400,CWE-59,CWE-399,CWE-119"
er_supported-219169961187992,"
#define ERContext

static int er_supported(ERContext *s)
{
    if(s->avctx->hwaccel && s->avctx->hwaccel->decode_slice           ||
       !s->cur_pic.f                                                  ||
       s->cur_pic.field_picture
    )
        return 0;
    return 1;
}
","1. if(s->avctx->hwaccel && s->avctx->hwaccel->decode_slice           ||
2. return 0;
return 1;","6
10-11","CWE-617,CWE-119,CWE-416"
validate_commit_metadata_1-132044871601795,"
#define GError
#define GVariant

static gboolean
validate_commit_metadata_1 (GVariant   *commit_data,
                          const char *ref,
                          const char *required_metadata,
                          gsize       required_metadata_size,
                          GError   **error)
{
  g_autoptr(GVariant) commit_metadata = NULL;
  g_autoptr(GVariant) xa_metadata_v = NULL;
  const char *xa_metadata = NULL;
  gsize xa_metadata_size = 0;

  commit_metadata = g_variant_get_child_value (commit_data, 0);

  if (commit_metadata != NULL)
    {
      xa_metadata_v = g_variant_lookup_value (commit_metadata,
                                              ""xa.metadata"",
                                              G_VARIANT_TYPE_STRING);
      if (xa_metadata_v)
        xa_metadata = g_variant_get_string (xa_metadata_v, &xa_metadata_size);
    }

  if (xa_metadata == NULL ||
      xa_metadata_size != required_metadata_size ||
      memcmp (xa_metadata, required_metadata, xa_metadata_size) != 0)
    {
      g_set_error (error, G_IO_ERROR, G_IO_ERROR_PERMISSION_DENIED,
                   _(""Commit metadata for %s not matching expected metadata""), ref);
      return FALSE;
    }

  return TRUE;
}
","1. validate_commit_metadata_1 (GVariant   *commit_data,
const char *ref,
const char *required_metadata,
gsize       required_metadata_size,
2. g_autoptr(GVariant) xa_metadata_v = NULL;
const char *xa_metadata = NULL;
gsize xa_metadata_size = 0;
3. commit_metadata = g_variant_get_child_value (commit_data, 0);
4. xa_metadata_v = g_variant_lookup_value (commit_metadata,
5. if (xa_metadata_v)
xa_metadata = g_variant_get_string (xa_metadata_v, &xa_metadata_size);
6. if (xa_metadata == NULL ||
xa_metadata_size != required_metadata_size ||
7. _(""Commit metadata for %s not matching expected metadata""), ref);
return FALSE;
8. return TRUE;","6-9
13-15
17
21
24-25
28-29
33-34
37","CWE-617,CWE-276,CWE-119,CWE-125,CWE-399"
init_global_keywords," init_global_keywords(bool global_active)
 {
	
	install_keyword_root(""linkbeat_use_polling"", use_polling_handler, global_active);
#if HAVE_DECL_CLONE_NEWNET
	install_keyword_root(""net_namespace"", &net_namespace_handler, global_active);
	install_keyword_root(""namespace_with_ipsets"", &namespace_ipsets_handler, global_active);
#endif
	install_keyword_root(""use_pid_dir"", &use_pid_dir_handler, global_active);
	install_keyword_root(""instance"", &instance_handler, global_active);
	install_keyword_root(""child_wait_time"", &child_wait_handler, global_active);
	install_keyword_root(""global_defs"", NULL, global_active);
	install_keyword(""router_id"", &routerid_handler);
	install_keyword(""notification_email_from"", &emailfrom_handler);
	install_keyword(""smtp_server"", &smtpserver_handler);
	install_keyword(""smtp_helo_name"", &smtphelo_handler);
	install_keyword(""smtp_connect_timeout"", &smtpto_handler);
	install_keyword(""notification_email"", &email_handler);
	install_keyword(""smtp_alert"", &smtp_alert_handler);
#ifdef _WITH_VRRP_
	install_keyword(""smtp_alert_vrrp"", &smtp_alert_vrrp_handler);
#endif
#ifdef _WITH_LVS_
	install_keyword(""smtp_alert_checker"", &smtp_alert_checker_handler);
#endif
#ifdef _WITH_VRRP_
	install_keyword(""dynamic_interfaces"", &dynamic_interfaces_handler);
	install_keyword(""no_email_faults"", &no_email_faults_handler);
	install_keyword(""default_interface"", &default_interface_handler);
#endif
#ifdef _WITH_LVS_
	install_keyword(""lvs_timeouts"", &lvs_timeouts);
	install_keyword(""lvs_flush"", &lvs_flush_handler);
#ifdef _WITH_VRRP_
	install_keyword(""lvs_sync_daemon"", &lvs_syncd_handler);
#endif
#endif
#ifdef _WITH_VRRP_
	install_keyword(""vrrp_mcast_group4"", &vrrp_mcast_group4_handler);
	install_keyword(""vrrp_mcast_group6"", &vrrp_mcast_group6_handler);
	install_keyword(""vrrp_garp_master_delay"", &vrrp_garp_delay_handler);
	install_keyword(""vrrp_garp_master_repeat"", &vrrp_garp_rep_handler);
	install_keyword(""vrrp_garp_master_refresh"", &vrrp_garp_refresh_handler);
	install_keyword(""vrrp_garp_master_refresh_repeat"", &vrrp_garp_refresh_rep_handler);
	install_keyword(""vrrp_garp_lower_prio_delay"", &vrrp_garp_lower_prio_delay_handler);
	install_keyword(""vrrp_garp_lower_prio_repeat"", &vrrp_garp_lower_prio_rep_handler);
	install_keyword(""vrrp_garp_interval"", &vrrp_garp_interval_handler);
	install_keyword(""vrrp_gna_interval"", &vrrp_gna_interval_handler);
	install_keyword(""vrrp_lower_prio_no_advert"", &vrrp_lower_prio_no_advert_handler);
	install_keyword(""vrrp_higher_prio_send_advert"", &vrrp_higher_prio_send_advert_handler);
	install_keyword(""vrrp_version"", &vrrp_version_handler);
	install_keyword(""vrrp_iptables"", &vrrp_iptables_handler);
#ifdef _HAVE_LIBIPSET_
	install_keyword(""vrrp_ipsets"", &vrrp_ipsets_handler);
#endif
	install_keyword(""vrrp_check_unicast_src"", &vrrp_check_unicast_src_handler);
	install_keyword(""vrrp_skip_check_adv_addr"", &vrrp_check_adv_addr_handler);
	install_keyword(""vrrp_strict"", &vrrp_strict_handler);
	install_keyword(""vrrp_priority"", &vrrp_prio_handler);
	install_keyword(""vrrp_no_swap"", &vrrp_no_swap_handler);
#ifdef _HAVE_SCHED_RT_
	install_keyword(""vrrp_rt_priority"", &vrrp_rt_priority_handler);
#if HAVE_DECL_RLIMIT_RTTIME == 1
	install_keyword(""vrrp_rlimit_rtime"", &vrrp_rt_rlimit_handler);
#endif
#endif
#endif
	install_keyword(""notify_fifo"", &global_notify_fifo);
	install_keyword(""notify_fifo_script"", &global_notify_fifo_script);
#ifdef _WITH_VRRP_
	install_keyword(""vrrp_notify_fifo"", &vrrp_notify_fifo);
	install_keyword(""vrrp_notify_fifo_script"", &vrrp_notify_fifo_script);
#endif
#ifdef _WITH_LVS_
	install_keyword(""lvs_notify_fifo"", &lvs_notify_fifo);
	install_keyword(""lvs_notify_fifo_script"", &lvs_notify_fifo_script);
	install_keyword(""checker_priority"", &checker_prio_handler);
	install_keyword(""checker_no_swap"", &checker_no_swap_handler);
#ifdef _HAVE_SCHED_RT_
	install_keyword(""checker_rt_priority"", &checker_rt_priority_handler);
#if HAVE_DECL_RLIMIT_RTTIME == 1
	install_keyword(""checker_rlimit_rtime"", &checker_rt_rlimit_handler);
#endif
#endif
#endif
#ifdef _WITH_BFD_
	install_keyword(""bfd_priority"", &bfd_prio_handler);
	install_keyword(""bfd_no_swap"", &bfd_no_swap_handler);
#ifdef _HAVE_SCHED_RT_
	install_keyword(""bfd_rt_priority"", &bfd_rt_priority_handler);
#if HAVE_DECL_RLIMIT_RTTIME == 1
	install_keyword(""bfd_rlimit_rtime"", &bfd_rt_rlimit_handler);
#endif
#endif
#endif
#ifdef _WITH_SNMP_
	install_keyword(""snmp_socket"", &snmp_socket_handler);
	install_keyword(""enable_traps"", &trap_handler);
#ifdef _WITH_SNMP_VRRP_
	install_keyword(""enable_snmp_vrrp"", &snmp_vrrp_handler);
	install_keyword(""enable_snmp_keepalived"", &snmp_vrrp_handler);	
#endif
#ifdef _WITH_SNMP_RFC_
	install_keyword(""enable_snmp_rfc"", &snmp_rfc_handler);
#endif
#ifdef _WITH_SNMP_RFCV2_
	install_keyword(""enable_snmp_rfcv2"", &snmp_rfcv2_handler);
#endif
#ifdef _WITH_SNMP_RFCV3_
	install_keyword(""enable_snmp_rfcv3"", &snmp_rfcv3_handler);
#endif
#ifdef _WITH_SNMP_CHECKER_
	install_keyword(""enable_snmp_checker"", &snmp_checker_handler);
#endif
#endif
#ifdef _WITH_DBUS_
	install_keyword(""enable_dbus"", &enable_dbus_handler);
	install_keyword(""dbus_service_name"", &dbus_service_name_handler);
#endif
	install_keyword(""script_user"", &script_user_handler);
	install_keyword(""enable_script_security"", &script_security_handler);
#ifdef _WITH_VRRP_
	install_keyword(""vrrp_netlink_cmd_rcv_bufs"", &vrrp_netlink_cmd_rcv_bufs_handler);
	install_keyword(""vrrp_netlink_cmd_rcv_bufs_force"", &vrrp_netlink_cmd_rcv_bufs_force_handler);
	install_keyword(""vrrp_netlink_monitor_rcv_bufs"", &vrrp_netlink_monitor_rcv_bufs_handler);
	install_keyword(""vrrp_netlink_monitor_rcv_bufs_force"", &vrrp_netlink_monitor_rcv_bufs_force_handler);
#endif
#ifdef _WITH_LVS_
	install_keyword(""lvs_netlink_cmd_rcv_bufs"", &lvs_netlink_cmd_rcv_bufs_handler);
	install_keyword(""lvs_netlink_cmd_rcv_bufs_force"", &lvs_netlink_cmd_rcv_bufs_force_handler);
	install_keyword(""lvs_netlink_monitor_rcv_bufs"", &lvs_netlink_monitor_rcv_bufs_handler);
	install_keyword(""lvs_netlink_monitor_rcv_bufs_force"", &lvs_netlink_monitor_rcv_bufs_force_handler);
#endif
#ifdef _WITH_LVS_
	install_keyword(""rs_init_notifies"", &rs_init_notifies_handler);
	install_keyword(""no_checker_emails"", &no_checker_emails_handler);
#endif
#ifdef _WITH_VRRP_
 	install_keyword(""vrrp_rx_bufs_policy"", &vrrp_rx_bufs_policy_handler);
 	install_keyword(""vrrp_rx_bufs_multiplier"", &vrrp_rx_bufs_multiplier_handler);
 #endif
	install_keyword(""umask"", &umask_handler);
 }
","1. init_global_keywords(bool global_active)
2. install_keyword_root(""linkbeat_use_polling"", use_polling_handler, global_active);
3. install_keyword_root(""global_defs"", NULL, global_active);
4. install_keyword(""smtp_server"", &smtpserver_handler);
5. install_keyword(""smtp_connect_timeout"", &smtpto_handler);
6. install_keyword(""umask"", &umask_handler);","1
4
12
15
17
142","CWE-200,CWE-284"
decomp_get_rddata-252169396000384,"int decomp_get_rddata(js_string *compressed, js_string *out,
                      unsigned int compressed_offset, int type, int rdlength) {

    char *desc;
    int subtype, total, len;

    desc = decomp_get_rrdesc(type);

    if(desc == 0) { 
        if(rdlength == 0) {
            return JS_SUCCESS;
            }
        if(decomp_append_bytes(compressed,out,compressed_offset,
                               rdlength) != JS_SUCCESS) {
            return JS_ERROR;
            }
        else {
            return JS_SUCCESS;
            }
        }
    else {
        subtype = *desc;
        total = 0;
        
        while(subtype != 0) {
            
            if(subtype > 0 && subtype < 64) {
                if(decomp_append_bytes(compressed,out,
                   compressed_offset,subtype) != JS_SUCCESS) {
                       return JS_ERROR;
                       }
                total += subtype;
                compressed_offset += subtype;
                }
            
            else if(subtype == RRSUB_DLABEL) {
                len = decomp_append_dlabel(compressed,out,
                        compressed_offset);
                if(len == JS_ERROR) {
                    return JS_ERROR;
                    }
                total += len;
                compressed_offset += len;
                }
            
            else if(subtype == RRSUB_TEXT) {
                
                len = *(compressed->string + compressed_offset);
                len += 1; 
                if(len < 0 || len > 256) {
                    return JS_ERROR;
                    }
                if(decomp_append_bytes(compressed,out,
                                       compressed_offset,len) !=
                   JS_SUCCESS) {
                    return JS_ERROR;
                    }
                total += len;
                compressed_offset += len;
                }
            
            else if(subtype == RRSUB_VARIABLE) {
                len = rdlength - total;
                if(len <= 0) {
                    break;
                    }
                if(decomp_append_bytes(compressed,out,
                                       compressed_offset,len) != JS_SUCCESS) {
                    return JS_ERROR;
                    }
                total += len;
                compressed_offset += len;
                }
            else { 
                return JS_ERROR;
                }
            desc++;
            
            if(subtype != RRSUB_VARIABLE)
                subtype = *desc;
            else
                subtype = 0; 
            }
        
        if(rdlength != total) {
            return JS_ERROR;
            }
        }

    
    return JS_SUCCESS;
    }
","1. return JS_SUCCESS;
2. rdlength) != JS_SUCCESS) {
3. subtype = *desc;
total = 0;
4. compressed_offset,subtype) != JS_SUCCESS) {
5. else if(subtype == RRSUB_TEXT) {
6. len += 1; /* To account for the one byte which
7. return JS_ERROR;
8. total += len;
9. return JS_ERROR;
10. total += len;
11. subtype = 0;","11
14
22-23
29
46
49
52
59
70
72
83","CWE-20,CWE-200,CWE-264,CWE-835"
pk_transaction_finished_emit-149608328450220,"
#define PkExitEnum
#define PkTransaction

static void
pk_transaction_finished_emit (PkTransaction *transaction,
			      PkExitEnum exit_enum,
			      guint time_ms)
{
	g_assert (!transaction->priv->emitted_finished);
	transaction->priv->emitted_finished = TRUE;

	g_debug (""emitting finished '%s', %i"",
		 pk_exit_enum_to_string (exit_enum),
		 time_ms);
	g_dbus_connection_emit_signal (transaction->priv->connection,
				       NULL,
				       transaction->priv->tid,
				       PK_DBUS_INTERFACE_TRANSACTION,
				       ""Finished"",
				       g_variant_new (""(uu)"",
						      exit_enum,
						      time_ms),
				       NULL);

	
	g_signal_emit (transaction, signals[SIGNAL_FINISHED], 0);
}
","1. static void
2. guint time_ms)
3. transaction->priv->emitted_finished = TRUE;
4. g_debug (""emitting finished '%s', %i"",
5. PK_DBUS_INTERFACE_TRANSACTION,","5
8
11
13
19","CWE-310,CWE-400,CWE-552,CWE-119"
set_geometry_1,"static int set_geometry_1(unsigned int cmd, struct floppy_struct *g,
			       int drive, int type, struct block_device *bdev)
{
 	int cnt;
 
 	
	if ((int)g->sect <= 0 ||
	    (int)g->head <= 0 ||
	    
	    (int)(g->sect * g->head) <= 0 ||
 	    
 	    (unsigned char)((g->sect << 2) >> FD_SIZECODE(g)) == 0 ||
 	    g->track <= 0 || g->track > UDP->tracks >> STRETCH(g) ||
	    
	    (g->stretch & ~(FD_STRETCH | FD_SWAPSIDES | FD_SECTBASEMASK)) != 0)
		return -EINVAL;
	if (type) {
		if (!capable(CAP_SYS_ADMIN))
			return -EPERM;
		mutex_lock(&open_lock);
		if (lock_fdc(drive)) {
			mutex_unlock(&open_lock);
			return -EINTR;
		}
		floppy_type[type] = *g;
		floppy_type[type].name = ""user format"";
		for (cnt = type << 2; cnt < (type << 2) + 4; cnt++)
			floppy_sizes[cnt] = floppy_sizes[cnt + 0x80] =
			    floppy_type[type].size + 1;
		process_fd_request();
		for (cnt = 0; cnt < N_DRIVE; cnt++) {
			struct block_device *bdev = opened_bdev[cnt];
			if (!bdev || ITYPE(drive_state[cnt].fd_device) != type)
				continue;
			__invalidate_device(bdev, true);
		}
		mutex_unlock(&open_lock);
	} else {
		int oldStretch;

		if (lock_fdc(drive))
			return -EINTR;
		if (cmd != FDDEFPRM) {
			
			if (poll_drive(true, FD_RAW_NEED_DISK) == -EINTR)
				return -EINTR;
		}
		oldStretch = g->stretch;
		user_params[drive] = *g;
		if (buffer_drive == drive)
			SUPBOUND(buffer_max, user_params[drive].sect);
		current_type[drive] = &user_params[drive];
		floppy_sizes[drive] = user_params[drive].size;
		if (cmd == FDDEFPRM)
			DRS->keep_data = -1;
		else
			DRS->keep_data = 1;
		
		if (DRS->maxblock > user_params[drive].sect ||
		    DRS->maxtrack ||
		    ((user_params[drive].sect ^ oldStretch) &
		     (FD_SWAPSIDES | FD_SECTBASEMASK)))
			invalidate_drive(bdev);
		else
			process_fd_request();
	}
	return 0;
}
","1. (unsigned char)((g->sect << 2) >> FD_SIZECODE(g)) == 0 ||
2. if (!capable(CAP_SYS_ADMIN))
3. mutex_lock(&open_lock);
4. mutex_unlock(&open_lock);
5. continue;
6. mutex_unlock(&open_lock);
7. return -EINTR;
8. DRS->keep_data = -1;
9. process_fd_request();","12
18
20
22
34
37
47
56
70","CWE-476,CWE-125,CWE-189,CWE-369"
t220_frontend_attach-224829804918538,"static int t220_frontend_attach(struct dvb_usb_adapter *adap)
{
	struct dvb_usb_device *d = adap->dev;
	struct dw2102_state *state = d->priv;

	mutex_lock(&d->data_mutex);

	state->data[0] = 0xe;
	state->data[1] = 0x87;
	state->data[2] = 0x0;

	if (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)
		err(""command 0x0e transfer failed."");

	state->data[0] = 0xe;
	state->data[1] = 0x86;
	state->data[2] = 1;

	if (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)
		err(""command 0x0e transfer failed."");

	state->data[0] = 0xe;
	state->data[1] = 0x80;
	state->data[2] = 0;

	if (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)
		err(""command 0x0e transfer failed."");

	msleep(50);

	state->data[0] = 0xe;
	state->data[1] = 0x80;
	state->data[2] = 1;

	if (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)
		err(""command 0x0e transfer failed."");

	state->data[0] = 0x51;

	if (dvb_usb_generic_rw(d, state->data, 1, state->data, 1, 0) < 0)
		err(""command 0x51 transfer failed."");

	mutex_unlock(&d->data_mutex);

	adap->fe_adap[0].fe = dvb_attach(cxd2820r_attach, &cxd2820r_config,
					&d->i2c_adap, NULL);
	if (adap->fe_adap[0].fe != NULL) {
		if (dvb_attach(tda18271_attach, adap->fe_adap[0].fe, 0x60,
					&d->i2c_adap, &tda18271_config)) {
			info(""Attached TDA18271HD/CXD2820R!"");
			return 0;
		}
	}

	info(""Failed to attach TDA18271HD/CXD2820R!"");
	return -EIO;
}
","1. static int t220_frontend_attach(struct dvb_usb_adapter *adap)
2. struct dvb_usb_device *d = adap->dev;
struct dw2102_state *state = d->priv;
3. mutex_lock(&d->data_mutex);
4. state->data[0] = 0xe;
state->data[1] = 0x87;
state->data[2] = 0x0;
5. if (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)
err(""command 0x0e transfer failed."");
6. state->data[0] = 0xe;
state->data[1] = 0x86;
state->data[2] = 1;
7. if (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)
err(""command 0x0e transfer failed."");
8. state->data[0] = 0xe;
state->data[1] = 0x80;
state->data[2] = 0;
9. if (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)
err(""command 0x0e transfer failed."");
10. msleep(50);
11. state->data[0] = 0xe;
state->data[1] = 0x80;
state->data[2] = 1;
12. if (dvb_usb_generic_rw(d, state->data, 3, state->data, 1, 0) < 0)
err(""command 0x0e transfer failed."");
13. state->data[0] = 0x51;
14. if (dvb_usb_generic_rw(d, state->data, 1, state->data, 1, 0) < 0)
err(""command 0x51 transfer failed."");
15. mutex_unlock(&d->data_mutex);
16. adap->fe_adap[0].fe = dvb_attach(cxd2820r_attach, &cxd2820r_config,
&d->i2c_adap, NULL);
if (adap->fe_adap[0].fe != NULL) {
if (dvb_attach(tda18271_attach, adap->fe_adap[0].fe, 0x60,
&d->i2c_adap, &tda18271_config)) {
info(""Attached TDA18271HD/CXD2820R!"");
return 0;
17. info(""Failed to attach TDA18271HD/CXD2820R!"");
return -EIO;","1
3-4
6
8-10
12-13
15-17
19-20
22-24
26-27
29
31-33
35-36
38
40-41
43
45-51
55-56",CWE-119
enc624j600UpdateMacConfig-50367760070256,"
#define NetInterface

void enc624j600UpdateMacConfig(NetInterface *interface)
{
   uint16_t duplexMode;

   
   duplexMode = enc624j600ReadReg(interface, ENC624J600_ESTAT) & ENC624J600_ESTAT_PHYDPX;

   
   if(duplexMode)
   {
      
      enc624j600WriteReg(interface, ENC624J600_MACON2, ENC624J600_MACON2_DEFER |
         ENC624J600_MACON2_PADCFG_AUTO | ENC624J600_MACON2_TXCRCEN |
         ENC624J600_MACON2_R1_DEFAULT | ENC624J600_MACON2_FULDPX);

      
      enc624j600WriteReg(interface, ENC624J600_MABBIPG,
         ENC624J600_MABBIPG_BBIPG_DEFAULT_FD);
   }
   
   else
   {
      
      enc624j600WriteReg(interface, ENC624J600_MACON2, ENC624J600_MACON2_DEFER |
         ENC624J600_MACON2_PADCFG_AUTO | ENC624J600_MACON2_TXCRCEN |
         ENC624J600_MACON2_R1_DEFAULT);

      
      enc624j600WriteReg(interface, ENC624J600_MABBIPG,
         ENC624J600_MABBIPG_BBIPG_DEFAULT_HD);
   }
}
","1. void enc624j600UpdateMacConfig(NetInterface *interface)
2. uint16_t duplexMode;
3. duplexMode = enc624j600ReadReg(interface, ENC624J600_ESTAT) & ENC624J600_ESTAT_PHYDPX;
4. enc624j600WriteReg(interface, ENC624J600_MACON2, ENC624J600_MACON2_DEFER |
ENC624J600_MACON2_PADCFG_AUTO | ENC624J600_MACON2_TXCRCEN |
ENC624J600_MACON2_R1_DEFAULT | ENC624J600_MACON2_FULDPX);
5. enc624j600WriteReg(interface, ENC624J600_MABBIPG,
6. enc624j600WriteReg(interface, ENC624J600_MACON2, ENC624J600_MACON2_DEFER |
ENC624J600_MACON2_PADCFG_AUTO | ENC624J600_MACON2_TXCRCEN |
7. enc624j600WriteReg(interface, ENC624J600_MABBIPG,
ENC624J600_MABBIPG_BBIPG_DEFAULT_HD);","4
6
9
15-17
20
27-28
32-33",CWE-20
ap_http_filter," apr_status_t ap_http_filter(ap_filter_t *f, apr_bucket_brigade *b,
                            ap_input_mode_t mode, apr_read_type_e block,
                            apr_off_t readbytes)
 {
     core_server_config *conf;
     apr_bucket *e;
    http_ctx_t *ctx = f->ctx;
    apr_status_t rv;
    apr_off_t totalread;
    int again;

    conf = (core_server_config *)
        ap_get_module_config(f->r->server->module_config, &core_module);

    
    if (mode != AP_MODE_READBYTES && mode != AP_MODE_GETLINE) {
        return ap_get_brigade(f->next, b, mode, block, readbytes);
    }

    if (!ctx) {
        const char *tenc, *lenp;
        f->ctx = ctx = apr_pcalloc(f->r->pool, sizeof(*ctx));
        ctx->state = BODY_NONE;

        
        if (!f->r->proxyreq) {
            ctx->limit = ap_get_limit_req_body(f->r);
        }
        else {
            ctx->limit = 0;
        }

        tenc = apr_table_get(f->r->headers_in, ""Transfer-Encoding"");
        lenp = apr_table_get(f->r->headers_in, ""Content-Length"");

        if (tenc) {
            if (strcasecmp(tenc, ""chunked"") == 0 
                    || ap_find_last_token(f->r->pool, tenc, ""chunked"")) {
                ctx->state = BODY_CHUNK;
            }
            else if (f->r->proxyreq == PROXYREQ_RESPONSE) {
                
                 ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(02555)
                              ""Unknown Transfer-Encoding: %s; ""
                              ""using read-until-close"", tenc);
                 tenc = NULL;
             }
             else {
                
                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01585)
                              ""Unknown Transfer-Encoding: %s"", tenc);
                return APR_EGENERAL;
            }
            lenp = NULL;
        }
        if (lenp) {
            char *endstr;

            ctx->state = BODY_LENGTH;

            
            if (apr_strtoff(&ctx->remaining, lenp, &endstr, 10)
                     || endstr == lenp || *endstr || ctx->remaining < 0) {
 
                 ctx->remaining = 0;
                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01587)
                              ""Invalid Content-Length"");
 
                return APR_EINVAL;
             }
 
             
             if (ctx->limit && ctx->limit < ctx->remaining) {
                ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01588)
                          ""Requested content-length of %"" APR_OFF_T_FMT
                          "" is larger than the configured limit""
                          "" of %"" APR_OFF_T_FMT, ctx->remaining, ctx->limit);
                 return APR_ENOSPC;
             }
         }

        
        if (ctx->state == BODY_NONE && f->r->proxyreq != PROXYREQ_RESPONSE) {
            e = apr_bucket_eos_create(f->c->bucket_alloc);
            APR_BRIGADE_INSERT_TAIL(b, e);
            ctx->eos_sent = 1;
            return APR_SUCCESS;
        }

        
        if ((ctx->state == BODY_CHUNK
                || (ctx->state == BODY_LENGTH && ctx->remaining > 0))
                && f->r->expecting_100 && f->r->proto_num >= HTTP_VERSION(1,1)
                && !(f->r->eos_sent || f->r->bytes_sent)) {
            if (!ap_is_HTTP_SUCCESS(f->r->status)) {
                ctx->state = BODY_NONE;
                ctx->eos_sent = 1;
            }
            else {
                char *tmp;
                int len;
                apr_bucket_brigade *bb;

                bb = apr_brigade_create(f->r->pool, f->c->bucket_alloc);

                
                f->r->expecting_100 = 0;
                tmp = apr_pstrcat(f->r->pool, AP_SERVER_PROTOCOL "" "",
                        ap_get_status_line(HTTP_CONTINUE), CRLF CRLF, NULL);
                len = strlen(tmp);
                ap_xlate_proto_to_ascii(tmp, len);
                e = apr_bucket_pool_create(tmp, len, f->r->pool,
                        f->c->bucket_alloc);
                APR_BRIGADE_INSERT_HEAD(bb, e);
                e = apr_bucket_flush_create(f->c->bucket_alloc);
                 APR_BRIGADE_INSERT_TAIL(bb, e);
 
                 rv = ap_pass_brigade(f->c->output_filters, bb);
                apr_brigade_cleanup(bb);
                 if (rv != APR_SUCCESS) {
                     return AP_FILTER_ERROR;
                 }
            }
        }
    }

    
    if (ctx->eos_sent) {
        e = apr_bucket_eos_create(f->c->bucket_alloc);
        APR_BRIGADE_INSERT_TAIL(b, e);
        return APR_SUCCESS;
    }

    do {
        apr_brigade_cleanup(b);
        again = 0; 

        
        switch (ctx->state) {
         case BODY_CHUNK:
         case BODY_CHUNK_PART:
         case BODY_CHUNK_EXT:
        case BODY_CHUNK_LF:
        case BODY_CHUNK_END:
        case BODY_CHUNK_END_LF: {
 
             rv = ap_get_brigade(f->next, b, AP_MODE_GETLINE, block, 0);
 
            
            if (block == APR_NONBLOCK_READ
                    && ((rv == APR_SUCCESS && APR_BRIGADE_EMPTY(b))
                            || (APR_STATUS_IS_EAGAIN(rv)))) {
                return APR_EAGAIN;
            }

            if (rv == APR_EOF) {
                return APR_INCOMPLETE;
            }

            if (rv != APR_SUCCESS) {
                return rv;
            }

            e = APR_BRIGADE_FIRST(b);
            while (e != APR_BRIGADE_SENTINEL(b)) {
                const char *buffer;
                apr_size_t len;

                if (!APR_BUCKET_IS_METADATA(e)) {
                    rv = apr_bucket_read(e, &buffer, &len, APR_BLOCK_READ);

                    if (rv == APR_SUCCESS) {
                        rv = parse_chunk_size(ctx, buffer, len,
                                 f->r->server->limit_req_fieldsize);
                     }
                     if (rv != APR_SUCCESS) {
                        ap_log_rerror(APLOG_MARK, APLOG_INFO, rv, f->r, APLOGNO(01590)
                                      ""Error reading chunk %s "",
                                      (APR_ENOSPC == rv) ? ""(overflow)"" : """");
                         return rv;
                     }
                 }

                apr_bucket_delete(e);
                e = APR_BRIGADE_FIRST(b);
            }
            again = 1; 
 
             if (ctx->state == BODY_CHUNK_TRAILER) {
                 
                return read_chunked_trailers(ctx, f, b,
                            conf->merge_trailers == AP_MERGE_TRAILERS_ENABLE);
             }
 
             break;
        }
        case BODY_NONE:
        case BODY_LENGTH:
        case BODY_CHUNK_DATA: {

            
            if (ctx->state != BODY_NONE && ctx->remaining < readbytes) {
                readbytes = ctx->remaining;
            }
            if (readbytes > 0) {

                rv = ap_get_brigade(f->next, b, mode, block, readbytes);

                
                if (block == APR_NONBLOCK_READ
                        && ((rv == APR_SUCCESS && APR_BRIGADE_EMPTY(b))
                                || (APR_STATUS_IS_EAGAIN(rv)))) {
                    return APR_EAGAIN;
                }

                if (rv == APR_EOF && ctx->state != BODY_NONE
                        && ctx->remaining > 0) {
                    return APR_INCOMPLETE;
                }

                if (rv != APR_SUCCESS) {
                    return rv;
                }

                
                apr_brigade_length(b, 0, &totalread);

                
                AP_DEBUG_ASSERT(totalread >= 0);

                if (ctx->state != BODY_NONE) {
                    ctx->remaining -= totalread;
                    if (ctx->remaining > 0) {
                        e = APR_BRIGADE_LAST(b);
                        if (APR_BUCKET_IS_EOS(e)) {
                            apr_bucket_delete(e);
                            return APR_INCOMPLETE;
                        }
                    }
                    else if (ctx->state == BODY_CHUNK_DATA) {
                        
                        ctx->state = BODY_CHUNK_END;
                        ctx->chunk_used = 0;
                    }
                }

            }

            
            if (ctx->state == BODY_LENGTH && ctx->remaining == 0) {
                e = apr_bucket_eos_create(f->c->bucket_alloc);
                APR_BRIGADE_INSERT_TAIL(b, e);
                ctx->eos_sent = 1;
            }

            
            if (ctx->limit) {
                
                 ctx->limit_used += totalread;
                 if (ctx->limit < ctx->limit_used) {
                    ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, f->r, APLOGNO(01591)
                                  ""Read content-length of %"" APR_OFF_T_FMT
                                  "" is larger than the configured limit""
                                  "" of %"" APR_OFF_T_FMT, ctx->limit_used, ctx->limit);
                     return APR_ENOSPC;
                 }
             }

            break;
        }
        case BODY_CHUNK_TRAILER: {

            rv = ap_get_brigade(f->next, b, mode, block, readbytes);

            
            if (block == APR_NONBLOCK_READ
                    && ((rv == APR_SUCCESS && APR_BRIGADE_EMPTY(b))
                            || (APR_STATUS_IS_EAGAIN(rv)))) {
                return APR_EAGAIN;
            }

            if (rv != APR_SUCCESS) {
                return rv;
            }

             break;
         }
         default: {
            
            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, f->r, APLOGNO(02901)
                          ""Unexpected body state (%i)"", (int)ctx->state);
            return APR_EGENERAL;
         }
         }
 
    } while (again);

    return APR_SUCCESS;
}
","1. apr_status_t rv;
2. if (mode != AP_MODE_READBYTES && mode != AP_MODE_GETLINE) {
return ap_get_brigade(f->next, b, mode, block, readbytes);
3. ctx->limit = ap_get_limit_req_body(f->r);
4. if (tenc) {
5. tenc = NULL;
6. ctx->state = BODY_LENGTH;
7. if (apr_strtoff(&ctx->remaining, lenp, &endstr, 10)
8. ctx->remaining = 0;
9. return APR_EINVAL;
10. if (ctx->state == BODY_NONE && f->r->proxyreq != PROXYREQ_RESPONSE) {
11. if ((ctx->state == BODY_CHUNK
12. int len;
13. return AP_FILTER_ERROR;
14. again = 0;
15. case BODY_CHUNK_LF:
16. || (APR_STATUS_IS_EAGAIN(rv)))) {
17. return APR_INCOMPLETE;
18. const char *buffer;
apr_size_t len;
19. return rv;
20. again = 1;
21. if (ctx->state != BODY_NONE && ctx->remaining < readbytes) {
readbytes = ctx->remaining;
22. rv = ap_get_brigade(f->next, b, mode, block, readbytes);
23. || (APR_STATUS_IS_EAGAIN(rv)))) {
return APR_EAGAIN;
24. if (rv == APR_EOF && ctx->state != BODY_NONE
25. apr_brigade_length(b, 0, &totalread);
26. AP_DEBUG_ASSERT(totalread >= 0);
27. if (APR_BUCKET_IS_EOS(e)) {
28. ctx->chunk_used = 0;
29. e = apr_bucket_eos_create(f->c->bucket_alloc);
30. if (ctx->limit) {
31. && ((rv == APR_SUCCESS && APR_BRIGADE_EMPTY(b))
32. return APR_EAGAIN;
33. return rv;
34. break;
35. default: {
36. } while (again);
37. return APR_SUCCESS;","8
16-17
31
40
55
70
75
78
82
108
117
127
149
164
171
180
185
194-195
208
215
230-231
235
240-241
244
254
258
264
272
282
288
310
312
316
319
321
329
331","CWE-120,CWE-416,CWE-401,CWE-17,CWE-399"
dnxhd_init_vlc-14861557766573,"
#define DNXHDContext

static int dnxhd_init_vlc(DNXHDContext *ctx, uint32_t cid, int bitdepth)
{
    int ret;
    if (cid != ctx->cid) {
        const CIDEntry *cid_table = ff_dnxhd_get_cid_table(cid);

        if (!cid_table) {
            av_log(ctx->avctx, AV_LOG_ERROR, ""unsupported cid %""PRIu32""\n"", cid);
            return AVERROR(ENOSYS);
        }
        if (cid_table->bit_depth != bitdepth &&
            cid_table->bit_depth != DNXHD_VARIABLE) {
            av_log(ctx->avctx, AV_LOG_ERROR, ""bit depth mismatches %d %d\n"",
                   cid_table->bit_depth, bitdepth);
            return AVERROR_INVALIDDATA;
        }
        ctx->cid_table = cid_table;
        av_log(ctx->avctx, AV_LOG_VERBOSE, ""Profile cid %""PRIu32"".\n"", cid);

        ff_free_vlc(&ctx->ac_vlc);
        ff_free_vlc(&ctx->dc_vlc);
        ff_free_vlc(&ctx->run_vlc);

        if ((ret = init_vlc(&ctx->ac_vlc, DNXHD_VLC_BITS, 257,
                 ctx->cid_table->ac_bits, 1, 1,
                 ctx->cid_table->ac_codes, 2, 2, 0)) < 0)
            goto out;
        if ((ret = init_vlc(&ctx->dc_vlc, DNXHD_DC_VLC_BITS, bitdepth > 8 ? 14 : 12,
                 ctx->cid_table->dc_bits, 1, 1,
                 ctx->cid_table->dc_codes, 1, 1, 0)) < 0)
            goto out;
        if ((ret = init_vlc(&ctx->run_vlc, DNXHD_VLC_BITS, 62,
                 ctx->cid_table->run_bits, 1, 1,
                 ctx->cid_table->run_codes, 2, 2, 0)) < 0)
            goto out;

        ctx->cid = cid;
    }
    ret = 0;
out:
    if (ret < 0)
        av_log(ctx->avctx, AV_LOG_ERROR, ""init_vlc failed\n"");
    return ret;
}
","1. static int dnxhd_init_vlc(DNXHDContext *ctx, uint32_t cid, int bitdepth)
2. if (cid_table->bit_depth != bitdepth &&
3. ff_free_vlc(&ctx->ac_vlc);
4. if ((ret = init_vlc(&ctx->ac_vlc, DNXHD_VLC_BITS, 257,
5. ctx->cid = cid;
6. if (ret < 0)","4
14
23
27
40
44","CWE-125,CWE-787,CWE-119"
llc_sap_rcv-170823725707435,"static void llc_sap_rcv(struct llc_sap *sap, struct sk_buff *skb,
			struct sock *sk)
{
	struct llc_sap_state_ev *ev = llc_sap_ev(skb);

	ev->type   = LLC_SAP_EV_TYPE_PDU;
	ev->reason = 0;
	skb_orphan(skb);
	sock_hold(sk);
	skb->sk = sk;
	skb->destructor = sock_efree;
	llc_sap_state_process(sap, skb);
}
","1. struct llc_sap_state_ev *ev = llc_sap_ev(skb);
2. skb_orphan(skb);","4
8","CWE-200,CWE-284"
veth_xmit,"static netdev_tx_t veth_xmit(struct sk_buff *skb, struct net_device *dev)
{
	struct net_device *rcv = NULL;
	struct veth_priv *priv, *rcv_priv;
	struct veth_net_stats *stats, *rcv_stats;
	int length;

	priv = netdev_priv(dev);
	rcv = priv->peer;
	rcv_priv = netdev_priv(rcv);

	stats = this_cpu_ptr(priv->stats);
	rcv_stats = this_cpu_ptr(rcv_priv->stats);

	if (!(rcv->flags & IFF_UP))
		goto tx_drop;

	if (dev->features & NETIF_F_NO_CSUM)
		skb->ip_summed = rcv_priv->ip_summed;

	length = skb->len + ETH_HLEN;
	if (dev_forward_skb(rcv, skb) != NET_RX_SUCCESS)
		goto rx_drop;

	stats->tx_bytes += length;
	stats->tx_packets++;

	rcv_stats->rx_bytes += length;
	rcv_stats->rx_packets++;

	return NETDEV_TX_OK;

tx_drop:
	kfree_skb(skb);
	stats->tx_dropped++;
 	return NETDEV_TX_OK;
 
 rx_drop:
 	rcv_stats->rx_dropped++;
 	return NETDEV_TX_OK;
 }
","1. goto rx_drop;
2. return NETDEV_TX_OK;
3. kfree_skb(skb);
4. rcv_stats->rx_dropped++;","23
31
34
39","CWE-20,CWE-399,CWE-416"
set_options-159221258585235,"
#define PyObject
#define PySSLContext

static int
set_options(PySSLContext *self, PyObject *arg, void *c)
{
    long new_opts, opts, set, clear;
    if (!PyArg_Parse(arg, ""l"", &new_opts))
        return -1;
    opts = SSL_CTX_get_options(self->ctx);
    clear = opts & ~new_opts;
    set = ~opts & new_opts;
    if (clear) {
        SSL_CTX_clear_options(self->ctx, clear);
    }
    if (set)
        SSL_CTX_set_options(self->ctx, set);
    return 0;
}
","1. long new_opts, opts, set, clear;
2. SSL_CTX_clear_options(self->ctx, clear);
3. return 0;","8
15
19","CWE-20,CWE-264"
inode_change_ok,"int inode_change_ok(const struct inode *inode, struct iattr *attr)
{
	unsigned int ia_valid = attr->ia_valid;

	
	if (ia_valid & ATTR_SIZE) {
		int error = inode_newsize_ok(inode, attr->ia_size);
		if (error)
			return error;
	}

	
	if (ia_valid & ATTR_FORCE)
		return 0;

	
 	if ((ia_valid & ATTR_UID) &&
 	    (!uid_eq(current_fsuid(), inode->i_uid) ||
 	     !uid_eq(attr->ia_uid, inode->i_uid)) &&
	    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))
 		return -EPERM;
 
 	
 	if ((ia_valid & ATTR_GID) &&
 	    (!uid_eq(current_fsuid(), inode->i_uid) ||
 	    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&
	    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))
 		return -EPERM;
 
 	
	if (ia_valid & ATTR_MODE) {
		if (!inode_owner_or_capable(inode))
			return -EPERM;
 		
 		if (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :
 				inode->i_gid) &&
		    !capable_wrt_inode_uidgid(inode, CAP_FSETID))
 			attr->ia_mode &= ~S_ISGID;
 	}
 
	
	if (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {
		if (!inode_owner_or_capable(inode))
			return -EPERM;
	}

	return 0;
}
","1. if (ia_valid & ATTR_SIZE) {
2. return error;
3. if (ia_valid & ATTR_FORCE)
return 0;
4. if ((ia_valid & ATTR_UID) &&
(!uid_eq(current_fsuid(), inode->i_uid) ||
!uid_eq(attr->ia_uid, inode->i_uid)) &&
!capable_wrt_inode_uidgid(inode, CAP_CHOWN))
5. if ((ia_valid & ATTR_GID) &&
(!uid_eq(current_fsuid(), inode->i_uid) ||
(!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&
!capable_wrt_inode_uidgid(inode, CAP_CHOWN))
6. inode->i_gid) &&
7. if (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {","9
12
16-17
20-23
27-30
39
45","CWE-254,CWE-264,CWE-119"
xgene_hwmon_remove-27760921278065,"static int xgene_hwmon_remove(struct platform_device *pdev)
{
	struct xgene_hwmon_dev *ctx = platform_get_drvdata(pdev);

	cancel_work_sync(&ctx->workq);
	hwmon_device_unregister(ctx->hwmon_dev);
	kfifo_free(&ctx->async_msg_fifo);
	if (acpi_disabled)
		mbox_free_channel(ctx->mbox_chan);
	else
		pcc_mbox_free_channel(ctx->pcc_chan);

	return 0;
}
","1. cancel_work_sync(&ctx->workq);
hwmon_device_unregister(ctx->hwmon_dev);
2. if (acpi_disabled)
3. pcc_mbox_free_channel(ctx->pcc_chan);","5-6
8
11","CWE-401,CWE-264,CWE-416,CWE-415"
ImagingPcxDecode-134578044648743,"
#define Imaging
#define ImagingCodecState
#define Py_ssize_t
#define UINT8

int
ImagingPcxDecode(Imaging im, ImagingCodecState state, UINT8* buf, Py_ssize_t bytes)
{
    UINT8 n;
    UINT8* ptr;

    if ((state->xsize * state->bits + 7) / 8 > state->bytes) {
        state->errcode = IMAGING_CODEC_OVERRUN;
        return -1;
    }

    ptr = buf;

    for (;;) {

	if (bytes < 1)
	    return ptr - buf;

	if ((*ptr & 0xC0) == 0xC0) {

	    
	    if (bytes < 2)
		return ptr - buf;

	    n = ptr[0] & 0x3F;

	    while (n > 0) {
		if (state->x >= state->bytes) {
		    state->errcode = IMAGING_CODEC_OVERRUN;
		    break;
		}
		state->buffer[state->x++] = ptr[1];
		n--;
	    }

	    ptr += 2; bytes -= 2;

	} else {

	    
	    state->buffer[state->x++] = ptr[0];
	    ptr++; bytes--;

	}

	if (state->x >= state->bytes) {
        if (state->bytes % state->xsize && state->bytes > state->xsize) {
            int bands = state->bytes / state->xsize;
            int stride = state->bytes / bands;
            int i;
            for (i=1; i< bands; i++) {  
                memmove(&state->buffer[i*state->xsize],
                        &state->buffer[i*stride],
                        state->xsize);
            }
        }
	    
	    state->shuffle((UINT8*) im->image[state->y + state->yoff] +
			   state->xoff * im->pixelsize, state->buffer,
			   state->xsize);

	    state->x = 0;

	    if (++state->y >= state->ysize) {
		
		return -1;
	    }
	}

    }
}
","1. int
2. UINT8 n;
UINT8* ptr;
3. for (;;) {
4. if ((*ptr & 0xC0) == 0xC0) {
5. if (state->x >= state->bytes) {
state->errcode = IMAGING_CODEC_OVERRUN;
break;
6. state->buffer[state->x++] = ptr[1];
7. ptr += 2; bytes -= 2;
8. } else {
9. ptr++; bytes--;
10. if (state->x >= state->bytes) {
if (state->bytes % state->xsize && state->bytes > state->xsize) {
11. int stride = state->bytes / bands;
12. &state->buffer[i*stride],
state->xsize);
13. state->x = 0;","7
10-11
20
25
34-36
38
42
44
48
52-53
55
59-60
68","CWE-119,CWE-125,CWE-189"
write_version,"
#define FILE

static void write_version(
    FILE       *fp,
    const char *fname,
    const char *dirname,
    xref_t     *xref)
{
    long  start;
    char *c, *new_fname, data;
    FILE *new_fp;
    
    start = ftell(fp);

     
     if ((c = strstr(fname, "".pdf"")))
       *c = '\0';
    new_fname = safe_calloc(strlen(fname) + strlen(dirname) + 16);
     snprintf(new_fname, strlen(fname) + strlen(dirname) + 16,
              ""%s/%s-version-%d.pdf"", dirname, fname, xref->version);
 
    if (!(new_fp = fopen(new_fname, ""w"")))
    {
        ERR(""Could not create file '%s'\n"", new_fname);
        fseek(fp, start, SEEK_SET);
        free(new_fname);
        return;
    }
    
    
    fseek(fp, 0, SEEK_SET);
    while (fread(&data, 1, 1, fp))
      fwrite(&data, 1, 1, new_fp);

    
    fprintf(new_fp, ""\r\nstartxref\r\n%ld\r\n%%%%EOF"", xref->start);

    
    fclose(new_fp);
    free(new_fname);
    fseek(fp, start, SEEK_SET);
}
","1. FILE       *fp,
2. *c = '\0';
3. snprintf(new_fname, strlen(fname) + strlen(dirname) + 16,
4. return;
5. free(new_fname);
fseek(fp, start, SEEK_SET);","5
18
20
28
41-42","CWE-22,CWE-264,CWE-787,CWE-399"
validate_as_request-57710495316399,"int
validate_as_request(kdc_realm_t *kdc_active_realm,
                    register krb5_kdc_req *request, krb5_db_entry client,
                    krb5_db_entry server, krb5_timestamp kdc_time,
                    const char **status, krb5_pa_data ***e_data)
{
    int errcode;
    krb5_error_code ret;

    
    if (request->kdc_options & AS_INVALID_OPTIONS) {
        *status = ""INVALID AS OPTIONS"";
        return KDC_ERR_BADOPTION;
    }

    
    if (client.expiration && client.expiration < kdc_time) {
        *status = ""CLIENT EXPIRED"";
        if (vague_errors)
            return(KRB_ERR_GENERIC);
        else
            return(KDC_ERR_NAME_EXP);
    }

    
    if (client.pw_expiration && client.pw_expiration < kdc_time &&
        !isflagset(server.attributes, KRB5_KDB_PWCHANGE_SERVICE)) {
        *status = ""CLIENT KEY EXPIRED"";
        if (vague_errors)
            return(KRB_ERR_GENERIC);
        else
            return(KDC_ERR_KEY_EXP);
    }

    
    if (server.expiration && server.expiration < kdc_time) {
        *status = ""SERVICE EXPIRED"";
        return(KDC_ERR_SERVICE_EXP);
    }

    
    if (isflagset(client.attributes, KRB5_KDB_REQUIRES_PWCHANGE) &&
        !isflagset(server.attributes, KRB5_KDB_PWCHANGE_SERVICE)) {
        *status = ""REQUIRED PWCHANGE"";
        return(KDC_ERR_KEY_EXP);
    }

    
    if ((isflagset(request->kdc_options, KDC_OPT_ALLOW_POSTDATE) ||
         isflagset(request->kdc_options, KDC_OPT_POSTDATED)) &&
        (isflagset(client.attributes, KRB5_KDB_DISALLOW_POSTDATED) ||
         isflagset(server.attributes, KRB5_KDB_DISALLOW_POSTDATED))) {
        *status = ""POSTDATE NOT ALLOWED"";
        return(KDC_ERR_CANNOT_POSTDATE);
    }

    

    
    if (isflagset(request->kdc_options, KDC_OPT_PROXIABLE) &&
        (isflagset(client.attributes, KRB5_KDB_DISALLOW_PROXIABLE) ||
         isflagset(server.attributes, KRB5_KDB_DISALLOW_PROXIABLE))) {
        *status = ""PROXIABLE NOT ALLOWED"";
        return(KDC_ERR_POLICY);
    }

    
    if (isflagset(client.attributes, KRB5_KDB_DISALLOW_ALL_TIX)) {
        *status = ""CLIENT LOCKED OUT"";
        return(KDC_ERR_CLIENT_REVOKED);
    }

    
    if (isflagset(server.attributes, KRB5_KDB_DISALLOW_ALL_TIX)) {
        *status = ""SERVICE LOCKED OUT"";
        return(KDC_ERR_S_PRINCIPAL_UNKNOWN);
    }

    
    if (isflagset(server.attributes, KRB5_KDB_DISALLOW_SVR)) {
        *status = ""SERVICE NOT ALLOWED"";
        return(KDC_ERR_MUST_USE_USER2USER);
    }

    if (check_anon(kdc_active_realm, client.princ, request->server) != 0) {
        *status = ""ANONYMOUS NOT ALLOWED"";
        return(KDC_ERR_POLICY);
    }

    
    ret = krb5_db_check_policy_as(kdc_context, request, &client, &server,
                                  kdc_time, status, e_data);
    if (ret && ret != KRB5_PLUGIN_OP_NOTSUPP)
        return errcode_to_protocol(ret);

    
    errcode = against_local_policy_as(request, client, server,
                                      kdc_time, status, e_data);
    if (errcode)
        return errcode;

    return 0;
}
","1. return(KDC_ERR_SERVICE_EXP);
2. if (isflagset(client.attributes, KRB5_KDB_REQUIRES_PWCHANGE) &&
3. if ((isflagset(request->kdc_options, KDC_OPT_ALLOW_POSTDATE) ||
4. if (isflagset(request->kdc_options, KDC_OPT_PROXIABLE) &&","41
48
55
79","CWE-617,CWE-190,CWE-125,CWE-119,CWE-17"
ipv6_defrag,"static unsigned int ipv6_defrag(void *priv,
				struct sk_buff *skb,
				const struct nf_hook_state *state)
{
	int err;

#if IS_ENABLED(CONFIG_NF_CONNTRACK)
	
	if (skb->nfct && !nf_ct_is_template((struct nf_conn *)skb->nfct))
		return NF_ACCEPT;
#endif

	err = nf_ct_frag6_gather(state->net, skb,
				 nf_ct6_defrag_user(state->hook, skb));
	
 	if (err == -EINPROGRESS)
 		return NF_STOLEN;
 
	return err == 0 ? NF_ACCEPT : NF_DROP;
 }
","1. const struct nf_hook_state *state)
2. int err;
3. return NF_STOLEN;","3
5
17","CWE-295,CWE-264,CWE-787,CWE-125"
ldbm_back_modify-155504574515228,"
#define Slapi_PBlock

int
ldbm_back_modify( Slapi_PBlock *pb )
{
	backend *be;
	ldbm_instance *inst = NULL;
	struct ldbminfo		*li;
	struct backentry	*e = NULL, *ec = NULL;
	struct backentry	*original_entry = NULL, *tmpentry = NULL;
	Slapi_Entry		*postentry = NULL;
	LDAPMod			**mods = NULL;
	LDAPMod			**mods_original = NULL;
	Slapi_Mods smods = {0};
	back_txn txn;
	back_txnid		parent_txn;
	modify_context		ruv_c = {0};
	int			ruv_c_init = 0;
	int			retval = -1;
	char			*msg;
	char			*errbuf = NULL;
	int retry_count = 0;
	int disk_full = 0;
	int ldap_result_code= LDAP_SUCCESS;
	char *ldap_result_message= NULL;
	int rc = 0;
	Slapi_Operation *operation;
	entry_address *addr;
	int is_fixup_operation= 0;
	int is_ruv = 0;                 
	CSN *opcsn = NULL;
	int repl_op;
	int opreturn = 0;
	int mod_count = 0;
	int not_an_error = 0;
	int fixup_tombstone = 0;
	int ec_locked = 0;
	int result_sent = 0;

	slapi_pblock_get( pb, SLAPI_BACKEND, &be);
	slapi_pblock_get( pb, SLAPI_PLUGIN_PRIVATE, &li );
	slapi_pblock_get( pb, SLAPI_TARGET_ADDRESS, &addr );
	slapi_pblock_get( pb, SLAPI_MODIFY_MODS, &mods );
	slapi_pblock_get( pb, SLAPI_TXN, (void**)&parent_txn );
	slapi_pblock_get( pb, SLAPI_IS_REPLICATED_OPERATION, &repl_op);
	slapi_pblock_get( pb, SLAPI_OPERATION, &operation );

	fixup_tombstone = operation_is_flag_set(operation, OP_FLAG_TOMBSTONE_FIXUP);

	dblayer_txn_init(li,&txn); 
	
	if (parent_txn) {
		txn.back_txn_txn = parent_txn;
	} else {
		parent_txn = txn.back_txn_txn;
		slapi_pblock_set( pb, SLAPI_TXN, parent_txn );
	}

	if (NULL == operation)
	{
		ldap_result_code = LDAP_OPERATIONS_ERROR;
		goto error_return;
	}

	is_fixup_operation = operation_is_flag_set(operation, OP_FLAG_REPL_FIXUP);
	is_ruv = operation_is_flag_set(operation, OP_FLAG_REPL_RUV);
	inst = (ldbm_instance *) be->be_instance_info;

	if (NULL == addr)
	{
		goto error_return;
	}
	if (inst && inst->inst_ref_count) {
		slapi_counter_increment(inst->inst_ref_count);
	} else {
		LDAPDebug1Arg(LDAP_DEBUG_ANY,
		              ""ldbm_modify: instance \""%s\"" does not exist.\n"",
		              inst ? inst->inst_name : ""null instance"");
		goto error_return;
	}

	
	if(!repl_op){
		ldap_result_code = slapi_dn_syntax_check(pb, slapi_sdn_get_dn(addr->sdn), 1);
		if (ldap_result_code)
		{
			ldap_result_code = LDAP_INVALID_DN_SYNTAX;
			slapi_pblock_get(pb, SLAPI_PB_RESULT_TEXT, &ldap_result_message);
			goto error_return;
		}
	}

	
	if ( MANAGE_ENTRY_BEFORE_DBLOCK(li)) {
		
		if (fixup_tombstone) {
			e = find_entry2modify_only_ext( pb, be, addr, TOMBSTONE_INCLUDED, &txn, &result_sent );
		} else {
			e = find_entry2modify( pb, be, addr, &txn, &result_sent );
		}
		if (e == NULL) {
			ldap_result_code = -1;
			goto error_return; 
		}
	}

	txn.back_txn_txn = NULL; 
	for (retry_count = 0; retry_count < RETRY_TIMES; retry_count++) {
		int cache_rc = 0;
		int new_mod_count = 0;
		if (txn.back_txn_txn && (txn.back_txn_txn != parent_txn)) {
			
			dblayer_txn_abort_ext(li, &txn, PR_FALSE); 
			slapi_pblock_set(pb, SLAPI_TXN, parent_txn);
			
			
			slapi_pblock_get(pb, SLAPI_MODIFY_MODS, &mods);
			ldap_mods_free(mods, 1);
			slapi_pblock_set(pb, SLAPI_MODIFY_MODS, copy_mods(mods_original));

			
			if (ec) {
				
				if ((tmpentry = backentry_dup(original_entry?original_entry:ec)) == NULL) {
					ldap_result_code= LDAP_OPERATIONS_ERROR;
					goto error_return;
				}
				if (cache_is_in_cache(&inst->inst_cache, ec)) {
					CACHE_REMOVE(&inst->inst_cache, ec);
				}
				CACHE_RETURN(&inst->inst_cache, &ec);
				slapi_pblock_set( pb, SLAPI_MODIFY_EXISTING_ENTRY, original_entry->ep_entry );
				ec = original_entry;
				original_entry = tmpentry;
				tmpentry = NULL;
			}

			if (ruv_c_init) {
				
				modify_term(&ruv_c, be);
				ruv_c_init = 0;
			}

			LDAPDebug0Args(LDAP_DEBUG_BACKLDBM,
			               ""Modify Retrying Transaction\n"");
#ifndef LDBM_NO_BACKOFF_DELAY
			{
			PRIntervalTime interval;
			interval = PR_MillisecondsToInterval(slapi_rand() % 100);
			DS_Sleep(interval);
			}
#endif
		}

		
		
		if (0 == retry_count) {
			
			retval = dblayer_txn_begin(be, parent_txn, &txn);
		} else {
			
			retval = dblayer_txn_begin_ext(li, parent_txn, &txn, PR_FALSE);
		}
		if (0 != retval) {
			if (LDBM_OS_ERR_IS_DISKFULL(retval)) disk_full = 1;
			ldap_result_code= LDAP_OPERATIONS_ERROR;
			goto error_return;
		}
		
		slapi_pblock_set(pb, SLAPI_TXN, txn.back_txn_txn);

		if (0 == retry_count) { 
			if ( !MANAGE_ENTRY_BEFORE_DBLOCK(li)) {
				
				if (fixup_tombstone) {
					e = find_entry2modify_only_ext( pb, be, addr, TOMBSTONE_INCLUDED, &txn, &result_sent );
				} else {
					e = find_entry2modify( pb, be, addr, &txn, &result_sent );
				}
				if (e == NULL) {
					ldap_result_code = -1;
					goto error_return; 
				}
			}
		
			if ( !is_fixup_operation && !fixup_tombstone)
			{
				if (!repl_op && slapi_entry_flag_is_set(e->ep_entry, SLAPI_ENTRY_FLAG_TOMBSTONE))
				{
					ldap_result_code = LDAP_UNWILLING_TO_PERFORM;
                			ldap_result_message = ""Operation not allowed on tombstone entry."";
					slapi_log_error(SLAPI_LOG_FATAL, ""ldbm_back_modify"",
						""Attempt to modify a tombstone entry %s\n"",
						slapi_sdn_get_dn(slapi_entry_get_sdn_const( e->ep_entry )));
					goto error_return;
				}
				opcsn = operation_get_csn (operation);
				if (NULL == opcsn && operation->o_csngen_handler)
				{
					
					opcsn = entry_assign_operation_csn ( pb, e->ep_entry, NULL );
				}
				if (opcsn)
				{
					entry_set_maxcsn (e->ep_entry, opcsn);
				}
			}
		
			
			slapi_pblock_set( pb, SLAPI_ENTRY_PRE_OP, slapi_entry_dup( e->ep_entry ));
			
			if ( (ldap_result_code = plugin_call_acl_mods_access( pb, e->ep_entry, mods, &errbuf)) != LDAP_SUCCESS ) {
				ldap_result_message= errbuf;
				goto error_return;
			}
		
			
			if ( (ec = backentry_dup( e )) == NULL ) {
				ldap_result_code= LDAP_OPERATIONS_ERROR;
				goto error_return;
			}
		
			if(!repl_op){
			    remove_illegal_mods(mods);
			}
		
			
			slapi_pblock_set( pb, SLAPI_MODIFY_EXISTING_ENTRY, ec->ep_entry );
			slapi_pblock_set(pb, SLAPI_RESULT_CODE, &ldap_result_code);
		
			opreturn = plugin_call_plugins(pb, SLAPI_PLUGIN_BE_PRE_MODIFY_FN);
			if (opreturn ||
				(slapi_pblock_get(pb, SLAPI_RESULT_CODE, &ldap_result_code) && ldap_result_code) ||
				(slapi_pblock_get(pb, SLAPI_PLUGIN_OPRETURN, &opreturn) && opreturn)) {
				slapi_pblock_get(pb, SLAPI_RESULT_CODE, &ldap_result_code);
				slapi_pblock_get(pb, SLAPI_PLUGIN_OPRETURN, &opreturn);
				if (!ldap_result_code) {
					LDAPDebug0Args(LDAP_DEBUG_ANY, ""ldbm_back_modify: SLAPI_PLUGIN_BE_PRE_MODIFY_FN ""
						       ""returned error but did not set SLAPI_RESULT_CODE\n"");
					ldap_result_code = LDAP_OPERATIONS_ERROR;
				}
				if (SLAPI_PLUGIN_NOOP == opreturn) {
					not_an_error = 1;
					rc = opreturn = LDAP_SUCCESS;
				} else if (!opreturn) {
					opreturn = SLAPI_PLUGIN_FAILURE;
					slapi_pblock_set(pb, SLAPI_PLUGIN_OPRETURN, &opreturn);
				}
				slapi_pblock_get(pb, SLAPI_PB_RESULT_TEXT, &ldap_result_message);
				goto error_return;
			}
			
			slapi_pblock_get( pb, SLAPI_MODIFY_MODS, &mods );
		
			
			if (modify_apply_check_expand(pb, operation, mods, e, ec, &postentry,
										  &ldap_result_code, &ldap_result_message)) {
				goto error_return;
			}
			
			slapi_pblock_get( pb, SLAPI_MODIFY_MODS, &mods );
			slapi_mods_init_byref(&smods,mods);
			mod_count = slapi_mods_get_num_mods(&smods);
			
			mods_original = copy_mods(mods);
			if ( (original_entry = backentry_dup( ec )) == NULL ) {
				ldap_result_code= LDAP_OPERATIONS_ERROR;
				goto error_return;
			}
		} 

		
		retval = plugin_call_plugins(pb, SLAPI_PLUGIN_BE_TXN_PRE_MODIFY_FN);
		if (retval) {
			LDAPDebug1Arg( LDAP_DEBUG_TRACE, ""SLAPI_PLUGIN_BE_TXN_PRE_MODIFY_FN plugin ""
						   ""returned error code %d\n"", retval );
			slapi_pblock_get(pb, SLAPI_RESULT_CODE, &ldap_result_code);
			slapi_pblock_get(pb, SLAPI_PLUGIN_OPRETURN, &opreturn);
			if (SLAPI_PLUGIN_NOOP == retval) {
				not_an_error = 1;
				rc = retval = LDAP_SUCCESS;
			}
			if (!opreturn) {
				slapi_pblock_set(pb, SLAPI_PLUGIN_OPRETURN, ldap_result_code ? &ldap_result_code : &retval);
			}
			slapi_pblock_get(pb, SLAPI_PB_RESULT_TEXT, &ldap_result_message);
			goto error_return;
		}

		
		slapi_pblock_get( pb, SLAPI_MODIFY_MODS, &mods );

		
		slapi_mods_done(&smods);
		slapi_mods_init_byref(&smods,mods);
		new_mod_count = slapi_mods_get_num_mods(&smods);
		if (new_mod_count < mod_count) {
			LDAPDebug2Args( LDAP_DEBUG_ANY, ""Error: BE_TXN_PRE_MODIFY plugin has removed ""
							""mods from the original list - mod count was [%d] now [%d] ""
							""mods will not be applied - mods list changes must be done ""
							""in the BE_PRE_MODIFY plugin, not the BE_TXN_PRE_MODIFY\n"",
							mod_count, new_mod_count );
		} else if (new_mod_count > mod_count) { 
			
			if (modify_apply_check_expand(pb, operation, &mods[mod_count], e, ec, &postentry,
										  &ldap_result_code, &ldap_result_message)) {
				goto error_return;
			}
		} 
			
		
		retval = id2entry_add_ext( be, ec, &txn, 1, &cache_rc ); 
		if (DB_LOCK_DEADLOCK == retval)
		{
			
			continue;
		}
		if (0 != retval) {
			LDAPDebug( LDAP_DEBUG_ANY, ""id2entry_add failed, err=%d %s\n"",
				   retval, (msg = dblayer_strerror( retval )) ? msg : """", 0 );
			if (LDBM_OS_ERR_IS_DISKFULL(retval)) disk_full = 1;
			MOD_SET_ERROR(ldap_result_code, LDAP_OPERATIONS_ERROR, retry_count);
			goto error_return;
		}
		retval = index_add_mods( be, mods, e, ec, &txn );
		if (DB_LOCK_DEADLOCK == retval)
		{
			
			continue;
		}
		if (0 != retval) {
			LDAPDebug( LDAP_DEBUG_ANY, ""index_add_mods failed, err=%d %s\n"",
				  retval, (msg = dblayer_strerror( retval )) ? msg : """", 0 );
			if (LDBM_OS_ERR_IS_DISKFULL(retval)) disk_full = 1;
			MOD_SET_ERROR(ldap_result_code, LDAP_OPERATIONS_ERROR, retry_count);
			goto error_return;
		}
		
		if (!is_ruv) {
			retval= vlv_update_all_indexes(&txn, be, pb, e, ec);
			if (DB_LOCK_DEADLOCK == retval)
			{
				
				continue;
			}
			if (0 != retval) {
				LDAPDebug( LDAP_DEBUG_ANY, 
					""vlv_update_index failed, err=%d %s\n"",
					retval, (msg = dblayer_strerror( retval )) ? msg : """", 0 );
				if (LDBM_OS_ERR_IS_DISKFULL(retval)) disk_full = 1;
				MOD_SET_ERROR(ldap_result_code, 
							  LDAP_OPERATIONS_ERROR, retry_count);
				goto error_return;
			}

		}

		if (!is_ruv && !is_fixup_operation && !NO_RUV_UPDATE(li)) {
			ruv_c_init = ldbm_txn_ruv_modify_context( pb, &ruv_c );
			if (-1 == ruv_c_init) {
				LDAPDebug( LDAP_DEBUG_ANY,
					""ldbm_back_modify: ldbm_txn_ruv_modify_context ""
					""failed to construct RUV modify context\n"",
					0, 0, 0);
				ldap_result_code= LDAP_OPERATIONS_ERROR;
				retval = 0;
				goto error_return;
			}
		}

		if (ruv_c_init) {
			retval = modify_update_all( be, pb, &ruv_c, &txn );
			if (DB_LOCK_DEADLOCK == retval) {
				
				continue;
			}
			if (0 != retval) {
				LDAPDebug( LDAP_DEBUG_ANY,
					""modify_update_all failed, err=%d %s\n"", retval,
					(msg = dblayer_strerror( retval )) ? msg : """", 0 );
				if (LDBM_OS_ERR_IS_DISKFULL(retval))
					disk_full = 1;
				ldap_result_code= LDAP_OPERATIONS_ERROR;
				goto error_return;
			}
		}

		if (0 == retval) {
			break;
		}
	}
	if (retry_count == RETRY_TIMES) {
		LDAPDebug( LDAP_DEBUG_ANY, ""Retry count exceeded in modify\n"", 0, 0, 0 );
	   	ldap_result_code= LDAP_BUSY;
		goto error_return;
	}

	if (ruv_c_init) {
		if (modify_switch_entries(&ruv_c, be) != 0 ) {
			ldap_result_code= LDAP_OPERATIONS_ERROR;
			LDAPDebug( LDAP_DEBUG_ANY,
				""ldbm_back_modify: modify_switch_entries failed\n"", 0, 0, 0);
			goto error_return;
		}
	}
	
	if (cache_replace( &inst->inst_cache, e, ec ) != 0 ) {
		MOD_SET_ERROR(ldap_result_code, LDAP_OPERATIONS_ERROR, retry_count);
		goto error_return;
	}
	
	
	
	cache_unlock_entry( &inst->inst_cache, e );
	CACHE_RETURN( &inst->inst_cache, &e );
	
	cache_lock_entry( &inst->inst_cache, ec );
	ec_locked = 1;
	postentry = slapi_entry_dup( ec->ep_entry );
	slapi_pblock_set( pb, SLAPI_ENTRY_POST_OP, postentry );

	
	ec->ep_entry->e_virtual_watermark = 0;

	
	e = NULL;
	
	
	if ((retval = plugin_call_plugins(pb, SLAPI_PLUGIN_BE_TXN_POST_MODIFY_FN))) {
		LDAPDebug1Arg( LDAP_DEBUG_TRACE, ""SLAPI_PLUGIN_BE_TXN_POST_MODIFY_FN plugin ""
					   ""returned error code %d\n"", retval );
		if (!ldap_result_code) {
			slapi_pblock_get(pb, SLAPI_RESULT_CODE, &ldap_result_code);
		}
		if (!opreturn) {
			slapi_pblock_get(pb, SLAPI_PLUGIN_OPRETURN, &opreturn);
		}
		if (!opreturn) {
			slapi_pblock_set(pb, SLAPI_PLUGIN_OPRETURN, ldap_result_code ? &ldap_result_code : &retval);
		}
		slapi_pblock_get(pb, SLAPI_PB_RESULT_TEXT, &ldap_result_message);
		goto error_return;
	}

	
	retval = dblayer_txn_commit(be, &txn);
	
	slapi_pblock_set(pb, SLAPI_TXN, parent_txn);
	if (0 != retval) {
		if (LDBM_OS_ERR_IS_DISKFULL(retval)) disk_full = 1;
		ldap_result_code= LDAP_OPERATIONS_ERROR;
		goto error_return;
	}

	rc= 0;
	goto common_return;

error_return:
	if ( postentry != NULL ) 
	{
		slapi_entry_free( postentry );
		postentry = NULL;
		slapi_pblock_set( pb, SLAPI_ENTRY_POST_OP, NULL );
	}
	if (retval == DB_RUNRECOVERY) {
	  dblayer_remember_disk_filled(li);
	  ldbm_nasty(""Modify"",81,retval);
	  disk_full = 1;
	}

	if (disk_full) {
	    rc= return_on_disk_full(li);
	} else {
		if (txn.back_txn_txn && (txn.back_txn_txn != parent_txn)) {
			
			int val = 0;
			slapi_pblock_get(pb, SLAPI_RESULT_CODE, &val);
			if (!val) {
				if (!ldap_result_code) {
					ldap_result_code = LDAP_OPERATIONS_ERROR;
				}
				slapi_pblock_set(pb, SLAPI_RESULT_CODE, &ldap_result_code);
			}
			slapi_pblock_get( pb, SLAPI_PLUGIN_OPRETURN, &val );
			if (!val) {
				opreturn = -1;
				slapi_pblock_set( pb, SLAPI_PLUGIN_OPRETURN, &opreturn );
			}
			
			
			if ((retval = plugin_call_plugins(pb, SLAPI_PLUGIN_BE_TXN_POST_MODIFY_FN))) {
				LDAPDebug1Arg( LDAP_DEBUG_TRACE, ""SLAPI_PLUGIN_BE_TXN_POST_MODIFY_FN plugin ""
							   ""returned error code %d\n"", retval );
				slapi_pblock_get(pb, SLAPI_RESULT_CODE, &ldap_result_code);
				slapi_pblock_get(pb, SLAPI_PB_RESULT_TEXT, &ldap_result_message);
				slapi_pblock_get(pb, SLAPI_PLUGIN_OPRETURN, &opreturn);
				if (!opreturn) {
					slapi_pblock_set(pb, SLAPI_PLUGIN_OPRETURN, ldap_result_code ? &ldap_result_code : &retval);
				}
			}

			
			
			dblayer_txn_abort(be, &txn); 
			
			slapi_pblock_set(pb, SLAPI_TXN, parent_txn);
		}
		if (!not_an_error) {
			rc = SLAPI_FAIL_GENERAL;
		}
	}

	
	if (inst && cache_is_in_cache(&inst->inst_cache, ec)) {
		CACHE_REMOVE( &inst->inst_cache, ec );
		
		if (e) {
			if (CACHE_ADD( &inst->inst_cache, e, NULL ) < 0) {
				LDAPDebug1Arg(LDAP_DEBUG_CACHE, ""ldbm_modify: CACHE_ADD %s failed\n"",
				              slapi_entry_get_dn(e->ep_entry));
			}
		}
	}

common_return:
	slapi_mods_done(&smods);
	
	if (inst) {
		if (ec_locked || cache_is_in_cache(&inst->inst_cache, ec)) {
			cache_unlock_entry(&inst->inst_cache, ec);
		} else if (e) {
			
			cache_unlock_entry(&inst->inst_cache, e);
			CACHE_RETURN(&inst->inst_cache, &e);
		}
		CACHE_RETURN(&inst->inst_cache, &ec);
		if (inst->inst_ref_count) {
			slapi_counter_decrement(inst->inst_ref_count);
		}
	}

	
	slapi_pblock_set(pb, SLAPI_RESULT_CODE, &ldap_result_code);

	
	if (!disk_full)
		plugin_call_plugins (pb, SLAPI_PLUGIN_BE_POST_MODIFY_FN);

	if (ruv_c_init) {
		modify_term(&ruv_c, be);
	}

	if (ldap_result_code == -1) {
		
		ldap_result_code = LDAP_NO_SUCH_OBJECT;
		slapi_pblock_set(pb, SLAPI_RESULT_CODE, &ldap_result_code);
	} else {
		if (not_an_error) {
			
			ldap_result_code = LDAP_SUCCESS;
		}
		if (!result_sent) {
			
			slapi_send_ldap_result( pb, ldap_result_code, NULL, ldap_result_message, 0, NULL );
		}
	}

	
	ldap_mods_free(mods_original, 1);
	backentry_free(&original_entry);
	backentry_free(&tmpentry);
	slapi_ch_free_string(&errbuf);

	return rc;
}
","1. ldbm_instance *inst = NULL;
2. modify_context		ruv_c = {0};
3. char			*errbuf = NULL;
4. int ldap_result_code= LDAP_SUCCESS;
5. fixup_tombstone = operation_is_flag_set(operation, OP_FLAG_TOMBSTONE_FIXUP);
6. parent_txn = txn.back_txn_txn;
7. } else {
8. if(!repl_op){
ldap_result_code = slapi_dn_syntax_check(pb, slapi_sdn_get_dn(addr->sdn), 1);
9. goto error_return;
10. if (fixup_tombstone) {
11. } else {
12. ldap_result_code = -1;
13. slapi_pblock_set(pb, SLAPI_MODIFY_MODS, copy_mods(mods_original));
14. if (ec) {
15. modify_term(&ruv_c, be);
16. PRIntervalTime interval;
17. if ( !MANAGE_ENTRY_BEFORE_DBLOCK(li)) {
18. if (fixup_tombstone) {
19. if ( !is_fixup_operation && !fixup_tombstone)
20. slapi_log_error(SLAPI_LOG_FATAL, ""ldbm_back_modify"",
21. goto error_return;
22. if(!repl_op){
23. if (SLAPI_PLUGIN_NOOP == opreturn) {
24. rc = opreturn = LDAP_SUCCESS;
25. mods_original = copy_mods(mods);
26. not_an_error = 1;
27. goto error_return;
28. slapi_mods_done(&smods);
29. if (new_mod_count < mod_count) {
LDAPDebug2Args( LDAP_DEBUG_ANY, ""Error: BE_TXN_PRE_MODIFY plugin has removed ""
30. if (LDBM_OS_ERR_IS_DISKFULL(retval)) disk_full = 1;
31. goto error_return;
32. if (DB_LOCK_DEADLOCK == retval) {
33. if (0 != retval) {
34. (msg = dblayer_strerror( retval )) ? msg : """", 0 );
35. LDAPDebug( LDAP_DEBUG_ANY, ""Retry count exceeded in modify\n"", 0, 0, 0 );
36. cache_unlock_entry( &inst->inst_cache, e );
37. slapi_pblock_get(pb, SLAPI_RESULT_CODE, &ldap_result_code);
38. retval = dblayer_txn_commit(be, &txn);
39. if (LDBM_OS_ERR_IS_DISKFULL(retval)) disk_full = 1;
40. slapi_pblock_get(pb, SLAPI_RESULT_CODE, &val);
41. ""returned error code %d\n"", retval );
slapi_pblock_get(pb, SLAPI_RESULT_CODE, &ldap_result_code);
42. if (e) {
43. slapi_mods_done(&smods);
44. if (inst) {
45. CACHE_RETURN(&inst->inst_cache, &ec);
if (inst->inst_ref_count) {
46. if (!disk_full)
47. if (ruv_c_init) {
48. if (ldap_result_code == -1) {
49. slapi_pblock_set(pb, SLAPI_RESULT_CODE, &ldap_result_code);
50. backentry_free(&original_entry);","8
18
22
25
49
57
77
85-86
91
113
115
119
140
143
162
170
196
198
209
215
246
249
268
270
296
311
318
326
329-330
370
407
413
417
420
433
454
480
493
497
524
543-544
567
576
578
587-588
597
600
604
607
622","CWE-362,CWE-200,CWE-399,CWE-119"
init_connection_options_1-223007314261056,"
#define MYSQL

static void
init_connection_options_1(MYSQL *mysql)
{
  SSL_SET_OPTIONS(mysql);

  if (opt_protocol)
    mysql_options(mysql, MYSQL_OPT_PROTOCOL, (char*) &opt_protocol);

#ifdef HAVE_SMEM
  if (shared_memory_base_name)
    mysql_options(mysql, MYSQL_SHARED_MEMORY_BASE_NAME, shared_memory_base_name);
#endif
}
","1. static void
init_connection_options_1(MYSQL *mysql)
2. SSL_SET_OPTIONS(mysql);
3. if (opt_protocol)
mysql_options(mysql, MYSQL_OPT_PROTOCOL, (char*) &opt_protocol);","4-5
7
9-10","CWE-476,CWE-200,CWE-399,CWE-287"
read_escaped_char,"int read_escaped_char(
    yyscan_t yyscanner,
    uint8_t* escaped_char)
{
  char text[4] = {0, 0, 0, 0};

   text[0] = '\\';
   text[1] = RE_YY_INPUT(yyscanner);
 
  if (text[1] == EOF || text[1] == 0)
     return 0;
 
   if (text[1] == 'x')
   {
     text[2] = RE_YY_INPUT(yyscanner);
 
    if (!isxdigit(text[2]))
       return 0;
 
     text[3] = RE_YY_INPUT(yyscanner);
 
    if (!isxdigit(text[3]))
       return 0;
   }
 
  *escaped_char = escaped_char_value(text);

  return 1;
}
","1. int read_escaped_char(
2. return 0;
3. text[3] = RE_YY_INPUT(yyscanner);","1
18
20",CWE-200
rose_parse_facilities-137421685662771,"int rose_parse_facilities(unsigned char *p,
	struct rose_facilities_struct *facilities)
{
	int facilities_len, len;

	facilities_len = *p++;

	if (facilities_len == 0)
		return 0;

	while (facilities_len > 0) {
		if (*p == 0x00) {
			facilities_len--;
			p++;

			switch (*p) {
			case FAC_NATIONAL:		
				len = rose_parse_national(p + 1, facilities, facilities_len - 1);
				if (len < 0)
					return 0;
				facilities_len -= len + 1;
				p += len + 1;
				break;

			case FAC_CCITT:		
				len = rose_parse_ccitt(p + 1, facilities, facilities_len - 1);
				if (len < 0)
					return 0;
				facilities_len -= len + 1;
				p += len + 1;
				break;

			default:
				printk(KERN_DEBUG ""ROSE: rose_parse_facilities - unknown facilities family %02X\n"", *p);
				facilities_len--;
				p++;
				break;
			}
		} else
			break;	
	}

	return 1;
}
","1. struct rose_facilities_struct *facilities)
2. int facilities_len, len;
3. facilities_len = *p++;
4. return 0;
5. if (*p == 0x00) {
6. if (len < 0)
return 0;
7. p += len + 1;
break;
8. break;
9. facilities_len--;
p++;
break;
10. return 1;","2
4
6
9
12
19-20
22-23
31
35-37
43","CWE-119,CWE-20,CWE-399,CWE-401"
fiber_switch-231276130172678,"static mrb_value
fiber_switch(mrb_state *mrb, mrb_value self, mrb_int len, const mrb_value *a, mrb_bool resume, mrb_bool vmexec)
{
  struct mrb_context *c = fiber_check(mrb, self);
  struct mrb_context *old_c = mrb->c;
  enum mrb_fiber_state status;
  mrb_value value;

  fiber_check_cfunc(mrb, c);
  status = c->status;
  if (resume && status == MRB_FIBER_TRANSFERRED) {
    mrb_raise(mrb, E_FIBER_ERROR, ""resuming transferred fiber"");
  }
  if (status == MRB_FIBER_RUNNING || status == MRB_FIBER_RESUMED) {
    mrb_raise(mrb, E_FIBER_ERROR, ""double resume (fib)"");
  }
  if (status == MRB_FIBER_TERMINATED) {
    mrb_raise(mrb, E_FIBER_ERROR, ""resuming dead fiber"");
  }
  old_c->status = resume ? MRB_FIBER_RESUMED : MRB_FIBER_TRANSFERRED;
  c->prev = resume ? mrb->c : (c->prev ? c->prev : mrb->root_c);
  fiber_switch_context(mrb, c);
  if (status == MRB_FIBER_CREATED) {
    mrb_value *b, *e;

    mrb_stack_extend(mrb, len+2); 
    b = c->stack+1;
    e = b + len;
    while (b<e) {
      *b++ = *a++;
    }
    c->cibase->argc = (int)len;
    value = c->stack[0] = MRB_PROC_ENV(c->ci->proc)->stack[0];
  }
  else {
    value = fiber_result(mrb, a, len);
  }

  if (vmexec) {
    c->vmexec = TRUE;
    value = mrb_vm_exec(mrb, c->ci[-1].proc, c->ci->pc);
    mrb->c = old_c;
  }
  else {
    MARK_CONTEXT_MODIFY(c);
  }
  return value;
}
","1. static mrb_value
2. struct mrb_context *old_c = mrb->c;
3. mrb_raise(mrb, E_FIBER_ERROR, ""double resume (fib)"");
4. if (status == MRB_FIBER_TERMINATED) {
5. old_c->status = resume ? MRB_FIBER_RESUMED : MRB_FIBER_TRANSFERRED;
c->prev = resume ? mrb->c : (c->prev ? c->prev : mrb->root_c);
6. if (status == MRB_FIBER_CREATED) {
mrb_value *b, *e;
7. c->cibase->argc = (int)len;
8. c->vmexec = TRUE;
9. else {","1
5
15
17
20-21
23-24
32
40
44","CWE-476,CWE-787,CWE-399,CWE-400"
dgram_recvmsg-78064163709713,"static int dgram_recvmsg(struct kiocb *iocb, struct sock *sk,
		struct msghdr *msg, size_t len, int noblock, int flags,
		int *addr_len)
{
	size_t copied = 0;
	int err = -EOPNOTSUPP;
	struct sk_buff *skb;
	struct sockaddr_ieee802154 *saddr;

	saddr = (struct sockaddr_ieee802154 *)msg->msg_name;

	skb = skb_recv_datagram(sk, flags, noblock, &err);
	if (!skb)
		goto out;

	copied = skb->len;
	if (len < copied) {
		msg->msg_flags |= MSG_TRUNC;
		copied = len;
	}

	
	err = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);
	if (err)
		goto done;

	sock_recv_ts_and_drops(msg, sk, skb);

	if (saddr) {
		saddr->family = AF_IEEE802154;
		saddr->addr = mac_cb(skb)->sa;
		*addr_len = sizeof(*saddr);
	}

	if (flags & MSG_TRUNC)
		copied = skb->len;
done:
	skb_free_datagram(sk, skb);
out:
	if (err)
		return err;
	return copied;
}
","1. struct msghdr *msg, size_t len, int noblock, int flags,
2. msg->msg_flags |= MSG_TRUNC;","2
18","CWE-665,CWE-20,CWE-369,CWE-119,CWE-125"
udp_gro_receive,"struct sk_buff **udp_gro_receive(struct sk_buff **head, struct sk_buff *skb,
				 struct udphdr *uh)
{
	struct udp_offload_priv *uo_priv;
	struct sk_buff *p, **pp = NULL;
	struct udphdr *uh2;
 	unsigned int off = skb_gro_offset(skb);
 	int flush = 1;
 
	if (NAPI_GRO_CB(skb)->encap_mark ||
 	    (skb->ip_summed != CHECKSUM_PARTIAL &&
 	     NAPI_GRO_CB(skb)->csum_cnt == 0 &&
 	     !NAPI_GRO_CB(skb)->csum_valid))
 		goto out;
 
	
	NAPI_GRO_CB(skb)->encap_mark = 1;
 
 	rcu_read_lock();
 	uo_priv = rcu_dereference(udp_offload_base);
	for (; uo_priv != NULL; uo_priv = rcu_dereference(uo_priv->next)) {
		if (net_eq(read_pnet(&uo_priv->net), dev_net(skb->dev)) &&
		    uo_priv->offload->port == uh->dest &&
		    uo_priv->offload->callbacks.gro_receive)
			goto unflush;
	}
	goto out_unlock;

unflush:
	flush = 0;

	for (p = *head; p; p = p->next) {
		if (!NAPI_GRO_CB(p)->same_flow)
			continue;

		uh2 = (struct udphdr   *)(p->data + off);

		
		if ((*(u32 *)&uh->source != *(u32 *)&uh2->source) ||
		    (!uh->check ^ !uh2->check)) {
			NAPI_GRO_CB(p)->same_flow = 0;
			continue;
		}
	}

	skb_gro_pull(skb, sizeof(struct udphdr)); 
	skb_gro_postpull_rcsum(skb, uh, sizeof(struct udphdr));
	NAPI_GRO_CB(skb)->proto = uo_priv->offload->ipproto;
	pp = uo_priv->offload->callbacks.gro_receive(head, skb,
						     uo_priv->offload);

out_unlock:
	rcu_read_unlock();
out:
	NAPI_GRO_CB(skb)->flush |= flush;
	return pp;
}
","1. if (NAPI_GRO_CB(skb)->encap_mark ||
2. NAPI_GRO_CB(skb)->csum_cnt == 0 &&
3. goto out;
4. NAPI_GRO_CB(skb)->encap_mark = 1;
5. if (net_eq(read_pnet(&uo_priv->net), dev_net(skb->dev)) &&
uo_priv->offload->port == uh->dest &&
6. for (p = *head; p; p = p->next) {
if (!NAPI_GRO_CB(p)->same_flow)
continue;
7. uh2 = (struct udphdr   *)(p->data + off);
8. if ((*(u32 *)&uh->source != *(u32 *)&uh2->source) ||
9. NAPI_GRO_CB(p)->same_flow = 0;
10. pp = uo_priv->offload->callbacks.gro_receive(head, skb,
11. out:
NAPI_GRO_CB(skb)->flush |= flush;","10
12
14
17
22-23
32-34
36
41
43
51
56-57","CWE-191,CWE-20,CWE-116,CWE-400"
BindSkiaToInProcessGL,"void BindSkiaToInProcessGL() {
  static bool host_StubGL_installed = false;
  if (!host_StubGL_installed) {
    GrGLBinding binding;
    switch (gfx::GetGLImplementation()) {
      case gfx::kGLImplementationNone:
        NOTREACHED();
        return;
      case gfx::kGLImplementationDesktopGL:
        binding = kDesktop_GrGLBinding;
        break;
      case gfx::kGLImplementationOSMesaGL:
        binding = kDesktop_GrGLBinding;
        break;
      case gfx::kGLImplementationEGLGLES2:
        binding = kES2_GrGLBinding;
        break;
       case gfx::kGLImplementationMockGL:
         NOTREACHED();
         return;
      default:
        NOTREACHED();
        return;
     }
 
     static GrGLInterface host_gl_interface = {
      binding,

      kProbe_GrGLCapability,   
      kProbe_GrGLCapability,   
      kProbe_GrGLCapability,   

      StubGLActiveTexture,
      StubGLAttachShader,
      StubGLBindAttribLocation,
      StubGLBindBuffer,
      StubGLBindTexture,
      StubGLBlendColor,
      StubGLBlendFunc,
      StubGLBufferData,
      StubGLBufferSubData,
      StubGLClear,
      StubGLClearColor,
      StubGLClearStencil,
      NULL,  
      NULL,  
      StubGLColorMask,
      NULL,  
      StubGLCompileShader,
      StubGLCompressedTexImage2D,
      StubGLCreateProgram,
      StubGLCreateShader,
      StubGLCullFace,
      StubGLDeleteBuffers,
      StubGLDeleteProgram,
      StubGLDeleteShader,
      StubGLDeleteTextures,
      StubGLDepthMask,
      StubGLDisable,
      NULL,  
      StubGLDisableVertexAttribArray,
      StubGLDrawArrays,
      StubGLDrawElements,
      StubGLEnable,
      NULL,  
      StubGLEnableVertexAttribArray,
      StubGLFrontFace,
      StubGLGenBuffers,
      StubGLGenTextures,
      StubGLGetBufferParameteriv,
      StubGLGetError,
      StubGLGetIntegerv,
      StubGLGetProgramInfoLog,
      StubGLGetProgramiv,
      StubGLGetShaderInfoLog,
      StubGLGetShaderiv,
      StubGLGetString,
      StubGLGetUniformLocation,
      StubGLLineWidth,
      StubGLLinkProgram,
      NULL,  
      NULL,  
      StubGLPixelStorei,
      NULL,  
      StubGLReadPixels,
      StubGLScissor,
      NULL,  
      StubGLShaderSource,
      StubGLStencilFunc,
      StubGLStencilFuncSeparate,
      StubGLStencilMask,
      StubGLStencilMaskSeparate,
      StubGLStencilOp,
      StubGLStencilOpSeparate,
      NULL,  
      NULL,  
      StubGLTexImage2D,
      StubGLTexParameteri,
      StubGLTexSubImage2D,
      StubGLUniform1f,
      StubGLUniform1i,
      StubGLUniform1fv,
      StubGLUniform1iv,
      StubGLUniform2f,
      StubGLUniform2i,
      StubGLUniform2fv,
      StubGLUniform2iv,
      StubGLUniform3f,
      StubGLUniform3i,
      StubGLUniform3fv,
      StubGLUniform3iv,
      StubGLUniform4f,
      StubGLUniform4i,
      StubGLUniform4fv,
      StubGLUniform4iv,
      StubGLUniformMatrix2fv,
      StubGLUniformMatrix3fv,
      StubGLUniformMatrix4fv,
      StubGLUseProgram,
      StubGLVertexAttrib4fv,
      StubGLVertexAttribPointer,
      NULL,  
      StubGLViewport,
      StubGLBindFramebuffer,
      StubGLBindRenderbuffer,
      StubGLCheckFramebufferStatus,
      StubGLDeleteFramebuffers,
      StubGLDeleteRenderbuffers,
      StubGLFramebufferRenderbuffer,
      StubGLFramebufferTexture2D,
      StubGLGenFramebuffers,
      StubGLGenRenderbuffers,
      StubGLRenderBufferStorage,
      StubGLRenderbufferStorageMultisample,
      StubGLBlitFramebuffer,
      NULL,  
      StubGLMapBuffer,
      StubGLUnmapBuffer,
      NULL,  
      GrGLInterface::kStaticInitEndGuard,
    };
    GrGLSetGLInterface(&host_gl_interface);
    host_StubGL_installed = true;
  }
}
","1. default:
NOTREACHED();
return;
2. GrGLSetGLInterface(&host_gl_interface);","21-23
142","CWE-119,CWE-125,CWE-287,CWE-416"
ip_ufo_append_data-251074942310668,"static inline int ip_ufo_append_data(struct sock *sk,
			struct sk_buff_head *queue,
			int getfrag(void *from, char *to, int offset, int len,
			       int odd, struct sk_buff *skb),
			void *from, int length, int hh_len, int fragheaderlen,
			int transhdrlen, int maxfraglen, unsigned int flags)
{
	struct sk_buff *skb;
	int err;

	
	if ((skb = skb_peek_tail(queue)) == NULL) {
		skb = sock_alloc_send_skb(sk,
			hh_len + fragheaderlen + transhdrlen + 20,
			(flags & MSG_DONTWAIT), &err);

		if (skb == NULL)
			return err;

		
		skb_reserve(skb, hh_len);

		
		skb_put(skb, fragheaderlen + transhdrlen);

		
		skb_reset_network_header(skb);

		
		skb->transport_header = skb->network_header + fragheaderlen;

		skb->csum = 0;


		__skb_queue_tail(queue, skb);
	} else if (skb_is_gso(skb)) {
		goto append;
	}

	skb->ip_summed = CHECKSUM_PARTIAL;
	
	skb_shinfo(skb)->gso_size = maxfraglen - fragheaderlen;
	skb_shinfo(skb)->gso_type = SKB_GSO_UDP;

append:
	return skb_append_datato_frags(sk, skb, getfrag, from,
				       (length - transhdrlen));
}
","1. static inline int ip_ufo_append_data(struct sock *sk,
struct sk_buff_head *queue,
2. void *from, int length, int hh_len, int fragheaderlen,
int transhdrlen, int maxfraglen, unsigned int flags)
3. struct sk_buff *skb;
int err;
4. if ((skb = skb_peek_tail(queue)) == NULL) {
skb = sock_alloc_send_skb(sk,
hh_len + fragheaderlen + transhdrlen + 20,
5. skb_put(skb, fragheaderlen + transhdrlen);
6. skb_reset_network_header(skb);
7. skb->csum = 0;
8. } else if (skb_is_gso(skb)) {
goto append;
9. skb->ip_summed = CHECKSUM_PARTIAL;
10. return skb_append_datato_frags(sk, skb, getfrag, from,
(length - transhdrlen));","1-2
5-6
8-9
15-17
27
30
35
39-40
43
49-50","CWE-264,CWE-787,CWE-119"
semctl_setval-151382613767745,"static int semctl_setval(struct ipc_namespace *ns, int semid, int semnum,
		unsigned long arg)
{
	struct sem_undo *un;
	struct sem_array *sma;
	struct sem* curr;
	int err;
	struct list_head tasks;
	int val;
#if defined(CONFIG_64BIT) && defined(__BIG_ENDIAN)
	
	val = arg >> 32;
#else
	
	val = arg;
#endif

	if (val > SEMVMX || val < 0)
		return -ERANGE;

	INIT_LIST_HEAD(&tasks);

	rcu_read_lock();
	sma = sem_obtain_object_check(ns, semid);
	if (IS_ERR(sma)) {
		rcu_read_unlock();
		return PTR_ERR(sma);
	}

	if (semnum < 0 || semnum >= sma->sem_nsems) {
		rcu_read_unlock();
		return -EINVAL;
	}


	if (ipcperms(ns, &sma->sem_perm, S_IWUGO)) {
		rcu_read_unlock();
		return -EACCES;
	}

	err = security_sem_semctl(sma, SETVAL);
	if (err) {
		rcu_read_unlock();
		return -EACCES;
	}

	sem_lock(sma, NULL, -1);

	curr = &sma->sem_base[semnum];

	assert_spin_locked(&sma->sem_perm.lock);
	list_for_each_entry(un, &sma->list_id, list_id)
		un->semadj[semnum] = 0;

	curr->semval = val;
	curr->sempid = task_tgid_vnr(current);
	sma->sem_ctime = get_seconds();
	
	do_smart_update(sma, NULL, 0, 0, &tasks);
	sem_unlock(sma, -1);
	wake_up_sem_queue_do(&tasks);
	return 0;
}
","1. struct sem_array *sma;
struct sem* curr;
2. sma = sem_obtain_object_check(ns, semid);
3. return PTR_ERR(sma);
4. sem_lock(sma, NULL, -1);
5. list_for_each_entry(un, &sma->list_id, list_id)
6. sem_unlock(sma, -1);","5-6
24
27
47
52
60","CWE-264,CWE-120,CWE-125,CWE-611"
cache_get_callno_locked_6-43475883329547,"static int cache_get_callno_locked_6(const char *data)
{
	struct sockaddr_in sin;
	int x;
	int callno;
	struct iax_ie_data ied;
	struct create_addr_info cai;
	struct parsed_dial_string pds;
	char *tmpstr;

	for (x=0; x<IAX_MAX_CALLS; x++) {
		
		if (!ast_mutex_trylock(&iaxsl[x])) {
			if (iaxs[x] && !strcasecmp(data, iaxs[x]->dproot))
				return x;
			ast_mutex_unlock(&iaxsl[x]);
		}
	}

	

	memset(&cai, 0, sizeof(cai));
	memset(&ied, 0, sizeof(ied));
	memset(&pds, 0, sizeof(pds));

	tmpstr = ast_strdupa(data);
	parse_dial_string(tmpstr, &pds);

	if (ast_strlen_zero(pds.peer)) {
		ast_log(LOG_WARNING, ""No peer provided in the IAX2 dial string '%s'\n"", data);
		return -1;
	}

	
	if (create_addr(pds.peer, NULL, &sin, &cai))
		return -1;

	ast_debug(1, ""peer: %s, username: %s, password: %s, context: %s\n"",
		pds.peer, pds.username, pds.password, pds.context);

	callno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);
	if (callno < 1) {
		ast_log(LOG_WARNING, ""Unable to create call\n"");
		return -1;
	}

	ast_string_field_set(iaxs[callno], dproot, data);
	iaxs[callno]->capability = IAX_CAPABILITY_FULLBANDWIDTH;

	iax_ie_append_short(&ied, IAX_IE_VERSION, IAX_PROTO_VERSION);
	iax_ie_append_str(&ied, IAX_IE_CALLED_NUMBER, ""TBD"");
	
	if (pds.exten)
		iax_ie_append_str(&ied, IAX_IE_CALLED_CONTEXT, pds.exten);
	if (pds.username)
		iax_ie_append_str(&ied, IAX_IE_USERNAME, pds.username);
	iax_ie_append_int(&ied, IAX_IE_FORMAT, IAX_CAPABILITY_FULLBANDWIDTH);
	iax_ie_append_int(&ied, IAX_IE_CAPABILITY, IAX_CAPABILITY_FULLBANDWIDTH);
	
	if (pds.password)
		ast_string_field_set(iaxs[callno], secret, pds.password);
	if (pds.key)
		ast_string_field_set(iaxs[callno], outkey, pds.key);
	
	send_command(iaxs[callno], AST_FRAME_IAX, IAX_COMMAND_NEW, 0, ied.buf, ied.pos, -1);

	return callno;
}
","1. static int cache_get_callno_locked_6(const char *data)
2. struct sockaddr_in sin;
3. if (iaxs[x] && !strcasecmp(data, iaxs[x]->dproot))
4. if (create_addr(pds.peer, NULL, &sin, &cai))
return -1;
5. iax_ie_append_str(&ied, IAX_IE_CALLED_NUMBER, ""TBD"");","1
3
15
36-37
52",CWE-287
ldm_frag_add-246280995472918,"static bool ldm_frag_add (const u8 *data, int size, struct list_head *frags)
{
	struct frag *f;
	struct list_head *item;
	int rec, num, group;

	BUG_ON (!data || !frags);

	if (size < 2 * VBLK_SIZE_HEAD) {
		ldm_error(""Value of size is to small."");
		return false;
	}

	group = get_unaligned_be32(data + 0x08);
	rec   = get_unaligned_be16(data + 0x0C);
	num   = get_unaligned_be16(data + 0x0E);
	if ((num < 1) || (num > 4)) {
		ldm_error (""A VBLK claims to have %d parts."", num);
		return false;
	}
	if (rec >= num) {
		ldm_error(""REC value (%d) exceeds NUM value (%d)"", rec, num);
		return false;
	}

	list_for_each (item, frags) {
		f = list_entry (item, struct frag, list);
		if (f->group == group)
			goto found;
	}

	f = kmalloc (sizeof (*f) + size*num, GFP_KERNEL);
	if (!f) {
		ldm_crit (""Out of memory."");
		return false;
	}

	f->group = group;
	f->num   = num;
	f->rec   = rec;
	f->map   = 0xFF << num;

	list_add_tail (&f->list, frags);
found:
	if (rec >= f->num) {
		ldm_error(""REC value (%d) exceeds NUM value (%d)"", rec, f->num);
		return false;
	}

	if (f->map & (1 << rec)) {
		ldm_error (""Duplicate VBLK, part %d."", rec);
		f->map &= 0x7F;			
		return false;
	}

	f->map |= (1 << rec);

	data += VBLK_SIZE_HEAD;
	size -= VBLK_SIZE_HEAD;

	memcpy (f->data+rec*(size-VBLK_SIZE_HEAD)+VBLK_SIZE_HEAD, data, size);

	return true;
}
","1. int rec, num, group;
2. BUG_ON (!data || !frags);
3. return false;
4. ldm_error(""REC value (%d) exceeds NUM value (%d)"", rec, num);
5. goto found;
6. f->num   = num;
7. return false;
8. if (f->map & (1 << rec)) {
9. f->map &= 0x7F;
10. data += VBLK_SIZE_HEAD;
size -= VBLK_SIZE_HEAD;
11. return true;","5
7
11
22
29
39
47
50
52
58-59
63","CWE-78,CWE-200,CWE-119,CWE-295,CWE-125"
dhcpv6_print-163578680869432,"static int
dhcpv6_print(netdissect_options *ndo,
             const u_char *cp, u_int length, int indent)
{
    u_int i, t;
    const u_char *tlv, *value;
    uint16_t type, optlen;

    i = 0;
    while (i < length) {
        if (i + 4 > length)
            return -1;
        tlv = cp + i;
        type = EXTRACT_16BITS(tlv);
        optlen = EXTRACT_16BITS(tlv + 2);
        value = tlv + 4;

        ND_PRINT((ndo, ""\n""));
        for (t = indent; t > 0; t--)
            ND_PRINT((ndo, ""\t""));

        ND_PRINT((ndo, ""%s"", tok2str(dh6opt_str, ""Unknown"", type)));
        ND_PRINT((ndo,"" (%u)"", optlen + 4 ));
        if (i + 4 + optlen > length)
            return -1;

        switch (type) {
            case DH6OPT_DNS_SERVERS:
            case DH6OPT_SNTP_SERVERS: {
                if (optlen % 16 != 0) {
                    ND_PRINT((ndo, "" %s"", istr));
                    return -1;
                }
                for (t = 0; t < optlen; t += 16)
                    ND_PRINT((ndo, "" %s"", ip6addr_string(ndo, value + t)));
            }
                break;
            case DH6OPT_DOMAIN_LIST: {
                const u_char *tp = value;
                while (tp < value + optlen) {
                    ND_PRINT((ndo, "" ""));
                    if ((tp = ns_nprint(ndo, tp, value + optlen)) == NULL)
                        return -1;
                }
            }
                break;
        }

        i += 4 + optlen;
    }
    return 0;
}
","1. static int
2. u_int i, t;
3. uint16_t type, optlen;
4. if (i + 4 > length)
5. tlv = cp + i;
6. ND_PRINT((ndo, ""\n""));
for (t = indent; t > 0; t--)
ND_PRINT((ndo, ""\t""));
7. ND_PRINT((ndo, ""%s"", tok2str(dh6opt_str, ""Unknown"", type)));
8. if (i + 4 + optlen > length)
return -1;
9. switch (type) {
10. if (optlen % 16 != 0) {
11. return -1;
12. ND_PRINT((ndo, "" %s"", ip6addr_string(ndo, value + t)));
13. while (tp < value + optlen) {
ND_PRINT((ndo, "" ""));
if ((tp = ns_nprint(ndo, tp, value + optlen)) == NULL)
return -1;
14. i += 4 + optlen;","1
5
7
11
13
18-20
22
24-25
27
30
32
35
40-43
49",CWE-125
sof_set_get_large_ctrl_data-22461925066639,"static int sof_set_get_large_ctrl_data(struct snd_sof_dev *sdev,
				       struct sof_ipc_ctrl_data *cdata,
				       struct sof_ipc_ctrl_data_params *sparams,
				       bool send)
{
	struct sof_ipc_ctrl_data *partdata;
	size_t send_bytes;
	size_t offset = 0;
	size_t msg_bytes;
	size_t pl_size;
	int err;
	int i;

	
	partdata = kzalloc(SOF_IPC_MSG_MAX_SIZE, GFP_KERNEL);
	if (!partdata)
		return -ENOMEM;

	if (send)
		err = sof_get_ctrl_copy_params(cdata->type, cdata, partdata,
					       sparams);
	else
		err = sof_get_ctrl_copy_params(cdata->type, partdata, cdata,
					       sparams);
	if (err < 0) {
		kfree(partdata);
		return err;
	}

	msg_bytes = sparams->msg_bytes;
	pl_size = sparams->pl_size;

	
	memcpy(partdata, cdata, sparams->hdr_bytes);

	
	mutex_lock(&sdev->ipc->tx_mutex);

	
	for (i = 0; i < sparams->num_msg; i++) {
		send_bytes = min(msg_bytes, pl_size);
		partdata->num_elems = send_bytes;
		partdata->rhdr.hdr.size = sparams->hdr_bytes + send_bytes;
		partdata->msg_index = i;
		msg_bytes -= send_bytes;
		partdata->elems_remaining = msg_bytes;

		if (send)
			memcpy(sparams->dst, sparams->src + offset, send_bytes);

		err = sof_ipc_tx_message_unlocked(sdev->ipc,
						  partdata->rhdr.hdr.cmd,
						  partdata,
						  partdata->rhdr.hdr.size,
						  partdata,
						  partdata->rhdr.hdr.size);
		if (err < 0)
			break;

		if (!send)
			memcpy(sparams->dst + offset, sparams->src, send_bytes);

		offset += pl_size;
	}

	mutex_unlock(&sdev->ipc->tx_mutex);

	kfree(partdata);
	return err;
}
","1. struct sof_ipc_ctrl_data *cdata,
2. sparams);
3. if (send)
memcpy(sparams->dst, sparams->src + offset, send_bytes);
4. partdata->rhdr.hdr.size,
5. if (err < 0)
break;
6. offset += pl_size;","2
21
48-49
54
57-58
63","CWE-362,CWE-665,CWE-20,CWE-264"
png_get_uint_32," png_get_uint_32(png_bytep buf)
 {
   png_uint_32 i = ((png_uint_32)((*(buf    )) & 0xff) << 24) +
                   ((png_uint_32)((*(buf + 1)) & 0xff) << 16) +
                   ((png_uint_32)((*(buf + 2)) & 0xff) <<  8) +
                   ((png_uint_32)((*(buf + 3)) & 0xff)      );
 
    return (i);
 }
","1. png_get_uint_32(png_bytep buf)
2. png_uint_32 i = ((png_uint_32)((*(buf    )) & 0xff) << 24) +
((png_uint_32)((*(buf + 1)) & 0xff) << 16) +
((png_uint_32)((*(buf + 2)) & 0xff) <<  8) +
((png_uint_32)((*(buf + 3)) & 0xff)      );
3. return (i);","1
3-6
8","CWE-416,CWE-125,CWE-399,CWE-119"
gf_swf_read_header-16909233158609,"
#define SWFReader

GF_Err gf_swf_read_header(SWFReader *read)
{
	SWFRec rc;
	u8 sig[3];

	
	sig[0] = gf_bs_read_u8(read->bs);
	sig[1] = gf_bs_read_u8(read->bs);
	sig[2] = gf_bs_read_u8(read->bs);
	
	if ( ((sig[0] != 'F') && (sig[0] != 'C')) || (sig[1] != 'W') || (sig[2] != 'S') ) {
		return GF_NON_COMPLIANT_BITSTREAM;
	}
	gf_bs_read_u8(read->bs);
	read->length = swf_get_32(read);

	
	if (sig[0] == 'C') {
		swf_init_decompress(read);
		if (!read->bs) return GF_NON_COMPLIANT_BITSTREAM;
	}

	swf_get_rec(read, &rc);
	read->width = rc.w;
	read->height = rc.h;

	swf_align(read);
	read->frame_rate = swf_get_16(read)>>8;
	read->frame_count = swf_get_16(read);
	GF_LOG(GF_LOG_INFO, GF_LOG_PARSER, (""SWF Import - Scene Size %gx%g - %d frames @ %d FPS\n"", read->width, read->height, read->frame_count, read->frame_rate));
	if (!read->frame_rate) read->frame_rate = 1;
	return GF_OK;
}
","1. if (sig[0] == 'C') {
swf_init_decompress(read);
2. read->width = rc.w;","21-22
27","CWE-264,CWE-120,CWE-787,CWE-399"
rtnl_fill_ifinfo,"static int rtnl_fill_ifinfo(struct sk_buff *skb, struct net_device *dev,
			    int type, u32 pid, u32 seq, u32 change,
			    unsigned int flags, u32 ext_filter_mask)
{
	struct ifinfomsg *ifm;
	struct nlmsghdr *nlh;
	struct rtnl_link_stats64 temp;
	const struct rtnl_link_stats64 *stats;
	struct nlattr *attr, *af_spec;
	struct rtnl_af_ops *af_ops;
	struct net_device *upper_dev = netdev_master_upper_dev_get(dev);

	ASSERT_RTNL();
	nlh = nlmsg_put(skb, pid, seq, type, sizeof(*ifm), flags);
	if (nlh == NULL)
		return -EMSGSIZE;

	ifm = nlmsg_data(nlh);
	ifm->ifi_family = AF_UNSPEC;
	ifm->__ifi_pad = 0;
	ifm->ifi_type = dev->type;
	ifm->ifi_index = dev->ifindex;
	ifm->ifi_flags = dev_get_flags(dev);
	ifm->ifi_change = change;

	if (nla_put_string(skb, IFLA_IFNAME, dev->name) ||
	    nla_put_u32(skb, IFLA_TXQLEN, dev->tx_queue_len) ||
	    nla_put_u8(skb, IFLA_OPERSTATE,
		       netif_running(dev) ? dev->operstate : IF_OPER_DOWN) ||
	    nla_put_u8(skb, IFLA_LINKMODE, dev->link_mode) ||
	    nla_put_u32(skb, IFLA_MTU, dev->mtu) ||
	    nla_put_u32(skb, IFLA_GROUP, dev->group) ||
	    nla_put_u32(skb, IFLA_PROMISCUITY, dev->promiscuity) ||
	    nla_put_u32(skb, IFLA_NUM_TX_QUEUES, dev->num_tx_queues) ||
#ifdef CONFIG_RPS
	    nla_put_u32(skb, IFLA_NUM_RX_QUEUES, dev->num_rx_queues) ||
#endif
	    (dev->ifindex != dev->iflink &&
	     nla_put_u32(skb, IFLA_LINK, dev->iflink)) ||
	    (upper_dev &&
	     nla_put_u32(skb, IFLA_MASTER, upper_dev->ifindex)) ||
	    nla_put_u8(skb, IFLA_CARRIER, netif_carrier_ok(dev)) ||
	    (dev->qdisc &&
	     nla_put_string(skb, IFLA_QDISC, dev->qdisc->ops->id)) ||
	    (dev->ifalias &&
	     nla_put_string(skb, IFLA_IFALIAS, dev->ifalias)))
		goto nla_put_failure;

	if (1) {
		struct rtnl_link_ifmap map = {
			.mem_start   = dev->mem_start,
			.mem_end     = dev->mem_end,
			.base_addr   = dev->base_addr,
			.irq         = dev->irq,
			.dma         = dev->dma,
			.port        = dev->if_port,
		};
		if (nla_put(skb, IFLA_MAP, sizeof(map), &map))
			goto nla_put_failure;
	}

	if (dev->addr_len) {
		if (nla_put(skb, IFLA_ADDRESS, dev->addr_len, dev->dev_addr) ||
		    nla_put(skb, IFLA_BROADCAST, dev->addr_len, dev->broadcast))
			goto nla_put_failure;
	}

	attr = nla_reserve(skb, IFLA_STATS,
			sizeof(struct rtnl_link_stats));
	if (attr == NULL)
		goto nla_put_failure;

	stats = dev_get_stats(dev, &temp);
	copy_rtnl_link_stats(nla_data(attr), stats);

	attr = nla_reserve(skb, IFLA_STATS64,
			sizeof(struct rtnl_link_stats64));
	if (attr == NULL)
		goto nla_put_failure;
	copy_rtnl_link_stats64(nla_data(attr), stats);

	if (dev->dev.parent && (ext_filter_mask & RTEXT_FILTER_VF) &&
	    nla_put_u32(skb, IFLA_NUM_VF, dev_num_vf(dev->dev.parent)))
		goto nla_put_failure;

	if (dev->netdev_ops->ndo_get_vf_config && dev->dev.parent
	    && (ext_filter_mask & RTEXT_FILTER_VF)) {
		int i;

		struct nlattr *vfinfo, *vf;
		int num_vfs = dev_num_vf(dev->dev.parent);

		vfinfo = nla_nest_start(skb, IFLA_VFINFO_LIST);
		if (!vfinfo)
			goto nla_put_failure;
		for (i = 0; i < num_vfs; i++) {
			struct ifla_vf_info ivi;
			struct ifla_vf_mac vf_mac;
			struct ifla_vf_vlan vf_vlan;
			struct ifla_vf_tx_rate vf_tx_rate;
			struct ifla_vf_spoofchk vf_spoofchk;

			
 			ivi.spoofchk = -1;
			memset(ivi.mac, 0, sizeof(ivi.mac));
 			if (dev->netdev_ops->ndo_get_vf_config(dev, i, &ivi))
 				break;
 			vf_mac.vf =
				vf_vlan.vf =
				vf_tx_rate.vf =
				vf_spoofchk.vf = ivi.vf;

			memcpy(vf_mac.mac, ivi.mac, sizeof(ivi.mac));
			vf_vlan.vlan = ivi.vlan;
			vf_vlan.qos = ivi.qos;
			vf_tx_rate.rate = ivi.tx_rate;
			vf_spoofchk.setting = ivi.spoofchk;
			vf = nla_nest_start(skb, IFLA_VF_INFO);
			if (!vf) {
				nla_nest_cancel(skb, vfinfo);
				goto nla_put_failure;
			}
			if (nla_put(skb, IFLA_VF_MAC, sizeof(vf_mac), &vf_mac) ||
			    nla_put(skb, IFLA_VF_VLAN, sizeof(vf_vlan), &vf_vlan) ||
			    nla_put(skb, IFLA_VF_TX_RATE, sizeof(vf_tx_rate),
				    &vf_tx_rate) ||
			    nla_put(skb, IFLA_VF_SPOOFCHK, sizeof(vf_spoofchk),
				    &vf_spoofchk))
				goto nla_put_failure;
			nla_nest_end(skb, vf);
		}
		nla_nest_end(skb, vfinfo);
	}

	if (rtnl_port_fill(skb, dev))
		goto nla_put_failure;

	if (dev->rtnl_link_ops) {
		if (rtnl_link_fill(skb, dev) < 0)
			goto nla_put_failure;
	}

	if (!(af_spec = nla_nest_start(skb, IFLA_AF_SPEC)))
		goto nla_put_failure;

	list_for_each_entry(af_ops, &rtnl_af_ops, list) {
		if (af_ops->fill_link_af) {
			struct nlattr *af;
			int err;

			if (!(af = nla_nest_start(skb, af_ops->family)))
				goto nla_put_failure;

			err = af_ops->fill_link_af(skb, dev);

			
			if (err == -ENODATA)
				nla_nest_cancel(skb, af);
			else if (err < 0)
				goto nla_put_failure;

			nla_nest_end(skb, af);
		}
	}

	nla_nest_end(skb, af_spec);

	return nlmsg_end(skb, nlh);

nla_put_failure:
	nlmsg_cancel(skb, nlh);
	return -EMSGSIZE;
}
","1. struct nlmsghdr *nlh;
2. ifm = nlmsg_data(nlh);
3. nla_put_u32(skb, IFLA_NUM_TX_QUEUES, dev->num_tx_queues) ||
4. .mem_end     = dev->mem_end,
5. if (nla_put(skb, IFLA_ADDRESS, dev->addr_len, dev->dev_addr) ||
6. if (attr == NULL)
7. attr = nla_reserve(skb, IFLA_STATS64,
sizeof(struct rtnl_link_stats64));
8. nla_put(skb, IFLA_VF_TX_RATE, sizeof(vf_tx_rate),
9. &vf_spoofchk))","6
18
34
52
63
70
76-77
130
133","CWE-190,CWE-269,CWE-116,CWE-399"
GetInstance,"  static InputMethodStatusConnection* GetInstance() {
  virtual void Connect() {
    MaybeRestoreConnections();
   }
",1. MaybeRestoreConnections();,3,"CWE-200,CWE-94,CWE-399,CWE-119"
mwifiex_set_uap_rates,"mwifiex_set_uap_rates(struct mwifiex_uap_bss_param *bss_cfg,
		      struct cfg80211_ap_settings *params)
{
	struct ieee_types_header *rate_ie;
	int var_offset = offsetof(struct ieee80211_mgmt, u.beacon.variable);
	const u8 *var_pos = params->beacon.head + var_offset;
	int len = params->beacon.head_len - var_offset;
	u8 rate_len = 0;
 
 	rate_ie = (void *)cfg80211_find_ie(WLAN_EID_SUPP_RATES, var_pos, len);
 	if (rate_ie) {
		if (rate_ie->len > MWIFIEX_SUPPORTED_RATES)
			return;
 		memcpy(bss_cfg->rates, rate_ie + 1, rate_ie->len);
 		rate_len = rate_ie->len;
 	}
 
 	rate_ie = (void *)cfg80211_find_ie(WLAN_EID_EXT_SUPP_RATES,
 					   params->beacon.tail,
 					   params->beacon.tail_len);
	if (rate_ie) {
		if (rate_ie->len > MWIFIEX_SUPPORTED_RATES - rate_len)
			return;
 		memcpy(bss_cfg->rates + rate_len, rate_ie + 1, rate_ie->len);
	}
 
 	return;
 }
","1. mwifiex_set_uap_rates(struct mwifiex_uap_bss_param *bss_cfg,
struct cfg80211_ap_settings *params)
2. struct ieee_types_header *rate_ie;
3. int len = params->beacon.head_len - var_offset;
u8 rate_len = 0;
4. rate_ie = (void *)cfg80211_find_ie(WLAN_EID_SUPP_RATES, var_pos, len);
if (rate_ie) {
if (rate_ie->len > MWIFIEX_SUPPORTED_RATES)
5. memcpy(bss_cfg->rates, rate_ie + 1, rate_ie->len);
rate_len = rate_ie->len;
6. params->beacon.tail,
7. if (rate_ie) {
if (rate_ie->len > MWIFIEX_SUPPORTED_RATES - rate_len)
return;
memcpy(bss_cfg->rates + rate_len, rate_ie + 1, rate_ie->len);
8. return;","1-2
4
7-8
10-12
14-15
19
21-24
27","CWE-122,CWE-190,CWE-125,CWE-119"
crypto_givcipher_report,"static int crypto_givcipher_report(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_blkcipher rblkcipher;
 
	strncpy(rblkcipher.type, ""givcipher"", sizeof(rblkcipher.type));
	strncpy(rblkcipher.geniv, alg->cra_ablkcipher.geniv ?: ""<built-in>"",
		sizeof(rblkcipher.geniv));
 
 	rblkcipher.blocksize = alg->cra_blocksize;
 	rblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;
	rblkcipher.max_keysize = alg->cra_ablkcipher.max_keysize;
	rblkcipher.ivsize = alg->cra_ablkcipher.ivsize;

	if (nla_put(skb, CRYPTOCFGA_REPORT_BLKCIPHER,
		    sizeof(struct crypto_report_blkcipher), &rblkcipher))
		goto nla_put_failure;
	return 0;

nla_put_failure:
	return -EMSGSIZE;
}
","1. static int crypto_givcipher_report(struct sk_buff *skb, struct crypto_alg *alg)
2. struct crypto_report_blkcipher rblkcipher;
3. strncpy(rblkcipher.geniv, alg->cra_ablkcipher.geniv ?: ""<built-in>"",
4. rblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;
5. if (nla_put(skb, CRYPTOCFGA_REPORT_BLKCIPHER,
sizeof(struct crypto_report_blkcipher), &rblkcipher))","1
3
6
10
14-15","CWE-310,CWE-200"
zsetcolor,"zsetcolor(i_ctx_t * i_ctx_p)
{
    os_ptr                  op = osp;
    es_ptr ep;
    const gs_color_space *  pcs = gs_currentcolorspace(igs);
    gs_client_color         cc;
    int                     n_comps, n_numeric_comps, num_offset = 0, code, depth;
    PS_colour_space_t *space;

    
    cc.pattern = 0;

    
    if ((n_comps = cs_num_components(pcs)) < 0) {
        n_comps = -n_comps;
         if (r_has_type(op, t_dictionary)) {
             ref     *pImpl, pPatInst;
 
            if ((code = dict_find_string(op, ""Implementation"", &pImpl)) < 0)
                return code;
            if (code > 0) {
                 code = array_get(imemory, pImpl, 0, &pPatInst);
                 if (code < 0)
                     return code;
                n_numeric_comps = ( pattern_instance_uses_base_space(cc.pattern)
                      ? n_comps - 1
                      : 0 );
            } else
                n_numeric_comps = 0;
        } else
            n_numeric_comps = 0;
        num_offset = 1;
    } else
        n_numeric_comps = n_comps;

    
    code = float_params(op - num_offset, n_numeric_comps, cc.paint.values);
    if (code < 0)
        return code;
    
    
    
    memset(cc.paint.values + n_numeric_comps, 0,
            sizeof(cc.paint.values) - sizeof(*cc.paint.values)*n_numeric_comps);

    code = get_space_object(i_ctx_p, &istate->colorspace[0].array, &space);
    if (code < 0)
        return code;
    if (space->validatecomponents) {
        code = space->validatecomponents(i_ctx_p,
                                         &istate->colorspace[0].array,
                                         cc.paint.values, n_numeric_comps);
        if (code < 0)
            return code;
    }

    
    if ((code = gs_setcolor(igs, &cc)) >= 0) {

        if (n_comps > n_numeric_comps) {
            istate->pattern[0] = *op;      
        }
    }

    
    code = validate_spaces(i_ctx_p, &istate->colorspace[0].array, &depth);
    if (code < 0)
        return code;
    
    
    check_estack(5);
    
    ep = esp += 1;
    make_int(ep, 0);
    
    ep = esp += 1;
    make_int(ep, 0);
    
    ep = esp += 1;
    make_int(ep, 0);
    
    ep = esp += 1;
    *ep = istate->colorspace[0].array;
    
    push_op_estack(setcolor_cont);
    return o_push_estack;
}
","1. code = array_get(imemory, pImpl, 0, &pPatInst);
2. num_offset = 1;
3. if (code < 0)","22
32
71","CWE-119,CWE-323,CWE-399,CWE-78"
mongo_insert_batch-3653417856818,"MONGO_EXPORT int mongo_insert_batch( mongo *conn, const char *ns,
                                     const bson **bsons, int count, mongo_write_concern *custom_write_concern,
                                     int flags ) {

    mongo_message *mm;
    mongo_write_concern *write_concern = NULL;
    int i;
    char *data;
    size_t overhead =  16 + 4 + strlen( ns ) + 1;
    size_t size = overhead;

    if( mongo_validate_ns( conn, ns ) != MONGO_OK )
        return MONGO_ERROR;

    for( i=0; i<count; i++ ) {
        size += bson_size( bsons[i] );
        if( mongo_bson_valid( conn, bsons[i], 1 ) != MONGO_OK )
            return MONGO_ERROR;
    }

    if( ( size - overhead ) > conn->max_bson_size ) {
        conn->err = MONGO_BSON_TOO_LARGE;
        return MONGO_ERROR;
    }

    if( mongo_choose_write_concern( conn, custom_write_concern,
                                    &write_concern ) == MONGO_ERROR ) {
        return MONGO_ERROR;
    }

    mm = mongo_message_create( size , 0 , 0 , MONGO_OP_INSERT );

    data = &mm->data;
    if( flags & MONGO_CONTINUE_ON_ERROR )
        data = mongo_data_append32( data, &ONE );
    else
        data = mongo_data_append32( data, &ZERO );
    data = mongo_data_append( data, ns, strlen( ns ) + 1 );

    for( i=0; i<count; i++ ) {
        data = mongo_data_append( data, bsons[i]->data, bson_size( bsons[i] ) );
    }

    
    if( write_concern ) {
        if( mongo_message_send( conn, mm ) == MONGO_ERROR ) {
            return MONGO_ERROR;
        }

        return mongo_check_last_error( conn, ns, write_concern );
    }
    else {
        return mongo_message_send( conn, mm );
    }
}
","1. int flags ) {
2. size_t size = overhead;
3. size += bson_size( bsons[i] );
4. conn->err = MONGO_BSON_TOO_LARGE;
5. data = mongo_data_append32( data, &ONE );
6. return mongo_check_last_error( conn, ns, write_concern );","3
10
16
22
35
51","CWE-362,CWE-787,CWE-416"
ep2_mul_fix_plain-66977923205198,"static void ep2_mul_fix_plain(ep2_t r, const ep2_t *table, const bn_t k) {
	int8_t naf[2 * RLC_FP_BITS + 1], *t;
	size_t len;
	int n;

	if (bn_is_zero(k)) {
		ep2_set_infty(r);
		return;
	}

	
	len = 2 * RLC_FP_BITS + 1;
	bn_rec_naf(naf, &len, k, EP_DEPTH);

	t = naf + len - 1;
	ep2_set_infty(r);
	for (int i = len - 1; i >= 0; i--, t--) {
		ep2_dbl(r, r);

		n = *t;
		if (n > 0) {
			ep2_add(r, r, table[n / 2]);
		}
		if (n < 0) {
			ep2_sub(r, r, table[-n / 2]);
		}
	}
	
	ep2_norm(r, r);
	if (bn_sign(k) == RLC_NEG) {
		ep2_neg(r, r);
	}
}
","1. static void ep2_mul_fix_plain(ep2_t r, const ep2_t *table, const bn_t k) {
int8_t naf[2 * RLC_FP_BITS + 1], *t;
2. ep2_set_infty(r);
3. len = 2 * RLC_FP_BITS + 1;
bn_rec_naf(naf, &len, k, EP_DEPTH);
4. t = naf + len - 1;
ep2_set_infty(r);
for (int i = len - 1; i >= 0; i--, t--) {
ep2_dbl(r, r);
5. n = *t;
6. if (n < 0) {
ep2_sub(r, r, table[-n / 2]);
7. ep2_neg(r, r);","1-2
7
12-13
15-18
20
24-25
31",CWE-190
search_make_new," search_make_new(const struct search_state *const state, int n, const char *const base_name) {
 	const size_t base_len = strlen(base_name);
	char need_to_append_dot;
 	struct search_domain *dom;
 
	if (!base_len) return NULL;
	need_to_append_dot = base_name[base_len - 1] == '.' ? 0 : 1;

 	for (dom = state->head; dom; dom = dom->next) {
 		if (!n--) {
 			
			
			const u8 *const postfix = ((u8 *) dom) + sizeof(struct search_domain);
			const int postfix_len = dom->len;
			char *const newname = (char *) mm_malloc(base_len + need_to_append_dot + postfix_len + 1);
			if (!newname) return NULL;
			memcpy(newname, base_name, base_len);
			if (need_to_append_dot) newname[base_len] = '.';
			memcpy(newname + base_len + need_to_append_dot, postfix, postfix_len);
			newname[base_len + need_to_append_dot + postfix_len] = 0;
			return newname;
		}
	}

	
	EVUTIL_ASSERT(0);
	return NULL; 
}
","1. char need_to_append_dot;
struct search_domain *dom;
2. if (!base_len) return NULL;
need_to_append_dot = base_name[base_len - 1] == '.' ? 0 : 1;
3. for (dom = state->head; dom; dom = dom->next) {
4. const u8 *const postfix = ((u8 *) dom) + sizeof(struct search_domain);
5. char *const newname = (char *) mm_malloc(base_len + need_to_append_dot + postfix_len + 1);
6. memcpy(newname, base_name, base_len);
7. newname[base_len + need_to_append_dot + postfix_len] = 0;
return newname;","3-4
6-7
9
13
15
17
20-21","CWE-401,CWE-772,CWE-125,CWE-119"
initiate_stratum,"bool initiate_stratum(struct pool *pool)
{
	bool ret = false, recvd = false, noresume = false, sockd = false;
	char s[RBUFSIZE], *sret = NULL, *nonce1, *sessionid;
	json_t *val = NULL, *res_val, *err_val;
	json_error_t err;
	int n2size;

resend:
	if (!setup_stratum_socket(pool)) {
		
		applog(LOG_INFO, ""setup_stratum_socket() on %s failed"", get_pool_name(pool));
		sockd = false;
		goto out;
	}

	sockd = true;

	if (recvd) {
		
		clear_sock(pool);
		sprintf(s, ""{\""id\"": %d, \""method\"": \""mining.subscribe\"", \""params\"": []}"", swork_id++);
	} else {
		if (pool->sessionid)
			sprintf(s, ""{\""id\"": %d, \""method\"": \""mining.subscribe\"", \""params\"": [\""""PACKAGE""/""VERSION""\"", \""%s\""]}"", swork_id++, pool->sessionid);
		else
			sprintf(s, ""{\""id\"": %d, \""method\"": \""mining.subscribe\"", \""params\"": [\""""PACKAGE""/""VERSION""\""]}"", swork_id++);
	}

	if (__stratum_send(pool, s, strlen(s)) != SEND_OK) {
		applog(LOG_DEBUG, ""Failed to send s in initiate_stratum"");
		goto out;
	}

	if (!socket_full(pool, DEFAULT_SOCKWAIT)) {
		applog(LOG_DEBUG, ""Timed out waiting for response in initiate_stratum"");
		goto out;
	}

	sret = recv_line(pool);
	if (!sret)
		goto out;

	recvd = true;

	val = JSON_LOADS(sret, &err);
	free(sret);
	if (!val) {
		applog(LOG_INFO, ""JSON decode failed(%d): %s"", err.line, err.text);
		goto out;
	}

	res_val = json_object_get(val, ""result"");
	err_val = json_object_get(val, ""error"");

	if (!res_val || json_is_null(res_val) ||
	    (err_val && !json_is_null(err_val))) {
		char *ss;

		if (err_val)
			ss = json_dumps(err_val, JSON_INDENT(3));
		else
			ss = strdup(""(unknown reason)"");

		applog(LOG_INFO, ""JSON-RPC decode failed: %s"", ss);

		free(ss);

		goto out;
	}

	sessionid = get_sessionid(res_val);
	if (!sessionid)
		applog(LOG_DEBUG, ""Failed to get sessionid in initiate_stratum"");
	nonce1 = json_array_string(res_val, 1);
	if (!nonce1) {
		applog(LOG_INFO, ""Failed to get nonce1 in initiate_stratum"");
		free(sessionid);
 		goto out;
 	}
 	n2size = json_integer_value(json_array_get(res_val, 2));
	if (n2size < 1)
	{
 		applog(LOG_INFO, ""Failed to get n2size in initiate_stratum"");
 		free(sessionid);
 		free(nonce1);
		goto out;
	}

	cg_wlock(&pool->data_lock);
	pool->sessionid = sessionid;
	pool->nonce1 = nonce1;
	pool->n1_len = strlen(nonce1) / 2;
	free(pool->nonce1bin);
	pool->nonce1bin = (unsigned char *)calloc(pool->n1_len, 1);
	if (unlikely(!pool->nonce1bin))
		quithere(1, ""Failed to calloc pool->nonce1bin"");
	hex2bin(pool->nonce1bin, pool->nonce1, pool->n1_len);
	pool->n2size = n2size;
	cg_wunlock(&pool->data_lock);

	if (sessionid)
		applog(LOG_DEBUG, ""%s stratum session id: %s"", get_pool_name(pool), pool->sessionid);

	ret = true;
out:
	if (ret) {
		if (!pool->stratum_url)
			pool->stratum_url = pool->sockaddr_url;
		pool->stratum_active = true;
		pool->swork.diff = 1;
		if (opt_protocol) {
			applog(LOG_DEBUG, ""%s confirmed mining.subscribe with extranonce1 %s extran2size %d"",
			       get_pool_name(pool), pool->nonce1, pool->n2size);
		}
	} else {
		if (recvd && !noresume) {
			
			cg_wlock(&pool->data_lock);
			free(pool->sessionid);
			free(pool->nonce1);
			pool->sessionid = pool->nonce1 = NULL;
			cg_wunlock(&pool->data_lock);

			applog(LOG_DEBUG, ""Failed to resume stratum, trying afresh"");
			noresume = true;
			json_decref(val);
			goto resend;
		}
		applog(LOG_DEBUG, ""Initiating stratum failed on %s"", get_pool_name(pool));
		if (sockd) {
		  applog(LOG_DEBUG, ""Suspending stratum on %s"", get_pool_name(pool));
			suspend_stratum(pool);
		}
	}

	json_decref(val);
	return ret;
}
","1. sockd = false;
goto out;
2. sockd = true;
3. } else {
4. if (!socket_full(pool, DEFAULT_SOCKWAIT)) {
applog(LOG_DEBUG, ""Timed out waiting for response in initiate_stratum"");
5. if (!sret)
goto out;
6. recvd = true;
7. char *ss;
8. goto out;
9. applog(LOG_INFO, ""Failed to get n2size in initiate_stratum"");
free(sessionid);
10. pool->sessionid = sessionid;
pool->nonce1 = nonce1;
11. out:
12. applog(LOG_DEBUG, ""%s confirmed mining.subscribe with extranonce1 %s extran2size %d"",
13. applog(LOG_DEBUG, ""Failed to resume stratum, trying afresh"");
14. json_decref(val);","13-14
17
23
35-36
41-42
44
58
79
84-85
91-92
106
113
127
129","CWE-122,CWE-119"
sdp_parse_fmtp_config_h264-199168140433030,"
#define AVFormatContext
#define AVStream
#define PayloadContext

static int sdp_parse_fmtp_config_h264(AVFormatContext *s,
                                      AVStream *stream,
                                      PayloadContext *h264_data,
                                      const char *attr, const char *value)
{
    AVCodecParameters *par = stream->codecpar;

    if (!strcmp(attr, ""packetization-mode"")) {
        av_log(s, AV_LOG_DEBUG, ""RTP Packetization Mode: %d\n"", atoi(value));
        h264_data->packetization_mode = atoi(value);
        
        if (h264_data->packetization_mode > 1)
            av_log(s, AV_LOG_ERROR,
                   ""Interleaved RTP mode is not supported yet.\n"");
    } else if (!strcmp(attr, ""profile-level-id"")) {
        if (strlen(value) == 6)
            parse_profile_level_id(s, h264_data, value);
    } else if (!strcmp(attr, ""sprop-parameter-sets"")) {
        int ret;
        if (*value == 0 || value[strlen(value) - 1] == ',') {
            av_log(s, AV_LOG_WARNING, ""Missing PPS in sprop-parameter-sets, ignoring\n"");
            return 0;
        }
        par->extradata_size = 0;
        av_freep(&par->extradata);
        ret = ff_h264_parse_sprop_parameter_sets(s, &par->extradata,
                                                 &par->extradata_size, value);
        av_log(s, AV_LOG_DEBUG, ""Extradata set to %p (size: %d)\n"",
               par->extradata, par->extradata_size);
        return ret;
    }
    return 0;
}
","1. static int sdp_parse_fmtp_config_h264(AVFormatContext *s,
2. AVCodecParameters *par = stream->codecpar;
3. if (!strcmp(attr, ""packetization-mode"")) {
4. if (h264_data->packetization_mode > 1)
av_log(s, AV_LOG_ERROR,
5. if (strlen(value) == 6)
6. } else if (!strcmp(attr, ""sprop-parameter-sets"")) {
7. return 0;
8. par->extradata_size = 0;
av_freep(&par->extradata);
ret = ff_h264_parse_sprop_parameter_sets(s, &par->extradata,
&par->extradata_size, value);
av_log(s, AV_LOG_DEBUG, ""Extradata set to %p (size: %d)\n"",","6
11
13
23-24
27
29
33
35-39","CWE-362,CWE-416,CWE-119"
iolog_parse_json_object-45635221385712,"static bool
iolog_parse_json_object(struct json_object *object, struct eventlog *evlog)
{
    struct json_item *item;
    bool ret = false;
    debug_decl(iolog_parse_json_object, SUDO_DEBUG_UTIL);

    
    item = TAILQ_FIRST(&object->items);
    if (item == NULL) {
	sudo_warnx(""%s"", U_(""missing JSON_OBJECT""));
	goto done;
    }
    if (item->type != JSON_OBJECT) {
	sudo_warnx(U_(""expected JSON_OBJECT, got %d""), item->type);
	goto done;
    }
    object = &item->u.child;

    TAILQ_FOREACH(item, &object->items, entries) {
	struct iolog_json_key *key;

	
	if (item->name == NULL) {
	    sudo_debug_printf(SUDO_DEBUG_WARN|SUDO_DEBUG_LINENO,
		""%s: missing object name"", __func__);
	    goto done;
	}

	
	for (key = iolog_json_keys; key->name != NULL; key++) {
	    if (strcmp(item->name, key->name) == 0)
		break;
	}
	if (key->name == NULL) {
	    sudo_debug_printf(SUDO_DEBUG_WARN|SUDO_DEBUG_LINENO,
		""%s: unknown key %s"", __func__, item->name);
	} else if (key->type != item->type &&
		(key->type != JSON_ID || item->type != JSON_NUMBER)) {
	    sudo_debug_printf(SUDO_DEBUG_WARN|SUDO_DEBUG_LINENO,
		""%s: key mismatch %s type %d, expected %d"", __func__,
		item->name, item->type, key->type);
	    goto done;
	} else {
	    
	    if (!key->setter(item, evlog)) {
		sudo_debug_printf(SUDO_DEBUG_ERROR|SUDO_DEBUG_LINENO,
		    ""unable to store %s"", key->name);
		goto done;
	    }
	}
    }

    ret = true;

done:
    debug_return_bool(ret);
}
","1. struct json_item *item;
bool ret = false;
debug_decl(iolog_parse_json_object, SUDO_DEBUG_UTIL);
2. if (item == NULL) {
3. sudo_warnx(U_(""expected JSON_OBJECT, got %d""), item->type);
goto done;
4. struct iolog_json_key *key;
5. if (item->name == NULL) {
6. for (key = iolog_json_keys; key->name != NULL; key++) {
if (strcmp(item->name, key->name) == 0)
break;
7. if (key->name == NULL) {
sudo_debug_printf(SUDO_DEBUG_WARN|SUDO_DEBUG_LINENO,
""%s: unknown key %s"", __func__, item->name);
} else if (key->type != item->type &&
(key->type != JSON_ID || item->type != JSON_NUMBER)) {
8. ""%s: key mismatch %s type %d, expected %d"", __func__,
9. if (!key->setter(item, evlog)) {
10. ""unable to store %s"", key->name);
11. ret = true;
12. debug_return_bool(ret);","4-6
10
15-16
21
24
31-33
35-39
41
46
48
54
57","CWE-22,CWE-78,CWE-264,CWE-120,CWE-200"
irc_ctcp_dcc_filename_without_quotes-87893766733580,"char *
irc_ctcp_dcc_filename_without_quotes (const char *filename)
{
    int length;

    length = strlen (filename);
    if (length > 1)
    {
        if ((filename[0] == '\""') && (filename[length - 1] == '\""'))
            return weechat_strndup (filename + 1, length - 2);
    }
    return strdup (filename);
}
","1. irc_ctcp_dcc_filename_without_quotes (const char *filename)
2. int length;
3. if (length > 1)
4. if ((filename[0] == '\""') && (filename[length - 1] == '\""'))
return weechat_strndup (filename + 1, length - 2);
5. return strdup (filename);","2
4
7
9-10
12","CWE-20,CWE-787,CWE-189"
get_rock_ridge_filename-216575126632156,"int get_rock_ridge_filename(struct iso_directory_record *de,
			    char *retname, struct inode *inode)
{
	struct rock_state rs;
	struct rock_ridge *rr;
	int sig;
	int retnamlen = 0;
	int truncate = 0;
	int ret = 0;
	char *p;
	int len;

	if (!ISOFS_SB(inode->i_sb)->s_rock)
		return 0;
	*retname = 0;

	init_rock_state(&rs, inode);
	setup_rock_ridge(de, inode, &rs);
repeat:

	while (rs.len > 2) { 
		rr = (struct rock_ridge *)rs.chr;
		
		if (rr->len < 3)
			goto out;	
		sig = isonum_721(rs.chr);
		if (rock_check_overflow(&rs, sig))
			goto eio;
		rs.chr += rr->len;
		rs.len -= rr->len;
		
		if (rs.len < 0)
			goto out;	

		switch (sig) {
		case SIG('R', 'R'):
			if ((rr->u.RR.flags[0] & RR_NM) == 0)
				goto out;
			break;
		case SIG('S', 'P'):
			if (check_sp(rr, inode))
				goto out;
			break;
		case SIG('C', 'E'):
			rs.cont_extent = isonum_733(rr->u.CE.extent);
			rs.cont_offset = isonum_733(rr->u.CE.offset);
			rs.cont_size = isonum_733(rr->u.CE.size);
			break;
		case SIG('N', 'M'):
			if (truncate)
				break;
			if (rr->len < 5)
				break;
			
			if (rr->u.NM.flags & 6)
				break;

			if (rr->u.NM.flags & ~1) {
				printk(""Unsupported NM flag settings (%d)\n"",
					rr->u.NM.flags);
				break;
			}
			len = rr->len - 5;
			if (retnamlen + len >= 254) {
				truncate = 1;
				break;
			}
			p = memchr(rr->u.NM.name, '\0', len);
			if (unlikely(p))
				len = p - rr->u.NM.name;
			memcpy(retname + retnamlen, rr->u.NM.name, len);
			retnamlen += len;
			retname[retnamlen] = '\0';
			break;
		case SIG('R', 'E'):
			kfree(rs.buffer);
			return -1;
		default:
			break;
		}
	}
	ret = rock_continue(&rs);
	if (ret == 0)
		goto repeat;
	if (ret == 1)
		return retnamlen; 
out:
	kfree(rs.buffer);
	return ret;
eio:
	ret = -EIO;
	goto out;
}
","1. struct rock_ridge *rr;
2. int retnamlen = 0;
3. *retname = 0;
4. rr = (struct rock_ridge *)rs.chr;
5. goto out;
6. goto out;
break;
7. if (check_sp(rr, inode))
8. break;
9. printk(""Unsupported NM flag settings (%d)\n"",
10. len = rr->len - 5;
11. p = memchr(rr->u.NM.name, '\0', len);
12. memcpy(retname + retnamlen, rr->u.NM.name, len);
13. kfree(rs.buffer);
14. default:
break;
15. ret = -EIO;","5
7
15
22
29
45-46
48
55
72
76
81
84
89
91-92
104","CWE-264,CWE-200,CWE-125,CWE-59"
pci_get_vdev_info-269828223107342,"struct pci_vdev*
pci_get_vdev_info(int slot)
{
	struct businfo *bi;
	struct slotinfo *si;
	struct pci_vdev *dev = NULL;

	bi = pci_businfo[0];
	if (bi == NULL)
		return NULL;

	si = &bi->slotinfo[slot];
	if (si != NULL)
		dev = si->si_funcs[0].fi_devi;
	else
		fprintf(stderr, ""slot=%d is empty!\n"", slot);

	return dev;
}
","1. bi = pci_businfo[0];
2. return NULL;","8
10","CWE-617,CWE-476,CWE-119,CWE-189"
journal_unmap_buffer,"static int journal_unmap_buffer(journal_t *journal, struct buffer_head *bh)
{
	transaction_t *transaction;
	struct journal_head *jh;
	int may_free = 1;
	int ret;

	BUFFER_TRACE(bh, ""entry"");

	

	if (!buffer_jbd(bh))
		goto zap_buffer_unlocked;

	
	write_lock(&journal->j_state_lock);
	jbd_lock_bh_state(bh);
	spin_lock(&journal->j_list_lock);

	jh = jbd2_journal_grab_journal_head(bh);
	if (!jh)
		goto zap_buffer_no_jh;

	
	transaction = jh->b_transaction;
	if (transaction == NULL) {
		
		if (!jh->b_cp_transaction) {
			JBUFFER_TRACE(jh, ""not on any transaction: zap"");
			goto zap_buffer;
		}

		if (!buffer_dirty(bh)) {
			
			goto zap_buffer;
		}

		

		if (journal->j_running_transaction) {
			
			JBUFFER_TRACE(jh, ""checkpointed: add to BJ_Forget"");
			ret = __dispose_buffer(jh,
					journal->j_running_transaction);
			jbd2_journal_put_journal_head(jh);
			spin_unlock(&journal->j_list_lock);
			jbd_unlock_bh_state(bh);
			write_unlock(&journal->j_state_lock);
			return ret;
		} else {
			
			if (journal->j_committing_transaction) {
				JBUFFER_TRACE(jh, ""give to committing trans"");
				ret = __dispose_buffer(jh,
					journal->j_committing_transaction);
				jbd2_journal_put_journal_head(jh);
				spin_unlock(&journal->j_list_lock);
				jbd_unlock_bh_state(bh);
				write_unlock(&journal->j_state_lock);
				return ret;
			} else {
				
				clear_buffer_jbddirty(bh);
				goto zap_buffer;
			}
		}
	} else if (transaction == journal->j_committing_transaction) {
		JBUFFER_TRACE(jh, ""on committing transaction"");
		
		set_buffer_freed(bh);
		if (journal->j_running_transaction && buffer_jbddirty(bh))
			jh->b_next_transaction = journal->j_running_transaction;
		jbd2_journal_put_journal_head(jh);
		spin_unlock(&journal->j_list_lock);
		jbd_unlock_bh_state(bh);
		write_unlock(&journal->j_state_lock);
		return 0;
	} else {
		
		J_ASSERT_JH(jh, transaction == journal->j_running_transaction);
		JBUFFER_TRACE(jh, ""on running transaction"");
		may_free = __dispose_buffer(jh, transaction);
	}

zap_buffer:
	jbd2_journal_put_journal_head(jh);
zap_buffer_no_jh:
	spin_unlock(&journal->j_list_lock);
	jbd_unlock_bh_state(bh);
	write_unlock(&journal->j_state_lock);
zap_buffer_unlocked:
	clear_buffer_dirty(bh);
	J_ASSERT_BH(bh, !buffer_jbddirty(bh));
 	clear_buffer_mapped(bh);
 	clear_buffer_req(bh);
 	clear_buffer_new(bh);
	clear_buffer_delay(bh);
	clear_buffer_unwritten(bh);
 	bh->b_bdev = NULL;
 	return may_free;
 }
","1. transaction_t *transaction;
2. jbd_lock_bh_state(bh);
3. write_unlock(&journal->j_state_lock);
4. } else {
5. write_unlock(&journal->j_state_lock);
return 0;
6. zap_buffer:
7. write_unlock(&journal->j_state_lock);
8. J_ASSERT_BH(bh, !buffer_jbddirty(bh));
9. bh->b_bdev = NULL;","3
21
73
75
111-112
125
130
133
139","CWE-22,CWE-119,CWE-19,CWE-400,CWE-125"
tt_face_load_kern,"
#define FT_Stream
#define TT_Face

  tt_face_load_kern( TT_Face    face,
                     FT_Stream  stream )
  {
    FT_Error   error;
    FT_ULong   table_size;
    FT_Byte*   p;
    FT_Byte*   p_limit;
    FT_UInt    nn, num_tables;
    FT_UInt32  avail = 0, ordered = 0;


    
    error = face->goto_table( face, TTAG_kern, stream, &table_size );
    if ( error )
      goto Exit;

    if ( table_size < 4 )  
    {
      FT_ERROR(( ""tt_face_load_kern:""
                 "" kerning table is too small - ignored\n"" ));
      error = FT_THROW( Table_Missing );
      goto Exit;
    }

    if ( FT_FRAME_EXTRACT( table_size, face->kern_table ) )
    {
      FT_ERROR(( ""tt_face_load_kern:""
                 "" could not extract kerning table\n"" ));
      goto Exit;
    }

    face->kern_table_size = table_size;

    p       = face->kern_table;
    p_limit = p + table_size;

    p         += 2; 
    num_tables = FT_NEXT_USHORT( p );

    if ( num_tables > 32 ) 
      num_tables = 32;

    for ( nn = 0; nn < num_tables; nn++ )
    {
      FT_UInt    num_pairs, length, coverage;
      FT_Byte*   p_next;
      FT_UInt32  mask = (FT_UInt32)1UL << nn;


      if ( p + 6 > p_limit )
        break;

      p_next = p;

      p += 2; 
       length   = FT_NEXT_USHORT( p );
       coverage = FT_NEXT_USHORT( p );
 
      if ( length <= 6 + 8 )
         break;
 
       p_next += length;

      if ( p_next > p_limit )  
        p_next = p_limit;

      
      if ( ( coverage & ~8 ) != 0x0001 ||
           p + 8 > p_limit             )
        goto NextTable;

      num_pairs = FT_NEXT_USHORT( p );
      p        += 6;

      if ( ( p_next - p ) < 6 * (int)num_pairs ) 
        num_pairs = (FT_UInt)( ( p_next - p ) / 6 );

      avail |= mask;

      
      if ( num_pairs > 0 )
      {
        FT_ULong  count;
        FT_ULong  old_pair;


        old_pair = FT_NEXT_ULONG( p );
        p       += 2;

        for ( count = num_pairs - 1; count > 0; count-- )
        {
          FT_UInt32  cur_pair;


          cur_pair = FT_NEXT_ULONG( p );
          if ( cur_pair <= old_pair )
            break;

          p += 2;
          old_pair = cur_pair;
        }

        if ( count == 0 )
          ordered |= mask;
      }

    NextTable:
      p = p_next;
    }

    face->num_kern_tables = nn;
    face->kern_avail_bits = avail;
    face->kern_order_bits = ordered;

  Exit:
    return error;
  }
","1. FT_Stream  stream )
2. FT_UInt32  avail = 0, ordered = 0;
3. if ( table_size < 4 )
4. goto Exit;
5. if ( FT_FRAME_EXTRACT( table_size, face->kern_table ) )
6. goto Exit;
7. num_tables = FT_NEXT_USHORT( p );
8. length   = FT_NEXT_USHORT( p );
9. p_next = p_limit;
10. if ( ( p_next - p ) < 6 * (int)num_pairs )
11. avail |= mask;
12. p       += 2;
13. for ( count = num_pairs - 1; count > 0; count-- )
14. if ( cur_pair <= old_pair )
break;
15. if ( count == 0 )
16. p = p_next;
17. return error;","6
13
21
26
29
33
42
60
69
79
82
95
97
103-104
110
115
123","CWE-772,CWE-400,CWE-125,CWE-119,CWE-17"
uwbd_start-153018448118570,"void uwbd_start(struct uwb_rc *rc)
{
	struct task_struct *task = kthread_run(uwbd, rc, ""uwbd"");
	if (IS_ERR(task)) {
		rc->uwbd.task = NULL;
		printk(KERN_ERR ""UWB: Cannot start management daemon; ""
		       ""UWB won't work\n"");
	} else {
		rc->uwbd.task = task;
		rc->uwbd.pid = rc->uwbd.task->pid;
	}
}
","1. void uwbd_start(struct uwb_rc *rc)
2. struct task_struct *task = kthread_run(uwbd, rc, ""uwbd"");
if (IS_ERR(task)) {
rc->uwbd.task = NULL;
3. } else {
rc->uwbd.task = task;
rc->uwbd.pid = rc->uwbd.task->pid;","1
3-5
8-10","CWE-362,CWE-190,CWE-20,CWE-119"
ftc_snode_load,"
#define FTC_Manager
#define FTC_SNode
#define FT_UInt
#define FT_ULong

  ftc_snode_load( FTC_SNode    snode,
                  FTC_Manager  manager,
                  FT_UInt      gindex,
                  FT_ULong    *asize )
  {
    FT_Error          error;
    FTC_GNode         gnode  = FTC_GNODE( snode );
    FTC_Family        family = gnode->family;
    FT_Memory         memory = manager->memory;
    FT_Face           face;
    FTC_SBit          sbit;
    FTC_SFamilyClass  clazz;


    if ( (FT_UInt)(gindex - gnode->gindex) >= snode->count )
    {
      FT_ERROR(( ""ftc_snode_load: invalid glyph index"" ));
      return FT_THROW( Invalid_Argument );
    }

    sbit  = snode->sbits + ( gindex - gnode->gindex );
    clazz = (FTC_SFamilyClass)family->clazz;

    sbit->buffer = 0;

    error = clazz->family_load_glyph( family, gindex, manager, &face );
    if ( error )
      goto BadGlyph;

    {
      FT_Int        temp;
      FT_GlyphSlot  slot   = face->glyph;
      FT_Bitmap*    bitmap = &slot->bitmap;
      FT_Pos        xadvance, yadvance; 


      if ( slot->format != FT_GLYPH_FORMAT_BITMAP )
      {
        FT_TRACE0(( ""ftc_snode_load:""
                    "" glyph loaded didn't return a bitmap\n"" ));
         goto BadGlyph;
       }
 
      
       
       
 
#define CHECK_CHAR( d )  ( temp = (FT_Char)d, (FT_Int) temp == (FT_Int) d )
#define CHECK_BYTE( d )  ( temp = (FT_Byte)d, (FT_UInt)temp == (FT_UInt)d )
 
       
       xadvance = ( slot->advance.x + 32 ) >> 6;
      yadvance = ( slot->advance.y + 32 ) >> 6;

      if ( !CHECK_BYTE( bitmap->rows  )     ||
           !CHECK_BYTE( bitmap->width )     ||
           !CHECK_CHAR( bitmap->pitch )     ||
           !CHECK_CHAR( slot->bitmap_left ) ||
           !CHECK_CHAR( slot->bitmap_top  ) ||
           !CHECK_CHAR( xadvance )          ||
           !CHECK_CHAR( yadvance )          )
      {
        FT_TRACE2(( ""ftc_snode_load:""
                    "" glyph too large for small bitmap cache\n""));
        goto BadGlyph;
      }

      sbit->width     = (FT_Byte)bitmap->width;
      sbit->height    = (FT_Byte)bitmap->rows;
      sbit->pitch     = (FT_Char)bitmap->pitch;
      sbit->left      = (FT_Char)slot->bitmap_left;
      sbit->top       = (FT_Char)slot->bitmap_top;
      sbit->xadvance  = (FT_Char)xadvance;
      sbit->yadvance  = (FT_Char)yadvance;
      sbit->format    = (FT_Byte)bitmap->pixel_mode;
      sbit->max_grays = (FT_Byte)(bitmap->num_grays - 1);

      
      error = ftc_sbit_copy_bitmap( sbit, bitmap, memory );

      
      if ( asize )
        *asize = FT_ABS( sbit->pitch ) * sbit->height;

    } 

    
    
    
    
    if ( error && FT_ERR_NEQ( error, Out_Of_Memory ) )
    {
    BadGlyph:
      sbit->width  = 255;
      sbit->height = 0;
      sbit->buffer = NULL;
      error        = FT_Err_Ok;
      if ( asize )
        *asize = 0;
    }

    return error;
  }
","1. FT_Error          error;
2. if ( asize )","12
104","CWE-755,CWE-444,CWE-787,CWE-119"
do_free_keypair_1-201318844448585,"static void do_free_keypair_1(struct rsa_keypair *s)
{
	sss_status_t st = kStatus_SSS_Fail;
	sss_se05x_object_t k_object = { };
	uint32_t key_id = 0;

	if (!s)
		return;

	key_id = se050_rsa_keypair_from_nvm(s);
	if (key_id) {
		st = sss_se05x_key_object_get_handle(&k_object, key_id);
		if (st == kStatus_SSS_Success)
			sss_se05x_key_store_erase_key(se050_kstore, &k_object);
	}

	crypto_bignum_free(&s->e);
	crypto_bignum_free(&s->d);
	crypto_bignum_free(&s->n);
	crypto_bignum_free(&s->p);
	crypto_bignum_free(&s->q);
	crypto_bignum_free(&s->qp);
	crypto_bignum_free(&s->dp);
	crypto_bignum_free(&s->dq);
}
","1. sss_se05x_object_t k_object = { };
2. return;
3. key_id = se050_rsa_keypair_from_nvm(s);
if (key_id) {
st = sss_se05x_key_object_get_handle(&k_object, key_id);
4. crypto_bignum_free(&s->e);
crypto_bignum_free(&s->d);
crypto_bignum_free(&s->n);
5. crypto_bignum_free(&s->q);
crypto_bignum_free(&s->qp);
6. crypto_bignum_free(&s->dq);","4
8
10-12
17-19
21-22
24","CWE-59,CWE-119"
fpDiff-101907107918999,"
#define TIFF

static int fpDiff(TIFF* tif, uint8* cp0, tmsize_t cc);
","1. static int fpDiff(TIFF* tif, uint8* cp0, tmsize_t cc);",4,"CWE-19,CWE-119"
certstack_create-131282373124804,"int
certstack_create(struct cert_stack **result)
{
	struct cert_stack *stack;

	stack = malloc(sizeof(struct cert_stack));
	if (stack == NULL)
		return pr_enomem();

	stack->x509s = sk_X509_new_null();
	if (stack->x509s == NULL) {
		free(stack);
		return val_crypto_err(""sk_X509_new_null() returned NULL"");
	}

	SLIST_INIT(&stack->defers);
	SLIST_INIT(&stack->metas);

	*result = stack;
	return 0;
}
","1. int
2. struct cert_stack *stack;
3. if (stack == NULL)
4. stack->x509s = sk_X509_new_null();
if (stack->x509s == NULL) {
free(stack);
5. SLIST_INIT(&stack->metas);
6. *result = stack;
return 0;","1
4
7
10-12
17
19-20","CWE-552,CWE-252,CWE-125,CWE-17,CWE-399"
virtio_load_1,"
#define QEMUFile
#define VirtIODevice

int virtio_load_1(VirtIODevice *vdev, QEMUFile *f)
{
    int i, ret;
    uint32_t num;
    uint32_t features;
    uint32_t supported_features;
    BusState *qbus = qdev_get_parent_bus(DEVICE(vdev));
    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);

    if (k->load_config) {
        ret = k->load_config(qbus->parent, f);
        if (ret)
            return ret;
    }

     qemu_get_8s(f, &vdev->status);
     qemu_get_8s(f, &vdev->isr);
     qemu_get_be16s(f, &vdev->queue_sel);
    if (vdev->queue_sel >= VIRTIO_PCI_QUEUE_MAX) {
        return -1;
    }
     qemu_get_be32s(f, &features);
 
     if (virtio_set_features(vdev, features) < 0) {
        return -1;
    }
    vdev->config_len = qemu_get_be32(f);
    qemu_get_buffer(f, vdev->config, vdev->config_len);

    num = qemu_get_be32(f);

    if (num > VIRTIO_PCI_QUEUE_MAX) {
        error_report(""Invalid number of PCI queues: 0x%x"", num);
        return -1;
    }

    for (i = 0; i < num; i++) {
        vdev->vq[i].vring.num = qemu_get_be32(f);
        if (k->has_variable_vring_alignment) {
            vdev->vq[i].vring.align = qemu_get_be32(f);
        }
        vdev->vq[i].pa = qemu_get_be64(f);
        qemu_get_be16s(f, &vdev->vq[i].last_avail_idx);
        vdev->vq[i].signalled_used_valid = false;
        vdev->vq[i].notification = true;

        if (vdev->vq[i].pa) {
            uint16_t nheads;
            virtqueue_init(&vdev->vq[i]);
            nheads = vring_avail_idx(&vdev->vq[i]) - vdev->vq[i].last_avail_idx;
            
            if (nheads > vdev->vq[i].vring.num) {
                error_report(""VQ %d size 0x%x Guest index 0x%x ""
                             ""inconsistent with Host index 0x%x: delta 0x%x"",
                             i, vdev->vq[i].vring.num,
                             vring_avail_idx(&vdev->vq[i]),
                             vdev->vq[i].last_avail_idx, nheads);
                return -1;
            }
        } else if (vdev->vq[i].last_avail_idx) {
            error_report(""VQ %d address 0x0 ""
                         ""inconsistent with Host index 0x%x"",
                         i, vdev->vq[i].last_avail_idx);
                return -1;
	}
        if (k->load_queue) {
            ret = k->load_queue(qbus->parent, i, f);
            if (ret)
                return ret;
        }
    }

    virtio_notify_vector(vdev, VIRTIO_NO_VECTOR);
    return 0;
}
","1. int virtio_load_1(VirtIODevice *vdev, QEMUFile *f)
2. int i, ret;
3. VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);
4. return ret;
5. qemu_get_be16s(f, &vdev->queue_sel);
6. return -1;
7. num = qemu_get_be32(f);
8. if (vdev->vq[i].pa) {
9. return -1;
10. if (ret)
11. return 0;","5
7
12
17
22
24
34
51
68
72
78","CWE-416,CWE-399,CWE-189,CWE-119"
rpza_decode_stream-279120299851827,"
#define RpzaContext

static void rpza_decode_stream(RpzaContext *s)
{
    int width = s->avctx->width;
    int stride = s->frame.linesize[0] / 2;
    int row_inc = stride - 4;
    int stream_ptr = 0;
    int chunk_size;
    unsigned char opcode;
    int n_blocks;
    unsigned short colorA = 0, colorB;
    unsigned short color4[4];
    unsigned char index, idx;
    unsigned short ta, tb;
    unsigned short *pixels = (unsigned short *)s->frame.data[0];

    int row_ptr = 0;
    int pixel_ptr = -4;
    int block_ptr;
    int pixel_x, pixel_y;
    int total_blocks;

    
    if (s->buf[stream_ptr] != 0xe1)
        av_log(s->avctx, AV_LOG_ERROR, ""First chunk byte is 0x%02x instead of 0xe1\n"",
            s->buf[stream_ptr]);

    
    chunk_size = AV_RB32(&s->buf[stream_ptr]) & 0x00FFFFFF;
    stream_ptr += 4;

    
    if (chunk_size != s->size)
        av_log(s->avctx, AV_LOG_ERROR, ""MOV chunk size != encoded chunk size; using MOV chunk size\n"");

    chunk_size = s->size;

    
    total_blocks = ((s->avctx->width + 3) / 4) * ((s->avctx->height + 3) / 4);

    
    while (stream_ptr < chunk_size) {
        opcode = s->buf[stream_ptr++]; 

        n_blocks = (opcode & 0x1f) + 1; 

        
        if ((opcode & 0x80) == 0) {
            colorA = (opcode << 8) | (s->buf[stream_ptr++]);
            opcode = 0;
            if ((s->buf[stream_ptr] & 0x80) != 0) {
                
                opcode = 0x20;
                n_blocks = 1;
            }
        }

        switch (opcode & 0xe0) {

        
        case 0x80:
            while (n_blocks--) {
              ADVANCE_BLOCK();
            }
            break;

        
        case 0xa0:
            colorA = AV_RB16 (&s->buf[stream_ptr]);
            stream_ptr += 2;
            while (n_blocks--) {
                ADVANCE_BLOCK()
                block_ptr = row_ptr + pixel_ptr;
                for (pixel_y = 0; pixel_y < 4; pixel_y++) {
                    for (pixel_x = 0; pixel_x < 4; pixel_x++){
                        pixels[block_ptr] = colorA;
                        block_ptr++;
                    }
                    block_ptr += row_inc;
                }
            }
            break;

        
        case 0xc0:
            colorA = AV_RB16 (&s->buf[stream_ptr]);
            stream_ptr += 2;
        case 0x20:
            colorB = AV_RB16 (&s->buf[stream_ptr]);
            stream_ptr += 2;

            
            color4[0] = colorB;
            color4[1] = 0;
            color4[2] = 0;
            color4[3] = colorA;

            
            ta = (colorA >> 10) & 0x1F;
            tb = (colorB >> 10) & 0x1F;
            color4[1] |= ((11 * ta + 21 * tb) >> 5) << 10;
            color4[2] |= ((21 * ta + 11 * tb) >> 5) << 10;

            
            ta = (colorA >> 5) & 0x1F;
            tb = (colorB >> 5) & 0x1F;
            color4[1] |= ((11 * ta + 21 * tb) >> 5) << 5;
            color4[2] |= ((21 * ta + 11 * tb) >> 5) << 5;

            
            ta = colorA & 0x1F;
            tb = colorB & 0x1F;
            color4[1] |= ((11 * ta + 21 * tb) >> 5);
            color4[2] |= ((21 * ta + 11 * tb) >> 5);

            if (s->size - stream_ptr < n_blocks * 4)
                return;
            while (n_blocks--) {
                ADVANCE_BLOCK();
                block_ptr = row_ptr + pixel_ptr;
                for (pixel_y = 0; pixel_y < 4; pixel_y++) {
                    index = s->buf[stream_ptr++];
                    for (pixel_x = 0; pixel_x < 4; pixel_x++){
                        idx = (index >> (2 * (3 - pixel_x))) & 0x03;
                        pixels[block_ptr] = color4[idx];
                        block_ptr++;
                    }
                    block_ptr += row_inc;
                }
            }
            break;

        
        case 0x00:
            if (s->size - stream_ptr < 16)
                return;
            ADVANCE_BLOCK();
            block_ptr = row_ptr + pixel_ptr;
            for (pixel_y = 0; pixel_y < 4; pixel_y++) {
                for (pixel_x = 0; pixel_x < 4; pixel_x++){
                    
                    if ((pixel_y != 0) || (pixel_x !=0)) {
                        colorA = AV_RB16 (&s->buf[stream_ptr]);
                        stream_ptr += 2;
                    }
                    pixels[block_ptr] = colorA;
                    block_ptr++;
                }
                block_ptr += row_inc;
            }
            break;

        
        default:
            av_log(s->avctx, AV_LOG_ERROR, ""Unknown opcode %d in rpza chunk.""
                 "" Skip remaining %d bytes of chunk data.\n"", opcode,
                 chunk_size - stream_ptr);
            return;
        } 
    }
}
","1. if (s->buf[stream_ptr] != 0xe1)
2. n_blocks = (opcode & 0x1f) + 1;
3. if ((opcode & 0x80) == 0) {
4. stream_ptr += 2;
5. tb = (colorB >> 5) & 0x1F;
6. color4[1] |= ((11 * ta + 21 * tb) >> 5);
7. return;
8. return;","26
47
50
74
110
117
121
162","CWE-119,CWE-190,CWE-787,CWE-400,CWE-125"
umount_tree,"static void umount_tree(struct mount *mnt, enum umount_tree_flags how)
{
	LIST_HEAD(tmp_list);
	struct mount *p;

	if (how & UMOUNT_PROPAGATE)
		propagate_mount_unlock(mnt);

	
	for (p = mnt; p; p = next_mnt(p, mnt)) {
		p->mnt.mnt_flags |= MNT_UMOUNT;
		list_move(&p->mnt_list, &tmp_list);
	}

	
	list_for_each_entry(p, &tmp_list, mnt_list) {
		list_del_init(&p->mnt_child);
	}

	
	if (how & UMOUNT_PROPAGATE)
 		propagate_umount(&tmp_list);
 
 	while (!list_empty(&tmp_list)) {
		struct mnt_namespace *ns;
 		bool disconnect;
 		p = list_first_entry(&tmp_list, struct mount, mnt_list);
 		list_del_init(&p->mnt_expire);
 		list_del_init(&p->mnt_list);
		ns = p->mnt_ns;
		if (ns) {
			ns->mounts--;
			__touch_mnt_namespace(ns);
		}
 		p->mnt_ns = NULL;
 		if (how & UMOUNT_SYNC)
 			p->mnt.mnt_flags |= MNT_SYNC_UMOUNT;

		disconnect = disconnect_mount(p, how);

		pin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt,
				 disconnect ? &unmounted : NULL);
		if (mnt_has_parent(p)) {
			mnt_add_count(p->mnt_parent, -1);
			if (!disconnect) {
				
				list_add_tail(&p->mnt_child, &p->mnt_parent->mnt_mounts);
			} else {
				umount_mnt(p);
			}
		}
		change_mnt_propagation(p, MS_PRIVATE);
	}
}
","1. LIST_HEAD(tmp_list);
struct mount *p;
2. if (how & UMOUNT_PROPAGATE)
propagate_mount_unlock(mnt);
3. for (p = mnt; p; p = next_mnt(p, mnt)) {
4. if (how & UMOUNT_PROPAGATE)
5. struct mnt_namespace *ns;
bool disconnect;
6. list_del_init(&p->mnt_expire);
7. ns = p->mnt_ns;
8. __touch_mnt_namespace(ns);
9. p->mnt.mnt_flags |= MNT_SYNC_UMOUNT;
10. pin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt,
disconnect ? &unmounted : NULL);
11. if (!disconnect) {
12. list_add_tail(&p->mnt_child, &p->mnt_parent->mnt_mounts);
} else {","3-4
6-7
10
21
25-26
28
30
33
37
41-42
45
47-48","CWE-200,CWE-284,CWE-400"
psf_binheader_writef,"
#define SF_PRIVATE

psf_binheader_writef (SF_PRIVATE *psf, const char *format, ...)
{	va_list	argptr ;
	sf_count_t 		countdata ;
	unsigned long 	longdata ;
	unsigned int 	data ;
	float			floatdata ;
	double			doubledata ;
	void			*bindata ;
	size_t			size ;
	char			c, *strptr ;
	int				count = 0, trunc_8to4 ;

	trunc_8to4 = SF_FALSE ;

 	va_start (argptr, format) ;
 
 	while ((c = *format++))
	{
		if (psf->header.indx + 16 >= psf->header.len && psf_bump_header_allocation (psf, 16))
			return count ;

		switch (c)
 		{	case ' ' : 
 					break ;
 
			case 'e' : 
					psf->rwf_endian = SF_ENDIAN_LITTLE ;
					break ;

			case 'E' : 
					psf->rwf_endian = SF_ENDIAN_BIG ;
					break ;

			case 't' : 
					trunc_8to4 = SF_TRUE ;
					break ;

			case 'T' : 
					trunc_8to4 = SF_FALSE ;
					break ;

			case 'm' :
					data = va_arg (argptr, unsigned int) ;
					header_put_marker (psf, data) ;
					count += 4 ;
					break ;

			case '1' :
					data = va_arg (argptr, unsigned int) ;
					header_put_byte (psf, data) ;
					count += 1 ;
					break ;

			case '2' :
					data = va_arg (argptr, unsigned int) ;
					if (psf->rwf_endian == SF_ENDIAN_BIG)
					{	header_put_be_short (psf, data) ;
						}
					else
					{	header_put_le_short (psf, data) ;
						} ;
					count += 2 ;
					break ;

			case '3' : 
					data = va_arg (argptr, unsigned int) ;
					if (psf->rwf_endian == SF_ENDIAN_BIG)
					{	header_put_be_3byte (psf, data) ;
						}
					else
					{	header_put_le_3byte (psf, data) ;
						} ;
					count += 3 ;
					break ;

			case '4' :
					data = va_arg (argptr, unsigned int) ;
					if (psf->rwf_endian == SF_ENDIAN_BIG)
					{	header_put_be_int (psf, data) ;
						}
					else
					{	header_put_le_int (psf, data) ;
						} ;
					count += 4 ;
					break ;

			case '8' :
					countdata = va_arg (argptr, sf_count_t) ;
					if (psf->rwf_endian == SF_ENDIAN_BIG && trunc_8to4 == SF_FALSE)
					{	header_put_be_8byte (psf, countdata) ;
						count += 8 ;
						}
					else if (psf->rwf_endian == SF_ENDIAN_LITTLE && trunc_8to4 == SF_FALSE)
					{	header_put_le_8byte (psf, countdata) ;
						count += 8 ;
						}
					else if (psf->rwf_endian == SF_ENDIAN_BIG && trunc_8to4 == SF_TRUE)
					{	longdata = countdata & 0xFFFFFFFF ;
						header_put_be_int (psf, longdata) ;
						count += 4 ;
						}
					else if (psf->rwf_endian == SF_ENDIAN_LITTLE && trunc_8to4 == SF_TRUE)
					{	longdata = countdata & 0xFFFFFFFF ;
						header_put_le_int (psf, longdata) ;
						count += 4 ;
						}
					break ;

			case 'f' :
 					
 					floatdata = (float) va_arg (argptr, double) ;
 					if (psf->rwf_endian == SF_ENDIAN_BIG)
						float32_be_write (floatdata, psf->header.ptr + psf->header.indx) ;
 					else
						float32_le_write (floatdata, psf->header.ptr + psf->header.indx) ;
					psf->header.indx += 4 ;
 					count += 4 ;
 					break ;
 
 			case 'd' :
 					doubledata = va_arg (argptr, double) ;
 					if (psf->rwf_endian == SF_ENDIAN_BIG)
						double64_be_write (doubledata, psf->header.ptr + psf->header.indx) ;
 					else
						double64_le_write (doubledata, psf->header.ptr + psf->header.indx) ;
					psf->header.indx += 8 ;
 					count += 8 ;
 					break ;
 
			case 's' :
					
 					strptr = va_arg (argptr, char *) ;
 					size = strlen (strptr) + 1 ;
 					size += (size & 1) ;

					if (psf->header.indx + (sf_count_t) size >= psf->header.len && psf_bump_header_allocation (psf, 16))
						return count ;

 					if (psf->rwf_endian == SF_ENDIAN_BIG)
 						header_put_be_int (psf, size) ;
 					else
 						header_put_le_int (psf, size) ;
					memcpy (&(psf->header.ptr [psf->header.indx]), strptr, size) ;
					psf->header.indx += size ;
					psf->header.ptr [psf->header.indx - 1] = 0 ;
 					count += 4 + size ;
 					break ;
 
			case 'S' :
					
 					strptr = va_arg (argptr, char *) ;
 					size = strlen (strptr) ;
					if (psf->header.indx + (sf_count_t) size > psf->header.len && psf_bump_header_allocation (psf, size))
						return count ;
 					if (psf->rwf_endian == SF_ENDIAN_BIG)
 						header_put_be_int (psf, size) ;
 					else
 						header_put_le_int (psf, size) ;
					memcpy (&(psf->header.ptr [psf->header.indx]), strptr, size + 1) ;
 					size += (size & 1) ;
					psf->header.indx += size ;
					psf->header.ptr [psf->header.indx] = 0 ;
 					count += 4 + size ;
 					break ;
 
			case 'p' :
					
					strptr = va_arg (argptr, char *) ;
 					size = strlen (strptr) ;
 					size = (size & 1) ? size : size + 1 ;
 					size = (size > 254) ? 254 : size ;

					if (psf->header.indx + (sf_count_t) size > psf->header.len && psf_bump_header_allocation (psf, size))
						return count ;

 					header_put_byte (psf, size) ;
					memcpy (&(psf->header.ptr [psf->header.indx]), strptr, size) ;
					psf->header.indx += size ;
 					count += 1 + size ;
 					break ;
 
 			case 'b' :
 					bindata	= va_arg (argptr, void *) ;
 					size	= va_arg (argptr, size_t) ;

					if (psf->header.indx + (sf_count_t) size > psf->header.len && psf_bump_header_allocation (psf, size))
						return count ;

					memcpy (&(psf->header.ptr [psf->header.indx]), bindata, size) ;
					psf->header.indx += size ;
					count += size ;
 					break ;
 
 			case 'z' :
 					size = va_arg (argptr, size_t) ;

					if (psf->header.indx + (sf_count_t) size > psf->header.len && psf_bump_header_allocation (psf, size))
						return count ;

 					count += size ;
 					while (size)
					{	psf->header.ptr [psf->header.indx] = 0 ;
						psf->header.indx ++ ;
 						size -- ;
 						} ;
 					break ;
 
 			case 'h' :
 					bindata = va_arg (argptr, void *) ;
					memcpy (&(psf->header.ptr [psf->header.indx]), bindata, 16) ;
					psf->header.indx += 16 ;
 					count += 16 ;
 					break ;
 
 			case 'j' :	
 					size = va_arg (argptr, size_t) ;

					if (psf->header.indx + (sf_count_t) size > psf->header.len && psf_bump_header_allocation (psf, size))
						return count ;

					psf->header.indx += size ;
 					count += size ;
 					break ;
 
 			case 'o' :	
 					size = va_arg (argptr, size_t) ;

					if ((sf_count_t) size >= psf->header.len && psf_bump_header_allocation (psf, size))
						return count ;

					psf->header.indx = size ;
 					break ;
 
 			default :
				psf_log_printf (psf, ""*** Invalid format specifier `%c'\n"", c) ;
				psf->error = SFE_INTERNAL ;
				break ;
			} ;
		} ;

	va_end (argptr) ;
	return count ;
} 
","1. psf_binheader_writef (SF_PRIVATE *psf, const char *format, ...)
{	va_list	argptr ;
2. unsigned long 	longdata ;
3. float			floatdata ;
4. size_t			size ;
5. trunc_8to4 = SF_FALSE ;
6. switch (c)
{	case ' ' :
7. case 'e' :
psf->rwf_endian = SF_ENDIAN_LITTLE ;
8. case 'E' :
psf->rwf_endian = SF_ENDIAN_BIG ;
break ;
9. case 't' :
trunc_8to4 = SF_TRUE ;
10. case 'T' :
trunc_8to4 = SF_FALSE ;
11. case 'm' :
12. header_put_marker (psf, data) ;
count += 4 ;
break ;
13. case '1' :
14. header_put_byte (psf, data) ;
count += 1 ;
break ;
15. if (psf->rwf_endian == SF_ENDIAN_BIG)
{	header_put_be_short (psf, data) ;
16. {	header_put_le_short (psf, data) ;
17. count += 2 ;
18. {	header_put_be_3byte (psf, data) ;
19. count += 3 ;
break ;
20. case '4' :
21. if (psf->rwf_endian == SF_ENDIAN_BIG)
{	header_put_be_int (psf, data) ;
22. {	header_put_le_int (psf, data) ;
23. count += 4 ;
24. countdata = va_arg (argptr, sf_count_t) ;
25. {	header_put_be_8byte (psf, countdata) ;
26. else if (psf->rwf_endian == SF_ENDIAN_LITTLE && trunc_8to4 == SF_FALSE)
27. count += 8 ;
28. {	longdata = countdata & 0xFFFFFFFF ;
header_put_be_int (psf, longdata) ;
count += 4 ;
29. {	longdata = countdata & 0xFFFFFFFF ;
30. case 'f' :
31. if (psf->rwf_endian == SF_ENDIAN_BIG)
32. psf->header.indx += 4 ;
count += 4 ;
break ;
33. case 'd' :
34. double64_be_write (doubledata, psf->header.ptr + psf->header.indx) ;
35. double64_le_write (doubledata, psf->header.ptr + psf->header.indx) ;
psf->header.indx += 8 ;
count += 8 ;
36. case 's' :
37. size += (size & 1) ;
38. if (psf->header.indx + (sf_count_t) size >= psf->header.len && psf_bump_header_allocation (psf, 16))
39. if (psf->rwf_endian == SF_ENDIAN_BIG)
header_put_be_int (psf, size) ;
40. header_put_le_int (psf, size) ;
41. psf->header.indx += size ;
psf->header.ptr [psf->header.indx - 1] = 0 ;
count += 4 + size ;
break ;
42. case 'S' :
43. if (psf->header.indx + (sf_count_t) size > psf->header.len && psf_bump_header_allocation (psf, size))
return count ;
if (psf->rwf_endian == SF_ENDIAN_BIG)
header_put_be_int (psf, size) ;
44. header_put_le_int (psf, size) ;
45. size += (size & 1) ;
psf->header.indx += size ;
46. count += 4 + size ;
47. case 'p' :
48. size = strlen (strptr) ;
49. return count ;
50. header_put_byte (psf, size) ;
51. psf->header.indx += size ;
count += 1 + size ;
52. size	= va_arg (argptr, size_t) ;
53. if (psf->header.indx + (sf_count_t) size > psf->header.len && psf_bump_header_allocation (psf, size))
54. memcpy (&(psf->header.ptr [psf->header.indx]), bindata, size) ;
55. break ;
56. size = va_arg (argptr, size_t) ;
57. count += size ;
while (size)
{	psf->header.ptr [psf->header.indx] = 0 ;
psf->header.indx ++ ;
size -- ;
58. break ;
59. case 'h' :
60. psf->header.indx += 16 ;
61. break ;
62. case 'j' :
size = va_arg (argptr, size_t) ;
63. if (psf->header.indx + (sf_count_t) size > psf->header.len && psf_bump_header_allocation (psf, size))
return count ;
64. count += size ;
65. case 'o' :
size = va_arg (argptr, size_t) ;
66. return count ;
67. psf->header.indx = size ;
break ;
68. default :
psf_log_printf (psf, ""*** Invalid format specifier `%c'\n"", c) ;
psf->error = SFE_INTERNAL ;
break ;
69. va_end (argptr) ;
return count ;","4-5
7
9
12
16
25-26
29-30
33-35
37-38
41-42
45
47-49
51
53-55
59-60
63
65
71
76-77
79
81-82
85
87
91
93
96
98
101-103
106
112
115
119-121
123
126
128-130
133
137
139
142-143
145
147-150
152
159-162
164
166-167
169
172
176
181
183
185-186
191
193
196
199
202
207-211
213
215
218
220
222-223
225-226
229
232-233
236
238-239
241-244
248-249","CWE-190,CWE-787,CWE-119"
asymmetric_key_match_preparse-101448423531587,"static int asymmetric_key_match_preparse(struct key_match_data *match_data)
{
	match_data->lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE;
	match_data->cmp = asymmetric_key_cmp;
	return 0;
}
",1. static int asymmetric_key_match_preparse(struct key_match_data *match_data),1,"CWE-362,CWE-326,CWE-399"
eb_map-107770443176034,"void eb_map(eb_t p, const uint8_t *msg, size_t len) {
	bn_t k;
	fb_t t0, t1;
	int i;
	uint8_t digest[RLC_MD_LEN];

	bn_null(k);
	fb_null(t0);
	fb_null(t1);

	RLC_TRY {
		bn_new(k);
		fb_new(t0);
		fb_new(t1);

		md_map(digest, msg, len);
		bn_read_bin(k, digest, RLC_MIN(RLC_FB_BYTES, RLC_MD_LEN));
		fb_set_dig(p->z, 1);

		i = 0;
		while (1) {
			bn_add_dig(k, k, 1);
			bn_mod_2b(k, k, RLC_FB_BITS);
			dv_copy(p->x, k->dp, RLC_FB_DIGS);

			eb_rhs(t1, p);

			
			fb_sqr(t0, p->x);
			fb_inv(t0, t0);
			
			fb_mul(t0, t0, t1);
			
			if (fb_trc(t0) != 0) {
				i++;
			} else {
				fb_slv(t1, t0);
				
				fb_mul(p->y, t1, p->x);
				fb_set_dig(p->z, 1);

				p->coord = BASIC;
				break;
			}
		}
		
		eb_curve_get_cof(k);
		if (bn_bits(k) < RLC_DIG) {
			eb_mul_dig(p, p, k->dp[0]);
		} else {
			eb_mul(p, p, k);
		}
	}
	RLC_CATCH_ANY {
		RLC_THROW(ERR_CAUGHT);
	}
	RLC_FINALLY {
		bn_free(k);
		fb_free(t0);
		fb_free(t1);
	}
}
","1. void eb_map(eb_t p, const uint8_t *msg, size_t len) {
2. uint8_t digest[RLC_MD_LEN];
3. bn_null(k);
4. RLC_TRY {
5. i = 0;
6. bn_add_dig(k, k, 1);
7. if (fb_trc(t0) != 0) {
8. eb_mul(p, p, k);
9. RLC_CATCH_ANY {","1
5
7
11
20
22
34
51
54","CWE-476,CWE-190"
comics_document_render_pixbuf-148064057821074,"
#define EvDocument
#define EvRenderContext

static GdkPixbuf *
comics_document_render_pixbuf (EvDocument      *document,
			       EvRenderContext *rc)
{
	GdkPixbufLoader *loader;
	GdkPixbuf *tmp_pixbuf;
	GdkPixbuf *rotated_pixbuf = NULL;
	ComicsDocument *comics_document = COMICS_DOCUMENT (document);
	const char *page_path;
	GError *error = NULL;

	page_path = g_ptr_array_index (comics_document->page_names, rc->page->index);

	if (!archive_reopen_if_needed (comics_document, page_path, &error)) {
		g_warning (""Fatal error opening archive: %s"", error->message);
		g_error_free (error);
		return NULL;
	}

	loader = gdk_pixbuf_loader_new ();
	g_signal_connect (loader, ""size-prepared"",
			  G_CALLBACK (render_pixbuf_size_prepared_cb),
			  rc);

	while (1) {
		const char *name;

		if (!ev_archive_read_next_header (comics_document->archive, &error)) {
			if (error != NULL) {
				g_warning (""Fatal error handling archive (%s): %s"", G_STRFUNC, error->message);
				g_error_free (error);
			}
			break;
		}

		name = ev_archive_get_entry_pathname (comics_document->archive);
		if (g_strcmp0 (name, page_path) == 0) {
			size_t size = ev_archive_get_entry_size (comics_document->archive);
			char *buf;
			ssize_t read;

			buf = g_malloc (size);
			read = ev_archive_read_data (comics_document->archive, buf, size, &error);
			if (read <= 0) {
				if (read < 0) {
					g_warning (""Fatal error reading '%s' in archive: %s"", name, error->message);
					g_error_free (error);
				} else {
					g_warning (""Read an empty file from the archive"");
				}
			} else {
				gdk_pixbuf_loader_write (loader, (guchar *) buf, size, NULL);
			}
			g_free (buf);
			gdk_pixbuf_loader_close (loader, NULL);
			break;
		}
	}

	tmp_pixbuf = gdk_pixbuf_loader_get_pixbuf (loader);
	if (tmp_pixbuf) {
		if ((rc->rotation % 360) == 0)
			rotated_pixbuf = g_object_ref (tmp_pixbuf);
		else
			rotated_pixbuf = gdk_pixbuf_rotate_simple (tmp_pixbuf,
								   360 - rc->rotation);
	}
	g_object_unref (loader);

	return rotated_pixbuf;
}
","1. GdkPixbuf *tmp_pixbuf;
GdkPixbuf *rotated_pixbuf = NULL;
ComicsDocument *comics_document = COMICS_DOCUMENT (document);
const char *page_path;
GError *error = NULL;
2. if (!archive_reopen_if_needed (comics_document, page_path, &error)) {
g_warning (""Fatal error opening archive: %s"", error->message);
3. return NULL;
4. loader = gdk_pixbuf_loader_new ();
5. G_CALLBACK (render_pixbuf_size_prepared_cb),
6. const char *name;
7. if (!ev_archive_read_next_header (comics_document->archive, &error)) {
8. g_warning (""Fatal error handling archive (%s): %s"", G_STRFUNC, error->message);
9. break;
10. name = ev_archive_get_entry_pathname (comics_document->archive);
11. size_t size = ev_archive_get_entry_size (comics_document->archive);
12. ssize_t read;
13. buf = g_malloc (size);
read = ev_archive_read_data (comics_document->archive, buf, size, &error);
14. g_error_free (error);
} else {
g_warning (""Read an empty file from the archive"");
15. } else {
gdk_pixbuf_loader_write (loader, (guchar *) buf, size, NULL);
16. g_free (buf);
17. break;
18. tmp_pixbuf = gdk_pixbuf_loader_get_pixbuf (loader);
if (tmp_pixbuf) {
if ((rc->rotation % 360) == 0)
rotated_pixbuf = g_object_ref (tmp_pixbuf);
19. 360 - rc->rotation);
20. g_object_unref (loader);","10-14
18-19
21
24
26
30
32
34
37
40
42
44
46-47
51-53
55-56
58
60
64-67
70
72","CWE-20,CWE-134,CWE-78"
iakerb_gss_export_sec_context,"
#define OM_uint32

iakerb_gss_export_sec_context(OM_uint32 *minor_status,
                              gss_ctx_id_t *context_handle,
                               gss_buffer_t interprocess_token)
 {
     OM_uint32 maj;
    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)*context_handle;
 
     
     if (!ctx->established)
        return GSS_S_UNAVAILABLE;

    maj = krb5_gss_export_sec_context(minor_status, &ctx->gssc,
                                      interprocess_token);
    if (ctx->gssc == GSS_C_NO_CONTEXT) {
        iakerb_release_context(ctx);
        *context_handle = GSS_C_NO_CONTEXT;
    }
     return maj;
 }
","1. iakerb_gss_export_sec_context(OM_uint32 *minor_status,
gss_ctx_id_t *context_handle,
2. OM_uint32 maj;
iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)*context_handle;
3. if (!ctx->established)
return GSS_S_UNAVAILABLE;
4. maj = krb5_gss_export_sec_context(minor_status, &ctx->gssc,
interprocess_token);","4-5
8-9
12-13
15-16",CWE-18
createFromTiffRgba,"
#define TIFF

static int createFromTiffRgba(TIFF * tif, gdImagePtr im)
{
	int a;
	int x, y;
	int alphaBlendingFlag = 0;
	int color;
	int width = im->sx;
 	int height = im->sy;
 	uint32 *buffer;
 	uint32 rgba;
	int success;
 
 	
	alphaBlendingFlag = im->alphaBlendingFlag;
	gdImageAlphaBlending(im, 0);

	buffer = (uint32 *) gdCalloc(sizeof(uint32), width * height);
	if (!buffer) {
 		return GD_FAILURE;
 	}
 
	success = TIFFReadRGBAImage(tif, width, height, buffer, 1);

	if (success) {
		for(y = 0; y < height; y++) {
			for(x = 0; x < width; x++) {
				
				rgba = buffer[(y * width + x)];
				a = (0xff - TIFFGetA(rgba)) / 2;
				color = gdTrueColorAlpha(TIFFGetR(rgba), TIFFGetG(rgba), TIFFGetB(rgba), a);
	
				
				gdImageSetPixel(im, x, height - y - 1, color);
			}
 		}
 	}
 
 	gdFree(buffer);
 
 	
 	gdImageAlphaBlending(im, alphaBlendingFlag);
	return success;
 }
","1. static int createFromTiffRgba(TIFF * tif, gdImagePtr im)
2. int a;
int x, y;
3. int success;
4. gdImageAlphaBlending(im, 0);
5. if (!buffer) {
return GD_FAILURE;
6. success = TIFFReadRGBAImage(tif, width, height, buffer, 1);
7. gdImageSetPixel(im, x, height - y - 1, color);
8. return success;","4
6-7
14
20
23-24
27
39
48","CWE-362,CWE-416,CWE-190,CWE-119,CWE-125"
SPL_METHOD_4,"
#define Array

SPL_METHOD_4(Array, unserialize)
{
	spl_array_object *intern = (spl_array_object*)zend_object_store_get_object(getThis() TSRMLS_CC);

	char *buf;
	int buf_len;
	const unsigned char *p, *s;
	php_unserialize_data_t var_hash;
	zval *pmembers, *pflags = NULL;
	HashTable *aht;
	long flags;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &buf, &buf_len) == FAILURE) {
		return;
	}

	if (buf_len == 0) {
		return;
	}

	aht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);
	if (aht->nApplyCount > 0) {
		zend_error(E_WARNING, ""Modification of ArrayObject during sorting is prohibited"");
		return;
	}

	
	s = p = (const unsigned char*)buf;
	PHP_VAR_UNSERIALIZE_INIT(var_hash);

	if (*p!= 'x' || *++p != ':') {
		goto outexcept;
	}
	++p;

	ALLOC_INIT_ZVAL(pflags);
	if (!php_var_unserialize(&pflags, &p, s + buf_len, &var_hash TSRMLS_CC) || Z_TYPE_P(pflags) != IS_LONG) {
		goto outexcept;
	}

	var_push_dtor(&var_hash, &pflags);
	--p; 
	flags = Z_LVAL_P(pflags);
	

	if (*p != ';') {
		goto outexcept;
	}
	++p;

	if (*p!='m') {
		if (*p!='a' && *p!='O' && *p!='C' && *p!='r') {
			goto outexcept;
		}
		intern->ar_flags &= ~SPL_ARRAY_CLONE_MASK;
 		intern->ar_flags |= flags & SPL_ARRAY_CLONE_MASK;
 		zval_ptr_dtor(&intern->array);
 		ALLOC_INIT_ZVAL(intern->array);
		if (!php_var_unserialize(&intern->array, &p, s + buf_len, &var_hash TSRMLS_CC)
				|| (Z_TYPE_P(intern->array) != IS_ARRAY && Z_TYPE_P(intern->array) != IS_OBJECT)) {
			zval_ptr_dtor(&intern->array);
 			goto outexcept;
 		}
 		var_push_dtor(&var_hash, &intern->array);
	}
	if (*p != ';') {
		goto outexcept;
	}
	++p;

	
	if (*p!= 'm' || *++p != ':') {
		goto outexcept;
	}
	++p;

	ALLOC_INIT_ZVAL(pmembers);
	if (!php_var_unserialize(&pmembers, &p, s + buf_len, &var_hash TSRMLS_CC) || Z_TYPE_P(pmembers) != IS_ARRAY) {
		zval_ptr_dtor(&pmembers);
		goto outexcept;
	}

	var_push_dtor(&var_hash, &pmembers);
	
	if (!intern->std.properties) {
		rebuild_object_properties(&intern->std);
	}
	zend_hash_copy(intern->std.properties, Z_ARRVAL_P(pmembers), (copy_ctor_func_t) zval_add_ref, (void *) NULL, sizeof(zval *));
	zval_ptr_dtor(&pmembers);

	

	PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
	if (pflags) {
		zval_ptr_dtor(&pflags);
	}
	return;

outexcept:
	PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
	if (pflags) {
		zval_ptr_dtor(&pflags);
	}
	zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, ""Error at offset %ld of %d bytes"", (long)((char*)p - buf), buf_len);
	return;

} 


",1. ALLOC_INIT_ZVAL(pmembers);,83,"CWE-190,CWE-125,CWE-189,CWE-119"
fp54_write_bin-172167877249369,"void fp54_write_bin(uint8_t *bin, size_t len, const fp54_t a, int pack) {
	fp54_t t;

	fp54_null(t);

	RLC_TRY {
		fp54_new(t);

		if (pack) {
			if (len != 36 * RLC_FP_BYTES) {
				RLC_THROW(ERR_NO_BUFFER);
			}
			fp54_pck(t, a);
			fp9_write_bin(bin, 9 * RLC_FP_BYTES, a[1][0]);
			fp9_write_bin(bin + 9 * RLC_FP_BYTES, 9 * RLC_FP_BYTES, a[1][1]);
			fp9_write_bin(bin + 18 * RLC_FP_BYTES, 9 * RLC_FP_BYTES, a[2][0]);
			fp9_write_bin(bin + 27 * RLC_FP_BYTES, 9 * RLC_FP_BYTES, a[2][1]);
		} else {
			if (len != 54 * RLC_FP_BYTES) {
				RLC_THROW(ERR_NO_BUFFER);
			}
			fp18_write_bin(bin, 18 * RLC_FP_BYTES, a[0]);
			fp18_write_bin(bin + 18 * RLC_FP_BYTES, 18 * RLC_FP_BYTES, a[1]);
			fp18_write_bin(bin + 36 * RLC_FP_BYTES, 18 * RLC_FP_BYTES, a[2]);
		}
	} RLC_CATCH_ANY {
		RLC_THROW(ERR_CAUGHT);
	} RLC_FINALLY {
		fp54_free(t);
	}
}
","1. void fp54_write_bin(uint8_t *bin, size_t len, const fp54_t a, int pack) {
fp54_t t;
2. RLC_TRY {
fp54_new(t);
3. if (pack) {
if (len != 36 * RLC_FP_BYTES) {
RLC_THROW(ERR_NO_BUFFER);
4. fp54_pck(t, a);
5. fp9_write_bin(bin + 9 * RLC_FP_BYTES, 9 * RLC_FP_BYTES, a[1][1]);
fp9_write_bin(bin + 18 * RLC_FP_BYTES, 9 * RLC_FP_BYTES, a[2][0]);
6. } else {
if (len != 54 * RLC_FP_BYTES) {
RLC_THROW(ERR_NO_BUFFER);
7. fp18_write_bin(bin, 18 * RLC_FP_BYTES, a[0]);
fp18_write_bin(bin + 18 * RLC_FP_BYTES, 18 * RLC_FP_BYTES, a[1]);
8. RLC_THROW(ERR_CAUGHT);
9. fp54_free(t);","1-2
6-7
9-11
13
15-16
18-20
22-23
27
29",CWE-190
dtls1_get_record,"
#define SSL

int dtls1_get_record(SSL *s)
	{
	int ssl_major,ssl_minor;
	int i,n;
	SSL3_RECORD *rr;
	unsigned char *p = NULL;
	unsigned short version;
	DTLS1_BITMAP *bitmap;
	unsigned int is_next_epoch;

	rr= &(s->s3->rrec);

	
	dtls1_process_buffered_records(s);

	
	if (dtls1_get_processed_record(s))
		return 1;

	
again:
	
	if (	(s->rstate != SSL_ST_READ_BODY) ||
		(s->packet_length < DTLS1_RT_HEADER_LENGTH)) 
		{
		n=ssl3_read_n(s, DTLS1_RT_HEADER_LENGTH, s->s3->rbuf.len, 0);
		
		if (n <= 0) return(n); 

		
		if (s->packet_length != DTLS1_RT_HEADER_LENGTH)
			{
			s->packet_length = 0;
			goto again;
			}

		s->rstate=SSL_ST_READ_BODY;

		p=s->packet;

		if (s->msg_callback)
			s->msg_callback(0, 0, SSL3_RT_HEADER, p, DTLS1_RT_HEADER_LENGTH, s, s->msg_callback_arg);

		
		rr->type= *(p++);
		ssl_major= *(p++);
		ssl_minor= *(p++);
		version=(ssl_major<<8)|ssl_minor;

		 
		n2s(p,rr->epoch);

		memcpy(&(s->s3->read_sequence[2]), p, 6);
		p+=6;

		n2s(p,rr->length);

		
		if (!s->first_packet)
			{
			if (version != s->version)
				{
				
				rr->length = 0;
				s->packet_length = 0;
				goto again;
				}
			}

		if ((version & 0xff00) != (s->version & 0xff00))
			{
			
			rr->length = 0;
			s->packet_length = 0;
			goto again;
			}

		if (rr->length > SSL3_RT_MAX_ENCRYPTED_LENGTH)
			{
			
			rr->length = 0;
			s->packet_length = 0;
			goto again;
			}

		
		}

	

	if (rr->length > s->packet_length-DTLS1_RT_HEADER_LENGTH)
		{
		
		i=rr->length;
		n=ssl3_read_n(s,i,i,1);
		
		if ( n != i)
			{
			rr->length = 0;
			s->packet_length = 0;
			goto again;
			}

		
		}
	s->rstate=SSL_ST_READ_HEADER; 

	
	bitmap = dtls1_get_bitmap(s, rr, &is_next_epoch);
	if ( bitmap == NULL)
		{
		rr->length = 0;
		s->packet_length = 0;  
		goto again;   
		}

#ifndef OPENSSL_NO_SCTP
	
	if (!BIO_dgram_is_sctp(SSL_get_rbio(s)))
  		{
#endif
		
 		if (!(s->d1->listen && rr->type == SSL3_RT_HANDSHAKE &&
		    s->packet_length > DTLS1_RT_HEADER_LENGTH &&
		    s->packet[DTLS1_RT_HEADER_LENGTH] == SSL3_MT_CLIENT_HELLO) &&
 		    !dtls1_record_replay_check(s, bitmap))
 			{
 			rr->length = 0;
			s->packet_length=0; 
			goto again;     
			}
#ifndef OPENSSL_NO_SCTP
  		}
#endif

	
	if (rr->length == 0) goto again;

	
	if (is_next_epoch)
		{
		if ((SSL_in_init(s) || s->in_handshake) && !s->d1->listen)
			{
			dtls1_buffer_record(s, &(s->d1->unprocessed_rcds), rr->seq_num);
			}
		rr->length = 0;
		s->packet_length = 0;
		goto again;
		}

	if (!dtls1_process_record(s))
		{
		rr->length = 0;
		s->packet_length = 0;  
		goto again;   
		}

	return(1);

	}
","1. SSL3_RECORD *rr;
2. rr= &(s->s3->rrec);
3. if (n <= 0) return(n);
4. p=s->packet;
5. rr->type= *(p++);
6. s->packet_length = 0;
7. if (rr->length > s->packet_length-DTLS1_RT_HEADER_LENGTH)
8. i=rr->length;
9. if ( n != i)
10. s->rstate=SSL_ST_READ_HEADER;
11. rr->length = 0;
12. s->packet_length=0;
goto again;
13. rr->length = 0;
14. return(1);","8
14
32
43
49
78
95
98
101
111
117
139-140
167
172","CWE-190,CWE-20,CWE-125,CWE-119"
avi_parse_input_file_2-115339422251927,"
#define AVI

int avi_parse_input_file_2(avi_t *AVI, int getIndex)
{
	int rate, scale, idx_type;
	s64 n, i;
	unsigned char *hdrl_data;
	u64 header_offset=0;
	int hdrl_len=0;
	int nvi, nai[AVI_MAX_TRACKS], ioff;
	u64 tot[AVI_MAX_TRACKS];
	u32 j;
	int lasttag = 0;
	int vids_strh_seen = 0;
	int vids_strf_seen = 0;
	int auds_strh_seen = 0;
	
	int num_stream = 0;
	char data[256];
	s64 oldpos=-1, newpos=-1;

	int aud_chunks = 0;
	if (!AVI) {
	   AVI_errno = AVI_ERR_OPEN;
	   return 0;
	}

	
	if (avi_read(AVI->fdes,data,12) != 12 )
		ERR_EXIT(AVI_ERR_READ)

	if (strnicmp(data  ,""RIFF"",4) !=0 || strnicmp(data+8,""AVI "",4) !=0 )
		ERR_EXIT(AVI_ERR_NO_AVI)

	

	hdrl_data = 0;

	while(1)
	{
		if( avi_read(AVI->fdes,data,8) != 8 ) break; 
		newpos = gf_ftell(AVI->fdes);
		if(oldpos==newpos) {
			
			return -1;
		}
		oldpos=newpos;

		n = str2ulong((unsigned char *)data+4);
		n = PAD_EVEN(n);

		if(strnicmp(data,""LIST"",4) == 0)
		{
			if( avi_read(AVI->fdes,data,4) != 4 ) ERR_EXIT(AVI_ERR_READ)
				n -= 4;
			if(strnicmp(data,""hdrl"",4) == 0)
			{
				if (n>0xFFFFFFFF) ERR_EXIT(AVI_ERR_READ)
				hdrl_len = (u32) n;
				hdrl_data = (unsigned char *) gf_malloc((u32)n);
				if(hdrl_data==0) ERR_EXIT(AVI_ERR_NO_MEM);

				

				header_offset = gf_ftell(AVI->fdes);

				if( avi_read(AVI->fdes,(char *)hdrl_data, (u32) n) != n ) {
					if (hdrl_data) gf_free(hdrl_data);
					ERR_EXIT(AVI_ERR_READ)
				}
			}
			else if(strnicmp(data,""movi"",4) == 0)
			{
				AVI->movi_start = gf_ftell(AVI->fdes);
				if (gf_fseek(AVI->fdes,n,SEEK_CUR)==(u64)-1) break;
			}
			else if (gf_fseek(AVI->fdes,n,SEEK_CUR)==(u64)-1) break;
		}
		else if(strnicmp(data,""idx1"",4) == 0)
		{
			

			AVI->n_idx = AVI->max_idx = (u32) (n/16);
			AVI->idx = (unsigned  char((*)[16]) ) gf_malloc((u32)n);
			if(AVI->idx==0) {
				if (hdrl_data) gf_free(hdrl_data);
				ERR_EXIT(AVI_ERR_NO_MEM)
			}
			if(avi_read(AVI->fdes, (char *) AVI->idx, (u32) n) != n ) {
				gf_free( AVI->idx);
				AVI->idx=NULL;
				AVI->n_idx = 0;
				if (hdrl_data) gf_free(hdrl_data);
				ERR_EXIT(AVI_ERR_READ)
			}
		}
		else
			gf_fseek(AVI->fdes,n,SEEK_CUR);
	}

	if(!hdrl_data) ERR_EXIT(AVI_ERR_NO_HDRL)
	if(!AVI->movi_start) ERR_EXIT(AVI_ERR_NO_MOVI)

			

			for(i=0; i<hdrl_len;)
			{
				

#ifdef DEBUG_ODML
				GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[avilib] TAG %c%c%c%c\n"", (hdrl_data+i)[0], (hdrl_data+i)[1], (hdrl_data+i)[2], (hdrl_data+i)[3]));
#endif

				if(strnicmp((char *)hdrl_data+i,""LIST"",4)==0) {
					i+= 12;
					continue;
				}

				n = str2ulong(hdrl_data+i+4);
				n = PAD_EVEN(n);
				if (i+n>hdrl_len) ERR_EXIT(AVI_ERR_READ)


				

				if(strnicmp((char *)hdrl_data+i,""strh"",4)==0)
				{
					i += 8;
#ifdef DEBUG_ODML
					GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[avilib] TAG   %c%c%c%c\n"", (hdrl_data+i)[0], (hdrl_data+i)[1], (hdrl_data+i)[2], (hdrl_data+i)[3]));
#endif
					if(strnicmp((char *)hdrl_data+i,""vids"",4) == 0 && !vids_strh_seen)
					{
						memcpy(AVI->compressor,hdrl_data+i+4,4);
						AVI->compressor[4] = 0;

						
						AVI->v_codech_off = header_offset + i+4;

						scale = str2ulong(hdrl_data+i+20);
						rate  = str2ulong(hdrl_data+i+24);
						if(scale!=0) AVI->fps = (double)rate/(double)scale;
						AVI->video_frames = str2ulong(hdrl_data+i+32);
						AVI->video_strn = num_stream;
						AVI->max_len = 0;
						vids_strh_seen = 1;
						lasttag = 1; 
						memcpy(&AVI->video_stream_header, hdrl_data + i,
						       sizeof(alAVISTREAMHEADER));
					}
					else if (strnicmp ((char *)hdrl_data+i,""auds"",4) ==0 && ! auds_strh_seen)
					{

						
						AVI->aptr=AVI->anum;
						++AVI->anum;

						if(AVI->anum > AVI_MAX_TRACKS) {
							GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[avilib] error - only %d audio tracks supported\n"", AVI_MAX_TRACKS));
							return(-1);
						}

						AVI->track[AVI->aptr].audio_bytes = str2ulong(hdrl_data+i+32)*avi_sampsize(AVI, 0);
						AVI->track[AVI->aptr].audio_strn = num_stream;

						
						AVI->track[AVI->aptr].a_vbr = !str2ulong(hdrl_data+i+44);

						AVI->track[AVI->aptr].padrate = str2ulong(hdrl_data+i+24);
						memcpy(&AVI->stream_headers[AVI->aptr], hdrl_data + i,
						       sizeof(alAVISTREAMHEADER));

						
						lasttag = 2; 

						
						AVI->track[AVI->aptr].a_codech_off = header_offset + i;

					}
					else if (strnicmp ((char*)hdrl_data+i,""iavs"",4) ==0 && ! auds_strh_seen) {
						GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[avilib] AVILIB: error - DV AVI Type 1 no supported\n""));
						return (-1);
					}
					else
						lasttag = 0;
					num_stream++;
				}
				else if(strnicmp((char*)hdrl_data+i,""dmlh"",4) == 0) {
					AVI->total_frames = str2ulong(hdrl_data+i+8);
#ifdef DEBUG_ODML
					GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[avilib] real number of frames %d\n"", AVI->total_frames));
#endif
					i += 8;
				}
				else if(strnicmp((char *)hdrl_data+i,""strf"",4)==0)
				{
					i += 8;
					if(lasttag == 1)
					{
						alBITMAPINFOHEADER bih;

						memcpy(&bih, hdrl_data + i, sizeof(alBITMAPINFOHEADER));
						bih.bi_size = str2ulong((unsigned char *)&bih.bi_size);

						if (i + bih.bi_size > hdrl_len) ERR_EXIT(AVI_ERR_READ)

						AVI->bitmap_info_header = (alBITMAPINFOHEADER *) gf_malloc(bih.bi_size);
						if (AVI->bitmap_info_header != NULL)
							memcpy(AVI->bitmap_info_header, hdrl_data + i, bih.bi_size);

						AVI->width  = str2ulong(hdrl_data+i+4);
						AVI->height = str2ulong(hdrl_data+i+8);
						vids_strf_seen = 1;
						
						AVI->v_codecf_off = header_offset + i+16;

						memcpy(AVI->compressor2, hdrl_data+i+16, 4);
						AVI->compressor2[4] = 0;

						if (n>40) {
							if (n>0xFFFFFFFF) ERR_EXIT(AVI_ERR_READ)
							AVI->extradata_size = (u32) (n - 40);
							AVI->extradata = gf_malloc(sizeof(u8)* AVI->extradata_size);
							if (!AVI->extradata) ERR_EXIT(AVI_ERR_NO_MEM)
							memcpy(AVI->extradata, hdrl_data + i + 40, AVI->extradata_size);
						}

					}
					else if(lasttag == 2)
					{
						alWAVEFORMATEX *wfe;
						char *nwfe;
						int wfes;

						if ((u32) (hdrl_len - i) < sizeof(alWAVEFORMATEX))
							wfes = (int) (hdrl_len - i);
						else
							wfes = sizeof(alWAVEFORMATEX);
						wfe = (alWAVEFORMATEX *)gf_malloc(sizeof(alWAVEFORMATEX));
						if (wfe != NULL) {
							memset(wfe, 0, sizeof(alWAVEFORMATEX));
							memcpy(wfe, hdrl_data + i, wfes);
							if (str2ushort((unsigned char *)&wfe->cb_size) != 0) {
								nwfe = (char *)
								       gf_realloc(wfe, sizeof(alWAVEFORMATEX) +
								                  str2ushort((unsigned char *)&wfe->cb_size));
								if (nwfe != 0) {
									s64 lpos = gf_ftell(AVI->fdes);
									gf_fseek(AVI->fdes, header_offset + i + sizeof(alWAVEFORMATEX),
									         SEEK_SET);
									wfe = (alWAVEFORMATEX *)nwfe;
									nwfe = &nwfe[sizeof(alWAVEFORMATEX)];
									avi_read(AVI->fdes, nwfe,
									         str2ushort((unsigned char *)&wfe->cb_size));
									gf_fseek(AVI->fdes, lpos, SEEK_SET);
								}
							}
							AVI->wave_format_ex[AVI->aptr] = wfe;
						}

						AVI->track[AVI->aptr].a_fmt   = str2ushort(hdrl_data+i  );

						
						AVI->track[AVI->aptr].a_codecf_off = header_offset + i;

						AVI->track[AVI->aptr].a_chans = str2ushort(hdrl_data+i+2);
						AVI->track[AVI->aptr].a_rate  = str2ulong (hdrl_data+i+4);
						
						AVI->track[AVI->aptr].mp3rate = 8*str2ulong(hdrl_data+i+8)/1000;
						
						AVI->track[AVI->aptr].a_bits  = str2ushort(hdrl_data+i+14);
						
					}
				}
				else if(strnicmp((char*)hdrl_data+i,""indx"",4) == 0) {
					char *a;

					if(lasttag == 1) 
					{

						a = (char*)hdrl_data+i;
						int avail = hdrl_len-i;
						if (avail<32) ERR_EXIT(AVI_ERR_READ)

						AVI->video_superindex = (avisuperindex_chunk *) gf_malloc (sizeof (avisuperindex_chunk));
						memset(AVI->video_superindex, 0, sizeof (avisuperindex_chunk));
						memcpy (AVI->video_superindex->fcc, a, 4);
						a += 4;
						AVI->video_superindex->dwSize = str2ulong((unsigned char *)a);
						a += 4;
						AVI->video_superindex->wLongsPerEntry = str2ushort((unsigned char *)a);
						a += 2;
						AVI->video_superindex->bIndexSubType = *a;
						a += 1;
						AVI->video_superindex->bIndexType = *a;
						a += 1;
						AVI->video_superindex->nEntriesInUse = str2ulong((unsigned char *)a);
						a += 4;
						memcpy (AVI->video_superindex->dwChunkId, a, 4);
						a += 4;

						
						a += 4;
						a += 4;
						a += 4;

						if (AVI->video_superindex->bIndexSubType != 0) {
							GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[avilib] Invalid Header, bIndexSubType != 0\n""));
						}
						avail -= 32;
						if (avail < AVI->video_superindex->nEntriesInUse*16) ERR_EXIT(AVI_ERR_READ)

						AVI->video_superindex->aIndex = (avisuperindex_entry*)
						                                gf_malloc (AVI->video_superindex->wLongsPerEntry * AVI->video_superindex->nEntriesInUse * sizeof (u32));

						
						for (j=0; j<AVI->video_superindex->nEntriesInUse; ++j) {
							AVI->video_superindex->aIndex[j].qwOffset = str2ullong ((unsigned char*)a);
							a += 8;
							AVI->video_superindex->aIndex[j].dwSize = str2ulong ((unsigned char*)a);
							a += 4;
							AVI->video_superindex->aIndex[j].dwDuration = str2ulong ((unsigned char*)a);
							a += 4;

#ifdef DEBUG_ODML
							GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[avilib] [%d] 0x%llx 0x%lx %lu\n"", j,
							                                        (unsigned int long)AVI->video_superindex->aIndex[j].qwOffset,
							                                        (unsigned long)AVI->video_superindex->aIndex[j].dwSize,
							                                        (unsigned long)AVI->video_superindex->aIndex[j].dwDuration));
#endif
						}


#ifdef DEBUG_ODML
						GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[avilib] FOURCC \""%c%c%c%c\""\n"", AVI->video_superindex->fcc[0], AVI->video_superindex->fcc[1],
						                                        AVI->video_superindex->fcc[2], AVI->video_superindex->fcc[3]));
						GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[avilib] LEN \""%ld\""\n"", (long)AVI->video_superindex->dwSize));
						GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[avilib] wLongsPerEntry \""%d\""\n"", AVI->video_superindex->wLongsPerEntry));
						GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[avilib] bIndexSubType \""%d\""\n"", AVI->video_superindex->bIndexSubType));
						GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[avilib] bIndexType \""%d\""\n"", AVI->video_superindex->bIndexType));
						GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[avilib] nEntriesInUse \""%ld\""\n"", (long)AVI->video_superindex->nEntriesInUse));
						GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[avilib] dwChunkId \""%c%c%c%c\""\n"", AVI->video_superindex->dwChunkId[0], AVI->video_superindex->dwChunkId[1],
						                                        AVI->video_superindex->dwChunkId[2], AVI->video_superindex->dwChunkId[3]));
#endif

						AVI->is_opendml = 1;

					}
					else if(lasttag == 2) 
					{

						a = (char*) hdrl_data+i;
						int avail = hdrl_len-i;
						if (avail<32) ERR_EXIT(AVI_ERR_READ)

						AVI->track[AVI->aptr].audio_superindex = (avisuperindex_chunk *) gf_malloc (sizeof (avisuperindex_chunk));
						memcpy (AVI->track[AVI->aptr].audio_superindex->fcc, a, 4);
						a += 4;
						AVI->track[AVI->aptr].audio_superindex->dwSize = str2ulong((unsigned char*)a);
						a += 4;
						AVI->track[AVI->aptr].audio_superindex->wLongsPerEntry = str2ushort((unsigned char*)a);
						a += 2;
						AVI->track[AVI->aptr].audio_superindex->bIndexSubType = *a;
						a += 1;
						AVI->track[AVI->aptr].audio_superindex->bIndexType = *a;
						a += 1;
						AVI->track[AVI->aptr].audio_superindex->nEntriesInUse = str2ulong((unsigned char*)a);
						a += 4;
						memcpy (AVI->track[AVI->aptr].audio_superindex->dwChunkId, a, 4);
						a += 4;

						
						a += 4;
						a += 4;
						a += 4;

						if (AVI->track[AVI->aptr].audio_superindex->bIndexSubType != 0) {
							GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[avilib] Invalid Header, bIndexSubType != 0\n""));
						}

						avail -= 32;
						if (avail < AVI->track[AVI->aptr].audio_superindex->nEntriesInUse*16) ERR_EXIT(AVI_ERR_READ)

						AVI->track[AVI->aptr].audio_superindex->aIndex = (avisuperindex_entry*)
						        gf_malloc (AVI->track[AVI->aptr].audio_superindex->wLongsPerEntry *
						                   AVI->track[AVI->aptr].audio_superindex->nEntriesInUse * sizeof (u32));

						
						for (j=0; j<AVI->track[AVI->aptr].audio_superindex->nEntriesInUse; ++j) {
							AVI->track[AVI->aptr].audio_superindex->aIndex[j].qwOffset = str2ullong ((unsigned char*)a);
							a += 8;
							AVI->track[AVI->aptr].audio_superindex->aIndex[j].dwSize = str2ulong ((unsigned char*)a);
							a += 4;
							AVI->track[AVI->aptr].audio_superindex->aIndex[j].dwDuration = str2ulong ((unsigned char*)a);
							a += 4;

#ifdef DEBUG_ODML
							GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[avilib] [%d] 0x%llx 0x%lx %lu\n"", j,
							                                        (unsigned int long)AVI->track[AVI->aptr].audio_superindex->aIndex[j].qwOffset,
							                                        (unsigned long)AVI->track[AVI->aptr].audio_superindex->aIndex[j].dwSize,
							                                        (unsigned long)AVI->track[AVI->aptr].audio_superindex->aIndex[j].dwDuration));
#endif
						}

						AVI->track[AVI->aptr].audio_superindex->stdindex = NULL;

#ifdef DEBUG_ODML
						GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[avilib] FOURCC \""%.4s\""\n"", AVI->track[AVI->aptr].audio_superindex->fcc));
						GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[avilib] LEN \""%ld\""\n"", (long)AVI->track[AVI->aptr].audio_superindex->dwSize));
						GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[avilib] wLongsPerEntry \""%d\""\n"", AVI->track[AVI->aptr].audio_superindex->wLongsPerEntry));
						GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[avilib] bIndexSubType \""%d\""\n"", AVI->track[AVI->aptr].audio_superindex->bIndexSubType));
						GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[avilib] bIndexType \""%d\""\n"", AVI->track[AVI->aptr].audio_superindex->bIndexType));
						GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[avilib] nEntriesInUse \""%ld\""\n"", (long)AVI->track[AVI->aptr].audio_superindex->nEntriesInUse));
						GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[avilib] dwChunkId \""%.4s\""\n"", AVI->track[AVI->aptr].audio_superindex->dwChunkId[0]));
#endif

					}
					i += 8;
				}
				else if((strnicmp((char*)hdrl_data+i,""JUNK"",4) == 0) ||
				        (strnicmp((char*)hdrl_data+i,""strn"",4) == 0) ||
				        (strnicmp((char*)hdrl_data+i,""vprp"",4) == 0)) {
					i += 8;
					
				} else
				{
					i += 8;
					lasttag = 0;
				}
				

				i += (u32) n;
			}

	gf_free(hdrl_data);

	if(!vids_strh_seen || !vids_strf_seen) ERR_EXIT(AVI_ERR_NO_VIDS)

		AVI->video_tag[0] = AVI->video_strn/10 + '0';
	AVI->video_tag[1] = AVI->video_strn%10 + '0';
	AVI->video_tag[2] = 'd';
	AVI->video_tag[3] = 'b';

	
	if(!AVI->track[0].a_chans) AVI->track[0].audio_strn = 99;

	{
		int tk=0;
		for(j=0; j<AVI->anum+1; ++j) {
			if (j == AVI->video_strn) continue;
			AVI->track[tk].audio_tag[0] = j/10 + '0';
			AVI->track[tk].audio_tag[1] = j%10 + '0';
			AVI->track[tk].audio_tag[2] = 'w';
			AVI->track[tk].audio_tag[3] = 'b';
			++tk;
		}
	}

	gf_fseek(AVI->fdes,AVI->movi_start,SEEK_SET);

	if(!getIndex) return(0);

	

	idx_type = 0;

	if(AVI->idx)
	{
		s64 pos, len;

		

		for(i=0; i<AVI->n_idx; i++)
			if( strnicmp((char *)AVI->idx[i],(char *)AVI->video_tag,3)==0 ) break;
		if(i>=AVI->n_idx) ERR_EXIT(AVI_ERR_NO_VIDS)

			pos = str2ulong(AVI->idx[i]+ 8);
		len = str2ulong(AVI->idx[i]+12);

		gf_fseek(AVI->fdes,pos,SEEK_SET);
		if(avi_read(AVI->fdes,data,8)!=8) ERR_EXIT(AVI_ERR_READ)
			if( strnicmp(data,(char *)AVI->idx[i],4)==0 && str2ulong((unsigned char *)data+4)==len )
			{
				idx_type = 1; 
			}
			else
			{
				gf_fseek(AVI->fdes,pos+AVI->movi_start-4,SEEK_SET);
				if(avi_read(AVI->fdes,data,8)!=8) ERR_EXIT(AVI_ERR_READ)
					if( strnicmp(data,(char *)AVI->idx[i],4)==0 && str2ulong((unsigned char *)data+4)==len )
					{
						idx_type = 2; 
					}
			}
		
	}


	if(idx_type == 0 && !AVI->is_opendml && !AVI->total_frames)
	{
		

		gf_fseek(AVI->fdes, AVI->movi_start, SEEK_SET);

		AVI->n_idx = 0;

		while(1)
		{
			if( avi_read(AVI->fdes,data,8) != 8 ) break;
			n = str2ulong((unsigned char *)data+4);

			

			if(strnicmp(data,""LIST"",4)==0)
			{
				gf_fseek(AVI->fdes,4,SEEK_CUR);
				continue;
			}

			

			if( ( (data[2]=='d' || data[2]=='D') &&
			        (data[3]=='b' || data[3]=='B' || data[3]=='c' || data[3]=='C') )
			        || ( (data[2]=='w' || data[2]=='W') &&
			             (data[3]=='b' || data[3]=='B') ) )
			{
				u64 __pos = gf_ftell(AVI->fdes) - 8;
				avi_add_index_entry(AVI,(unsigned char *)data,0,__pos,n);
			}

			gf_fseek(AVI->fdes,PAD_EVEN(n),SEEK_CUR);
		}
		idx_type = 1;
	}

	
	
	

	
	if (AVI->is_opendml) {
		u64 offset = 0;
		hdrl_len = 4+4+2+1+1+4+4+8+4;
		char *en, *chunk_start;
		int k = 0;
		u32 audtr = 0;
		u32 nrEntries = 0;

		AVI->video_index = NULL;

		nvi = 0;
		for(audtr=0; audtr<AVI->anum; ++audtr) {
			nai[audtr] = 0;
			tot[audtr] = 0;
		}

		
		
		

		for (j=0; j<AVI->video_superindex->nEntriesInUse; j++) {

			
			chunk_start = en = (char*) gf_malloc ((u32) (AVI->video_superindex->aIndex[j].dwSize+hdrl_len) );

			if (gf_fseek(AVI->fdes, AVI->video_superindex->aIndex[j].qwOffset, SEEK_SET) == (u64)-1) {
				gf_free(chunk_start);
				continue;
			}

			if (avi_read(AVI->fdes, en, (u32) (AVI->video_superindex->aIndex[j].dwSize+hdrl_len) ) <= 0) {
				gf_free(chunk_start);
				continue;
			}

			nrEntries = str2ulong((unsigned char*)en + 12);
#ifdef DEBUG_ODML
			
#endif
			offset = str2ullong((unsigned char*)en + 20);

			
			en += hdrl_len;
			nvi += nrEntries;
			AVI->video_index = (video_index_entry *) gf_realloc (AVI->video_index, nvi * sizeof (video_index_entry));
			if (!AVI->video_index) {
				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[avilib] out of mem (size = %ld)\n"", nvi * sizeof (video_index_entry)));
				exit(1);
			}

			while (k < nvi) {

				AVI->video_index[k].pos = offset + str2ulong((unsigned char*)en);
				en += 4;
				AVI->video_index[k].len = str2ulong_len((unsigned char*)en);
				AVI->video_index[k].key = str2ulong_key((unsigned char*)en);
				en += 4;

				
				if (AVI->video_index[k].pos-offset == 0 && AVI->video_index[k].len == 0) {
					k--;
					nvi--;
				}

#ifdef DEBUG_ODML
				
#endif

				k++;
			}

			gf_free(chunk_start);
		}

		AVI->video_frames = nvi;
		
		if (AVI->video_frames == 0) {
			AVI->is_opendml=0;
			goto multiple_riff;
		}

		
		
		

		for(audtr=0; audtr<AVI->anum; ++audtr) {

			k = 0;
			if (!AVI->track[audtr].audio_superindex) {
				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[avilib] (%s) cannot read audio index for track %d\n"", __FILE__, audtr));
				continue;
			}
			for (j=0; j<AVI->track[audtr].audio_superindex->nEntriesInUse; j++) {

				
				chunk_start = en = (char*)gf_malloc ((u32) (AVI->track[audtr].audio_superindex->aIndex[j].dwSize+hdrl_len));

				if (gf_fseek(AVI->fdes, AVI->track[audtr].audio_superindex->aIndex[j].qwOffset, SEEK_SET) == (u64)-1) {
					gf_free(chunk_start);
					continue;
				}

				if (avi_read(AVI->fdes, en, (u32) (AVI->track[audtr].audio_superindex->aIndex[j].dwSize+hdrl_len)) <= 0) {
					gf_free(chunk_start);
					continue;
				}

				nrEntries = str2ulong((unsigned char*)en + 12);
				
#ifdef DEBUG_ODML
				
#endif
				offset = str2ullong((unsigned char*)en + 20);

				
				en += hdrl_len;
				nai[audtr] += nrEntries;
				AVI->track[audtr].audio_index = (audio_index_entry *) gf_realloc (AVI->track[audtr].audio_index, nai[audtr] * sizeof (audio_index_entry));

				while (k < nai[audtr]) {

					AVI->track[audtr].audio_index[k].pos = offset + str2ulong((unsigned char*)en);
					en += 4;
					AVI->track[audtr].audio_index[k].len = str2ulong_len((unsigned char*)en);
					en += 4;
					AVI->track[audtr].audio_index[k].tot = tot[audtr];
					tot[audtr] += AVI->track[audtr].audio_index[k].len;

#ifdef DEBUG_ODML
					
#endif

					++k;
				}

				gf_free(chunk_start);
			}

			AVI->track[audtr].audio_chunks = nai[audtr];
			AVI->track[audtr].audio_bytes = tot[audtr];
		}
	} 

	else if (AVI->total_frames && !AVI->is_opendml && idx_type==0) {

		
		
		

multiple_riff:

		gf_fseek(AVI->fdes, AVI->movi_start, SEEK_SET);

		AVI->n_idx = 0;

		GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[avilib] Reconstructing index...""));

		
		nvi = AVI->video_frames = AVI->total_frames;
		nai[0] = AVI->track[0].audio_chunks = AVI->total_frames;
		for(j=1; j<AVI->anum; ++j) AVI->track[j].audio_chunks = 0;

		AVI->video_index = (video_index_entry *) gf_malloc(nvi*sizeof(video_index_entry));

		if(AVI->video_index==0) ERR_EXIT(AVI_ERR_NO_MEM);

		for(j=0; j<AVI->anum; ++j) {
			if(AVI->track[j].audio_chunks) {
				AVI->track[j].audio_index = (audio_index_entry *) gf_malloc((nai[j]+1)*sizeof(audio_index_entry));
				memset(AVI->track[j].audio_index, 0, (nai[j]+1)*(sizeof(audio_index_entry)));
				if(AVI->track[j].audio_index==0) ERR_EXIT(AVI_ERR_NO_MEM);
			}
		}

		nvi = 0;
		for(j=0; j<AVI->anum; ++j) {
			nai[j] = 0;
			tot[j] = 0;
		}

		aud_chunks = AVI->total_frames;

		while(1)
		{
			if (nvi >= AVI->total_frames) break;

			if( avi_read(AVI->fdes,data,8) != 8 ) break;
			n = str2ulong((unsigned char *)data+4);


			j=0;

			if (aud_chunks - nai[j] -1 <= 0) {
				aud_chunks += AVI->total_frames;
				AVI->track[j].audio_index = (audio_index_entry *)
				                            gf_realloc( AVI->track[j].audio_index, (aud_chunks+1)*sizeof(audio_index_entry));
				if (!AVI->track[j].audio_index) {
					GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[avilib] Internal error in avilib -- no mem\n""));
					AVI_errno = AVI_ERR_NO_MEM;
					return -1;
				}
			}

			

			
			if(
			    (data[0]=='0' || data[1]=='0') &&
			    (data[2]=='d' || data[2]=='D') &&
			    (data[3]=='b' || data[3]=='B' || data[3]=='c' || data[3]=='C') ) {

				AVI->video_index[nvi].key = 0x0;
				AVI->video_index[nvi].pos = gf_ftell(AVI->fdes);
				AVI->video_index[nvi].len = (u32) n;

				
				nvi++;
				gf_fseek(AVI->fdes,PAD_EVEN(n),SEEK_CUR);
			}

			
			else if(
			    (data[0]=='0' || data[1]=='1') &&
			    (data[2]=='w' || data[2]=='W') &&
			    (data[3]=='b' || data[3]=='B') ) {


				AVI->track[j].audio_index[nai[j]].pos = gf_ftell(AVI->fdes);
				AVI->track[j].audio_index[nai[j]].len = (u32) n;
				AVI->track[j].audio_index[nai[j]].tot = tot[j];
				tot[j] += AVI->track[j].audio_index[nai[j]].len;
				nai[j]++;

				gf_fseek(AVI->fdes,PAD_EVEN(n),SEEK_CUR);
			}
			else {
				gf_fseek(AVI->fdes,-4,SEEK_CUR);
			}

		}
		if (nvi < AVI->total_frames) {
			GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[avilib] Uh? Some frames seems missing (%ld/%d)\n"",
			        nvi,  AVI->total_frames));
		}


		AVI->video_frames = nvi;
		AVI->track[0].audio_chunks = nai[0];

		for(j=0; j<AVI->anum; ++j) AVI->track[j].audio_bytes = tot[j];
		GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[avilib] done. nvi=%ld nai=%ld tot=%ld\n"", nvi, nai[0], tot[0]));

	} 

	else

	{
		
		
		

		

		nvi = 0;
		for(j=0; j<AVI->anum; ++j) nai[j] = 0;

		for(i=0; i<AVI->n_idx; i++) {

			if(strnicmp((char *)AVI->idx[i],AVI->video_tag,3) == 0) nvi++;

			for(j=0; j<AVI->anum; ++j) if(strnicmp((char *)AVI->idx[i], AVI->track[j].audio_tag,4) == 0) nai[j]++;
		}

		AVI->video_frames = nvi;
		for(j=0; j<AVI->anum; ++j) AVI->track[j].audio_chunks = nai[j];


		if(AVI->video_frames==0) ERR_EXIT(AVI_ERR_NO_VIDS);
		AVI->video_index = (video_index_entry *) gf_malloc(nvi*sizeof(video_index_entry));
		if(AVI->video_index==0) ERR_EXIT(AVI_ERR_NO_MEM);

		for(j=0; j<AVI->anum; ++j) {
			if(AVI->track[j].audio_chunks) {
				AVI->track[j].audio_index = (audio_index_entry *) gf_malloc((nai[j]+1)*sizeof(audio_index_entry));
				memset(AVI->track[j].audio_index, 0, (nai[j]+1)*(sizeof(audio_index_entry)));
				if(AVI->track[j].audio_index==0) ERR_EXIT(AVI_ERR_NO_MEM);
			}
		}

		nvi = 0;
		for(j=0; j<AVI->anum; ++j) {
			nai[j] = 0;
			tot[j] = 0;
		}

		ioff = idx_type == 1 ? 8 : (u32)AVI->movi_start+4;

		for(i=0; i<AVI->n_idx; i++) {

			
			if(strnicmp((char *)AVI->idx[i],AVI->video_tag,3) == 0) {
				AVI->video_index[nvi].key = str2ulong(AVI->idx[i]+ 4);
				AVI->video_index[nvi].pos = str2ulong(AVI->idx[i]+ 8)+ioff;
				AVI->video_index[nvi].len = str2ulong(AVI->idx[i]+12);
				nvi++;
			}

			
			for(j=0; j<AVI->anum; ++j) {

				if(strnicmp((char *)AVI->idx[i],AVI->track[j].audio_tag,4) == 0) {
					AVI->track[j].audio_index[nai[j]].pos = str2ulong(AVI->idx[i]+ 8)+ioff;
					AVI->track[j].audio_index[nai[j]].len = str2ulong(AVI->idx[i]+12);
					AVI->track[j].audio_index[nai[j]].tot = tot[j];
					tot[j] += AVI->track[j].audio_index[nai[j]].len;
					nai[j]++;
				}
			}
		}


		for(j=0; j<AVI->anum; ++j) AVI->track[j].audio_bytes = tot[j];

	} 

	

	gf_fseek(AVI->fdes,AVI->movi_start,SEEK_SET);
	AVI->video_pos = 0;

	return(0);
}
","1. unsigned char *hdrl_data;
u64 header_offset=0;
2. if (!AVI) {
3. if(oldpos==newpos) {
4. num_stream++;
5. wfes = (int) (hdrl_len - i);
6. if (avail < AVI->video_superindex->nEntriesInUse*16) ERR_EXIT(AVI_ERR_READ)
7. i += 8;
8. (strnicmp((char*)hdrl_data+i,""vprp"",4) == 0)) {
9. gf_free(hdrl_data);
10. pos = str2ulong(AVI->idx[i]+ 8);
11. if(avi_read(AVI->fdes,data,8)!=8) ERR_EXIT(AVI_ERR_READ)
12. for(j=0; j<AVI->anum; ++j) {
13. if (aud_chunks - nai[j] -1 <= 0) {
14. GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[avilib] Internal error in avilib -- no mem\n""));
15. (data[3]=='b' || data[3]=='B') ) {
16. nvi = 0;
for(j=0; j<AVI->anum; ++j) {","8-9
24
46
190
240
315
422
426
439
483
495
733
750
755
785
850-851","CWE-190,CWE-125,CWE-119"
send_acknowledge-166637555818930,"static int send_acknowledge(struct nci_spi *nspi, u8 acknowledge)
{
	struct sk_buff *skb;
	unsigned char *hdr;
	u16 crc;
	int ret;

	skb = nci_skb_alloc(nspi->ndev, 0, GFP_KERNEL);
	if (!skb)
		return -ENOMEM;

	
	hdr = skb_push(skb, NCI_SPI_HDR_LEN);
	hdr[0] = NCI_SPI_DIRECT_WRITE;
	hdr[1] = NCI_SPI_CRC_ENABLED;
	hdr[2] = acknowledge << NCI_SPI_ACK_SHIFT;
	hdr[3] = 0;

	crc = crc_ccitt(CRC_INIT, skb->data, skb->len);
	skb_put_u8(skb, crc >> 8);
	skb_put_u8(skb, crc & 0xFF);

	ret = __nci_spi_send(nspi, skb, 0);

	kfree_skb(skb);

	return ret;
}
","1. struct sk_buff *skb;
unsigned char *hdr;
2. hdr[0] = NCI_SPI_DIRECT_WRITE;","3-4
14","CWE-416,CWE-119"
dhcps_receive_udp_packet_handler-173392188470348,"static void dhcps_receive_udp_packet_handler(void *arg, struct udp_pcb *udp_pcb,
struct pbuf *udp_packet_buffer, struct ip_addr *sender_addr, uint16_t sender_port)
{	
  	int16_t total_length_of_packet_buffer;
	struct pbuf *merged_packet_buffer = NULL;

	dhcp_message_repository = (struct dhcp_msg *)udp_packet_buffer->payload;
	if (udp_packet_buffer == NULL) {
		printf(""\n\r Error!!!! System doesn't allocate any buffer \n\r"");
		return;  
	}
	if (sender_port == DHCP_CLIENT_PORT) {
#if LWIP_VERSION_MAJOR >= 2
		if(netif_get_idx(ip_current_input_netif()) == 0 && wifi_mode == RTW_MODE_STA_AP)
#else
		if(netif_get_idx(ip_current_netif()) == 0 && wifi_mode == RTW_MODE_STA_AP)
#endif
		{
			pbuf_free(udp_packet_buffer);
			return;
		}
		total_length_of_packet_buffer = udp_packet_buffer->tot_len;
		if (udp_packet_buffer->next != NULL) {
			merged_packet_buffer = pbuf_coalesce(udp_packet_buffer,
								PBUF_TRANSPORT);
			if (merged_packet_buffer->tot_len !=
						total_length_of_packet_buffer) {
				pbuf_free(udp_packet_buffer);	
				return;
			}
			udp_packet_buffer = merged_packet_buffer;
		}
		switch (dhcps_check_msg_and_handle_options(udp_packet_buffer)) {
		case  DHCP_SERVER_STATE_OFFER:
			#if (debug_dhcps)	
			printf(""%s DHCP_SERVER_STATE_OFFER\n"",__func__);
			#endif
			dhcps_send_offer(udp_packet_buffer);
			break;
		case DHCP_SERVER_STATE_ACK:
			#if (debug_dhcps)	
			printf(""%s DHCP_SERVER_STATE_ACK\n"",__func__);
			#endif
			dhcps_send_ack(udp_packet_buffer);
#if (!IS_USE_FIXED_IP)
#if LWIP_VERSION_MAJOR >= 2
			mark_ip_in_table((uint8_t)ip4_addr4(ip_2_ip4(&dhcps_allocated_client_address))); 
#else
			mark_ip_in_table((uint8_t)ip4_addr4(&dhcps_allocated_client_address)); 	
#endif			
	#ifdef CONFIG_DHCPS_KEPT_CLIENT_INFO
			save_client_addr(&dhcps_allocated_client_address, client_addr);
			memset(&client_request_ip, 0, sizeof(client_request_ip));
			memset(&client_addr, 0, sizeof(client_addr));
			memset(&dhcps_allocated_client_address, 0, sizeof(dhcps_allocated_client_address));
			#if (debug_dhcps)	
			dump_client_table();
			#endif
	#endif
#endif
			dhcp_server_state_machine = DHCP_SERVER_STATE_IDLE;
			break;
		case DHCP_SERVER_STATE_NAK:
			#if (debug_dhcps)	
			printf(""%s DHCP_SERVER_STATE_NAK\n"",__func__);
			#endif
			dhcps_send_nak(udp_packet_buffer);
			dhcp_server_state_machine = DHCP_SERVER_STATE_IDLE;
			break;
		case DHCP_OPTION_CODE_END:
			#if (debug_dhcps)	
			printf(""%s DHCP_OPTION_CODE_END\n"",__func__);
			#endif
			break;
		}
	}
	
	
	udp_disconnect(udp_pcb);

	   
	if (merged_packet_buffer != NULL)
		pbuf_free(merged_packet_buffer);
	else 
		pbuf_free(udp_packet_buffer);
}
","1. static void dhcps_receive_udp_packet_handler(void *arg, struct udp_pcb *udp_pcb,
2. return;
3. udp_disconnect(udp_pcb);","1
10
79","CWE-119,CWE-125,CWE-399,CWE-401"
infra_delete-183597802519154,"void 
infra_delete(struct infra_cache* infra)
{
	if(!infra)
		return;
	slabhash_delete(infra->hosts);
	slabhash_delete(infra->domain_rates);
	traverse_postorder(&infra->domain_limits, domain_limit_free, NULL);
	slabhash_delete(infra->client_ip_rates);
	traverse_postorder(&infra->wait_limits_netblock,
		wait_limit_netblock_del, NULL);
	traverse_postorder(&infra->wait_limits_cookie_netblock,
		wait_limit_netblock_del, NULL);
	free(infra);
}
",1. void,1,"CWE-772,CWE-190,CWE-125,CWE-399"
hwahc_security_create,"static int hwahc_security_create(struct hwahc *hwahc)
{
	int result;
	struct wusbhc *wusbhc = &hwahc->wusbhc;
	struct usb_device *usb_dev = hwahc->wa.usb_dev;
	struct device *dev = &usb_dev->dev;
	struct usb_security_descriptor *secd;
	struct usb_encryption_descriptor *etd;
	void *itr, *top;
	size_t itr_size, needed, bytes;
	u8 index;
	char buf[64];

	
	index = (usb_dev->actconfig - usb_dev->config) /
		sizeof(usb_dev->config[0]);
	itr = usb_dev->rawdescriptors[index];
	itr_size = le16_to_cpu(usb_dev->actconfig->desc.wTotalLength);
 	top = itr + itr_size;
 	result = __usb_get_extra_descriptor(usb_dev->rawdescriptors[index],
 			le16_to_cpu(usb_dev->actconfig->desc.wTotalLength),
			USB_DT_SECURITY, (void **) &secd, sizeof(*secd));
 	if (result == -1) {
 		dev_warn(dev, ""BUG? WUSB host has no security descriptors\n"");
 		return 0;
	}
	needed = sizeof(*secd);
	if (top - (void *)secd < needed) {
		dev_err(dev, ""BUG? Not enough data to process security ""
			""descriptor header (%zu bytes left vs %zu needed)\n"",
			top - (void *) secd, needed);
		return 0;
	}
	needed = le16_to_cpu(secd->wTotalLength);
	if (top - (void *)secd < needed) {
		dev_err(dev, ""BUG? Not enough data to process security ""
			""descriptors (%zu bytes left vs %zu needed)\n"",
			top - (void *) secd, needed);
		return 0;
	}
	
	itr = (void *) secd + sizeof(*secd);
	top = (void *) secd + le16_to_cpu(secd->wTotalLength);
	index = 0;
	bytes = 0;
	while (itr < top) {
		etd = itr;
		if (top - itr < sizeof(*etd)) {
			dev_err(dev, ""BUG: bad host security descriptor; ""
				""not enough data (%zu vs %zu left)\n"",
				top - itr, sizeof(*etd));
			break;
		}
		if (etd->bLength < sizeof(*etd)) {
			dev_err(dev, ""BUG: bad host encryption descriptor; ""
				""descriptor is too short ""
				""(%zu vs %zu needed)\n"",
				(size_t)etd->bLength, sizeof(*etd));
			break;
		}
		itr += etd->bLength;
		bytes += snprintf(buf + bytes, sizeof(buf) - bytes,
				  ""%s (0x%02x) "",
				  wusb_et_name(etd->bEncryptionType),
				  etd->bEncryptionValue);
		wusbhc->ccm1_etd = etd;
	}
	dev_info(dev, ""supported encryption types: %s\n"", buf);
	if (wusbhc->ccm1_etd == NULL) {
		dev_err(dev, ""E: host doesn't support CCM-1 crypto\n"");
		return 0;
	}
	
	return 0;
}
","1. struct usb_security_descriptor *secd;
2. size_t itr_size, needed, bytes;
3. itr_size = le16_to_cpu(usb_dev->actconfig->desc.wTotalLength);
4. result = __usb_get_extra_descriptor(usb_dev->rawdescriptors[index],
5. USB_DT_SECURITY, (void **) &secd, sizeof(*secd));
6. if (top - (void *)secd < needed) {
7. bytes = 0;
8. etd->bEncryptionValue);
9. dev_err(dev, ""E: host doesn't support CCM-1 crypto\n"");","7
10
18
20
22
28
45
65
70","CWE-200,CWE-264,CWE-404,CWE-119"
fpAcc,"
#define TIFF

fpAcc(TIFF* tif, uint8* cp0, tmsize_t cc)
{
	tmsize_t stride = PredictorState(tif)->stride;
	uint32 bps = tif->tif_dir.td_bitspersample / 8;
 	tmsize_t wc = cc / bps;
 	tmsize_t count = cc;
 	uint8 *cp = (uint8 *) cp0;
	uint8 *tmp;
 
     if(cc%(bps*stride)!=0)
     {
        TIFFErrorExt(tif->tif_clientdata, ""fpAcc"",
                     ""%s"", ""cc%(bps*stride))!=0"");
         return 0;
     }
 
    tmp = (uint8 *)_TIFFmalloc(cc);
 	if (!tmp)
 		return 0;
 
	while (count > stride) {
		REPEAT4(stride, cp[stride] =
                        (unsigned char) ((cp[stride] + cp[0]) & 0xff); cp++)
		count -= stride;
	}

	_TIFFmemcpy(tmp, cp0, cc);
	cp = (uint8 *) cp0;
	for (count = 0; count < wc; count++) {
		uint32 byte;
		for (byte = 0; byte < bps; byte++) {
			#if WORDS_BIGENDIAN
			cp[bps * count + byte] = tmp[byte * wc + count];
			#else
			cp[bps * count + byte] =
				tmp[(bps - byte - 1) * wc + count];
			#endif
		}
	}
	_TIFFfree(tmp);
    return 1;
}
","1. tmsize_t stride = PredictorState(tif)->stride;
uint32 bps = tif->tif_dir.td_bitspersample / 8;
tmsize_t wc = cc / bps;
2. if(cc%(bps*stride)!=0)
3. TIFFErrorExt(tif->tif_clientdata, ""fpAcc"",
4. while (count > stride) {
5. uint32 byte;
for (byte = 0; byte < bps; byte++) {
6. cp[bps * count + byte] =
7. _TIFFfree(tmp);","6-8
13
15
24
33-34
38
43","CWE-125,CWE-119"
handle_global-265437914224728,"static void handle_global(void *data, struct wl_registry *registry,
		uint32_t name, const char *interface, uint32_t version) {
	struct swaylock_state *state = data;
	if (strcmp(interface, wl_compositor_interface.name) == 0) {
		state->compositor = wl_registry_bind(registry, name,
				&wl_compositor_interface, 4);
	} else if (strcmp(interface, wl_subcompositor_interface.name) == 0) {
		state->subcompositor = wl_registry_bind(registry, name,
				&wl_subcompositor_interface, 1);
	} else if (strcmp(interface, wl_shm_interface.name) == 0) {
		state->shm = wl_registry_bind(registry, name,
				&wl_shm_interface, 1);
	} else if (strcmp(interface, wl_seat_interface.name) == 0) {
		struct wl_seat *seat = wl_registry_bind(
				registry, name, &wl_seat_interface, 4);
		struct swaylock_seat *swaylock_seat =
			calloc(1, sizeof(struct swaylock_seat));
		swaylock_seat->state = state;
		wl_seat_add_listener(seat, &seat_listener, swaylock_seat);
	} else if (strcmp(interface, zwlr_layer_shell_v1_interface.name) == 0) {
		state->layer_shell = wl_registry_bind(
				registry, name, &zwlr_layer_shell_v1_interface, 1);
	} else if (strcmp(interface, zwlr_input_inhibit_manager_v1_interface.name) == 0) {
		state->input_inhibit_manager = wl_registry_bind(
				registry, name, &zwlr_input_inhibit_manager_v1_interface, 1);
	} else if (strcmp(interface, zxdg_output_manager_v1_interface.name) == 0) {
		state->zxdg_output_manager = wl_registry_bind(
				registry, name, &zxdg_output_manager_v1_interface, 2);
	} else if (strcmp(interface, wl_output_interface.name) == 0) {
		struct swaylock_surface *surface =
			calloc(1, sizeof(struct swaylock_surface));
		surface->state = state;
		surface->output = wl_registry_bind(registry, name,
				&wl_output_interface, 3);
		surface->output_global_name = name;
		wl_output_add_listener(surface->output, &_wl_output_listener, surface);
		wl_list_insert(&state->surfaces, &surface->link);

		if (state->run_display) {
			create_surface(surface);
			wl_display_roundtrip(state->display);
		}
	} else if (strcmp(interface, ext_session_lock_manager_v1_interface.name) == 0) {
		state->ext_session_lock_manager_v1 = wl_registry_bind(registry, name,
				&ext_session_lock_manager_v1_interface, 1);
	}
}
","1. uint32_t name, const char *interface, uint32_t version) {
2. struct wl_seat *seat = wl_registry_bind(
3. wl_seat_add_listener(seat, &seat_listener, swaylock_seat);
4. registry, name, &zwlr_layer_shell_v1_interface, 1);
5. registry, name, &zwlr_input_inhibit_manager_v1_interface, 1);
6. state->zxdg_output_manager = wl_registry_bind(
7. &wl_output_interface, 3);
8. wl_output_add_listener(surface->output, &_wl_output_listener, surface);
9. if (state->run_display) {
10. } else if (strcmp(interface, ext_session_lock_manager_v1_interface.name) == 0) {","2
14
19
22
25
27
34
36
39
43","CWE-200,CWE-704,CWE-269,CWE-787"
dccp_v6_init_sequence,"static inline __u32 dccp_v6_init_sequence(struct sk_buff *skb)
static inline __u64 dccp_v6_init_sequence(struct sk_buff *skb)
 {
 	return secure_dccpv6_sequence_number(ipv6_hdr(skb)->daddr.s6_addr32,
 					     ipv6_hdr(skb)->saddr.s6_addr32,
					     dccp_hdr(skb)->dccph_dport,
					     dccp_hdr(skb)->dccph_sport     );

}
","1. static inline __u64 dccp_v6_init_sequence(struct sk_buff *skb)
2. ipv6_hdr(skb)->saddr.s6_addr32,
dccp_hdr(skb)->dccph_dport,","2
5-6","CWE-125,CWE-416"
tls1_change_cipher_state_1,"
#define SSL

int tls1_change_cipher_state_1(SSL *s, int which)
	{
	static const unsigned char empty[]="""";
	unsigned char *p,*mac_secret;
	unsigned char *exp_label;
	unsigned char tmp1[EVP_MAX_KEY_LENGTH];
	unsigned char tmp2[EVP_MAX_KEY_LENGTH];
	unsigned char iv1[EVP_MAX_IV_LENGTH*2];
	unsigned char iv2[EVP_MAX_IV_LENGTH*2];
	unsigned char *ms,*key,*iv;
	int client_write;
	EVP_CIPHER_CTX *dd;
	const EVP_CIPHER *c;
#ifndef OPENSSL_NO_COMP
	const SSL_COMP *comp;
#endif
	const EVP_MD *m;
	int mac_type;
	int *mac_secret_size;
	EVP_MD_CTX *mac_ctx;
	EVP_PKEY *mac_key;
	int is_export,n,i,j,k,exp_label_len,cl;
	int reuse_dd = 0;

	is_export=SSL_C_IS_EXPORT(s->s3->tmp.new_cipher);
	c=s->s3->tmp.new_sym_enc;
	m=s->s3->tmp.new_hash;
	mac_type = s->s3->tmp.new_mac_pkey_type;
#ifndef OPENSSL_NO_COMP
	comp=s->s3->tmp.new_compression;
#endif

#ifdef KSSL_DEBUG
	printf(""tls1_change_cipher_state_1(which= %d) w/\n"", which);
	printf(""\talg= %ld/%ld, comp= %p\n"",
	       s->s3->tmp.new_cipher->algorithm_mkey,
	       s->s3->tmp.new_cipher->algorithm_auth,
	       comp);
	printf(""\tevp_cipher == %p ==? &d_cbc_ede_cipher3\n"", c);
	printf(""\tevp_cipher: nid, blksz= %d, %d, keylen=%d, ivlen=%d\n"",
                c->nid,c->block_size,c->key_len,c->iv_len);
	printf(""\tkey_block: len= %d, data= "", s->s3->tmp.key_block_length);
	{
        int i;
        for (i=0; i<s->s3->tmp.key_block_length; i++)
		printf(""%02x"", s->s3->tmp.key_block[i]);  printf(""\n"");
        }
#endif	

	if (which & SSL3_CC_READ)
		{
		if (s->s3->tmp.new_cipher->algorithm2 & TLS1_STREAM_MAC)
			s->mac_flags |= SSL_MAC_FLAG_READ_MAC_STREAM;
		else
			s->mac_flags &= ~SSL_MAC_FLAG_READ_MAC_STREAM;

		if (s->enc_read_ctx != NULL)
			reuse_dd = 1;
		else if ((s->enc_read_ctx=OPENSSL_malloc(sizeof(EVP_CIPHER_CTX))) == NULL)
			goto err;
		else
			
			EVP_CIPHER_CTX_init(s->enc_read_ctx);
		dd= s->enc_read_ctx;
		mac_ctx=ssl_replace_hash(&s->read_hash,NULL);
#ifndef OPENSSL_NO_COMP
		if (s->expand != NULL)
			{
			COMP_CTX_free(s->expand);
			s->expand=NULL;
			}
		if (comp != NULL)
			{
			s->expand=COMP_CTX_new(comp->method);
			if (s->expand == NULL)
				{
				SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,SSL_R_COMPRESSION_LIBRARY_ERROR);
				goto err2;
				}
			if (s->s3->rrec.comp == NULL)
				s->s3->rrec.comp=(unsigned char *)
					OPENSSL_malloc(SSL3_RT_MAX_ENCRYPTED_LENGTH);
			if (s->s3->rrec.comp == NULL)
				goto err;
			}
#endif
		
 		if (s->version != DTLS1_VERSION)
			memset(&(s->s3->read_sequence[0]),0,8);
		mac_secret= &(s->s3->read_mac_secret[0]);
		mac_secret_size=&(s->s3->read_mac_secret_size);
		}
	else
		{
		if (s->s3->tmp.new_cipher->algorithm2 & TLS1_STREAM_MAC)
                        s->mac_flags |= SSL_MAC_FLAG_WRITE_MAC_STREAM;
                        else
                        s->mac_flags &= ~SSL_MAC_FLAG_WRITE_MAC_STREAM;
               if (s->enc_write_ctx != NULL && !SSL_IS_DTLS(s))
                        reuse_dd = 1;
               else if ((s->enc_write_ctx=EVP_CIPHER_CTX_new()) == NULL)
                        goto err;
                dd= s->enc_write_ctx;
               if (SSL_IS_DTLS(s))
                       {
                       mac_ctx = EVP_MD_CTX_create();
                       if (!mac_ctx)
                               goto err;
                       s->write_hash = mac_ctx;
                       }
               else
                       mac_ctx = ssl_replace_hash(&s->write_hash,NULL);
 #ifndef OPENSSL_NO_COMP
                if (s->compress != NULL)
                        {
			s->compress=COMP_CTX_new(comp->method);
			if (s->compress == NULL)
				{
				SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,SSL_R_COMPRESSION_LIBRARY_ERROR);
				goto err2;
				}
			}
#endif
		
 		if (s->version != DTLS1_VERSION)
			memset(&(s->s3->write_sequence[0]),0,8);
		mac_secret= &(s->s3->write_mac_secret[0]);
		mac_secret_size = &(s->s3->write_mac_secret_size);
		}

	if (reuse_dd)
		EVP_CIPHER_CTX_cleanup(dd);

	p=s->s3->tmp.key_block;
	i=*mac_secret_size=s->s3->tmp.new_mac_secret_size;

	cl=EVP_CIPHER_key_length(c);
	j=is_export ? (cl < SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher) ?
	               cl : SSL_C_EXPORT_KEYLENGTH(s->s3->tmp.new_cipher)) : cl;
	
	
	if (EVP_CIPHER_mode(c) == EVP_CIPH_GCM_MODE)
		k = EVP_GCM_TLS_FIXED_IV_LEN;
	else
		k=EVP_CIPHER_iv_length(c);
	if (	(which == SSL3_CHANGE_CIPHER_CLIENT_WRITE) ||
		(which == SSL3_CHANGE_CIPHER_SERVER_READ))
		{
		ms=  &(p[ 0]); n=i+i;
		key= &(p[ n]); n+=j+j;
		iv=  &(p[ n]); n+=k+k;
		exp_label=(unsigned char *)TLS_MD_CLIENT_WRITE_KEY_CONST;
		exp_label_len=TLS_MD_CLIENT_WRITE_KEY_CONST_SIZE;
		client_write=1;
		}
	else
		{
		n=i;
		ms=  &(p[ n]); n+=i+j;
		key= &(p[ n]); n+=j+k;
		iv=  &(p[ n]); n+=k;
		exp_label=(unsigned char *)TLS_MD_SERVER_WRITE_KEY_CONST;
		exp_label_len=TLS_MD_SERVER_WRITE_KEY_CONST_SIZE;
		client_write=0;
		}

	if (n > s->s3->tmp.key_block_length)
		{
		SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,ERR_R_INTERNAL_ERROR);
		goto err2;
		}

	memcpy(mac_secret,ms,i);

	if (!(EVP_CIPHER_flags(c)&EVP_CIPH_FLAG_AEAD_CIPHER))
		{
		mac_key = EVP_PKEY_new_mac_key(mac_type, NULL,
				mac_secret,*mac_secret_size);
		EVP_DigestSignInit(mac_ctx,NULL,m,NULL,mac_key);
		EVP_PKEY_free(mac_key);
		}
#ifdef TLS_DEBUG
printf(""which = %04X\nmac key="",which);
{ int z; for (z=0; z<i; z++) printf(""%02X%c"",ms[z],((z+1)%16)?' ':'\n'); }
#endif
	if (is_export)
		{
		
		if (!tls1_PRF(ssl_get_algorithm2(s),
				exp_label,exp_label_len,
				s->s3->client_random,SSL3_RANDOM_SIZE,
				s->s3->server_random,SSL3_RANDOM_SIZE,
				NULL,0,NULL,0,
				key,j,tmp1,tmp2,EVP_CIPHER_key_length(c)))
			goto err2;
		key=tmp1;

		if (k > 0)
			{
			if (!tls1_PRF(ssl_get_algorithm2(s),
					TLS_MD_IV_BLOCK_CONST,TLS_MD_IV_BLOCK_CONST_SIZE,
					s->s3->client_random,SSL3_RANDOM_SIZE,
					s->s3->server_random,SSL3_RANDOM_SIZE,
					NULL,0,NULL,0,
					empty,0,iv1,iv2,k*2))
				goto err2;
			if (client_write)
				iv=iv1;
			else
				iv= &(iv1[k]);
			}
		}

	s->session->key_arg_length=0;
#ifdef KSSL_DEBUG
	{
        int i;
	printf(""EVP_CipherInit_ex(dd,c,key=,iv=,which)\n"");
	printf(""\tkey= ""); for (i=0; i<c->key_len; i++) printf(""%02x"", key[i]);
	printf(""\n"");
	printf(""\t iv= ""); for (i=0; i<c->iv_len; i++) printf(""%02x"", iv[i]);
	printf(""\n"");
	}
#endif	

	if (EVP_CIPHER_mode(c) == EVP_CIPH_GCM_MODE)
		{
		EVP_CipherInit_ex(dd,c,NULL,key,NULL,(which & SSL3_CC_WRITE));
		EVP_CIPHER_CTX_ctrl(dd, EVP_CTRL_GCM_SET_IV_FIXED, k, iv);
		}
	else	
		EVP_CipherInit_ex(dd,c,NULL,key,iv,(which & SSL3_CC_WRITE));

	
	if ((EVP_CIPHER_flags(c)&EVP_CIPH_FLAG_AEAD_CIPHER) && *mac_secret_size)
		EVP_CIPHER_CTX_ctrl(dd,EVP_CTRL_AEAD_SET_MAC_KEY,
				*mac_secret_size,mac_secret);

#ifdef TLS_DEBUG
printf(""which = %04X\nkey="",which);
{ int z; for (z=0; z<EVP_CIPHER_key_length(c); z++) printf(""%02X%c"",key[z],((z+1)%16)?' ':'\n'); }
printf(""\niv="");
{ int z; for (z=0; z<k; z++) printf(""%02X%c"",iv[z],((z+1)%16)?' ':'\n'); }
printf(""\n"");
#endif

	OPENSSL_cleanse(tmp1,sizeof(tmp1));
	OPENSSL_cleanse(tmp2,sizeof(tmp1));
	OPENSSL_cleanse(iv1,sizeof(iv1));
	OPENSSL_cleanse(iv2,sizeof(iv2));
	return(1);
err:
	SSLerr(SSL_F_TLS1_CHANGE_CIPHER_STATE,ERR_R_MALLOC_FAILURE);
err2:
	return(0);
	}
","1. s->mac_flags |= SSL_MAC_FLAG_READ_MAC_STREAM;
2. dd= s->enc_write_ctx;
if (SSL_IS_DTLS(s))
3. memset(&(s->s3->write_sequence[0]),0,8);
4. if (EVP_CIPHER_mode(c) == EVP_CIPH_GCM_MODE)
5. ms=  &(p[ 0]); n=i+i;
6. if (n > s->s3->tmp.key_block_length)
7. goto err2;
8. if (!(EVP_CIPHER_flags(c)&EVP_CIPH_FLAG_AEAD_CIPHER))
9. return(1);","56
106-107
129
145
152
170
173
178
256","CWE-552,CWE-264,CWE-119,CWE-674,CWE-399"
virtio_config_readb-85408642271370,"
#define VirtIODevice

uint32_t virtio_config_readb(VirtIODevice *vdev, uint32_t addr)
{
    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);
    uint8_t val;

    if (addr + sizeof(val) > vdev->config_len) {
        return (uint32_t)-1;
    }

    k->get_config(vdev, vdev->config);

    val = ldub_p(vdev->config + addr);
    return val;
}
","1. uint32_t virtio_config_readb(VirtIODevice *vdev, uint32_t addr)
2. VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);
uint8_t val;
3. if (addr + sizeof(val) > vdev->config_len) {
return (uint32_t)-1;
4. k->get_config(vdev, vdev->config);
5. return val;","4
6-7
9-10
13
16","CWE-269,CWE-119"
http_splitheader,"http_splitheader(struct http *hp, int req)
{
	char *p, *q, **hh;
	int n;
	char buf[20];

	CHECK_OBJ_NOTNULL(hp, HTTP_MAGIC);
	if (req) {
		memset(hp->req, 0, sizeof hp->req);
		hh = hp->req;
	} else {
		memset(hp->resp, 0, sizeof hp->resp);
		hh = hp->resp;
	}

	n = 0;
	p = hp->rxbuf;

	
	while (vct_islws(*p))
		p++;
 	hh[n++] = p;
 	while (!vct_islws(*p))
 		p++;
	assert(!vct_iscrlf(p));
 	*p++ = '\0';
 
 	
 	while (vct_issp(*p))		
 		p++;
	assert(!vct_iscrlf(p));
 	hh[n++] = p;
 	while (!vct_islws(*p))
 		p++;
	if (vct_iscrlf(p)) {
 		hh[n++] = NULL;
 		q = p;
 		p += vct_skipcrlf(p);
		*q = '\0';
	} else {
		*p++ = '\0';
		
 		while (vct_issp(*p))		
 			p++;
 		hh[n++] = p;
		while (!vct_iscrlf(p))
 			p++;
 		q = p;
 		p += vct_skipcrlf(p);
		*q = '\0';
	}
	assert(n == 3);
 
 	while (*p != '\0') {
 		assert(n < MAX_HDR);
		if (vct_iscrlf(p))
 			break;
 		hh[n++] = p++;
		while (*p != '\0' && !vct_iscrlf(p))
 			p++;
 		q = p;
 		p += vct_skipcrlf(p);
		*q = '\0';
	}
	p += vct_skipcrlf(p);
	assert(*p == '\0');

	for (n = 0; n < 3 || hh[n] != NULL; n++) {
		sprintf(buf, ""http[%2d] "", n);
		vtc_dump(hp->vl, 4, buf, hh[n], -1);
	}
}
","1. char *p, *q, **hh;
int n;
2. hh = hp->resp;
3. p++;
4. if (vct_iscrlf(p)) {
5. } else {
*p++ = '\0';
6. while (vct_issp(*p))
p++;
hh[n++] = p;
while (!vct_iscrlf(p))
p++;
7. *q = '\0';
8. assert(n == 3);
9. if (vct_iscrlf(p))
10. hh[n++] = p++;","3-4
13
30
35
40-41
43-47
50
52
56
58","CWE-125,CWE-189"
rdg_receive_packet-28928380954758,"static wStream* rdg_receive_packet(rdpRdg* rdg)
{
	wStream* s;
	const size_t header = sizeof(RdgPacketHeader);
	size_t packetLength;
	assert(header <= INT_MAX);
	s = Stream_New(NULL, 1024);

	if (!s)
		return NULL;

	if (!rdg_read_all(rdg->tlsOut, Stream_Buffer(s), header))
	{
		Stream_Free(s, TRUE);
		return NULL;
	}

	Stream_Seek(s, 4);
	Stream_Read_UINT32(s, packetLength);

	if ((packetLength > INT_MAX) || !Stream_EnsureCapacity(s, packetLength) ||
	    (packetLength < header))
	{
		Stream_Free(s, TRUE);
		return NULL;
	}

	if (!rdg_read_all(rdg->tlsOut, Stream_Buffer(s) + header, (int)packetLength - (int)header))
	{
		Stream_Free(s, TRUE);
		return NULL;
	}

	Stream_SetLength(s, packetLength);
	return s;
}
","1. wStream* s;
2. assert(header <= INT_MAX);
s = Stream_New(NULL, 1024);
3. return NULL;
4. Stream_Read_UINT32(s, packetLength);
5. Stream_Free(s, TRUE);","3
6-7
15
19
30","CWE-190,CWE-119"
check_mem_access-186607715035310,"static int check_mem_access(struct bpf_verifier_env *env, int insn_idx, u32 regno, int off,
			    int bpf_size, enum bpf_access_type t,
			    int value_regno)
{
	struct bpf_verifier_state *state = env->cur_state;
	struct bpf_reg_state *regs = cur_regs(env);
	struct bpf_reg_state *reg = regs + regno;
	int size, err = 0;

	size = bpf_size_to_bytes(bpf_size);
	if (size < 0)
		return size;

	
	err = check_ptr_alignment(env, reg, off, size);
	if (err)
		return err;

	
	off += reg->off;

	if (reg->type == PTR_TO_MAP_VALUE) {
		if (t == BPF_WRITE && value_regno >= 0 &&
		    is_pointer_value(env, value_regno)) {
			verbose(env, ""R%d leaks addr into map\n"", value_regno);
			return -EACCES;
		}

		err = check_map_access(env, regno, off, size, false);
		if (!err && t == BPF_READ && value_regno >= 0)
			mark_reg_unknown(env, regs, value_regno);

	} else if (reg->type == PTR_TO_CTX) {
		enum bpf_reg_type reg_type = SCALAR_VALUE;

		if (t == BPF_WRITE && value_regno >= 0 &&
		    is_pointer_value(env, value_regno)) {
			verbose(env, ""R%d leaks addr into ctx\n"", value_regno);
			return -EACCES;
		}
		
		if (reg->off) {
			verbose(env,
				""dereference of modified ctx ptr R%d off=%d+%d, ctx+const is allowed, ctx+const+const is not\n"",
				regno, reg->off, off - reg->off);
			return -EACCES;
		}
		if (!tnum_is_const(reg->var_off) || reg->var_off.value) {
			char tn_buf[48];

			tnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);
			verbose(env,
				""variable ctx access var_off=%s off=%d size=%d"",
				tn_buf, off, size);
			return -EACCES;
		}
		err = check_ctx_access(env, insn_idx, off, size, t, &reg_type);
		if (!err && t == BPF_READ && value_regno >= 0) {
			
			if (reg_type == SCALAR_VALUE)
				mark_reg_unknown(env, regs, value_regno);
			else
				mark_reg_known_zero(env, regs,
						    value_regno);
			regs[value_regno].id = 0;
			regs[value_regno].off = 0;
			regs[value_regno].range = 0;
			regs[value_regno].type = reg_type;
		}

	} else if (reg->type == PTR_TO_STACK) {
		
		if (!tnum_is_const(reg->var_off)) {
			char tn_buf[48];

			tnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);
			verbose(env, ""variable stack access var_off=%s off=%d size=%d"",
				tn_buf, off, size);
			return -EACCES;
		}
		off += reg->var_off.value;
		if (off >= 0 || off < -MAX_BPF_STACK) {
			verbose(env, ""invalid stack off=%d size=%d\n"", off,
				size);
			return -EACCES;
		}

		if (env->prog->aux->stack_depth < -off)
			env->prog->aux->stack_depth = -off;

		if (t == BPF_WRITE)
			err = check_stack_write(env, state, off, size,
						value_regno);
		else
			err = check_stack_read(env, state, off, size,
					       value_regno);
	} else if (reg_is_pkt_pointer(reg)) {
		if (t == BPF_WRITE && !may_access_direct_pkt_data(env, NULL, t)) {
			verbose(env, ""cannot write into packet\n"");
			return -EACCES;
		}
		if (t == BPF_WRITE && value_regno >= 0 &&
		    is_pointer_value(env, value_regno)) {
			verbose(env, ""R%d leaks addr into packet\n"",
				value_regno);
			return -EACCES;
		}
		err = check_packet_access(env, regno, off, size, false);
		if (!err && t == BPF_READ && value_regno >= 0)
			mark_reg_unknown(env, regs, value_regno);
	} else {
		verbose(env, ""R%d invalid mem access '%s'\n"", regno,
			reg_type_str[reg->type]);
		return -EACCES;
	}

	if (!err && size < BPF_REG_SIZE && value_regno >= 0 && t == BPF_READ &&
	    regs[value_regno].type == SCALAR_VALUE) {
		
		coerce_reg_to_size(&regs[value_regno], size);
	}
	return err;
}
","1. struct bpf_reg_state *reg = regs + regno;
2. err = check_ptr_alignment(env, reg, off, size);
3. if (reg->type == PTR_TO_MAP_VALUE) {
4. mark_reg_unknown(env, regs, value_regno);
5. } else if (reg->type == PTR_TO_CTX) {
6. ""dereference of modified ctx ptr R%d off=%d+%d, ctx+const is allowed, ctx+const+const is not\n"",
7. if (!tnum_is_const(reg->var_off) || reg->var_off.value) {
8. tnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);
9. err = check_ctx_access(env, insn_idx, off, size, t, &reg_type);
if (!err && t == BPF_READ && value_regno >= 0) {
10. regs[value_regno].id = 0;
11. regs[value_regno].type = reg_type;
12. tnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);
verbose(env, ""variable stack access var_off=%s off=%d size=%d"",
13. off += reg->var_off.value;
14. return -EACCES;
15. err = check_stack_write(env, state, off, size,
16. verbose(env, ""R%d invalid mem access '%s'\n"", regno,","7
15
22
31
33
46
50
53
59-60
70
73
84-85
89
93
100
120","CWE-17,CWE-476,CWE-400,CWE-119"
ModPlug_SampleName,"
#define ModPlugFile

 LIBOPENMPT_MODPLUG_API unsigned int ModPlug_SampleName(ModPlugFile* file, unsigned int qual, char* buff)
 {
 	const char* str;
	char buf[32];
 	if(!file) return 0;
 	str = openmpt_module_get_sample_name(file->mod,qual-1);
	memset(buf,0,32);
	if(str){
		strncpy(buf,str,31);
		openmpt_free_string(str);
 	}
 	if(buff){
		strncpy(buff,buf,32);
 	}
	return (unsigned int)strlen(buf);
 }
","1. LIBOPENMPT_MODPLUG_API unsigned int ModPlug_SampleName(ModPlugFile* file, unsigned int qual, char* buff)
2. const char* str;
char buf[32];
if(!file) return 0;
str = openmpt_module_get_sample_name(file->mod,qual-1);
memset(buf,0,32);
if(str){
strncpy(buf,str,31);
openmpt_free_string(str);
3. if(buff){
strncpy(buff,buf,32);","4
6-13
15-16","CWE-120,CWE-119"
ksz8851IrqHandler-60830589270555,"
#define NetInterface

bool_t ksz8851IrqHandler(NetInterface *interface)
{
   bool_t flag;
   size_t n;
   uint16_t ier;
   uint16_t isr;

   
   flag = FALSE;

   
   ier = ksz8851ReadReg(interface, KSZ8851_IER);
   
   ksz8851WriteReg(interface, KSZ8851_IER, 0);

   
   isr = ksz8851ReadReg(interface, KSZ8851_ISR);

   
   if((isr & KSZ8851_ISR_LCIS) != 0)
   {
      
      ier &= ~KSZ8851_IER_LCIE;

      
      interface->nicEvent = TRUE;
      
      flag |= osSetEventFromIsr(&netEvent);
   }

   
   if((isr & KSZ8851_ISR_TXIS) != 0)
   {
      
      ksz8851WriteReg(interface, KSZ8851_ISR, KSZ8851_ISR_TXIS);

      
      n = ksz8851ReadReg(interface, KSZ8851_TXMIR) & KSZ8851_TXMIR_TXMA;

      
      if(n >= (ETH_MAX_FRAME_SIZE + 8))
      {
         
         flag |= osSetEventFromIsr(&interface->nicTxEvent);
      }
   }

   
   if((isr & KSZ8851_ISR_RXIS) != 0)
   {
      
      ier &= ~KSZ8851_IER_RXIE;

      
      interface->nicEvent = TRUE;
      
      flag |= osSetEventFromIsr(&netEvent);
   }

   
   ksz8851WriteReg(interface, KSZ8851_IER, ier);

   
   return flag;
}
","1. bool_t ksz8851IrqHandler(NetInterface *interface)
2. bool_t flag;
size_t n;
uint16_t ier;
uint16_t isr;
3. flag = FALSE;
4. ksz8851WriteReg(interface, KSZ8851_IER, 0);
5. if((isr & KSZ8851_ISR_LCIS) != 0)
6. ier &= ~KSZ8851_IER_LCIE;
7. flag |= osSetEventFromIsr(&netEvent);
8. if((isr & KSZ8851_ISR_TXIS) != 0)
9. ksz8851WriteReg(interface, KSZ8851_ISR, KSZ8851_ISR_TXIS);
10. if(n >= (ETH_MAX_FRAME_SIZE + 8))
11. flag |= osSetEventFromIsr(&interface->nicTxEvent);
12. ier &= ~KSZ8851_IER_RXIE;","4
6-9
12
17
23
26
31
35
38
44
47
55",CWE-20
sunkbd_enable-204255385466196,"static void sunkbd_enable(struct sunkbd *sunkbd, bool enable)
{
	serio_pause_rx(sunkbd->serio);
	sunkbd->enabled = enable;
	serio_continue_rx(sunkbd->serio);

	if (!enable) {
		wake_up_interruptible(&sunkbd->wait);
		cancel_work_sync(&sunkbd->tq);
	}
}
","1. serio_pause_rx(sunkbd->serio);
sunkbd->enabled = enable;
serio_continue_rx(sunkbd->serio);
2. if (!enable) {
wake_up_interruptible(&sunkbd->wait);
cancel_work_sync(&sunkbd->tq);","3-5
7-9","CWE-362,CWE-190,CWE-20"
atalk_ioctl-200642332666461,"static int atalk_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)
{
	int rc = -ENOIOCTLCMD;
	struct sock *sk = sock->sk;
	void __user *argp = (void __user *)arg;

	switch (cmd) {
	
	case TIOCOUTQ: {
		long amount = sk->sk_sndbuf - sk_wmem_alloc_get(sk);

		if (amount < 0)
			amount = 0;
		rc = put_user(amount, (int __user *)argp);
		break;
	}
	case TIOCINQ: {
		struct sk_buff *skb;
		long amount = 0;

		spin_lock_irq(&sk->sk_receive_queue.lock);
		skb = skb_peek(&sk->sk_receive_queue);
		if (skb)
			amount = skb->len - sizeof(struct ddpehdr);
		spin_unlock_irq(&sk->sk_receive_queue.lock);
		rc = put_user(amount, (int __user *)argp);
		break;
	}
	
	case SIOCADDRT:
	case SIOCDELRT:
		rc = -EPERM;
		if (capable(CAP_NET_ADMIN))
			rc = atrtr_ioctl(cmd, argp);
		break;
	
	case SIOCGIFADDR:
	case SIOCSIFADDR:
	case SIOCGIFBRDADDR:
	case SIOCATALKDIFADDR:
	case SIOCDIFADDR:
	case SIOCSARP:		
	case SIOCDARP:		
		rtnl_lock();
		rc = atif_ioctl(cmd, argp);
		rtnl_unlock();
		break;
	}

	return rc;
}
","1. switch (cmd) {
2. case TIOCOUTQ: {
3. case SIOCATALKDIFADDR:
4. break;","7
9
40
47","CWE-22,CWE-416,CWE-190,CWE-200,CWE-119"
parse_string_node-267419028757726,"static plist_t parse_string_node(const char **bnode, uint64_t size)
{
    plist_data_t data = plist_new_plist_data();

    data->type = PLIST_STRING;
    data->strval = (char *) malloc(sizeof(char) * (size + 1));
    if (!data->strval) {
        plist_free_data(data);
        PLIST_BIN_ERR(""%s: Could not allocate %"" PRIu64 "" bytes\n"", __func__, sizeof(char) * (size + 1));
        return NULL;
    }
    memcpy(data->strval, *bnode, size);
    data->strval[size] = '\0';
    data->length = strlen(data->strval);

    return node_create(NULL, data);
}
","1. plist_data_t data = plist_new_plist_data();
2. data->type = PLIST_STRING;
3. data->strval[size] = '\0';
data->length = strlen(data->strval);","3
5
13-14","CWE-362,CWE-326,CWE-200,CWE-416"
PHP_METHOD_7,"
#define Phar

PHP_METHOD_7(Phar, buildFromDirectory)
{
	char *dir, *error, *regex = NULL;
	size_t dir_len, regex_len = 0;
	zend_bool apply_reg = 0;
	zval arg, arg2, iter, iteriter, regexiter;
	struct _phar_t pass;

	PHAR_ARCHIVE_OBJECT();

	if (PHAR_G(readonly) && !phar_obj->archive->is_data) {
		zend_throw_exception_ex(spl_ce_UnexpectedValueException, 0,
			""Cannot write to archive - write operations restricted by INI setting"");
                return;
        }
 
       if (zend_parse_parameters(ZEND_NUM_ARGS(), ""p|s"", &dir, &dir_len, &regex, &regex_len) == FAILURE) {
                RETURN_FALSE;
        }
 
	if (SUCCESS != object_init_ex(&iter, spl_ce_RecursiveDirectoryIterator)) {
		zval_ptr_dtor(&iter);
		zend_throw_exception_ex(spl_ce_BadMethodCallException, 0, ""Unable to instantiate directory iterator for %s"", phar_obj->archive->fname);
		RETURN_FALSE;
	}

	ZVAL_STRINGL(&arg, dir, dir_len);
	ZVAL_LONG(&arg2, SPL_FILE_DIR_SKIPDOTS|SPL_FILE_DIR_UNIXPATHS);

	zend_call_method_with_2_params(&iter, spl_ce_RecursiveDirectoryIterator,
			&spl_ce_RecursiveDirectoryIterator->constructor, ""__construct"", NULL, &arg, &arg2);

	zval_ptr_dtor(&arg);
	if (EG(exception)) {
		zval_ptr_dtor(&iter);
		RETURN_FALSE;
	}

	if (SUCCESS != object_init_ex(&iteriter, spl_ce_RecursiveIteratorIterator)) {
		zval_ptr_dtor(&iter);
		zval_ptr_dtor(&iteriter);
		zend_throw_exception_ex(spl_ce_BadMethodCallException, 0, ""Unable to instantiate directory iterator for %s"", phar_obj->archive->fname);
		RETURN_FALSE;
	}

	zend_call_method_with_1_params(&iteriter, spl_ce_RecursiveIteratorIterator,
			&spl_ce_RecursiveIteratorIterator->constructor, ""__construct"", NULL, &iter);

	if (EG(exception)) {
		zval_ptr_dtor(&iter);
		zval_ptr_dtor(&iteriter);
		RETURN_FALSE;
	}

	zval_ptr_dtor(&iter);

	if (regex_len > 0) {
		apply_reg = 1;

		if (SUCCESS != object_init_ex(&regexiter, spl_ce_RegexIterator)) {
			zval_ptr_dtor(&iteriter);
			zval_dtor(&regexiter);
			zend_throw_exception_ex(spl_ce_BadMethodCallException, 0, ""Unable to instantiate regex iterator for %s"", phar_obj->archive->fname);
			RETURN_FALSE;
		}

		ZVAL_STRINGL(&arg2, regex, regex_len);

		zend_call_method_with_2_params(&regexiter, spl_ce_RegexIterator,
			&spl_ce_RegexIterator->constructor, ""__construct"", NULL, &iteriter, &arg2);
		zval_ptr_dtor(&arg2);
	}

	array_init(return_value);

	pass.c = apply_reg ? Z_OBJCE(regexiter) : Z_OBJCE(iteriter);
	pass.p = phar_obj;
	pass.b = dir;
	pass.l = dir_len;
	pass.count = 0;
	pass.ret = return_value;
	pass.fp = php_stream_fopen_tmpfile();
	if (pass.fp == NULL) {
		zend_throw_exception_ex(phar_ce_PharException, 0, ""phar \""%s\"" unable to create temporary file"", phar_obj->archive->fname);
		return;
	}

	if (phar_obj->archive->is_persistent && FAILURE == phar_copy_on_write(&(phar_obj->archive))) {
		zval_ptr_dtor(&iteriter);
		if (apply_reg) {
			zval_ptr_dtor(&regexiter);
		}
		php_stream_close(pass.fp);
		zend_throw_exception_ex(phar_ce_PharException, 0, ""phar \""%s\"" is persistent, unable to copy on write"", phar_obj->archive->fname);
		return;
	}

	if (SUCCESS == spl_iterator_apply((apply_reg ? &regexiter : &iteriter), (spl_iterator_apply_func_t) phar_build, (void *) &pass)) {
		zval_ptr_dtor(&iteriter);

		if (apply_reg) {
			zval_ptr_dtor(&regexiter);
		}

		phar_obj->archive->ufp = pass.fp;
		phar_flush(phar_obj->archive, 0, 0, 0, &error);

		if (error) {
			zend_throw_exception_ex(phar_ce_PharException, 0, ""%s"", error);
			efree(error);
		}

	} else {
		zval_ptr_dtor(&iteriter);
		if (apply_reg) {
			zval_ptr_dtor(&regexiter);
		}
		php_stream_close(pass.fp);
	}
}
","1. zval_ptr_dtor(&iteriter);
2. pass.c = apply_reg ? Z_OBJCE(regexiter) : Z_OBJCE(iteriter);
3. pass.count = 0;
pass.ret = return_value;
4. zval_ptr_dtor(&regexiter);
5. zend_throw_exception_ex(phar_ce_PharException, 0, ""phar \""%s\"" is persistent, unable to copy on write"", phar_obj->archive->fname);
6. zval_ptr_dtor(&regexiter);
7. zend_throw_exception_ex(phar_ce_PharException, 0, ""%s"", error);
8. zval_ptr_dtor(&regexiter);","54
79
83-84
94
97
105
112
119","CWE-362,CWE-476,CWE-125,CWE-119"
ASN1_item_verify_3,"
#define ASN1_BIT_STRING
#define ASN1_ITEM
#define EVP_PKEY
#define X509_ALGOR

int ASN1_item_verify_3(const ASN1_ITEM *it, X509_ALGOR *a, ASN1_BIT_STRING *signature,
	     void *asn, EVP_PKEY *pkey)
	{
	EVP_MD_CTX ctx;
	const EVP_MD *type;
        unsigned char *buf_in=NULL;
        int ret= -1,i,inl;
 
       if (!pkey)
               {
               ASN1err(ASN1_F_ASN1_ITEM_VERIFY, ERR_R_PASSED_NULL_PARAMETER);
               return -1;
               }

        EVP_MD_CTX_init(&ctx);
        i=OBJ_obj2nid(a->algorithm);
        type=EVP_get_digestbyname(OBJ_nid2sn(i));
	if (!EVP_VerifyInit_ex(&ctx,type, NULL))
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);
		ret=0;
		goto err;
		}

	inl = ASN1_item_i2d(asn, &buf_in, it);
	
	if (buf_in == NULL)
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_MALLOC_FAILURE);
		goto err;
		}

	EVP_VerifyUpdate(&ctx,(unsigned char *)buf_in,inl);

	OPENSSL_cleanse(buf_in,(unsigned int)inl);
	OPENSSL_free(buf_in);

	if (EVP_VerifyFinal(&ctx,(unsigned char *)signature->data,
			(unsigned int)signature->length,pkey) <= 0)
		{
		ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);
		ret=0;
		goto err;
		}
	
	
	ret=1;
err:
	EVP_MD_CTX_cleanup(&ctx);
	return(ret);
	}
","1. int ASN1_item_verify_3(const ASN1_ITEM *it, X509_ALGOR *a, ASN1_BIT_STRING *signature,
2. EVP_MD_CTX ctx;
const EVP_MD *type;
3. EVP_MD_CTX_init(&ctx);
4. ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);
ret=0;
5. inl = ASN1_item_i2d(asn, &buf_in, it);
6. (unsigned int)signature->length,pkey) <= 0)
7. ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);
ret=0;
8. ret=1;
err:","7
10-11
21
26-27
31
45
47-48
54-55","CWE-310,CWE-129,CWE-416,CWE-787,CWE-119"
ReadBits,"
#define BitReader

 static uint64_t ReadBits(BitReader* reader, int num_bits) {
   DCHECK_GE(reader->bits_available(), num_bits);
   DCHECK((num_bits > 0) && (num_bits <= 64));
  uint64_t value = 0;

  if (!reader->ReadBits(num_bits, &value))
    return 0;

   return value;
 }
","1. static uint64_t ReadBits(BitReader* reader, int num_bits) {
DCHECK_GE(reader->bits_available(), num_bits);
DCHECK((num_bits > 0) && (num_bits <= 64));
2. if (!reader->ReadBits(num_bits, &value))
return 0;","4-6
9-10","CWE-264,CWE-200,CWE-125,CWE-415"
ed_read_bin-163016404992275,"void ed_read_bin(ed_t a, const uint8_t *bin, size_t len) {
	if (len == 1) {
		if (bin[0] == 0) {
			ed_set_infty(a);
			return;
		} else {
			RLC_THROW(ERR_NO_BUFFER);
			return;
		}
	}

	if (len != (RLC_FP_BYTES + 1) && len != (2 * RLC_FP_BYTES + 1)) {
		RLC_THROW(ERR_NO_BUFFER);
		return;
	}

	a->coord = BASIC;
	fp_set_dig(a->z, 1);
	fp_read_bin(a->y, bin + 1, RLC_FP_BYTES);
	if (len == RLC_FP_BYTES + 1) {
		switch (bin[0]) {
			case 2:
				fp_zero(a->x);
				break;
			case 3:
				fp_zero(a->x);
				fp_set_bit(a->x, 0, 1);
				break;
			default:
				RLC_THROW(ERR_NO_VALID);
				break;
		}
		ed_upk(a, a);
	}

	if (len == 2 * RLC_FP_BYTES + 1) {
		if (bin[0] == 4) {
			fp_read_bin(a->x, bin + RLC_FP_BYTES + 1, RLC_FP_BYTES);
		} else {
			RLC_THROW(ERR_NO_VALID);
			return;
		}
	}
#if ED_ADD == EXTND
	fp_mul(a->t, a->x, a->y);
	fp_mul(a->x, a->x, a->z);
	fp_mul(a->y, a->y, a->z);
	fp_sqr(a->z, a->z);
#endif

	if (!ed_on_curve(a)) {
		RLC_THROW(ERR_NO_VALID);
	}
}
","1. if (len == 1) {
2. ed_set_infty(a);
return;
3. RLC_THROW(ERR_NO_BUFFER);
return;
4. if (len != (RLC_FP_BYTES + 1) && len != (2 * RLC_FP_BYTES + 1)) {
5. return;
6. fp_read_bin(a->y, bin + 1, RLC_FP_BYTES);
7. switch (bin[0]) {
case 2:
fp_zero(a->x);
8. fp_zero(a->x);
fp_set_bit(a->x, 0, 1);
9. default:
10. break;
11. if (len == 2 * RLC_FP_BYTES + 1) {
if (bin[0] == 4) {
fp_read_bin(a->x, bin + RLC_FP_BYTES + 1, RLC_FP_BYTES);
12. return;
13. fp_mul(a->t, a->x, a->y);
fp_mul(a->x, a->x, a->z);
14. if (!ed_on_curve(a)) {","2
4-5
7-8
12
14
19
21-23
26-27
29
31
36-38
41
45-46
51",CWE-190
lua_websocket_read,"
#define L

static int lua_websocket_read(lua_State *L) 
 {
     apr_socket_t *sock;
     apr_status_t rv;
    int do_read = 1;
     int n = 0;
     apr_size_t len = 1;
     apr_size_t plen = 0;
    unsigned short payload_short = 0;
    apr_uint64_t payload_long = 0;
    unsigned char *mask_bytes;
    char byte;
    int plaintext;
    
    
    request_rec *r = ap_lua_check_request_rec(L, 1);
    plaintext = ap_lua_ssl_is_https(r->connection) ? 0 : 1;

    
     mask_bytes = apr_pcalloc(r->pool, 4);
     sock = ap_get_conn_socket(r->connection);
 
    while (do_read) { 
    do_read = 0;
     
     if (plaintext) {
         rv = apr_socket_recv(sock, &byte, &len);
    }
    else {
        rv = lua_websocket_readbytes(r->connection, &byte, 1);
    }
    if (rv == APR_SUCCESS) {
        unsigned char ubyte, fin, opcode, mask, payload;
        ubyte = (unsigned char)byte;
        
        fin = ubyte >> (CHAR_BIT - 1);
        
        opcode = ubyte & 0xf;
        
        
        if (plaintext) {
            rv = apr_socket_recv(sock, &byte, &len);
        }
        else {
            rv = lua_websocket_readbytes(r->connection, &byte, 1);
        }
        if (rv == APR_SUCCESS) {
            ubyte = (unsigned char)byte;
            
            mask = ubyte >> (CHAR_BIT - 1);
            
            payload = ubyte & 0x7f;
            plen = payload;
            
            
            if (payload == 126) {
                len = 2;
                if (plaintext) {
                    
                    rv = apr_socket_recv(sock, (char*) &payload_short, &len);
                }
                else {
                    rv = lua_websocket_readbytes(r->connection, 
                        (char*) &payload_short, 2);
                }
                payload_short = ntohs(payload_short);
                
                if (rv == APR_SUCCESS) {
                    plen = payload_short;
                }
                else {
                    return 0;
                }
            }
            
            if (payload == 127) {
                len = 8;
                if (plaintext) {
                    rv = apr_socket_recv(sock, (char*) &payload_long, &len);
                }
                else {
                    rv = lua_websocket_readbytes(r->connection, 
                            (char*) &payload_long, 8);
                }
                if (rv == APR_SUCCESS) {
                    plen = ap_ntoh64(&payload_long);
                }
                else {
                    return 0;
                }
            }
            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, 
                    ""Websocket: Reading %"" APR_SIZE_T_FMT "" (%s) bytes, masking is %s. %s"", 
                    plen,
                    (payload >= 126) ? ""extra payload"" : ""no extra payload"", 
                    mask ? ""on"" : ""off"", 
                    fin ? ""This is a final frame"" : ""more to follow"");
            if (mask) {
                len = 4;
                if (plaintext) {
                    rv = apr_socket_recv(sock, (char*) mask_bytes, &len);
                }
                else {
                    rv = lua_websocket_readbytes(r->connection, 
                            (char*) mask_bytes, 4);
                }
                if (rv != APR_SUCCESS) {
                    return 0;
                }
            }
            if (plen < (HUGE_STRING_LEN*1024) && plen > 0) {
                apr_size_t remaining = plen;
                apr_size_t received;
                apr_off_t at = 0;
                char *buffer = apr_palloc(r->pool, plen+1);
                buffer[plen] = 0;
                
                if (plaintext) {
                    while (remaining > 0) {
                        received = remaining;
                        rv = apr_socket_recv(sock, buffer+at, &received);
                        if (received > 0 ) {
                            remaining -= received;
                            at += received;
                        }
                    }
                    ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, 
                    ""Websocket: Frame contained %"" APR_OFF_T_FMT "" bytes, pushed to Lua stack"", 
                        at);
                }
                else {
                    rv = lua_websocket_readbytes(r->connection, buffer, 
                            remaining);
                    ap_log_rerror(APLOG_MARK, APLOG_TRACE1, 0, r, 
                    ""Websocket: SSL Frame contained %"" APR_SIZE_T_FMT "" bytes, ""\
                            ""pushed to Lua stack"", 
                        remaining);
                }
                if (mask) {
                    for (n = 0; n < plen; n++) {
                        buffer[n] ^= mask_bytes[n%4];
                    }
                }
                
                lua_pushlstring(L, buffer, (size_t) plen); 
                lua_pushboolean(L, fin); 
                return 2;
            }
            
            
            
            if (opcode == 0x09) { 
                char frame[2];
                plen = 2;
                 frame[0] = 0x8A;
                 frame[1] = 0;
                 apr_socket_send(sock, frame, &plen); 
                do_read = 1;
             }
         }
     }
    }
     return 0;
 }
","1. apr_socket_t *sock;
2. int do_read = 1;
int n = 0;
3. unsigned short payload_short = 0;
4. do_read = 0;
5. if (plaintext) {
6. fin = ubyte >> (CHAR_BIT - 1);
7. rv = apr_socket_recv(sock, &byte, &len);
8. if (payload == 126) {
9. (char*) &payload_short, 2);
10. plen = ap_ntoh64(&payload_long);
11. else {
12. len = 4;
13. apr_off_t at = 0;
14. at += received;
15. if (mask) {
16. return 2;
17. frame[0] = 0x8A;
18. do_read = 1;","6
8-9
12
27
29
39
45
59
67
89
91
102
117
127
142
150
158
161",CWE-362
ConnectionChangeHandler,"  static void ConnectionChangeHandler(void* object, bool connected) {
  
  virtual void OnConnectionChange(bool connected) {
     if (!BrowserThread::CurrentlyOn(BrowserThread::UI)) {
       LOG(ERROR) << ""Not on UI thread"";
       return;
     }
 
    ime_connected_ = connected;
     if (connected) {
      pending_config_requests_.clear();
      pending_config_requests_.insert(
          current_config_values_.begin(),
          current_config_values_.end());
      FlushImeConfig();

      ChangeInputMethod(previous_input_method().id);
      ChangeInputMethod(current_input_method().id);
     }
   }
",1. current_config_values_.end());,14,"CWE-190,CWE-94,CWE-399"
native_handle_create," native_handle_t* native_handle_create(int numFds, int numInts)
 {
    if (numFds < 0 || numInts < 0 || numFds > kMaxNativeFds || numInts > kMaxNativeInts) {
        return NULL;
    }
 
    size_t mallocSize = sizeof(native_handle_t) + (sizeof(int) * (numFds + numInts));
    native_handle_t* h = malloc(mallocSize);
     if (h) {
         h->version = sizeof(native_handle_t);
         h->numFds = numFds;
        h->numInts = numInts;
 }
 return h;
}
","1. if (numFds < 0 || numInts < 0 || numFds > kMaxNativeFds || numInts > kMaxNativeInts) {
return NULL;
2. size_t mallocSize = sizeof(native_handle_t) + (sizeof(int) * (numFds + numInts));
3. if (h) {
h->version = sizeof(native_handle_t);
h->numFds = numFds;
h->numInts = numInts;
4. return h;","3-4
7
9-12
14","CWE-119,CWE-200,CWE-125,CWE-189"
hugetlb_vm_op_close_1," static void hugetlb_vm_op_close_1(struct vm_area_struct *vma)
 {
 	struct hstate *h = hstate_vma(vma);
	struct resv_map *reservations = vma_resv_map(vma);
	struct hugepage_subpool *spool = subpool_vma(vma);
	unsigned long reserve;
	unsigned long start;
	unsigned long end;

	if (reservations) {
		start = vma_hugecache_offset(h, vma, vma->vm_start);
		end = vma_hugecache_offset(h, vma, vma->vm_end);

 		reserve = (end - start) -
 			region_count(&reservations->regions, start, end);
 
		resv_map_put(vma);
 
 		if (reserve) {
 			hugetlb_acct_memory(h, -reserve);
			hugepage_subpool_put_pages(spool, reserve);
		}
	}
}
","1. static void hugetlb_vm_op_close_1(struct vm_area_struct *vma)
2. struct resv_map *reservations = vma_resv_map(vma);
3. unsigned long end;
4. if (reservations) {
5. end = vma_hugecache_offset(h, vma, vma->vm_end);
6. resv_map_put(vma);
7. hugetlb_acct_memory(h, -reserve);
hugepage_subpool_put_pages(spool, reserve);","1
4
8
10
12
17
20-21","CWE-476,CWE-399,CWE-119"
serdes_simple_xlate-165370703228258,"static struct phy *serdes_simple_xlate(struct device *dev,
				       struct of_phandle_args *args)
{
	struct serdes_ctrl *ctrl = dev_get_drvdata(dev);
	unsigned int port, idx, i;

	if (args->args_count != 2)
		return ERR_PTR(-EINVAL);

	port = args->args[0];
	idx = args->args[1];

	for (i = 0; i < SERDES_MAX; i++) {
		struct serdes_macro *macro = phy_get_drvdata(ctrl->phys[i]);

		if (idx != macro->idx)
			continue;

		
		if (idx != SERDES6G(0) && macro->port >= 0)
			return ERR_PTR(-EBUSY);

		macro->port = port;
		return ctrl->phys[i];
	}

	return ERR_PTR(-ENODEV);
}
","1. static struct phy *serdes_simple_xlate(struct device *dev,
struct of_phandle_args *args)
2. unsigned int port, idx, i;
3. if (args->args_count != 2)
4. port = args->args[0];
5. return ERR_PTR(-EBUSY);
6. macro->port = port;","1-2
5
7
10
21
23","CWE-476,CWE-125,CWE-399,CWE-189"
rtl_usb_probe-152644340770520,"int rtl_usb_probe(struct usb_interface *intf,
		  const struct usb_device_id *id,
		  struct rtl_hal_cfg *rtl_hal_cfg)
{
	int err;
	struct ieee80211_hw *hw = NULL;
	struct rtl_priv *rtlpriv = NULL;
	struct usb_device	*udev;
	struct rtl_usb_priv *usb_priv;

	hw = ieee80211_alloc_hw(sizeof(struct rtl_priv) +
				sizeof(struct rtl_usb_priv), &rtl_ops);
	if (!hw) {
		WARN_ONCE(true, ""rtl_usb: ieee80211 alloc failed\n"");
		return -ENOMEM;
	}
	rtlpriv = hw->priv;
	rtlpriv->hw = hw;
	rtlpriv->usb_data = kcalloc(RTL_USB_MAX_RX_COUNT, sizeof(u32),
				    GFP_KERNEL);
	if (!rtlpriv->usb_data) {
		ieee80211_free_hw(hw);
		return -ENOMEM;
	}

	
	spin_lock_init(&rtlpriv->locks.usb_lock);
	INIT_WORK(&rtlpriv->works.fill_h2c_cmd,
		  rtl_fill_h2c_cmd_work_callback);
	INIT_WORK(&rtlpriv->works.lps_change_work,
		  rtl_lps_change_work_callback);

	rtlpriv->usb_data_index = 0;
	init_completion(&rtlpriv->firmware_loading_complete);
	SET_IEEE80211_DEV(hw, &intf->dev);
	udev = interface_to_usbdev(intf);
	usb_get_dev(udev);
	usb_priv = rtl_usbpriv(hw);
	memset(usb_priv, 0, sizeof(*usb_priv));
	usb_priv->dev.intf = intf;
	usb_priv->dev.udev = udev;
	usb_set_intfdata(intf, hw);
	
	rtlpriv->rtlhal.interface = INTF_USB;
	rtlpriv->cfg = rtl_hal_cfg;
	rtlpriv->intf_ops = &rtl_usb_ops;
	
	_rtl_usb_io_handler_init(&udev->dev, hw);
	rtlpriv->cfg->ops->read_chip_version(hw);
	
	rtlpriv->cfg->ops->read_eeprom_info(hw);
	err = _rtl_usb_init(hw);
	if (err)
		goto error_out2;
	rtl_usb_init_sw(hw);
	
	err = rtl_init_core(hw);
	if (err) {
		pr_err(""Can't allocate sw for mac80211\n"");
		goto error_out2;
	}
	if (rtlpriv->cfg->ops->init_sw_vars(hw)) {
		pr_err(""Can't init_sw_vars\n"");
		goto error_out;
	}
	rtlpriv->cfg->ops->init_sw_leds(hw);

	err = ieee80211_register_hw(hw);
	if (err) {
		pr_err(""Can't register mac80211 hw.\n"");
		err = -ENODEV;
		goto error_out;
	}
	rtlpriv->mac80211.mac80211_registered = 1;

	set_bit(RTL_STATUS_INTERFACE_START, &rtlpriv->status);
	return 0;

error_out:
	rtl_deinit_core(hw);
error_out2:
	_rtl_usb_io_handler_release(hw);
	usb_put_dev(udev);
	complete(&rtlpriv->firmware_loading_complete);
	kfree(rtlpriv->usb_data);
	return -ENODEV;
}
","1. struct rtl_priv *rtlpriv = NULL;
2. if (!rtlpriv->usb_data) {
3. rtlpriv->rtlhal.interface = INTF_USB;
4. rtl_usb_init_sw(hw);
5. if (rtlpriv->cfg->ops->init_sw_vars(hw)) {
6. error_out2:","7
21
44
55
62
81","CWE-476,CWE-787,CWE-122,CWE-77,CWE-399"
nlmsg_populate_mdb_fill-151381946993090,"static int nlmsg_populate_mdb_fill(struct sk_buff *skb,
				   struct net_device *dev,
				   struct br_mdb_entry *entry, u32 pid,
				   u32 seq, int type, unsigned int flags)
{
	struct nlmsghdr *nlh;
	struct br_port_msg *bpm;
	struct nlattr *nest, *nest2;

	nlh = nlmsg_put(skb, pid, seq, type, sizeof(*bpm), NLM_F_MULTI);
	if (!nlh)
		return -EMSGSIZE;

	bpm = nlmsg_data(nlh);
	memset(bpm, 0, sizeof(*bpm));
	bpm->family  = AF_BRIDGE;
	bpm->ifindex = dev->ifindex;
	nest = nla_nest_start(skb, MDBA_MDB);
	if (nest == NULL)
		goto cancel;
	nest2 = nla_nest_start(skb, MDBA_MDB_ENTRY);
	if (nest2 == NULL)
		goto end;

	if (nla_put(skb, MDBA_MDB_ENTRY_INFO, sizeof(*entry), entry))
		goto end;

	nla_nest_end(skb, nest2);
	nla_nest_end(skb, nest);
	return nlmsg_end(skb, nlh);

end:
	nla_nest_end(skb, nest);
cancel:
	nlmsg_cancel(skb, nlh);
	return -EMSGSIZE;
}
","1. static int nlmsg_populate_mdb_fill(struct sk_buff *skb,
struct net_device *dev,
2. if (!nlh)
3. memset(bpm, 0, sizeof(*bpm));
4. nla_nest_end(skb, nest);","1-2
11
15
29","CWE-20,CWE-125,CWE-399,CWE-119"
setup_connection,"
#define GsmXSMPClient

setup_connection (GsmXSMPClient *client)
{
        GIOChannel    *channel;
        int            fd;

        g_debug (""GsmXSMPClient: Setting up new connection"");

        fd = IceConnectionNumber (client->priv->ice_connection);
        fcntl (fd, F_SETFD, fcntl (fd, F_GETFD, 0) | FD_CLOEXEC);
        channel = g_io_channel_unix_new (fd);
        client->priv->watch_id = g_io_add_watch (channel,
                                                 G_IO_IN | G_IO_ERR,
                                                 (GIOFunc)client_iochannel_watch,
                                                  client);
         g_io_channel_unref (channel);
 
         set_description (client);
 
         g_debug (""GsmXSMPClient: New client '%s'"", client->priv->description);
}
","1. GIOChannel    *channel;
2. fcntl (fd, F_SETFD, fcntl (fd, F_GETFD, 0) | FD_CLOEXEC);
channel = g_io_channel_unix_new (fd);
3. set_description (client);","6
12-13
20","CWE-401,CWE-254,CWE-358,CWE-835"
update_recv-215527949348887,"BOOL update_recv(rdpUpdate* update, wStream* s)
{
	BOOL rc = FALSE;
	UINT16 updateType;
	rdpContext* context = update->context;

	if (Stream_GetRemainingLength(s) < 2)
	{
		WLog_ERR(TAG, ""Stream_GetRemainingLength(s) < 2"");
		return FALSE;
	}

	Stream_Read_UINT16(s, updateType); 
	WLog_Print(update->log, WLOG_TRACE, ""%s Update Data PDU"", UPDATE_TYPE_STRINGS[updateType]);

	if (!update_begin_paint(update))
		goto fail;

	switch (updateType)
	{
		case UPDATE_TYPE_ORDERS:
			rc = update_recv_orders(update, s);
			break;

		case UPDATE_TYPE_BITMAP:
		{
			BITMAP_UPDATE* bitmap_update = update_read_bitmap_update(update, s);

			if (!bitmap_update)
			{
				WLog_ERR(TAG, ""UPDATE_TYPE_BITMAP - update_read_bitmap_update() failed"");
				goto fail;
			}

			rc = IFCALLRESULT(FALSE, update->BitmapUpdate, context, bitmap_update);
			free_bitmap_update(update->context, bitmap_update);
		}
		break;

		case UPDATE_TYPE_PALETTE:
		{
			PALETTE_UPDATE* palette_update = update_read_palette(update, s);

			if (!palette_update)
			{
				WLog_ERR(TAG, ""UPDATE_TYPE_PALETTE - update_read_palette() failed"");
				goto fail;
			}

			rc = IFCALLRESULT(FALSE, update->Palette, context, palette_update);
			free_palette_update(context, palette_update);
		}
		break;

		case UPDATE_TYPE_SYNCHRONIZE:
			if (!update_read_synchronize(update, s))
				goto fail;
			rc = IFCALLRESULT(TRUE, update->Synchronize, context);
			break;

		default:
			break;
	}

fail:

	if (!update_end_paint(update))
		rc = FALSE;

	if (!rc)
	{
		WLog_ERR(TAG, ""UPDATE_TYPE %s [%"" PRIu16 ""] failed"", update_type_to_string(updateType),
		         updateType);
		return FALSE;
	}

	return TRUE;
}
","1. UINT16 updateType;
2. WLog_ERR(TAG, ""Stream_GetRemainingLength(s) < 2"");
3. PALETTE_UPDATE* palette_update = update_read_palette(update, s);
4. free_palette_update(context, palette_update);
5. rc = IFCALLRESULT(TRUE, update->Synchronize, context);","4
9
42
51
58","CWE-19,CWE-20,CWE-125,CWE-787"
llcp_sock_recvmsg_1,"static int llcp_sock_recvmsg_1(struct kiocb *iocb, struct socket *sock,
			     struct msghdr *msg, size_t len, int flags)
{
	int noblock = flags & MSG_DONTWAIT;
	struct sock *sk = sock->sk;
	unsigned int copied, rlen;
	struct sk_buff *skb, *cskb;
	int err = 0;
 
 	pr_debug(""%p %zu\n"", sk, len);
 
 	lock_sock(sk);
 
 	if (sk->sk_state == LLCP_CLOSED &&
	    skb_queue_empty(&sk->sk_receive_queue)) {
		release_sock(sk);
		return 0;
	}

	release_sock(sk);

	if (flags & (MSG_OOB))
		return -EOPNOTSUPP;

	skb = skb_recv_datagram(sk, flags, noblock, &err);
	if (!skb) {
		pr_err(""Recv datagram failed state %d %d %d"",
		       sk->sk_state, err, sock_error(sk));

		if (sk->sk_shutdown & RCV_SHUTDOWN)
			return 0;

		return err;
	}

	rlen = skb->len;		
	copied = min_t(unsigned int, rlen, len);

	cskb = skb;
	if (skb_copy_datagram_iovec(cskb, 0, msg->msg_iov, copied)) {
		if (!(flags & MSG_PEEK))
			skb_queue_head(&sk->sk_receive_queue, skb);
		return -EFAULT;
	}

	sock_recv_timestamp(msg, sk, skb);

	if (sk->sk_type == SOCK_DGRAM && msg->msg_name) {
		struct nfc_llcp_ui_cb *ui_cb = nfc_llcp_ui_skb_cb(skb);
		struct sockaddr_nfc_llcp *sockaddr =
			(struct sockaddr_nfc_llcp *) msg->msg_name;

		msg->msg_namelen = sizeof(struct sockaddr_nfc_llcp);

		pr_debug(""Datagram socket %d %d\n"", ui_cb->dsap, ui_cb->ssap);

		memset(sockaddr, 0, sizeof(*sockaddr));
		sockaddr->sa_family = AF_NFC;
		sockaddr->nfc_protocol = NFC_PROTO_NFC_DEP;
		sockaddr->dsap = ui_cb->dsap;
		sockaddr->ssap = ui_cb->ssap;
	}

	
	if (!(flags & MSG_PEEK)) {

		
		if (sk->sk_type == SOCK_STREAM ||
		    sk->sk_type == SOCK_DGRAM ||
		    sk->sk_type == SOCK_RAW) {
			skb_pull(skb, copied);
			if (skb->len) {
				skb_queue_head(&sk->sk_receive_queue, skb);
				goto done;
			}
		}

		kfree_skb(skb);
	}

	

done:
	
	if (sk->sk_type == SOCK_SEQPACKET && (flags & MSG_TRUNC))
		copied = rlen;

	return copied;
}
","1. int err = 0;
2. if (sk->sk_state == LLCP_CLOSED &&
3. return 0;
4. release_sock(sk);
5. return -EOPNOTSUPP;
6. sockaddr->sa_family = AF_NFC;
sockaddr->nfc_protocol = NFC_PROTO_NFC_DEP;
7. skb_pull(skb, copied);","8
14
17
20
23
58-59
71","CWE-200,CWE-20,CWE-358"
AES_encrypt-158052812421875,"int AES_encrypt(char *message, uint8_t *encr_message, uint64_t encrBufLen, unsigned  char type,
                unsigned char decryptable, uint64_t* resultLen) {



    if (!type) {
        LOG_ERROR(""Null type in AES_encrypt"");
        return -1;
    }

    if (!message) {
        LOG_ERROR(""Null message in AES_encrypt"");
        return -1;
    }

    if (!encr_message) {
        LOG_ERROR(""Null encr message in AES_encrypt"");
        return -2;
    }

    uint64_t len = strlen(message) + 1;

    if (2 + len + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE > encrBufLen ) {
        LOG_ERROR(""Output buffer too small"");
        return -3;
    }

    SAFE_CHAR_BUF(fullMessage, len + 2);

    fullMessage[0] = type;
    fullMessage[1] = decryptable;

    strncpy(fullMessage + 2, message, len );

    len = len + 2;
    message = fullMessage;

    sgx_read_rand(encr_message + SGX_AESGCM_MAC_SIZE, SGX_AESGCM_IV_SIZE);

    sgx_status_t status = sgx_rijndael128GCM_encrypt(&AES_key, (uint8_t*)message, len,
                                                     encr_message + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE,
                                                     encr_message + SGX_AESGCM_MAC_SIZE, SGX_AESGCM_IV_SIZE,
                                                     NULL, 0,
                                                     (sgx_aes_gcm_128bit_tag_t *) encr_message);

    *resultLen = len + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE;

    return status;
}
","1. if (!type) {
LOG_ERROR(""Null type in AES_encrypt"");
2. if (!message) {
3. LOG_ERROR(""Null encr message in AES_encrypt"");
4. uint64_t len = strlen(message) + 1;
5. if (2 + len + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE > encrBufLen ) {
6. return -3;
7. fullMessage[1] = decryptable;
8. encr_message + SGX_AESGCM_MAC_SIZE, SGX_AESGCM_IV_SIZE,
NULL, 0,
9. *resultLen = len + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE;
10. return status;","6-7
11
17
21
23
25
31
42-43
46
48","CWE-362,CWE-200,CWE-399,CWE-119"
txid_snapshot_recv-186616044815788,"
#define PG_FUNCTION_ARGS

Datum
txid_snapshot_recv(PG_FUNCTION_ARGS)
{
	StringInfo	buf = (StringInfo) PG_GETARG_POINTER(0);
	TxidSnapshot *snap;
	txid		last = 0;
	int			nxip;
	int			i;
	txid		xmin,
				xmax;

	
	nxip = pq_getmsgint(buf, 4);
	if (nxip < 0 || nxip > TXID_SNAPSHOT_MAX_NXIP)
		goto bad_format;

	xmin = pq_getmsgint64(buf);
	xmax = pq_getmsgint64(buf);
	if (xmin == 0 || xmax == 0 || xmin > xmax || xmax > MAX_TXID)
		goto bad_format;

	snap = palloc(TXID_SNAPSHOT_SIZE(nxip));
	snap->xmin = xmin;
	snap->xmax = xmax;
	snap->nxip = nxip;
	SET_VARSIZE(snap, TXID_SNAPSHOT_SIZE(nxip));

	for (i = 0; i < nxip; i++)
	{
		txid		cur = pq_getmsgint64(buf);

		if (cur <= last || cur < xmin || cur >= xmax)
			goto bad_format;
		snap->xip[i] = cur;
		last = cur;
	}
	PG_RETURN_POINTER(snap);

bad_format:
	elog(ERROR, ""invalid snapshot data"");
	return (Datum) NULL;
}
","1. StringInfo	buf = (StringInfo) PG_GETARG_POINTER(0);
TxidSnapshot *snap;
2. int			i;
3. goto bad_format;
4. snap->xmin = xmin;
5. snap->nxip = nxip;
6. for (i = 0; i < nxip; i++)
7. goto bad_format;
8. last = cur;","7-8
11
18
26
28
31
36
38","CWE-119,CWE-20,CWE-189"
check_entry_size_and_hooks_3,"static inline int check_entry_size_and_hooks_3(struct arpt_entry *e,
					     struct xt_table_info *newinfo,
					     const unsigned char *base,
					     const unsigned char *limit,
					     const unsigned int *hook_entries,
					     const unsigned int *underflows,
					     unsigned int valid_hooks)
{
	unsigned int h;
 	int err;
 
 	if ((unsigned long)e % __alignof__(struct arpt_entry) != 0 ||
	    (unsigned char *)e + sizeof(struct arpt_entry) >= limit ||
	    (unsigned char *)e + e->next_offset > limit) {
 		duprintf(""Bad offset %p\n"", e);
 		return -EINVAL;
 	}

	if (e->next_offset
	    < sizeof(struct arpt_entry) + sizeof(struct xt_entry_target)) {
		duprintf(""checking: element %p size %u\n"",
			 e, e->next_offset);
		return -EINVAL;
	}

	err = check_entry(e);
	if (err)
		return err;

	
	for (h = 0; h < NF_ARP_NUMHOOKS; h++) {
		if (!(valid_hooks & (1 << h)))
			continue;
		if ((unsigned char *)e - base == hook_entries[h])
			newinfo->hook_entry[h] = hook_entries[h];
		if ((unsigned char *)e - base == underflows[h]) {
			if (!check_underflow(e)) {
				pr_err(""Underflows must be unconditional and ""
				       ""use the STANDARD target with ""
				       ""ACCEPT/DROP\n"");
				return -EINVAL;
			}
			newinfo->underflow[h] = underflows[h];
		}
	}

	
	e->counters = ((struct xt_counters) { 0, 0 });
	e->comefrom = 0;
	return 0;
}
","1. unsigned int valid_hooks)
2. e, e->next_offset);","7
22","CWE-476,CWE-125,CWE-189"
spk_ttyio_ldisc_open-158503067878282,"static int spk_ttyio_ldisc_open(struct tty_struct *tty)
{
	struct spk_ldisc_data *ldisc_data;

	if (!tty->ops->write)
		return -EOPNOTSUPP;

	mutex_lock(&speakup_tty_mutex);
	if (speakup_tty) {
		mutex_unlock(&speakup_tty_mutex);
		return -EBUSY;
	}
	speakup_tty = tty;

	ldisc_data = kmalloc(sizeof(*ldisc_data), GFP_KERNEL);
	if (!ldisc_data) {
		speakup_tty = NULL;
		mutex_unlock(&speakup_tty_mutex);
		return -ENOMEM;
	}

	init_completion(&ldisc_data->completion);
	ldisc_data->buf_free = true;
	speakup_tty->disc_data = ldisc_data;
	mutex_unlock(&speakup_tty_mutex);

	return 0;
}
","1. static int spk_ttyio_ldisc_open(struct tty_struct *tty)
2. return -EOPNOTSUPP;
3. mutex_unlock(&speakup_tty_mutex);
4. ldisc_data = kmalloc(sizeof(*ldisc_data), GFP_KERNEL);
5. init_completion(&ldisc_data->completion);
6. return 0;","1
6
10
15
22
27","CWE-476,CWE-190,CWE-20,CWE-119"
pp_mil_k12-148956186833948,"static void pp_mil_k12(fp12_t r, ep2_t *t, ep2_t *q, ep_t *p, int m, bn_t a) {
	fp12_t l;
	ep_t *_p = RLC_ALLOCA(ep_t, m);
	ep2_t *_q = RLC_ALLOCA(ep2_t, m);
	size_t len = bn_bits(a) + 1;
	int i, j;
	int8_t s[RLC_FP_BITS + 1];

	if (m == 0) {
		return;
	}

	fp12_null(l);

	RLC_TRY {
		fp12_new(l);
		if (_p == NULL || _q == NULL) {
			RLC_THROW(ERR_NO_MEMORY);
		}
		for (j = 0; j < m; j++) {
			ep_null(_p[j]);
			ep2_null(_q[j]);
			ep_new(_p[j]);
			ep2_new(_q[j]);
			ep2_copy(t[j], q[j]);
			ep2_neg(_q[j], q[j]);
#if EP_ADD == BASIC
			ep_neg(_p[j], p[j]);
#else
			fp_add(_p[j]->x, p[j]->x, p[j]->x);
			fp_add(_p[j]->x, _p[j]->x, p[j]->x);
			fp_neg(_p[j]->y, p[j]->y);
#endif
		}

		fp12_zero(l);
		bn_rec_naf(s, &len, a, 2);
		pp_dbl_k12(r, t[0], t[0], _p[0]);
		for (j = 1; j < m; j++) {
			pp_dbl_k12(l, t[j], t[j], _p[j]);
			fp12_mul_dxs(r, r, l);
		}
		if (s[len - 2] > 0) {
			for (j = 0; j < m; j++) {
				pp_add_k12(l, t[j], q[j], p[j]);
				fp12_mul_dxs(r, r, l);
			}
		}
		if (s[len - 2] < 0) {
			for (j = 0; j < m; j++) {
				pp_add_k12(l, t[j], _q[j], p[j]);
				fp12_mul_dxs(r, r, l);
			}
		}

		for (i = len - 3; i >= 0; i--) {
			fp12_sqr(r, r);
			for (j = 0; j < m; j++) {
				pp_dbl_k12(l, t[j], t[j], _p[j]);
				fp12_mul_dxs(r, r, l);
				if (s[i] > 0) {
					pp_add_k12(l, t[j], q[j], p[j]);
					fp12_mul_dxs(r, r, l);
				}
				if (s[i] < 0) {
					pp_add_k12(l, t[j], _q[j], p[j]);
					fp12_mul_dxs(r, r, l);
				}
			}
		}
	}
	RLC_CATCH_ANY {
		RLC_THROW(ERR_CAUGHT);
	}
	RLC_FINALLY {
		fp12_free(l);
		for (j = 0; j < m; j++) {
			ep_free(_p[j]);
			ep2_free(_q[j]);
		}
		RLC_FREE(_p);
		RLC_FREE(_q);
	}
}
","1. fp12_t l;
2. size_t len = bn_bits(a) + 1;
3. if (m == 0) {
4. for (j = 0; j < m; j++) {
5. ep2_null(_q[j]);
6. pp_add_k12(l, t[j], _q[j], p[j]);","2
5
9
20
22
66","CWE-190,CWE-20,CWE-264,CWE-399"
decode_studio_vop_header-22935563796444,"
#define GetBitContext
#define Mpeg4DecContext

static int decode_studio_vop_header(Mpeg4DecContext *ctx, GetBitContext *gb)
{
    MpegEncContext *s = &ctx->m;

    if (get_bits_left(gb) <= 32)
        return 0;

    s->partitioned_frame = 0;
    s->interlaced_dct = 0;
    s->decode_mb = mpeg4_decode_studio_mb;

    decode_smpte_tc(ctx, gb);

    skip_bits(gb, 10); 
    skip_bits(gb, 2); 
    s->pict_type = get_bits(gb, 2) + AV_PICTURE_TYPE_I; 
    if (get_bits1(gb)) { 
        skip_bits1(gb); 
        skip_bits1(gb); 
        s->progressive_frame = get_bits1(gb) ^ 1; 
    }

    if (s->pict_type == AV_PICTURE_TYPE_I) {
        if (get_bits1(gb))
            reset_studio_dc_predictors(s);
    }

    if (ctx->shape != BIN_ONLY_SHAPE) {
        s->alternate_scan = get_bits1(gb);
        s->frame_pred_frame_dct = get_bits1(gb);
        s->dct_precision = get_bits(gb, 2);
        s->intra_dc_precision = get_bits(gb, 2);
        s->q_scale_type = get_bits1(gb);
    }

    if (s->alternate_scan) {
        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable,   ff_alternate_vertical_scan);
        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable,   ff_alternate_vertical_scan);
        ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_vertical_scan);
        ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan);
    } else {
        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable,   ff_zigzag_direct);
        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable,   ff_zigzag_direct);
        ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_horizontal_scan);
        ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan);
    }

    mpeg4_load_default_matrices(s);

    next_start_code_studio(gb);
    extension_and_user_data(s, gb, 4);

    return 0;
}
","1. s->pict_type = get_bits(gb, 2) + AV_PICTURE_TYPE_I;
2. reset_studio_dc_predictors(s);
3. s->frame_pred_frame_dct = get_bits1(gb);
s->dct_precision = get_bits(gb, 2);
4. ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable,   ff_alternate_vertical_scan);
5. } else {
6. next_start_code_studio(gb);","20
29
34-35
42
45
54","CWE-20,CWE-362,CWE-190,CWE-125,CWE-77"
enable,"static int enable(void) {
static int enable(bool start_restricted) {
  LOG_INFO(LOG_TAG, ""%s: start restricted = %d"", __func__, start_restricted);

  restricted_mode = start_restricted;
 
   if (!interface_ready())
     return BT_STATUS_NOT_READY;

  stack_manager_get_interface()->start_up_stack_async();
 return BT_STATUS_SUCCESS;
}
","1. static int enable(bool start_restricted) {
2. return BT_STATUS_NOT_READY;","2
8","CWE-190,CWE-264,CWE-399"
sign-91097312256141,"static TEE_Result sign(uint32_t algo, struct ecc_keypair *key,
		       const uint8_t *msg, size_t msg_len,
		       uint8_t *sig, size_t *sig_len)
{
	struct versal_ecc_sign_param *cmd = NULL;
	struct versal_mbox_mem cmd_buf = { };
	struct ecc_keypair ephemeral = { };
	struct versal_cmd_args arg = { };
	struct versal_mbox_mem p = { };
	struct versal_mbox_mem k = { };
	struct versal_mbox_mem d = { };
	struct versal_mbox_mem s = { };
	TEE_Result ret = TEE_SUCCESS;
	uint32_t err = 0;
	size_t bytes = 0;
	size_t bits = 0;

	ret = ecc_get_key_size(key->curve, &bytes, &bits);
	if (ret != TEE_SUCCESS) {
		if (ret != TEE_ERROR_NOT_SUPPORTED)
			return ret;

		
		return pair_ops->sign(algo, key, msg, msg_len, sig, sig_len);
	}

	
	ret = ecc_prepare_msg(algo, msg, msg_len, &p);
	if (ret)
		return ret;

	
	ret = drvcrypt_asym_alloc_ecc_keypair(&ephemeral,
					      TEE_TYPE_ECDSA_KEYPAIR, bits);
	if (ret) {
		EMSG(""Versal, can't allocate the ephemeral key"");
		return ret;
	}

	ephemeral.curve = key->curve;
	ret = crypto_acipher_gen_ecc_key(&ephemeral, bits);
	if (ret) {
		EMSG(""Versal, can't generate the ephemeral key"");
		return ret;
	}

	versal_mbox_alloc(bytes, NULL, &k);
	crypto_bignum_bn2bin_eswap(key->curve, ephemeral.d, k.buf);
	crypto_bignum_free(&ephemeral.d);
	crypto_bignum_free(&ephemeral.x);
	crypto_bignum_free(&ephemeral.y);

	
	versal_mbox_alloc(bytes, NULL, &d);
	crypto_bignum_bn2bin_eswap(key->curve, key->d, d.buf);

	
	versal_mbox_alloc(*sig_len, NULL, &s);

	
	versal_mbox_alloc(sizeof(*cmd), NULL, &cmd_buf);

	cmd = cmd_buf.buf;
	cmd->priv_key_addr = virt_to_phys(d.buf);
	cmd->epriv_key_addr = virt_to_phys(k.buf);
	cmd->hash_addr = virt_to_phys(p.buf);
	cmd->hash_len = p.len;
	cmd->curve = key->curve;

	arg.ibuf[0].mem = cmd_buf;
	arg.ibuf[1].mem = s;
	arg.ibuf[2].mem = k;
	arg.ibuf[3].mem = d;
	arg.ibuf[4].mem = p;

	if (versal_crypto_request(VERSAL_ELLIPTIC_GENERATE_SIGN, &arg, &err)) {
		EMSG(""Versal ECC: %s"", versal_ecc_error(err));
		ret = TEE_ERROR_GENERIC;
		goto out;
	}

	*sig_len = 2 * bytes;

	
	memcpy_swp(sig, s.buf, *sig_len / 2);
	memcpy_swp(sig + *sig_len / 2, (uint8_t *)s.buf + *sig_len / 2,
		   *sig_len / 2);
out:
	free(cmd);
	free(k.buf);
	free(p.buf);
	free(s.buf);
	free(d.buf);

	return ret;
}
","1. struct versal_mbox_mem cmd_buf = { };
struct ecc_keypair ephemeral = { };
2. struct versal_mbox_mem k = { };
3. ret = ecc_prepare_msg(algo, msg, msg_len, &p);
if (ret)
4. versal_mbox_alloc(bytes, NULL, &k);
5. versal_mbox_alloc(*sig_len, NULL, &s);
6. versal_mbox_alloc(sizeof(*cmd), NULL, &cmd_buf);
7. cmd = cmd_buf.buf;
8. arg.ibuf[1].mem = s;
arg.ibuf[2].mem = k;
arg.ibuf[3].mem = d;
9. goto out;
10. *sig_len / 2);
11. free(s.buf);
free(d.buf);","6-7
10
28-29
47
58
61
63
71-73
79
87
92-93","CWE-362,CWE-191,CWE-59"
PHP_METHOD_21,"
#define Phar

PHP_METHOD_21(Phar, createDefaultStub)
{
	char *index = NULL, *webindex = NULL, *error;
        zend_string *stub;
        size_t index_len = 0, webindex_len = 0;
 
       if (zend_parse_parameters(ZEND_NUM_ARGS(), ""|pp"", &index, &index_len, &webindex, &webindex_len) == FAILURE) {
                return;
        }
 
	stub = phar_create_default_stub(index, webindex, &error);

	if (error) {
		zend_throw_exception_ex(phar_ce_PharException, 0, ""%s"", error);
		efree(error);
		return;
	}
	RETURN_NEW_STR(stub);
}
","1. char *index = NULL, *webindex = NULL, *error;
2. stub = phar_create_default_stub(index, webindex, &error);
3. zend_throw_exception_ex(phar_ce_PharException, 0, ""%s"", error);
efree(error);
4. RETURN_NEW_STR(stub);","6
14
17-18
21","CWE-190,CWE-200,CWE-125,CWE-400"
proc_mount,"static struct dentry *proc_mount(struct file_system_type *fs_type,
	int flags, const char *dev_name, void *data)
{
	int err;
	struct super_block *sb;
	struct pid_namespace *ns;
	char *options;

	if (flags & MS_KERNMOUNT) {
		ns = (struct pid_namespace *)data;
		options = NULL;
	} else {
		ns = task_active_pid_ns(current);
		options = data;

		
		if (!ns_capable(ns->user_ns, CAP_SYS_ADMIN))
			return ERR_PTR(-EPERM);
	}

	sb = sget(fs_type, proc_test_super, proc_set_super, flags, ns);
 	if (IS_ERR(sb))
 		return ERR_CAST(sb);
 
	
	sb->s_stack_depth = FILESYSTEM_MAX_STACK_DEPTH;

 	if (!proc_parse_options(options, ns)) {
 		deactivate_locked_super(sb);
 		return ERR_PTR(-EINVAL);
	}

	if (!sb->s_root) {
		err = proc_fill_super(sb);
		if (err) {
			deactivate_locked_super(sb);
			return ERR_PTR(err);
		}

		sb->s_flags |= MS_ACTIVE;
		
		sb->s_iflags |= SB_I_NOEXEC;
	}

	return dget(sb->s_root);
}
","1. int flags, const char *dev_name, void *data)
2. struct pid_namespace *ns;
3. } else {
ns = task_active_pid_ns(current);
options = data;
4. if (!sb->s_root) {
5. sb->s_flags |= MS_ACTIVE;
6. sb->s_iflags |= SB_I_NOEXEC;","2
6
12-14
37
44
46","CWE-476,CWE-362,CWE-416"
ssl_flush_wbio-276944086863890,"static pj_status_t ssl_flush_wbio(dtls_srtp *ds, unsigned idx)
{
    pj_size_t len;
    pj_status_t status = PJ_SUCCESS;

    DTLS_LOCK(ds);

    if (!ds->ossl_wbio[idx]) {
        DTLS_UNLOCK(ds);
        return PJ_EGONE;
    }

    
    if (BIO_ctrl_pending(ds->ossl_wbio[idx]) > 0) {
        
        len = BIO_read(ds->ossl_wbio[idx], ds->buf[idx], sizeof(ds->buf));
        if (len > 0) {
            DTLS_UNLOCK(ds);

            status = send_raw(ds, idx, ds->buf[idx], len);
            if (status != PJ_SUCCESS) {
#if DTLS_DEBUG
                pj_perror(2, ds->base.name, status, ""Send error"");
#endif
                
            }
            DTLS_LOCK(ds);
        }
    }

    if (!ds->ossl_ssl[idx]) {
        DTLS_UNLOCK(ds);
        return PJ_EGONE;
    }

    
    if (ds->nego_completed[idx] || !SSL_is_init_finished(ds->ossl_ssl[idx])) {
        DTLS_UNLOCK(ds);
        return PJ_SUCCESS;
    }

    
    ds->nego_completed[idx] = PJ_TRUE;
    PJ_LOG(2,(ds->base.name, ""DTLS-SRTP negotiation for %s completed!"",
                             CHANNEL_TO_STRING(idx)));

    DTLS_UNLOCK(ds);

    
    if (ds->clock[idx])
        pjmedia_clock_stop(ds->clock[idx]);

    
    status = ssl_get_srtp_material(ds, idx);
    if (status != PJ_SUCCESS) {
        pj_perror(4, ds->base.name, status,
                  ""Failed to get SRTP material"");
        goto on_return;
    }

    
    if (ds->rem_fingerprint.slen && ds->rem_fprint_status == PJ_EPENDING) {
        ds->rem_fprint_status = status = ssl_match_fingerprint(ds, idx);
        if (status != PJ_SUCCESS) {
            pj_perror(4, ds->base.name, status,
                      ""Fingerprint specified in remote SDP doesn't match ""
                      ""to actual remote certificate fingerprint!"");
            goto on_return;
        }
    }

    
    if (ds->pending_start && idx == RTP_CHANNEL) {
        ds->pending_start = PJ_FALSE;
        ds->srtp->keying_pending_cnt--;

        
        ds->srtp->srtp_ctx.tx_policy_neg = ds->tx_crypto[idx];
        ds->srtp->srtp_ctx.rx_policy_neg = ds->rx_crypto[idx];

        status = start_srtp(ds->srtp);
        if (status != PJ_SUCCESS)
            pj_perror(4, ds->base.name, status, ""Failed starting SRTP"");
    } else if (idx == RTCP_CHANNEL) {
        pjmedia_srtp_setting setting;

        pjmedia_srtp_setting_default (&setting);

        
        ds->srtp->srtp_rtcp.tx_policy_neg = ds->tx_crypto[idx];
        ds->srtp->srtp_rtcp.rx_policy_neg = ds->rx_crypto[idx];

        status = create_srtp_ctx(ds->srtp, &ds->srtp->srtp_rtcp,
                                 &setting, &ds->srtp->srtp_rtcp.tx_policy_neg,
                                 &ds->srtp->srtp_rtcp.rx_policy_neg);
        if (status != PJ_SUCCESS)
            pj_perror(4, ds->base.name, status, ""Failed creating SRTP RTCP"");
    }

on_return:
    if (idx == RTP_CHANNEL && ds->srtp->setting.cb.on_srtp_nego_complete) {
        (*ds->srtp->setting.cb.on_srtp_nego_complete)
                                            (&ds->srtp->base, status);
    }

    return status;
}
","1. static pj_status_t ssl_flush_wbio(dtls_srtp *ds, unsigned idx)
2. pj_status_t status = PJ_SUCCESS;
3. if (!ds->ossl_wbio[idx]) {
DTLS_UNLOCK(ds);
4. if (BIO_ctrl_pending(ds->ossl_wbio[idx]) > 0) {
5. len = BIO_read(ds->ossl_wbio[idx], ds->buf[idx], sizeof(ds->buf));
if (len > 0) {
DTLS_UNLOCK(ds);
6. if (status != PJ_SUCCESS) {
7. DTLS_UNLOCK(ds);
8. if (ds->nego_completed[idx] || !SSL_is_init_finished(ds->ossl_ssl[idx])) {
9. PJ_LOG(2,(ds->base.name, ""DTLS-SRTP negotiation for %s completed!"",
CHANNEL_TO_STRING(idx)));
10. ""Failed to get SRTP material"");
goto on_return;
11. if (ds->rem_fingerprint.slen && ds->rem_fprint_status == PJ_EPENDING) {
ds->rem_fprint_status = status = ssl_match_fingerprint(ds, idx);
12. pj_perror(4, ds->base.name, status,
13. goto on_return;
14. if (ds->pending_start && idx == RTP_CHANNEL) {
15. ds->srtp->srtp_ctx.tx_policy_neg = ds->tx_crypto[idx];
ds->srtp->srtp_ctx.rx_policy_neg = ds->rx_crypto[idx];
16. } else if (idx == RTCP_CHANNEL) {
17. ds->srtp->srtp_rtcp.rx_policy_neg = ds->rx_crypto[idx];
18. status = create_srtp_ctx(ds->srtp, &ds->srtp->srtp_rtcp,
19. &ds->srtp->srtp_rtcp.rx_policy_neg);
20. pj_perror(4, ds->base.name, status, ""Failed creating SRTP RTCP"");
21. on_return:
22. (&ds->srtp->base, status);","1
4
8-9
14
16-18
21
34
41
48-49
64-65
69-70
72
75
80
85-86
91
98
100
102
104
107
110","CWE-20,CWE-416,CWE-401,CWE-19,CWE-125"
ppp_unregister_channel,"ppp_unregister_channel(struct ppp_channel *chan)
{
	struct channel *pch = chan->ppp;
	struct ppp_net *pn;

	if (!pch)
		return;		

	chan->ppp = NULL;

	
	down_write(&pch->chan_sem);
	spin_lock_bh(&pch->downl);
	pch->chan = NULL;
	spin_unlock_bh(&pch->downl);
	up_write(&pch->chan_sem);
	ppp_disconnect_channel(pch);

	pn = ppp_pernet(pch->chan_net);
 	spin_lock_bh(&pn->all_channels_lock);
 	list_del(&pch->list);
 	spin_unlock_bh(&pn->all_channels_lock);
	put_net(pch->chan_net);
	pch->chan_net = NULL;
 
 	pch->file.dead = 1;
 	wake_up_interruptible(&pch->file.rwait);
	if (atomic_dec_and_test(&pch->file.refcnt))
		ppp_destroy_channel(pch);
}
","1. ppp_unregister_channel(struct ppp_channel *chan)
2. return;
3. chan->ppp = NULL;
4. pch->chan = NULL;
5. ppp_disconnect_channel(pch);
6. put_net(pch->chan_net);
7. if (atomic_dec_and_test(&pch->file.refcnt))","1
7
9
17
20
26
31","CWE-476,CWE-190,CWE-362,CWE-416"
http_read_stream,"
#define URLContext

static int http_read_stream(URLContext *h, uint8_t *buf, int size)
{
    HTTPContext *s = h->priv_data;
    int err, new_location, read_ret;
    int64_t seek_ret;

    if (!s->hd)
        return AVERROR_EOF;

    if (s->end_chunked_post && !s->end_header) {
        err = http_read_header(h, &new_location);
        if (err < 0)
             return err;
     }
 
    if (s->chunksize != UINT64_MAX) {
         if (!s->chunksize) {
             char line[32];
 
                do {
                    if ((err = http_get_line(s, line, sizeof(line))) < 0)
                         return err;
                 } while (!*line);    
 
                s->chunksize = strtoull(line, NULL, 16);
 
                av_log(h, AV_LOG_TRACE,
                       ""Chunked encoding data size: %""PRIu64""'\n"",
                         s->chunksize);
 
                 if (!s->chunksize)
                     return 0;
                else if (s->chunksize == UINT64_MAX) {
                    av_log(h, AV_LOG_ERROR, ""Invalid chunk size %""PRIu64""\n"",
                           s->chunksize);
                    return AVERROR(EINVAL);
                }
         }
         size = FFMIN(size, s->chunksize);
     }
#if CONFIG_ZLIB
    if (s->compressed)
        return http_buf_read_compressed(h, buf, size);
#endif 
     read_ret = http_buf_read(h, buf, size);
     if (   (read_ret  < 0 && s->reconnect        && (!h->is_streamed || s->reconnect_streamed) && s->filesize > 0 && s->off < s->filesize)
         || (read_ret == 0 && s->reconnect_at_eof && (!h->is_streamed || s->reconnect_streamed))) {
        uint64_t target = h->is_streamed ? 0 : s->off;
 
         if (s->reconnect_delay > s->reconnect_delay_max)
             return AVERROR(EIO);
 
        av_log(h, AV_LOG_INFO, ""Will reconnect at %""PRIu64"" error=%s.\n"", s->off, av_err2str(read_ret));
         av_usleep(1000U*1000*s->reconnect_delay);
         s->reconnect_delay = 1 + 2*s->reconnect_delay;
         seek_ret = http_seek_internal(h, target, SEEK_SET, 1);
         if (seek_ret != target) {
            av_log(h, AV_LOG_ERROR, ""Failed to reconnect at %""PRIu64"".\n"", target);
             return read_ret;
         }
 
        read_ret = http_buf_read(h, buf, size);
    } else
        s->reconnect_delay = 0;

    return read_ret;
}
","1. static int http_read_stream(URLContext *h, uint8_t *buf, int size)
2. int64_t seek_ret;
3. return AVERROR_EOF;
4. if (s->end_chunked_post && !s->end_header) {
err = http_read_header(h, &new_location);
5. if ((err = http_get_line(s, line, sizeof(line))) < 0)
6. s->chunksize = strtoull(line, NULL, 16);
7. return AVERROR(EINVAL);
8. size = FFMIN(size, s->chunksize);
9. read_ret = http_buf_read(h, buf, size);
if (   (read_ret  < 0 && s->reconnect        && (!h->is_streamed || s->reconnect_streamed) && s->filesize > 0 && s->off < s->filesize)
10. uint64_t target = h->is_streamed ? 0 : s->off;
11. if (s->reconnect_delay > s->reconnect_delay_max)
12. if (seek_ret != target) {","4
8
11
13-14
24
28
39
42
48-49
51
53
60","CWE-125,CWE-119"
follow_page_pte_1-277014837048969,"static struct page *follow_page_pte_1(struct vm_area_struct *vma,
		unsigned long address, pmd_t *pmd, unsigned int flags,
		struct dev_pagemap **pgmap)
{
	struct mm_struct *mm = vma->vm_mm;
	struct page *page;
	spinlock_t *ptl;
	pte_t *ptep, pte;

retry:
	if (unlikely(pmd_bad(*pmd)))
		return no_page_table(vma, flags);

	ptep = pte_offset_map_lock(mm, pmd, address, &ptl);
	pte = *ptep;
	if (!pte_present(pte)) {
		swp_entry_t entry;
		
		if (likely(!(flags & FOLL_MIGRATION)))
			goto no_page;
		if (pte_none(pte))
			goto no_page;
		entry = pte_to_swp_entry(pte);
		if (!is_migration_entry(entry))
			goto no_page;
		pte_unmap_unlock(ptep, ptl);
		migration_entry_wait(mm, pmd, address);
		goto retry;
	}
	if ((flags & FOLL_NUMA) && pte_protnone(pte))
		goto no_page;
	if ((flags & FOLL_WRITE) && !can_follow_write_pte(pte, flags)) {
		pte_unmap_unlock(ptep, ptl);
		return NULL;
	}

	page = vm_normal_page(vma, address, pte);
	if (!page && pte_devmap(pte) && (flags & FOLL_GET)) {
		
		*pgmap = get_dev_pagemap(pte_pfn(pte), *pgmap);
		if (*pgmap)
			page = pte_page(pte);
		else
			goto no_page;
	} else if (unlikely(!page)) {
		if (flags & FOLL_DUMP) {
			
			page = ERR_PTR(-EFAULT);
			goto out;
		}

		if (is_zero_pfn(pte_pfn(pte))) {
			page = pte_page(pte);
		} else {
			int ret;

			ret = follow_pfn_pte(vma, address, ptep, flags);
			page = ERR_PTR(ret);
			goto out;
		}
	}

	if (flags & FOLL_SPLIT && PageTransCompound(page)) {
		int ret;
		get_page(page);
		pte_unmap_unlock(ptep, ptl);
		lock_page(page);
		ret = split_huge_page(page);
		unlock_page(page);
		put_page(page);
		if (ret)
			return ERR_PTR(ret);
		goto retry;
	}

	if (flags & FOLL_GET) {
		if (unlikely(!try_get_page(page))) {
			page = ERR_PTR(-ENOMEM);
			goto out;
		}
	}
	if (flags & FOLL_TOUCH) {
		if ((flags & FOLL_WRITE) &&
		    !pte_dirty(pte) && !PageDirty(page))
			set_page_dirty(page);
		
		mark_page_accessed(page);
	}
	if ((flags & FOLL_MLOCK) && (vma->vm_flags & VM_LOCKED)) {
		
		if (PageTransCompound(page))
			goto out;

		
		if (page->mapping && trylock_page(page)) {
			lru_add_drain();  
			
			mlock_vma_page(page);
			unlock_page(page);
		}
	}
out:
	pte_unmap_unlock(ptep, ptl);
	return page;
no_page:
	pte_unmap_unlock(ptep, ptl);
	if (!pte_none(pte))
		return NULL;
	return no_page_table(vma, flags);
}
","1. pte_t *ptep, pte;
2. return no_page_table(vma, flags);
3. goto no_page;
4. migration_entry_wait(mm, pmd, address);
goto retry;
5. if ((flags & FOLL_WRITE) && !can_follow_write_pte(pte, flags)) {
6. if (!page && pte_devmap(pte) && (flags & FOLL_GET)) {
7. goto no_page;
} else if (unlikely(!page)) {
if (flags & FOLL_DUMP) {
8. get_page(page);
9. ret = split_huge_page(page);
10. put_page(page);
11. return ERR_PTR(ret);
12. page = ERR_PTR(-ENOMEM);
13. if ((flags & FOLL_WRITE) &&
14. unlock_page(page);
15. no_page:
16. if (!pte_none(pte))
17. return no_page_table(vma, flags);","8
12
29
31-32
36
42
51-53
72
75
77
79
85
90
123
129
131
133","CWE-362,CWE-200,CWE-59,CWE-416"
saa7164_bus_get-23364250227309,"int saa7164_bus_get(struct saa7164_dev *dev, struct tmComResInfo* msg,
	void *buf, int peekonly)
{
	struct tmComResBusInfo *bus = &dev->bus;
	u32 bytes_to_read, write_distance, curr_grp, curr_gwp,
		new_grp, buf_size, space_rem;
	struct tmComResInfo msg_tmp;
	int ret = SAA_ERR_BAD_PARAMETER;

	saa7164_bus_verify(dev);

	if (msg == NULL)
		return ret;

	if (msg->size > dev->bus.m_wMaxReqSize) {
		printk(KERN_ERR ""%s() Exceeded dev->bus.m_wMaxReqSize\n"",
			__func__);
		return ret;
	}

	if ((peekonly == 0) && (msg->size > 0) && (buf == NULL)) {
		printk(KERN_ERR
			""%s() Missing msg buf, size should be %d bytes\n"",
			__func__, msg->size);
		return ret;
	}

	mutex_lock(&bus->lock);

	
	curr_gwp = saa7164_readl(bus->m_dwGetWritePos);
	curr_grp = saa7164_readl(bus->m_dwGetReadPos);

	if (curr_gwp == curr_grp) {
		ret = SAA_ERR_EMPTY;
		goto out;
	}

	bytes_to_read = sizeof(*msg);

	
	write_distance = 0;
	if (curr_gwp >= curr_grp)
		
		write_distance = curr_gwp - curr_grp;
	else
		
		write_distance = curr_gwp + bus->m_dwSizeGetRing - curr_grp;

	if (bytes_to_read > write_distance) {
		printk(KERN_ERR ""%s() No message/response found\n"", __func__);
		ret = SAA_ERR_INVALID_COMMAND;
		goto out;
	}

	
	new_grp = curr_grp + bytes_to_read;
	if (new_grp > bus->m_dwSizeGetRing) {

		
		new_grp -= bus->m_dwSizeGetRing;
		space_rem = bus->m_dwSizeGetRing - curr_grp;

		memcpy_fromio(&msg_tmp, bus->m_pdwGetRing + curr_grp, space_rem);
		memcpy_fromio((u8 *)&msg_tmp + space_rem, bus->m_pdwGetRing,
			bytes_to_read - space_rem);

	} else {
		
		memcpy_fromio(&msg_tmp, bus->m_pdwGetRing + curr_grp, bytes_to_read);
	}
	
	msg_tmp.size = le16_to_cpu((__force __le16)msg_tmp.size);
	msg_tmp.command = le32_to_cpu((__force __le32)msg_tmp.command);
	msg_tmp.controlselector = le16_to_cpu((__force __le16)msg_tmp.controlselector);
	memcpy(msg, &msg_tmp, sizeof(*msg));

	
	
	if (peekonly) {
		goto peekout;
	}

	
	if ((msg_tmp.id != msg->id) || (msg_tmp.command != msg->command) ||
		(msg_tmp.controlselector != msg->controlselector) ||
		(msg_tmp.seqno != msg->seqno) || (msg_tmp.size != msg->size)) {

		printk(KERN_ERR ""%s() Unexpected msg miss-match\n"", __func__);
		saa7164_bus_dumpmsg(dev, msg, buf);
		saa7164_bus_dumpmsg(dev, &msg_tmp, NULL);
		ret = SAA_ERR_INVALID_COMMAND;
		goto out;
	}

	
	buf_size = msg->size;

	bytes_to_read = sizeof(*msg) + msg->size;
	
	write_distance = 0;
	if (curr_gwp >= curr_grp)
		
		write_distance = curr_gwp - curr_grp;
	else
		
		write_distance = curr_gwp + bus->m_dwSizeGetRing - curr_grp;

	if (bytes_to_read > write_distance) {
		printk(KERN_ERR ""%s() Invalid bus state, missing msg or mangled ring, faulty H/W / bad code?\n"",
		       __func__);
		ret = SAA_ERR_INVALID_COMMAND;
		goto out;
	}

	
	new_grp = curr_grp + bytes_to_read;
	if (new_grp > bus->m_dwSizeGetRing) {

		
		new_grp -= bus->m_dwSizeGetRing;
		space_rem = bus->m_dwSizeGetRing - curr_grp;

		if (space_rem < sizeof(*msg)) {
			if (buf)
				memcpy_fromio(buf, bus->m_pdwGetRing + sizeof(*msg) -
					space_rem, buf_size);

		} else if (space_rem == sizeof(*msg)) {
			if (buf)
				memcpy_fromio(buf, bus->m_pdwGetRing, buf_size);
		} else {
			
			if (buf) {
				memcpy_fromio(buf, bus->m_pdwGetRing + curr_grp +
					sizeof(*msg), space_rem - sizeof(*msg));
				memcpy_fromio(buf + space_rem - sizeof(*msg),
					bus->m_pdwGetRing, bytes_to_read -
					space_rem);
			}

		}

	} else {
		
		if (buf)
			memcpy_fromio(buf, bus->m_pdwGetRing + curr_grp + sizeof(*msg),
				buf_size);
	}

	
	saa7164_writel(bus->m_dwGetReadPos, new_grp);

peekout:
	ret = SAA_OK;
out:
	mutex_unlock(&bus->lock);
	saa7164_bus_verify(dev);
	return ret;
}
","1. int saa7164_bus_get(struct saa7164_dev *dev, struct tmComResInfo* msg,
2. int ret = SAA_ERR_BAD_PARAMETER;
3. if (msg->size > dev->bus.m_wMaxReqSize) {
4. if (new_grp > bus->m_dwSizeGetRing) {
5. } else {
6. goto peekout;
7. if ((msg_tmp.id != msg->id) || (msg_tmp.command != msg->command) ||
8. bytes_to_read = sizeof(*msg) + msg->size;
9. if (bytes_to_read > write_distance) {
10. goto out;
11. new_grp = curr_grp + bytes_to_read;
12. space_rem = bus->m_dwSizeGetRing - curr_grp;
13. memcpy_fromio(buf, bus->m_pdwGetRing + sizeof(*msg) -
14. } else {","1
8
15
60
70
83
87
101
111
115
119
124
128
134","CWE-824,CWE-190,CWE-119,CWE-189"
snd_ctl_elem_add_1-199288668544541,"static int snd_ctl_elem_add_1(struct snd_ctl_file *file,
			    struct snd_ctl_elem_info *info, int replace)
{
	struct snd_card *card = file->card;
	struct snd_kcontrol kctl, *_kctl;
	unsigned int access;
	long private_size;
	struct user_element *ue;
	int idx, err;

	if (info->count < 1)
		return -EINVAL;
	access = info->access == 0 ? SNDRV_CTL_ELEM_ACCESS_READWRITE :
		(info->access & (SNDRV_CTL_ELEM_ACCESS_READWRITE|
				 SNDRV_CTL_ELEM_ACCESS_INACTIVE|
				 SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE));
	info->id.numid = 0;
	memset(&kctl, 0, sizeof(kctl));

	if (replace) {
		err = snd_ctl_remove_user_ctl(file, &info->id);
		if (err)
			return err;
	}

	if (card->user_ctl_count >= MAX_USER_CONTROLS)
		return -ENOMEM;

	memcpy(&kctl.id, &info->id, sizeof(info->id));
	kctl.count = info->owner ? info->owner : 1;
	access |= SNDRV_CTL_ELEM_ACCESS_USER;
	if (info->type == SNDRV_CTL_ELEM_TYPE_ENUMERATED)
		kctl.info = snd_ctl_elem_user_enum_info;
	else
		kctl.info = snd_ctl_elem_user_info;
	if (access & SNDRV_CTL_ELEM_ACCESS_READ)
		kctl.get = snd_ctl_elem_user_get;
	if (access & SNDRV_CTL_ELEM_ACCESS_WRITE)
		kctl.put = snd_ctl_elem_user_put;
	if (access & SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE) {
		kctl.tlv.c = snd_ctl_elem_user_tlv;
		access |= SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK;
	}
	switch (info->type) {
	case SNDRV_CTL_ELEM_TYPE_BOOLEAN:
	case SNDRV_CTL_ELEM_TYPE_INTEGER:
		private_size = sizeof(long);
		if (info->count > 128)
			return -EINVAL;
		break;
	case SNDRV_CTL_ELEM_TYPE_INTEGER64:
		private_size = sizeof(long long);
		if (info->count > 64)
			return -EINVAL;
		break;
	case SNDRV_CTL_ELEM_TYPE_ENUMERATED:
		private_size = sizeof(unsigned int);
		if (info->count > 128 || info->value.enumerated.items == 0)
			return -EINVAL;
		break;
	case SNDRV_CTL_ELEM_TYPE_BYTES:
		private_size = sizeof(unsigned char);
		if (info->count > 512)
			return -EINVAL;
		break;
	case SNDRV_CTL_ELEM_TYPE_IEC958:
		private_size = sizeof(struct snd_aes_iec958);
		if (info->count != 1)
			return -EINVAL;
		break;
	default:
		return -EINVAL;
	}
	private_size *= info->count;
	ue = kzalloc(sizeof(struct user_element) + private_size, GFP_KERNEL);
	if (ue == NULL)
		return -ENOMEM;
	ue->card = card;
	ue->info = *info;
	ue->info.access = 0;
	ue->elem_data = (char *)ue + sizeof(*ue);
	ue->elem_data_size = private_size;
	if (ue->info.type == SNDRV_CTL_ELEM_TYPE_ENUMERATED) {
		err = snd_ctl_elem_init_enum_names(ue);
		if (err < 0) {
			kfree(ue);
			return err;
		}
	}
	kctl.private_free = snd_ctl_elem_user_free;
	_kctl = snd_ctl_new(&kctl, access);
	if (_kctl == NULL) {
		kfree(ue->priv_data);
		kfree(ue);
		return -ENOMEM;
	}
	_kctl->private_data = ue;
	for (idx = 0; idx < _kctl->count; idx++)
		_kctl->vd[idx].owner = file;
	err = snd_ctl_add(card, _kctl);
	if (err < 0)
		return err;

	down_write(&card->controls_rwsem);
	card->user_ctl_count++;
	up_write(&card->controls_rwsem);

	return 0;
}
","1. static int snd_ctl_elem_add_1(struct snd_ctl_file *file,
2. struct snd_card *card = file->card;
struct snd_kcontrol kctl, *_kctl;
unsigned int access;
3. if (info->count < 1)
4. SNDRV_CTL_ELEM_ACCESS_INACTIVE|
SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE));
info->id.numid = 0;
5. if (replace) {
6. return err;
7. kctl.count = info->owner ? info->owner : 1;
8. kctl.get = snd_ctl_elem_user_get;
9. kctl.put = snd_ctl_elem_user_put;
10. return -EINVAL;
11. return -EINVAL;
12. case SNDRV_CTL_ELEM_TYPE_ENUMERATED:
private_size = sizeof(unsigned int);
13. case SNDRV_CTL_ELEM_TYPE_IEC958:
14. if (info->count != 1)
15. default:
16. private_size *= info->count;
17. if (ue == NULL)
return -ENOMEM;
ue->card = card;
ue->info = *info;
ue->info.access = 0;
18. err = snd_ctl_elem_init_enum_names(ue);
19. kctl.private_free = snd_ctl_elem_user_free;
20. return -ENOMEM;
21. _kctl->private_data = ue;
for (idx = 0; idx < _kctl->count; idx++)
22. err = snd_ctl_add(card, _kctl);","1
4-6
11
15-17
20
23
30
37
39
49
54
56-57
66
68
71
74
76-80
84
90
95
97-98
100","CWE-119,CWE-362,CWE-125,CWE-189"
do_remount_1,"static int do_remount_1(struct path *path, int flags, int mnt_flags,
		      void *data)
{
	int err;
	struct super_block *sb = path->mnt->mnt_sb;
	struct mount *mnt = real_mount(path->mnt);

	if (!check_mnt(mnt))
		return -EINVAL;

	if (path->dentry != path->mnt->mnt_root)
		return -EINVAL;

	
	if ((mnt->mnt.mnt_flags & MNT_LOCK_READONLY) &&
 	    !(mnt_flags & MNT_READONLY)) {
 		return -EPERM;
 	}
	if ((mnt->mnt.mnt_flags & MNT_LOCK_NODEV) &&
	    !(mnt_flags & MNT_NODEV)) {
		return -EPERM;
	}
	if ((mnt->mnt.mnt_flags & MNT_LOCK_NOSUID) &&
	    !(mnt_flags & MNT_NOSUID)) {
		return -EPERM;
	}
	if ((mnt->mnt.mnt_flags & MNT_LOCK_NOEXEC) &&
	    !(mnt_flags & MNT_NOEXEC)) {
		return -EPERM;
	}
	if ((mnt->mnt.mnt_flags & MNT_LOCK_ATIME) &&
	    ((mnt->mnt.mnt_flags & MNT_ATIME_MASK) != (mnt_flags & MNT_ATIME_MASK))) {
		return -EPERM;
	}

 	err = security_sb_remount(sb, data);
 	if (err)
 		return err;

	down_write(&sb->s_umount);
	if (flags & MS_BIND)
		err = change_mount_flags(path->mnt, flags);
	else if (!capable(CAP_SYS_ADMIN))
		err = -EPERM;
	else
		err = do_remount_sb(sb, flags, data, 0);
	if (!err) {
		lock_mount_hash();
		mnt_flags |= mnt->mnt.mnt_flags & ~MNT_USER_SETTABLE_MASK;
		mnt->mnt.mnt_flags = mnt_flags;
		touch_mnt_namespace(mnt->mnt_ns);
		unlock_mount_hash();
	}
	up_write(&sb->s_umount);
	return err;
}
","1. static int do_remount_1(struct path *path, int flags, int mnt_flags,
void *data)
2. return -EINVAL;
3. return -EINVAL;
4. !(mnt_flags & MNT_READONLY)) {
return -EPERM;
5. if ((mnt->mnt.mnt_flags & MNT_LOCK_NODEV) &&
6. if ((mnt->mnt.mnt_flags & MNT_LOCK_NOEXEC) &&
7. if ((mnt->mnt.mnt_flags & MNT_LOCK_ATIME) &&
8. err = security_sb_remount(sb, data);
if (err)
return err;
9. down_write(&sb->s_umount);
10. err = change_mount_flags(path->mnt, flags);
else if (!capable(CAP_SYS_ADMIN))
err = -EPERM;
11. if (!err) {
12. unlock_mount_hash();
13. return err;","1-2
9
12
21-22
24
32
36
41-43
45
47-49
52
57
60","CWE-22,CWE-269,CWE-835,CWE-787,CWE-119"
snd_usb_mixer_disconnect," void snd_usb_mixer_disconnect(struct usb_mixer_interface *mixer)
 {
	if (mixer->disconnected)
		return;
	if (mixer->urb)
		usb_kill_urb(mixer->urb);
	if (mixer->rc_urb)
		usb_kill_urb(mixer->rc_urb);
	mixer->disconnected = true;
 }
","1. void snd_usb_mixer_disconnect(struct usb_mixer_interface *mixer)
2. if (mixer->disconnected)
return;
if (mixer->urb)
usb_kill_urb(mixer->urb);
if (mixer->rc_urb)
usb_kill_urb(mixer->rc_urb);
mixer->disconnected = true;","1
3-9","CWE-119,CWE-20,CWE-404,CWE-416"
usbip_recv_xbuff-104129419429599,"int usbip_recv_xbuff(struct usbip_device *ud, struct urb *urb)
{
	int ret;
	int size;

	if (ud->side == USBIP_STUB) {
		
		if (usb_pipein(urb->pipe))
			return 0;

		size = urb->transfer_buffer_length;
	} else {
		
		if (usb_pipeout(urb->pipe))
			return 0;

		size = urb->actual_length;
	}

	
	if (!(size > 0))
		return 0;

	if (size > urb->transfer_buffer_length) {
		
		if (ud->side == USBIP_STUB) {
			usbip_event_add(ud, SDEV_EVENT_ERROR_TCP);
			return 0;
		} else {
			usbip_event_add(ud, VDEV_EVENT_ERROR_TCP);
			return -EPIPE;
		}
	}

	ret = usbip_recv(ud->tcp_socket, urb->transfer_buffer, size);
	if (ret != size) {
		dev_err(&urb->dev->dev, ""recv xbuf, %d\n"", ret);
		if (ud->side == USBIP_STUB) {
			usbip_event_add(ud, SDEV_EVENT_ERROR_TCP);
		} else {
			usbip_event_add(ud, VDEV_EVENT_ERROR_TCP);
			return -EPIPE;
		}
	}

	return ret;
}
","1. int usbip_recv_xbuff(struct usbip_device *ud, struct urb *urb)
2. int size;
3. return 0;
4. size = urb->transfer_buffer_length;
} else {
5. size = urb->actual_length;
6. return 0;
7. if (ud->side == USBIP_STUB) {
usbip_event_add(ud, SDEV_EVENT_ERROR_TCP);
8. } else {
usbip_event_add(ud, VDEV_EVENT_ERROR_TCP);
9. if (ret != size) {
10. if (ud->side == USBIP_STUB) {
usbip_event_add(ud, SDEV_EVENT_ERROR_TCP);
11. return ret;","1
4
9
11-12
17
22
26-27
29-30
36
38-39
46","CWE-189,CWE-119"
decode_nal_unit-156985245613776,"
#define H2645NAL
#define HEVCContext

static int decode_nal_unit(HEVCContext *s, const H2645NAL *nal)
{
    HEVCLocalContext *lc = s->HEVClc;
    GetBitContext *gb    = &lc->gb;
    int ctb_addr_ts, ret;

    *gb              = nal->gb;
    s->nal_unit_type = nal->type;
    s->temporal_id   = nal->temporal_id;

    switch (s->nal_unit_type) {
    case HEVC_NAL_VPS:
        if (s->avctx->hwaccel && s->avctx->hwaccel->decode_params) {
            ret = s->avctx->hwaccel->decode_params(s->avctx,
                                                   nal->type,
                                                   nal->raw_data,
                                                   nal->raw_size);
            if (ret < 0)
                goto fail;
        }
        ret = ff_hevc_decode_nal_vps(gb, s->avctx, &s->ps);
        if (ret < 0)
            goto fail;
        break;
    case HEVC_NAL_SPS:
        if (s->avctx->hwaccel && s->avctx->hwaccel->decode_params) {
            ret = s->avctx->hwaccel->decode_params(s->avctx,
                                                   nal->type,
                                                   nal->raw_data,
                                                   nal->raw_size);
            if (ret < 0)
                goto fail;
        }
        ret = ff_hevc_decode_nal_sps(gb, s->avctx, &s->ps,
                                     s->apply_defdispwin);
        if (ret < 0)
            goto fail;
        break;
    case HEVC_NAL_PPS:
        if (s->avctx->hwaccel && s->avctx->hwaccel->decode_params) {
            ret = s->avctx->hwaccel->decode_params(s->avctx,
                                                   nal->type,
                                                   nal->raw_data,
                                                   nal->raw_size);
            if (ret < 0)
                goto fail;
        }
        ret = ff_hevc_decode_nal_pps(gb, s->avctx, &s->ps);
        if (ret < 0)
            goto fail;
        break;
    case HEVC_NAL_SEI_PREFIX:
    case HEVC_NAL_SEI_SUFFIX:
        if (s->avctx->hwaccel && s->avctx->hwaccel->decode_params) {
            ret = s->avctx->hwaccel->decode_params(s->avctx,
                                                   nal->type,
                                                   nal->raw_data,
                                                   nal->raw_size);
            if (ret < 0)
                goto fail;
        }
        ret = ff_hevc_decode_nal_sei(gb, s->avctx, &s->sei, &s->ps, s->nal_unit_type);
        if (ret < 0)
            goto fail;
        break;
    case HEVC_NAL_TRAIL_R:
    case HEVC_NAL_TRAIL_N:
    case HEVC_NAL_TSA_N:
    case HEVC_NAL_TSA_R:
    case HEVC_NAL_STSA_N:
    case HEVC_NAL_STSA_R:
    case HEVC_NAL_BLA_W_LP:
    case HEVC_NAL_BLA_W_RADL:
    case HEVC_NAL_BLA_N_LP:
    case HEVC_NAL_IDR_W_RADL:
    case HEVC_NAL_IDR_N_LP:
    case HEVC_NAL_CRA_NUT:
    case HEVC_NAL_RADL_N:
    case HEVC_NAL_RADL_R:
    case HEVC_NAL_RASL_N:
    case HEVC_NAL_RASL_R:
        ret = hls_slice_header(s);
        if (ret < 0)
            return ret;
        if (ret == 1) {
            ret = AVERROR_INVALIDDATA;
            goto fail;
        }


        if (
            (s->avctx->skip_frame >= AVDISCARD_BIDIR && s->sh.slice_type == HEVC_SLICE_B) ||
            (s->avctx->skip_frame >= AVDISCARD_NONINTRA && s->sh.slice_type != HEVC_SLICE_I) ||
            (s->avctx->skip_frame >= AVDISCARD_NONKEY && !IS_IRAP(s))) {
            break;
        }

        if (s->sh.first_slice_in_pic_flag) {
            if (s->max_ra == INT_MAX) {
                if (s->nal_unit_type == HEVC_NAL_CRA_NUT || IS_BLA(s)) {
                    s->max_ra = s->poc;
                } else {
                    if (IS_IDR(s))
                        s->max_ra = INT_MIN;
                }
            }

            if ((s->nal_unit_type == HEVC_NAL_RASL_R || s->nal_unit_type == HEVC_NAL_RASL_N) &&
                s->poc <= s->max_ra) {
                s->is_decoded = 0;
                break;
            } else {
                if (s->nal_unit_type == HEVC_NAL_RASL_R && s->poc > s->max_ra)
                    s->max_ra = INT_MIN;
            }

            s->overlap ++;
            ret = hevc_frame_start(s);
            if (ret < 0)
                return ret;
        } else if (!s->ref) {
            av_log(s->avctx, AV_LOG_ERROR, ""First slice in a frame missing.\n"");
            goto fail;
        }

        if (s->nal_unit_type != s->first_nal_type) {
            av_log(s->avctx, AV_LOG_ERROR,
                   ""Non-matching NAL types of the VCL NALUs: %d %d\n"",
                   s->first_nal_type, s->nal_unit_type);
            return AVERROR_INVALIDDATA;
        }

        if (!s->sh.dependent_slice_segment_flag &&
            s->sh.slice_type != HEVC_SLICE_I) {
            ret = ff_hevc_slice_rpl(s);
            if (ret < 0) {
                av_log(s->avctx, AV_LOG_WARNING,
                       ""Error constructing the reference lists for the current slice.\n"");
                goto fail;
            }
        }

        if (s->sh.first_slice_in_pic_flag && s->avctx->hwaccel) {
            ret = s->avctx->hwaccel->start_frame(s->avctx, NULL, 0);
            if (ret < 0)
                goto fail;
        }

        if (s->avctx->hwaccel) {
            ret = s->avctx->hwaccel->decode_slice(s->avctx, nal->raw_data, nal->raw_size);
            if (ret < 0)
                goto fail;
        } else {
            if (s->threads_number > 1 && s->sh.num_entry_point_offsets > 0)
                ctb_addr_ts = hls_slice_data_wpp(s, nal);
            else
                ctb_addr_ts = hls_slice_data(s);
            if (ctb_addr_ts >= (s->ps.sps->ctb_width * s->ps.sps->ctb_height)) {
                s->is_decoded = 1;
            }

            if (ctb_addr_ts < 0) {
                ret = ctb_addr_ts;
                goto fail;
            }
        }
        break;
    case HEVC_NAL_EOS_NUT:
    case HEVC_NAL_EOB_NUT:
        s->seq_decode = (s->seq_decode + 1) & 0xff;
        s->max_ra     = INT_MAX;
        break;
    case HEVC_NAL_AUD:
    case HEVC_NAL_FD_NUT:
        break;
    default:
        av_log(s->avctx, AV_LOG_INFO,
               ""Skipping NAL unit %d\n"", s->nal_unit_type);
    }

    return 0;
fail:
    if (s->avctx->err_recognition & AV_EF_EXPLODE)
        return ret;
    return 0;
}
","1. nal->raw_size);
if (ret < 0)
2. ret = ff_hevc_decode_nal_vps(gb, s->avctx, &s->ps);
3. ret = ff_hevc_decode_nal_pps(gb, s->avctx, &s->ps);
4. ret = s->avctx->hwaccel->decode_params(s->avctx,
5. goto fail;
6. ret = hevc_frame_start(s);
7. av_log(s->avctx, AV_LOG_ERROR, ""First slice in a frame missing.\n"");
8. s->first_nal_type, s->nal_unit_type);
9. goto fail;
10. ret = s->avctx->hwaccel->decode_slice(s->avctx, nal->raw_data, nal->raw_size);
11. goto fail;","21-22
25
52
59
91
122
126
133
143
154
168","CWE-310,CWE-22,CWE-476,CWE-17,CWE-399"
ReadPANGOImage,"
#define ExceptionInfo
#define ImageInfo

static Image *ReadPANGOImage(const ImageInfo *image_info,
  ExceptionInfo *exception)
{
  cairo_font_options_t
    *font_options;

  cairo_surface_t
    *surface;

  char
    *caption,
    *property;

  cairo_t
    *cairo_image;

  const char
    *option;

  DrawInfo
    *draw_info;

  Image
    *image;

  MagickBooleanType
    status;

  MemoryInfo
    *pixel_info;

  PangoAlignment
    align;

  PangoContext
    *context;

  PangoFontMap
    *fontmap;

  PangoGravity
    gravity;

  PangoLayout
    *layout;

  PangoRectangle
    extent;

  PixelPacket
    fill_color;

  RectangleInfo
    page;

  register unsigned char
    *p;

  size_t
    stride;

  ssize_t
    y;

  unsigned char
    *pixels;

  
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickSignature);
  image=AcquireImage(image_info);
  (void) ResetImagePage(image,""0x0+0+0"");
  
  option=GetImageOption(image_info,""filename"");
  if (option == (const char *) NULL)
    property=InterpretImageProperties(image_info,image,image_info->filename);
  else
    if (LocaleNCompare(option,""pango:"",6) == 0)
      property=InterpretImageProperties(image_info,image,option+6);
    else
      property=InterpretImageProperties(image_info,image,option);
  (void) SetImageProperty(image,""caption"",property);
  property=DestroyString(property);
  caption=ConstantString(GetImageProperty(image,""caption""));
  
  fontmap=pango_cairo_font_map_new();
  pango_cairo_font_map_set_resolution(PANGO_CAIRO_FONT_MAP(fontmap),
    image->x_resolution == 0.0 ? 90.0 : image->x_resolution);
  font_options=cairo_font_options_create();
  option=GetImageOption(image_info,""pango:hinting"");
  if (option != (const char *) NULL)
    {
      if (LocaleCompare(option,""none"") != 0)
        cairo_font_options_set_hint_style(font_options,CAIRO_HINT_STYLE_NONE);
      if (LocaleCompare(option,""full"") != 0)
        cairo_font_options_set_hint_style(font_options,CAIRO_HINT_STYLE_FULL);
    }
  context=pango_font_map_create_context(fontmap);
  pango_cairo_context_set_font_options(context,font_options);
  cairo_font_options_destroy(font_options);
  option=GetImageOption(image_info,""pango:language"");
  if (option != (const char *) NULL)
    pango_context_set_language(context,pango_language_from_string(option));
  draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL);
  pango_context_set_base_dir(context,draw_info->direction ==
    RightToLeftDirection ? PANGO_DIRECTION_RTL : PANGO_DIRECTION_LTR);
  switch (draw_info->gravity)
  {
    case NorthGravity:
    {
      gravity=PANGO_GRAVITY_NORTH;
      break;
    }
    case NorthWestGravity:
    case WestGravity:
    case SouthWestGravity:
    {
      gravity=PANGO_GRAVITY_WEST;
      break;
    }
    case NorthEastGravity:
    case EastGravity:
    case SouthEastGravity:
    {
      gravity=PANGO_GRAVITY_EAST;
      break;
    }
    case SouthGravity:
    {
      gravity=PANGO_GRAVITY_SOUTH;
      break;
    }
    default:
    {
      gravity=PANGO_GRAVITY_AUTO;
      break;
    }
  }
  pango_context_set_base_gravity(context,gravity);
  option=GetImageOption(image_info,""pango:gravity-hint"");
  if (option != (const char *) NULL)
    {
      if (LocaleCompare(option,""line"") == 0)
        pango_context_set_gravity_hint(context,PANGO_GRAVITY_HINT_LINE);
      if (LocaleCompare(option,""natural"") == 0)
        pango_context_set_gravity_hint(context,PANGO_GRAVITY_HINT_NATURAL);
      if (LocaleCompare(option,""strong"") == 0)
        pango_context_set_gravity_hint(context,PANGO_GRAVITY_HINT_STRONG);
    }
  
  layout=pango_layout_new(context);
  option=GetImageOption(image_info,""pango:auto-dir"");
  if (option != (const char *) NULL)
    pango_layout_set_auto_dir(layout,1);
  option=GetImageOption(image_info,""pango:ellipsize"");
  if (option != (const char *) NULL)
    {
      if (LocaleCompare(option,""end"") == 0)
        pango_layout_set_ellipsize(layout,PANGO_ELLIPSIZE_END);
      if (LocaleCompare(option,""middle"") == 0)
        pango_layout_set_ellipsize(layout,PANGO_ELLIPSIZE_MIDDLE);
      if (LocaleCompare(option,""none"") == 0)
        pango_layout_set_ellipsize(layout,PANGO_ELLIPSIZE_NONE);
      if (LocaleCompare(option,""start"") == 0)
        pango_layout_set_ellipsize(layout,PANGO_ELLIPSIZE_START);
    }
  option=GetImageOption(image_info,""pango:justify"");
  if ((option != (const char *) NULL) && (IsMagickTrue(option) != MagickFalse))
    pango_layout_set_justify(layout,1);
  option=GetImageOption(image_info,""pango:single-paragraph"");
  if ((option != (const char *) NULL) && (IsMagickTrue(option) != MagickFalse))
    pango_layout_set_single_paragraph_mode(layout,1);
  option=GetImageOption(image_info,""pango:wrap"");
  if (option != (const char *) NULL)
    {
      if (LocaleCompare(option,""char"") == 0)
        pango_layout_set_wrap(layout,PANGO_WRAP_CHAR);
      if (LocaleCompare(option,""word"") == 0)
        pango_layout_set_wrap(layout,PANGO_WRAP_WORD);
      if (LocaleCompare(option,""word-char"") == 0)
        pango_layout_set_wrap(layout,PANGO_WRAP_WORD_CHAR);
    }
  option=GetImageOption(image_info,""pango:indent"");
  if (option != (const char *) NULL)
    pango_layout_set_indent(layout,(int) ((StringToLong(option)*
      (image->x_resolution == 0.0 ? 90.0 : image->x_resolution)*PANGO_SCALE+45)/
      90.0+0.5));
  switch (draw_info->align)
  {
    case CenterAlign: align=PANGO_ALIGN_CENTER; break;
    case RightAlign: align=PANGO_ALIGN_RIGHT; break;
    case LeftAlign: align=PANGO_ALIGN_LEFT; break;
    default:
    {
      if (draw_info->gravity == CenterGravity)
        {
          align=PANGO_ALIGN_CENTER;
          break;
        }
      align=PANGO_ALIGN_LEFT;
      break;
    }
  }
  if ((align != PANGO_ALIGN_CENTER) &&
      (draw_info->direction == RightToLeftDirection))
    align=(PangoAlignment) (PANGO_ALIGN_LEFT+PANGO_ALIGN_RIGHT-align);
  pango_layout_set_alignment(layout,align);
  if (draw_info->font != (char *) NULL)
    {
      PangoFontDescription
        *description;

      
      description=pango_font_description_from_string(draw_info->font);
      pango_font_description_set_size(description,(int) (PANGO_SCALE*
        draw_info->pointsize+0.5));
      pango_layout_set_font_description(layout,description);
      pango_font_description_free(description);
    }
  option=GetImageOption(image_info,""pango:markup"");
  if ((option != (const char *) NULL) && (IsMagickTrue(option) == MagickFalse))
    pango_layout_set_text(layout,caption,-1);
  else
    {
      GError
        *error;

      error=(GError *) NULL;
      if (pango_parse_markup(caption,-1,0,NULL,NULL,NULL,&error) == 0)
        (void) ThrowMagickException(exception,GetMagickModule(),CoderError,
          error->message,""`%s'"",image_info->filename);
      pango_layout_set_markup(layout,caption,-1);
    }
  pango_layout_context_changed(layout);
  page.x=0;
  page.y=0;
  if (image_info->page != (char *) NULL)
    (void) ParseAbsoluteGeometry(image_info->page,&page);
  if (image->columns == 0)
    {
      pango_layout_get_extents(layout,NULL,&extent);
      image->columns=(extent.x+extent.width+PANGO_SCALE/2)/PANGO_SCALE+2*page.x;
    }
  else
    {
      image->columns-=2*page.x;
      pango_layout_set_width(layout,(int) ((PANGO_SCALE*image->columns*
        (image->x_resolution == 0.0 ? 90.0 : image->x_resolution)+45.0)/90.0+
        0.5));
    }
  if (image->rows == 0)
    {
      pango_layout_get_extents(layout,NULL,&extent);
      image->rows=(extent.y+extent.height+PANGO_SCALE/2)/PANGO_SCALE+2*page.y;
    }
  else
    {
      image->rows-=2*page.y;
      pango_layout_set_height(layout,(int) ((PANGO_SCALE*image->rows*
         (image->y_resolution == 0.0 ? 90.0 : image->y_resolution)+45.0)/90.0+
         0.5));
     }
  status=SetImageExtent(image,image->columns,image->rows);
  if (status == MagickFalse)
    {
      InheritException(exception,&image->exception);
      return(DestroyImageList(image));
    }
   
  stride=(size_t) cairo_format_stride_for_width(CAIRO_FORMAT_ARGB32,(int)
    image->columns);
   pixel_info=AcquireVirtualMemory(image->rows,stride*sizeof(*pixels));
   if (pixel_info == (MemoryInfo *) NULL)
     {
      draw_info=DestroyDrawInfo(draw_info);
      caption=DestroyString(caption);
      ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
    }
  pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);
  surface=cairo_image_surface_create_for_data(pixels,CAIRO_FORMAT_ARGB32,
    (int) image->columns,(int) image->rows,(int) stride);
  cairo_image=cairo_create(surface);
  cairo_set_operator(cairo_image,CAIRO_OPERATOR_CLEAR);
  cairo_paint(cairo_image);
  cairo_set_operator(cairo_image,CAIRO_OPERATOR_OVER);
  cairo_translate(cairo_image,page.x,page.y);
  pango_cairo_show_layout(cairo_image,layout);
  cairo_destroy(cairo_image);
  cairo_surface_destroy(surface);
  g_object_unref(layout);
  g_object_unref(fontmap);
  
  (void) SetImageBackgroundColor(image);
  p=pixels;
  for (y=0; y < (ssize_t) image->rows; y++)
  {
    register PixelPacket
      *q;

    register ssize_t
      x;

    q=GetAuthenticPixels(image,0,y,image->columns,1,exception);
    if (q == (PixelPacket *) NULL)
      break;
    for (x=0; x < (ssize_t) image->columns; x++)
    {
      double
        gamma;

      fill_color.blue=ScaleCharToQuantum(*p++);
      fill_color.green=ScaleCharToQuantum(*p++);
      fill_color.red=ScaleCharToQuantum(*p++);
      fill_color.opacity=QuantumRange-ScaleCharToQuantum(*p++);
      
      gamma=1.0-QuantumScale*fill_color.opacity;
      gamma=PerceptibleReciprocal(gamma);
      fill_color.blue*=gamma;
      fill_color.green*=gamma;
      fill_color.red*=gamma;
      MagickCompositeOver(&fill_color,fill_color.opacity,q,(MagickRealType)
        q->opacity,q);
      q++;
    }
    if (SyncAuthenticPixels(image,exception) == MagickFalse)
      break;
    if (image->previous == (Image *) NULL)
      {
        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,
        image->rows);
        if (status == MagickFalse)
          break;
      }
  }
  
  pixel_info=RelinquishVirtualMemory(pixel_info);
  draw_info=DestroyDrawInfo(draw_info);
  caption=DestroyString(caption);
  return(GetFirstImageInList(image));
}
","1. ExceptionInfo *exception)
2. *caption,
3. *image;
4. align;
5. caption=ConstantString(GetImageProperty(image,""caption""));
6. fontmap=pango_cairo_font_map_new();
pango_cairo_font_map_set_resolution(PANGO_CAIRO_FONT_MAP(fontmap),
7. if (LocaleCompare(option,""full"") != 0)
8. cairo_font_options_destroy(font_options);
9. case EastGravity:
10. default:
11. pango_context_set_base_gravity(context,gravity);
12. if (LocaleCompare(option,""line"") == 0)
13. pango_context_set_gravity_hint(context,PANGO_GRAVITY_HINT_NATURAL);
if (LocaleCompare(option,""strong"") == 0)
14. pango_layout_set_ellipsize(layout,PANGO_ELLIPSIZE_END);
15. pango_layout_set_ellipsize(layout,PANGO_ELLIPSIZE_MIDDLE);
16. option=GetImageOption(image_info,""pango:justify"");
17. option=GetImageOption(image_info,""pango:indent"");
18. (image->x_resolution == 0.0 ? 90.0 : image->x_resolution)*PANGO_SCALE+45)/
19. if (draw_info->gravity == CenterGravity)
20. align=(PangoAlignment) (PANGO_ALIGN_LEFT+PANGO_ALIGN_RIGHT-align);
21. if ((option != (const char *) NULL) && (IsMagickTrue(option) == MagickFalse))
22. page.x=0;
23. caption=DestroyString(caption);
24. if (q == (PixelPacket *) NULL)
25. fill_color.blue=ScaleCharToQuantum(*p++);
26. fill_color.blue*=gamma;
27. if (SyncAuthenticPixels(image,exception) == MagickFalse)
28. caption=DestroyString(caption);","6
15
28
37
97
101-102
110
115
137
148
154
158
161-162
176
178
184
200
203
212
223
240
254
297
327
334
343
350
365","CWE-125,CWE-119"
cState_space_set-94224326865319,"
#define VALUE

static VALUE cState_space_set(VALUE self, VALUE space)
{
    unsigned long len;
    GET_STATE(self);
    Check_Type(space, T_STRING);
    len = RSTRING_LEN(space);
    if (len == 0) {
        if (state->space) {
            ruby_xfree(state->space);
            state->space = NULL;
            state->space_len = 0;
        }
    } else {
        if (state->space) ruby_xfree(state->space);
        state->space = fstrndup(RSTRING_PTR(space), len);
        state->space_len = len;
    }
    return Qnil;
}
","1. Check_Type(space, T_STRING);
len = RSTRING_LEN(space);
2. ruby_xfree(state->space);
state->space = NULL;
3. state->space_len = len;
4. return Qnil;","8-9
12-13
19
21","CWE-20,CWE-119"
hashbin_delete-164628710929043,"
#define FREE_FUNC

int hashbin_delete( hashbin_t* hashbin, FREE_FUNC free_func)
{
	irda_queue_t* queue;
	unsigned long flags = 0;
	int i;

	IRDA_ASSERT(hashbin != NULL, return -1;);
	IRDA_ASSERT(hashbin->magic == HB_MAGIC, return -1;);

	
	if (hashbin->hb_type & HB_LOCK)
		spin_lock_irqsave(&hashbin->hb_spinlock, flags);

	
	for (i = 0; i < HASHBIN_SIZE; i ++ ) {
		while (1) {
			queue = dequeue_first((irda_queue_t**) &hashbin->hb_queue[i]);

			if (!queue)
				break;

			if (free_func) {
				if (hashbin->hb_type & HB_LOCK)
					spin_unlock_irqrestore(&hashbin->hb_spinlock, flags);
				free_func(queue);
				if (hashbin->hb_type & HB_LOCK)
					spin_lock_irqsave(&hashbin->hb_spinlock, flags);
			}
		}
	}

	
	hashbin->hb_current = NULL;
	hashbin->magic = ~HB_MAGIC;

	
	if (hashbin->hb_type & HB_LOCK)
		spin_unlock_irqrestore(&hashbin->hb_spinlock, flags);

	
	kfree(hashbin);

	return 0;
}
","1. irda_queue_t* queue;
unsigned long flags = 0;
2. for (i = 0; i < HASHBIN_SIZE; i ++ ) {
3. if (free_func) {
4. free_func(queue);
5. hashbin->magic = ~HB_MAGIC;
6. if (hashbin->hb_type & HB_LOCK)
spin_unlock_irqrestore(&hashbin->hb_spinlock, flags);","6-7
21
28
31
40
43-44","CWE-119,CWE-310,CWE-125,CWE-190"
nfs_callback_create_svc,"static struct svc_serv *nfs_callback_create_svc(int minorversion)
{
	struct nfs_callback_data *cb_info = &nfs_callback_info[minorversion];
	struct svc_serv *serv;
	struct svc_serv_ops *sv_ops;

	
	if (cb_info->serv) {
		
		svc_get(cb_info->serv);
		return cb_info->serv;
	}

	switch (minorversion) {
	case 0:
		sv_ops = nfs4_cb_sv_ops[0];
		break;
	default:
		sv_ops = nfs4_cb_sv_ops[1];
	}

	if (sv_ops == NULL)
		return ERR_PTR(-ENOTSUPP);

	
	if (cb_info->users)
 		printk(KERN_WARNING ""nfs_callback_create_svc: no kthread, %d users??\n"",
 			cb_info->users);
 
	serv = svc_create_pooled(&nfs4_callback_program, NFS4_CALLBACK_BUFSIZE, sv_ops);
 	if (!serv) {
 		printk(KERN_ERR ""nfs_callback_create_svc: create service failed\n"");
 		return ERR_PTR(-ENOMEM);
	}
	cb_info->serv = serv;
	
	serv->sv_maxconn = 1024;
	dprintk(""nfs_callback_create_svc: service created\n"");
	return serv;
}
","1. static struct svc_serv *nfs_callback_create_svc(int minorversion)
2. struct nfs_callback_data *cb_info = &nfs_callback_info[minorversion];
3. svc_get(cb_info->serv);
4. if (!serv) {
5. dprintk(""nfs_callback_create_svc: service created\n"");","1
3
15
39
48","CWE-787,CWE-120,CWE-59,CWE-416"
hwahc_security_create-39054146676401,"static int hwahc_security_create(struct hwahc *hwahc)
{
	int result;
	struct wusbhc *wusbhc = &hwahc->wusbhc;
	struct usb_device *usb_dev = hwahc->wa.usb_dev;
	struct device *dev = &usb_dev->dev;
	struct usb_security_descriptor *secd;
	struct usb_encryption_descriptor *etd;
	void *itr, *top;
	size_t itr_size, needed, bytes;
	u8 index;
	char buf[64];

	
	index = (usb_dev->actconfig - usb_dev->config) /
		sizeof(usb_dev->config[0]);
	itr = usb_dev->rawdescriptors[index];
	itr_size = le16_to_cpu(usb_dev->actconfig->desc.wTotalLength);
	top = itr + itr_size;
	result = __usb_get_extra_descriptor(usb_dev->rawdescriptors[index],
			le16_to_cpu(usb_dev->actconfig->desc.wTotalLength),
			USB_DT_SECURITY, (void **) &secd, sizeof(*secd));
	if (result == -1) {
		dev_warn(dev, ""BUG? WUSB host has no security descriptors\n"");
		return 0;
	}
	needed = sizeof(*secd);
	if (top - (void *)secd < needed) {
		dev_err(dev, ""BUG? Not enough data to process security ""
			""descriptor header (%zu bytes left vs %zu needed)\n"",
			top - (void *) secd, needed);
		return 0;
	}
	needed = le16_to_cpu(secd->wTotalLength);
	if (top - (void *)secd < needed) {
		dev_err(dev, ""BUG? Not enough data to process security ""
			""descriptors (%zu bytes left vs %zu needed)\n"",
			top - (void *) secd, needed);
		return 0;
	}
	
	itr = (void *) secd + sizeof(*secd);
	top = (void *) secd + le16_to_cpu(secd->wTotalLength);
	index = 0;
	bytes = 0;
	while (itr < top) {
		etd = itr;
		if (top - itr < sizeof(*etd)) {
			dev_err(dev, ""BUG: bad host security descriptor; ""
				""not enough data (%zu vs %zu left)\n"",
				top - itr, sizeof(*etd));
			break;
		}
		if (etd->bLength < sizeof(*etd)) {
			dev_err(dev, ""BUG: bad host encryption descriptor; ""
				""descriptor is too short ""
				""(%zu vs %zu needed)\n"",
				(size_t)etd->bLength, sizeof(*etd));
			break;
		}
		itr += etd->bLength;
		bytes += snprintf(buf + bytes, sizeof(buf) - bytes,
				  ""%s (0x%02x) "",
				  wusb_et_name(etd->bEncryptionType),
				  etd->bEncryptionValue);
		wusbhc->ccm1_etd = etd;
	}
	dev_info(dev, ""supported encryption types: %s\n"", buf);
	if (wusbhc->ccm1_etd == NULL) {
		dev_err(dev, ""E: host doesn't support CCM-1 crypto\n"");
		return 0;
	}
	
	return 0;
}
","1. struct usb_security_descriptor *secd;
2. size_t itr_size, needed, bytes;
3. itr_size = le16_to_cpu(usb_dev->actconfig->desc.wTotalLength);
4. result = __usb_get_extra_descriptor(usb_dev->rawdescriptors[index],
5. USB_DT_SECURITY, (void **) &secd, sizeof(*secd));
6. if (top - (void *)secd < needed) {
7. bytes = 0;
8. etd->bEncryptionValue);
9. dev_err(dev, ""E: host doesn't support CCM-1 crypto\n"");","7
10
18
20
22
28
45
65
70","CWE-200,CWE-264,CWE-404,CWE-119"
put_crypt_info,"static void put_crypt_info(struct fscrypt_info *ci)
{
 	if (!ci)
 		return;
 
 	crypto_free_skcipher(ci->ci_ctfm);
 	kmem_cache_free(fscrypt_info_cachep, ci);
 }
","1. return;
2. crypto_free_skcipher(ci->ci_ctfm);
kmem_cache_free(fscrypt_info_cachep, ci);","4
6-7","CWE-476,CWE-125,CWE-119,CWE-416"
_handle_carbons-103360684947800,"static gboolean
_handle_carbons(xmpp_stanza_t *const stanza)
{
    xmpp_stanza_t *carbons = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_CARBONS);
    if (!carbons) {
        return FALSE;
    }

    const char *name = xmpp_stanza_get_name(carbons);
    if (!name) {
        log_error(""Unable to retrieve stanza name for Carbon"");
        return TRUE;
    }

    if (g_strcmp0(name, ""private"") == 0) {
        log_info(""Carbon received with private element."");
        return FALSE;
    }

    if ((g_strcmp0(name, ""received"") != 0) && (g_strcmp0(name, ""sent"") != 0)) {
        log_warning(""Carbon received with unrecognised stanza name: %s"", name);
        return TRUE;
    }

    xmpp_stanza_t *forwarded = xmpp_stanza_get_child_by_ns(carbons, STANZA_NS_FORWARD);
    if (!forwarded) {
        log_warning(""Carbon received with no forwarded element"");
        return TRUE;
    }

    xmpp_stanza_t *message = xmpp_stanza_get_child_by_name(forwarded, STANZA_NAME_MESSAGE);
    if (!message) {
        log_warning(""Carbon received with no message element"");
        return TRUE;
    }

    char *message_txt = xmpp_message_get_body(message);
    if (!message_txt) {
        log_warning(""Carbon received with no message."");
        return TRUE;
    }

    Jid *my_jid = jid_create(connection_get_fulljid());
    const char *const stanza_from = xmpp_stanza_get_from(stanza);
    Jid *msg_jid = jid_create(stanza_from);
    if (g_strcmp0(my_jid->barejid, msg_jid->barejid) != 0) {
        log_warning(""Invalid carbon received, from: %s"", stanza_from);
        return TRUE;
    }

    const gchar *to = xmpp_stanza_get_to(message);
    const gchar *from = xmpp_stanza_get_from(message);

    
    if (!to) to = from;

    Jid *jid_from = jid_create(from);
    Jid *jid_to = jid_create(to);

    
    char *enc_message = NULL;
    xmpp_stanza_t *x = xmpp_stanza_get_child_by_ns(message, STANZA_NS_ENCRYPTED);
    if (x) {
        enc_message = xmpp_stanza_get_text(x);
    }

    
    if (g_strcmp0(my_jid->barejid, jid_to->barejid) == 0) {
        sv_ev_incoming_carbon(jid_from->barejid, jid_from->resourcepart, message_txt, enc_message);

    
    } else {
        sv_ev_outgoing_carbon(jid_to->barejid, message_txt, enc_message);
    }

    xmpp_ctx_t *ctx = connection_get_ctx();
    xmpp_free(ctx, message_txt);
    xmpp_free(ctx, enc_message);

    jid_destroy(jid_from);
    jid_destroy(jid_to);
    jid_destroy(my_jid);

    return TRUE;
}
","1. xmpp_stanza_t *carbons = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_CARBONS);
2. return FALSE;
3. const char *name = xmpp_stanza_get_name(carbons);
if (!name) {
log_error(""Unable to retrieve stanza name for Carbon"");
return TRUE;
4. if (g_strcmp0(name, ""private"") == 0) {
log_info(""Carbon received with private element."");
5. log_warning(""Carbon received with unrecognised stanza name: %s"", name);
6. xmpp_stanza_t *forwarded = xmpp_stanza_get_child_by_ns(carbons, STANZA_NS_FORWARD);
if (!forwarded) {
7. return TRUE;
8. xmpp_stanza_t *message = xmpp_stanza_get_child_by_name(forwarded, STANZA_NAME_MESSAGE);
9. log_warning(""Carbon received with no message element"");
10. char *message_txt = xmpp_message_get_body(message);
11. return TRUE;
12. if (g_strcmp0(my_jid->barejid, msg_jid->barejid) != 0) {
13. const gchar *from = xmpp_stanza_get_from(message);
14. Jid *jid_to = jid_create(to);
15. xmpp_stanza_t *x = xmpp_stanza_get_child_by_ns(message, STANZA_NS_ENCRYPTED);
if (x) {
16. sv_ev_incoming_carbon(jid_from->barejid, jid_from->resourcepart, message_txt, enc_message);
17. } else {
18. xmpp_ctx_t *ctx = connection_get_ctx();
19. jid_destroy(jid_to);","4
6
9-12
15-16
21
25-26
28
31
33
37
40
46
52
58
62-63
69
72
76
81","CWE-346,CWE-189,CWE-119"
idna_strerror,"
#define Idna_rc

idna_strerror (Idna_rc rc)
{
  const char *p;

  bindtextdomain (PACKAGE, LOCALEDIR);

  switch (rc)
    {
    case IDNA_SUCCESS:
      p = _(""Success"");
      break;

    case IDNA_STRINGPREP_ERROR:
      p = _(""String preparation failed"");
      break;

    case IDNA_PUNYCODE_ERROR:
      p = _(""Punycode failed"");
      break;

    case IDNA_CONTAINS_NON_LDH:
      p = _(""Non-digit/letter/hyphen in input"");
      break;

    case IDNA_CONTAINS_MINUS:
      p = _(""Forbidden leading or trailing minus sign (`-')"");
      break;

    case IDNA_INVALID_LENGTH:
      p = _(""Output would be too large or too small"");
      break;

    case IDNA_NO_ACE_PREFIX:
      p = _(""Input does not start with ACE prefix (`xn--')"");
      break;

    case IDNA_ROUNDTRIP_VERIFY_ERROR:
      p = _(""String not idempotent under ToASCII"");
      break;

    case IDNA_CONTAINS_ACE_PREFIX:
      p = _(""Input already contain ACE prefix (`xn--')"");
       break;
 
     case IDNA_ICONV_ERROR:
      p = _(""Could not convert string in locale encoding"");
       break;
 
     case IDNA_MALLOC_ERROR:
      p = _(""Cannot allocate memory"");
      break;

    case IDNA_DLOPEN_ERROR:
      p = _(""System dlopen failed"");
      break;

    default:
      p = _(""Unknown error"");
      break;
    }

  return p;
}
","1. p = _(""String not idempotent under ToASCII"");
2. break;
3. case IDNA_DLOPEN_ERROR:","41
54
56","CWE-295,CWE-358"
destroy_server_connect,"
#define SERVER_CONNECT_REC

static void destroy_server_connect(SERVER_CONNECT_REC *conn)
{
	IRC_SERVER_CONNECT_REC *ircconn;

        ircconn = IRC_SERVER_CONNECT(conn);
	if (ircconn == NULL)
		return;
 
 	g_free_not_null(ircconn->usermode);
 	g_free_not_null(ircconn->alternate_nick);
	g_free_not_null(ircconn->sasl_username);
	g_free_not_null(ircconn->sasl_password);
 }
","1. static void destroy_server_connect(SERVER_CONNECT_REC *conn)
2. g_free_not_null(ircconn->alternate_nick);","4
13","CWE-264,CWE-326,CWE-119,CWE-125,CWE-404"
xfrm_replay_verify_len,"static inline int xfrm_replay_verify_len(struct xfrm_replay_state_esn *replay_esn,
					 struct nlattr *rp)
{
	struct xfrm_replay_state_esn *up;
	int ulen;

	if (!replay_esn || !rp)
		return 0;

	up = nla_data(rp);
	ulen = xfrm_replay_state_esn_len(up);

 	if (nla_len(rp) < ulen || xfrm_replay_state_esn_len(replay_esn) != ulen)
 		return -EINVAL;
 
	if (up->replay_window > up->bmp_len * sizeof(__u32) * 8)
		return -EINVAL;

 	return 0;
 }
","1. static inline int xfrm_replay_verify_len(struct xfrm_replay_state_esn *replay_esn,
struct nlattr *rp)
2. int ulen;
3. if (!replay_esn || !rp)
4. ulen = xfrm_replay_state_esn_len(up);
5. return -EINVAL;","1-2
5
7
11
17","CWE-200,CWE-284"
ih264d_mark_err_slice_skip_3,"
#define UWORD16
#define UWORD8
#define WORD32

WORD32 ih264d_mark_err_slice_skip_3(dec_struct_t * ps_dec,
                                WORD32 num_mb_skip,
                                UWORD8 u1_is_idr_slice,
                                UWORD16 u2_frame_num,
 pocstruct_t *ps_cur_poc,
                                WORD32 prev_slice_err)
{
    WORD32 i2_cur_mb_addr;
    UWORD32 u1_num_mbs, u1_num_mbsNby2;
    UWORD32 u1_mb_idx = ps_dec->u1_mb_idx;
    UWORD32 i2_mb_skip_run;

    UWORD32 u1_num_mbs_next, u1_end_of_row;
 const UWORD32 i2_pic_wdin_mbs = ps_dec->u2_frm_wd_in_mbs;
    UWORD32 u1_slice_end;
    UWORD32 u1_tfr_n_mb;
    UWORD32 u1_decode_nmb;
 dec_bit_stream_t * const ps_bitstrm = ps_dec->ps_bitstrm;
 dec_slice_params_t * ps_slice = ps_dec->ps_cur_slice;
    UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
    UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;
 deblk_mb_t *ps_cur_deblk_mb;
 dec_mb_info_t *ps_cur_mb_info;
 parse_pmbarams_t *ps_parse_mb_data;
    UWORD32 u1_inter_mb_type;
    UWORD32 u1_deblk_mb_type;
    UWORD16 u2_total_mbs_coded;
    UWORD32 u1_mbaff = ps_slice->u1_mbaff_frame_flag;
 parse_part_params_t *ps_part_info;
    WORD32 ret;


 if(ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC)
 {

         ih264d_err_pic_dispbuf_mgr(ps_dec);
         return 0;
     }
    ps_dec->ps_dpb_cmds->u1_long_term_reference_flag = 0;
     if(prev_slice_err == 1)
     {
         
        ps_dec->ps_cur_slice->u2_frame_num = u2_frame_num;


 if(!ps_dec->u1_first_slice_in_stream)
 {
            ih264d_end_of_pic(ps_dec, u1_is_idr_slice,
                ps_dec->ps_cur_slice->u2_frame_num);
            ps_dec->s_cur_pic_poc.u2_frame_num =
                ps_dec->ps_cur_slice->u2_frame_num;
 }

 {
            WORD32 i, j, poc = 0;

            ps_dec->ps_cur_slice->u2_first_mb_in_slice = 0;

            ps_dec->pf_mvpred = ih264d_mvpred_nonmbaff;
            ps_dec->p_form_mb_part_info = ih264d_form_mb_part_info_bp;
            ps_dec->p_motion_compensate = ih264d_motion_compensate_bp;

 if(ps_dec->ps_cur_pic != NULL)
                poc = ps_dec->ps_cur_pic->i4_poc + 2;

            j = 0;
 for(i = 0; i < MAX_NUM_PIC_PARAMS; i++)
 if(ps_dec->ps_pps[i].u1_is_valid == TRUE)
                       j = i;
 {
                ps_dec->ps_cur_slice->u1_bottom_field_flag = 0;
                ps_dec->ps_cur_slice->u1_field_pic_flag = 0;
                ps_dec->ps_cur_slice->u1_slice_type = P_SLICE;
                ps_dec->ps_cur_slice->u1_nal_ref_idc = 1;
                ps_dec->ps_cur_slice->u1_nal_unit_type = 1;
                ret = ih264d_start_of_pic(ps_dec, poc, ps_cur_poc,
                        ps_dec->ps_cur_slice->u2_frame_num,
 &ps_dec->ps_pps[j]);

 if(ret != OK)
 {
 return ret;
 }
 }

            ps_dec->ps_ref_pic_buf_lx[0][0]->u1_pic_buf_id = 0;

            ps_dec->u4_output_present = 0;

 {
                ih264d_get_next_display_field(ps_dec,
                                              ps_dec->ps_out_buffer,
 &(ps_dec->s_disp_op));
 

 if(0 != ps_dec->s_disp_op.u4_error_code)
 {
                    ps_dec->u4_fmt_conv_cur_row = ps_dec->s_disp_frame_info.u4_y_ht;
 }
 else
                    ps_dec->u4_output_present = 1;
 }

 if(ps_dec->u1_separate_parse == 1)
 {
 if(ps_dec->u4_dec_thread_created == 0)
 {
                    ithread_create(ps_dec->pv_dec_thread_handle, NULL,
 (void *)ih264d_decode_picture_thread,
 (void *)ps_dec);

                    ps_dec->u4_dec_thread_created = 1;
 }

 if((ps_dec->u4_num_cores == 3) &&
 ((ps_dec->u4_app_disable_deblk_frm == 0) || ps_dec->i1_recon_in_thread3_flag)
 && (ps_dec->u4_bs_deblk_thread_created == 0))
 {
                    ps_dec->u4_start_recon_deblk = 0;
                    ithread_create(ps_dec->pv_bs_deblk_thread_handle, NULL,
 (void *)ih264d_recon_deblk_thread,
 (void *)ps_dec);
                    ps_dec->u4_bs_deblk_thread_created = 1;
 }
 }
 }
 }
 else
 {

 dec_slice_struct_t *ps_parse_cur_slice;
        ps_parse_cur_slice = ps_dec->ps_dec_slice_buf + ps_dec->u2_cur_slice_num;

 if(ps_dec->u1_slice_header_done
 && ps_parse_cur_slice == ps_dec->ps_parse_cur_slice)
 {
            u1_num_mbs = ps_dec->u4_num_mbs_cur_nmb;

 if(u1_num_mbs)
 {
                ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs - 1;
 }
 else
 {
 if(ps_dec->u1_separate_parse)
 {
                    ps_cur_mb_info = ps_dec->ps_nmb_info - 1;
 }
 else
 {
                    ps_cur_mb_info = ps_dec->ps_nmb_info
 + ps_dec->u4_num_mbs_prev_nmb - 1;
 }
 }

            ps_dec->u2_mby = ps_cur_mb_info->u2_mby;
            ps_dec->u2_mbx = ps_cur_mb_info->u2_mbx;

            ps_dec->u1_mb_ngbr_availablity =
                    ps_cur_mb_info->u1_mb_ngbr_availablity;

            ps_dec->pv_parse_tu_coeff_data = ps_dec->pv_prev_mb_parse_tu_coeff_data;
            ps_dec->u2_cur_mb_addr--;
            ps_dec->i4_submb_ofst -= SUB_BLK_SIZE;

 if(u1_num_mbs)
 {
 if (ps_dec->u1_pr_sl_type == P_SLICE
 || ps_dec->u1_pr_sl_type == B_SLICE)
 {
                    ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx,    u1_num_mbs);
                    ps_dec->ps_part = ps_dec->ps_parse_part_params;
 }

                u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;
                u1_end_of_row = (!u1_num_mbs_next)
 && (!(u1_mbaff && (u1_num_mbs & 0x01)));
                u1_slice_end = 1;
                u1_tfr_n_mb = 1;
                ps_cur_mb_info->u1_end_of_slice = u1_slice_end;

 if(ps_dec->u1_separate_parse)
 {
                    ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,
                            u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);
                    ps_dec->ps_nmb_info += u1_num_mbs;
 }
 else
 {
                    ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,
                            u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);
 }
                ps_dec->u2_total_mbs_coded += u1_num_mbs;
                ps_dec->u1_mb_idx = 0;
                ps_dec->u4_num_mbs_cur_nmb = 0;
 }

 if(ps_dec->u2_total_mbs_coded
 >= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)
 {
                ps_dec->u1_pic_decode_done = 1;
 return 0;
 }

            ps_dec->u2_cur_slice_num++;
             ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;
            ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;
            ps_dec->ps_parse_cur_slice++;

 }
 else
 {
            ps_dec->ps_parse_cur_slice = ps_dec->ps_dec_slice_buf
 + ps_dec->u2_cur_slice_num;
 }
 }

 
 
 
 {
        WORD32 num_entries;
        WORD32 size;
        UWORD8 *pu1_buf;

        num_entries = MAX_FRAMES;
 if((1 >= ps_dec->ps_cur_sps->u1_num_ref_frames) &&
 (0 == ps_dec->i4_display_delay))
 {
            num_entries = 1;
 }
        num_entries = ((2 * num_entries) + 1);
 if(BASE_PROFILE_IDC != ps_dec->ps_cur_sps->u1_profile_idc)
 {
            num_entries *= 2;
 }
        size = num_entries * sizeof(void *);
        size += PAD_MAP_IDX_POC * sizeof(void *);

        pu1_buf = (UWORD8 *)ps_dec->pv_map_ref_idx_to_poc_buf;
        pu1_buf += size * ps_dec->u2_cur_slice_num;
        ps_dec->ps_parse_cur_slice->ppv_map_ref_idx_to_poc = (volatile void **)pu1_buf;
 }

    ps_dec->ps_cur_slice->u2_first_mb_in_slice = ps_dec->u2_total_mbs_coded << u1_mbaff;
    ps_dec->ps_cur_slice->i1_slice_alpha_c0_offset = 0;
    ps_dec->ps_cur_slice->i1_slice_beta_offset = 0;

 if(ps_dec->ps_cur_slice->u1_field_pic_flag)
        ps_dec->u2_prv_frame_num = ps_dec->ps_cur_slice->u2_frame_num;

    ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice = ps_dec->u2_total_mbs_coded << u1_mbaff;
    ps_dec->ps_parse_cur_slice->u2_log2Y_crwd =    ps_dec->ps_cur_slice->u2_log2Y_crwd;


 if(ps_dec->u1_separate_parse)
 {
        ps_dec->ps_parse_cur_slice->pv_tu_coeff_data_start = ps_dec->pv_parse_tu_coeff_data;
 }
 else
 {
        ps_dec->pv_proc_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data;
 }

 
 
 
    u1_inter_mb_type = P_MB;
    u1_deblk_mb_type = D_INTER_MB;

    ps_dec->ps_cur_slice->u1_slice_type = P_SLICE;
    ps_dec->ps_parse_cur_slice->slice_type = P_SLICE;
    ps_dec->pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb;
    ps_dec->ps_part = ps_dec->ps_parse_part_params;

 
 
 
    ps_dec->u1_slice_header_done = 2;
    ps_dec->u1_qp = ps_slice->u1_slice_qp;
    ih264d_update_qp(ps_dec, 0);
    u1_mb_idx = ps_dec->u1_mb_idx;
    ps_parse_mb_data = ps_dec->ps_parse_mb_data;
    u1_num_mbs = u1_mb_idx;

    u1_slice_end = 0;
    u1_tfr_n_mb = 0;
    u1_decode_nmb = 0;
    u1_num_mbsNby2 = 0;
    i2_cur_mb_addr = ps_dec->u2_total_mbs_coded;
    i2_mb_skip_run = num_mb_skip;

 while(!u1_slice_end)
 {
        UWORD8 u1_mb_type;

 if(i2_cur_mb_addr > ps_dec->ps_cur_sps->u2_max_mb_addr)
 break;

        ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs;
        ps_dec->u4_num_mbs_cur_nmb = u1_num_mbs;

        ps_cur_mb_info->u1_Mux = 0;
        ps_dec->u4_num_pmbair = (u1_num_mbs >> u1_mbaff);
        ps_cur_deblk_mb = ps_dec->ps_deblk_mbn + u1_num_mbs;

        ps_cur_mb_info->u1_end_of_slice = 0;

 
        ps_parse_mb_data->u1_num_part = 1;
        ps_parse_mb_data->u1_isI_mb = 0;

 
 
 
 
 if (u1_mbaff)
            ih264d_get_mb_info_cavlc_mbaff(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);
 else
            ih264d_get_mb_info_cavlc_nonmbaff(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run);

 
 if(ps_dec->u4_app_disable_deblk_frm == 0)
 {
            ih264d_set_deblocking_parameters(ps_cur_deblk_mb, ps_slice,
                                             ps_dec->u1_mb_ngbr_availablity,
                                             ps_dec->u1_cur_mb_fld_dec_flag);
 }

 
        ps_dec->i1_prev_mb_qp_delta = 0;
        ps_dec->u1_sub_mb_num = 0;
        ps_cur_mb_info->u1_mb_type = MB_SKIP;
        ps_cur_mb_info->u1_mb_mc_mode = PRED_16x16;
        ps_cur_mb_info->u1_cbp = 0;

 
        ps_part_info = ps_dec->ps_part;
        ps_part_info->u1_is_direct = PART_DIRECT_16x16;
        ps_part_info->u1_sub_mb_num = 0;
        ps_dec->ps_part++;

 
        ih264d_update_nnz_for_skipmb(ps_dec, ps_cur_mb_info, CAVLC);

        ps_cur_mb_info->ps_curmb->u1_mb_type = u1_inter_mb_type;
        ps_cur_deblk_mb->u1_mb_type |= u1_deblk_mb_type;

        i2_mb_skip_run--;

        ps_cur_deblk_mb->u1_mb_qp = ps_dec->u1_qp;

 if (u1_mbaff)
 {
            ih264d_update_mbaff_left_nnz(ps_dec, ps_cur_mb_info);
 }

 
 
 
        i2_cur_mb_addr++;

        u1_num_mbs++;
        u1_num_mbsNby2++;
        ps_parse_mb_data++;

 
 
 
 
 
        u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1;
        u1_end_of_row = (!u1_num_mbs_next) && (!(u1_mbaff && (u1_num_mbs & 0x01)));
        u1_slice_end = !i2_mb_skip_run;
        u1_tfr_n_mb = (u1_num_mbs == ps_dec->u1_recon_mb_grp) || u1_end_of_row
 || u1_slice_end;
        u1_decode_nmb = u1_tfr_n_mb || u1_slice_end;
        ps_cur_mb_info->u1_end_of_slice = u1_slice_end;

 if(u1_decode_nmb)
 {
            ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx, u1_num_mbs);
            u1_num_mbsNby2 = 0;

            ps_parse_mb_data = ps_dec->ps_parse_mb_data;
            ps_dec->ps_part = ps_dec->ps_parse_part_params;

 if(ps_dec->u1_separate_parse)
 {
                ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs,
                                     u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);
                ps_dec->ps_nmb_info +=  u1_num_mbs;
 }
 else
 {
                ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs, u1_num_mbs_next,
                                            u1_tfr_n_mb, u1_end_of_row);
 }
            ps_dec->u2_total_mbs_coded += u1_num_mbs;
 if(u1_tfr_n_mb)
                u1_num_mbs = 0;
            u1_mb_idx = u1_num_mbs;
            ps_dec->u1_mb_idx = u1_num_mbs;
 }
 }

    ps_dec->u4_num_mbs_cur_nmb = 0;
    ps_dec->ps_cur_slice->u4_mbs_in_slice = i2_cur_mb_addr
 - ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice;

    H264_DEC_DEBUG_PRINT(""Mbs in slice: %d\n"", ps_dec->ps_cur_slice->u4_mbs_in_slice);

    ps_dec->u2_cur_slice_num++;

 
 if(ps_dec->u4_first_slice_in_pic != 0)
        ps_dec->ps_parse_cur_slice++;

    ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;
    ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;

 if(ps_dec->u2_total_mbs_coded
 >= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)
 {
        ps_dec->u1_pic_decode_done = 1;
 }

 return 0;

}
","1. WORD32 prev_slice_err)
2. UWORD32 u1_num_mbs, u1_num_mbsNby2;
3. UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
4. WORD32 ret;
5. ret = ih264d_start_of_pic(ps_dec, poc, ps_cur_poc,
6. ps_dec->u4_bs_deblk_thread_created = 1;
7. {
8. ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs - 1;
9. u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row);
10. if(ps_dec->u2_total_mbs_coded
11. WORD32 num_entries;
WORD32 size;
12. (0 == ps_dec->i4_display_delay))
13. ps_dec->ps_cur_slice->i1_slice_beta_offset = 0;
14. ps_dec->ps_parse_cur_slice->slice_type = P_SLICE;
15. break;
16. ps_dec->u4_num_mbs_cur_nmb = u1_num_mbs;
17. u1_decode_nmb = u1_tfr_n_mb || u1_slice_end;
18. ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs, u1_num_mbs_next,
19. ps_dec->u4_num_mbs_cur_nmb = 0;
20. - ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice;","11
14
25
35
81
129
135
147
197
204
228-229
234
253
278
304
307
383
402
413
415","CWE-190,CWE-20,CWE-119"
gdev_pdf_put_params_impl,"gdev_pdf_put_params_impl(gx_device * dev, const gx_device_pdf * save_dev, gs_param_list * plist)
{
    int ecode, code;
    gx_device_pdf *pdev = (gx_device_pdf *) dev;
    float cl = (float)pdev->CompatibilityLevel;
    bool locked = pdev->params.LockDistillerParams, ForOPDFRead;
    gs_param_name param_name;

    pdev->pdf_memory = gs_memory_stable(pdev->memory);
    

    {
        gs_param_string_array ppa;
        gs_param_string pps;

        code = param_read_string_array(plist, (param_name = ""pdfmark""), &ppa);
        switch (code) {
            case 0:
                code = pdfwrite_pdf_open_document(pdev);
                if (code < 0)
                    return code;
                code = pdfmark_process(pdev, &ppa);
                if (code >= 0)
                    return code;
                
            default:
                param_signal_error(plist, param_name, code);
                return code;
            case 1:
                break;
        }

        code = param_read_string_array(plist, (param_name = ""DSC""), &ppa);
        switch (code) {
            case 0:
                code = pdfwrite_pdf_open_document(pdev);
                if (code < 0)
                    return code;
                code = pdf_dsc_process(pdev, &ppa);
                if (code >= 0)
                    return code;
                
            default:
                param_signal_error(plist, param_name, code);
                return code;
            case 1:
                break;
        }

        code = param_read_string(plist, (param_name = ""pdfpagelabels""), &pps);
        switch (code) {
            case 0:
                {
                    if (!pdev->ForOPDFRead) {
                        cos_dict_t *const pcd = pdev->Catalog;
                        code = pdfwrite_pdf_open_document(pdev);
                        if (code < 0)
                            return code;
                        code = cos_dict_put_string(pcd, (const byte *)""/PageLabels"", 11,
                                   pps.data, pps.size);
                        if (code >= 0)
                            return code;
                    } else
                        return 0;
                 }
                
            default:
                param_signal_error(plist, param_name, code);
                return code;
            case 1:
                break;
        }
    }

    
    ecode = param_read_bool(plist, (param_name = ""LockDistillerParams""), &locked);
     if (ecode < 0)
         param_signal_error(plist, param_name, ecode);
    

    {
        int efo = 1;

        ecode = param_put_int(plist, (param_name = "".EmbedFontObjects""), &efo, ecode);
        if (ecode < 0)
            param_signal_error(plist, param_name, ecode);
        if (efo != 1)
            param_signal_error(plist, param_name, ecode = gs_error_rangecheck);
    }
    {
        int cdv = CoreDistVersion;

        ecode = param_put_int(plist, (param_name = ""CoreDistVersion""), &cdv, ecode);
        if (ecode < 0)
            return gs_note_error(ecode);
        if (cdv != CoreDistVersion)
            param_signal_error(plist, param_name, ecode = gs_error_rangecheck);
    }

    switch (code = param_read_float(plist, (param_name = ""CompatibilityLevel""), &cl)) {
        default:
            ecode = code;
            param_signal_error(plist, param_name, ecode);
            break;
        case 0:
            if (!(locked && pdev->params.LockDistillerParams)) {
                
                if (cl < (float)1.15)
                    cl = (float)1.1;
                else if (cl < (float)1.25)
                    cl = (float)1.2;
                else if (cl < (float)1.35)
                    cl = (float)1.3;
                else if (cl < (float)1.45)
                    cl = (float)1.4;
                else if (cl < (float)1.55)
                    cl = (float)1.5;
                else if (cl < (float)1.65)
                    cl = (float)1.6;
                else if (cl < (float)1.75)
                    cl = (float)1.7;
                else {
                    cl = (float)2.0;
                    if (pdev->params.TransferFunctionInfo == tfi_Preserve)
                        pdev->params.TransferFunctionInfo = tfi_Apply;
                }
            }
        case 1:
            break;
    }
    {   
        gs_memory_t *mem = plist->memory;

        plist->memory = pdev->pdf_memory;
        code = gs_param_read_items(plist, pdev, pdf_param_items);
        if (code < 0 || (code = param_read_bool(plist, ""ForOPDFRead"", &ForOPDFRead)) < 0)
        {
        }
        if (code == 0 && !pdev->is_ps2write && !(locked && pdev->params.LockDistillerParams))
            pdev->ForOPDFRead = ForOPDFRead;
        plist->memory = mem;
    }
    if (code < 0)
        ecode = code;
    {
        
        long fon = pdev->FirstObjectNumber;

        if (fon != save_dev->FirstObjectNumber) {
            if (fon <= 0 || fon > 0x7fff0000 ||
                (pdev->next_id != 0 &&
                 pdev->next_id !=
                 save_dev->FirstObjectNumber + pdf_num_initial_ids)
                ) {
                ecode = gs_error_rangecheck;
                param_signal_error(plist, ""FirstObjectNumber"", ecode);
            }
        }
    }
    {
        
        static const char *const pcm_names[] = {
            ""DeviceGray"", ""DeviceRGB"", ""DeviceCMYK"", ""DeviceN"", 0
        };
        int pcm = -1;

        ecode = param_put_enum(plist, ""ProcessColorModel"", &pcm,
                               pcm_names, ecode);
        if (pcm >= 0) {
            pdf_set_process_color_model(pdev, pcm);
            rc_decrement(pdev->icc_struct, ""gdev_pdf_put_params_impl, ProcessColorModel changed"");
            pdev->icc_struct = 0;
        }
    }
    if (ecode < 0)
        goto fail;

    if (pdev->is_ps2write && (code = param_read_bool(plist, ""ProduceDSC"", &pdev->ProduceDSC)) < 0) {
        param_signal_error(plist, param_name, code);
    }

    
    if (pdev->PDFA < 0 || pdev->PDFA > 3){
        ecode = gs_note_error(gs_error_rangecheck);
        param_signal_error(plist, ""PDFA"", ecode);
        goto fail;
    }
    if(pdev->PDFA != 0 && pdev->AbortPDFAX)
        pdev->PDFA = 0;
    if(pdev->PDFX && pdev->AbortPDFAX)
        pdev->PDFX = 0;
    if (pdev->PDFX && pdev->PDFA != 0) {
        ecode = gs_note_error(gs_error_rangecheck);
        param_signal_error(plist, ""PDFA"", ecode);
        goto fail;
    }
    if (pdev->PDFX && pdev->ForOPDFRead) {
        ecode = gs_note_error(gs_error_rangecheck);
        param_signal_error(plist, ""PDFX"", ecode);
        goto fail;
    }
    if (pdev->PDFA != 0 && pdev->ForOPDFRead) {
        ecode = gs_note_error(gs_error_rangecheck);
        param_signal_error(plist, ""PDFA"", ecode);
        goto fail;
    }
    if (pdev->PDFA == 1 || pdev->PDFX || pdev->CompatibilityLevel < 1.4) {
         pdev->HaveTransparency = false;
         pdev->PreserveSMask = false;
    }

    
    if (pdev->PDFX)
        cl = (float)1.3; 
    if (pdev->PDFA != 0 && cl < 1.4)
        cl = (float)1.4;
    pdev->version = (cl < 1.2 ? psdf_version_level2 : psdf_version_ll3);
    if (pdev->ForOPDFRead) {
        pdev->ResourcesBeforeUsage = true;
        pdev->HaveCFF = false;
        pdev->HavePDFWidths = false;
        pdev->HaveStrokeColor = false;
        cl = (float)1.2; 
        pdev->MaxInlineImageSize = max_long; 
        pdev->version = psdf_version_level2;
    } else {
        pdev->ResourcesBeforeUsage = false;
        pdev->HaveCFF = true;
        pdev->HavePDFWidths = true;
        pdev->HaveStrokeColor = true;
    }
    pdev->ParamCompatibilityLevel = cl;
    if (cl < 1.2) {
        pdev->HaveCFF = false;
    }
    ecode = gdev_psdf_put_params(dev, plist);
    if (ecode < 0)
        goto fail;

    if (pdev->CompatibilityLevel > 1.7 && pdev->params.TransferFunctionInfo == tfi_Preserve) {
        pdev->params.TransferFunctionInfo = tfi_Apply;
        emprintf(pdev->memory, ""\nIt is not possible to preserve transfer functions in PDF 2.0\ntransfer functions will be applied instead\n"");
    }

    if (pdev->params.ConvertCMYKImagesToRGB) {
        if (pdev->params.ColorConversionStrategy == ccs_CMYK) {
            emprintf(pdev->memory, ""ConvertCMYKImagesToRGB is not compatible with ColorConversionStrategy of CMYK\n"");
        } else {
            if (pdev->params.ColorConversionStrategy == ccs_Gray) {
                emprintf(pdev->memory, ""ConvertCMYKImagesToRGB is not compatible with ColorConversionStrategy of Gray\n"");
            } else {
                if (pdev->icc_struct)
                    rc_decrement(pdev->icc_struct,
                                 ""reset default profile\n"");
                pdf_set_process_color_model(pdev,1);
                ecode = gsicc_init_device_profile_struct((gx_device *)pdev, NULL, 0);
                if (ecode < 0)
                    goto fail;
            }
        }
    }
    switch (pdev->params.ColorConversionStrategy) {
        case ccs_ByObjectType:
        case ccs_LeaveColorUnchanged:
            break;
        case ccs_UseDeviceDependentColor:
        case ccs_UseDeviceIndependentColor:
        case ccs_UseDeviceIndependentColorForImages:
            pdev->params.TransferFunctionInfo = tfi_Apply;
            break;
        case ccs_CMYK:
            pdev->params.TransferFunctionInfo = tfi_Apply;
            if (pdev->icc_struct)
                rc_decrement(pdev->icc_struct,
                             ""reset default profile\n"");
            pdf_set_process_color_model(pdev, 2);
            ecode = gsicc_init_device_profile_struct((gx_device *)pdev, NULL, 0);
            if (ecode < 0)
                goto fail;
            break;
        case ccs_Gray:
            pdev->params.TransferFunctionInfo = tfi_Apply;
            if (pdev->icc_struct)
                rc_decrement(pdev->icc_struct,
                             ""reset default profile\n"");
            pdf_set_process_color_model(pdev,0);
            ecode = gsicc_init_device_profile_struct((gx_device *)pdev, NULL, 0);
            if (ecode < 0)
                goto fail;
            break;
        case ccs_sRGB:
        case ccs_RGB:
            pdev->params.TransferFunctionInfo = tfi_Apply;
            
            if (!pdev->params.ConvertCMYKImagesToRGB) {
                if (pdev->icc_struct)
                    rc_decrement(pdev->icc_struct,
                                 ""reset default profile\n"");
                pdf_set_process_color_model(pdev,1);
                ecode = gsicc_init_device_profile_struct((gx_device *)pdev, NULL, 0);
                if (ecode < 0)
                    goto fail;
            }
            break;
        default:
            break;
    }
    if (cl < 1.5f && pdev->params.ColorImage.Filter != NULL &&
            !strcmp(pdev->params.ColorImage.Filter, ""JPXEncode"")) {
        emprintf(pdev->memory,
                 ""JPXEncode requires CompatibilityLevel >= 1.5 .\n"");
        ecode = gs_note_error(gs_error_rangecheck);
    }
    if (cl < 1.5f && pdev->params.GrayImage.Filter != NULL &&
            !strcmp(pdev->params.GrayImage.Filter, ""JPXEncode"")) {
        emprintf(pdev->memory,
                 ""JPXEncode requires CompatibilityLevel >= 1.5 .\n"");
        ecode = gs_note_error(gs_error_rangecheck);
    }
    if (cl < 1.4f && pdev->params.MonoImage.Filter != NULL &&
            !strcmp(pdev->params.MonoImage.Filter, ""JBIG2Encode"")) {
        emprintf(pdev->memory,
                 ""JBIG2Encode requires CompatibilityLevel >= 1.4 .\n"");
        ecode = gs_note_error(gs_error_rangecheck);
    }
    if (pdev->HaveTrueTypes && pdev->version == psdf_version_level2) {
        pdev->version = psdf_version_level2_with_TT ;
    }
    if (ecode < 0)
        goto fail;

    if (pdev->FirstObjectNumber != save_dev->FirstObjectNumber) {
        if (pdev->xref.file != 0) {
            if (gp_fseek_64(pdev->xref.file, 0L, SEEK_SET) != 0) {
                ecode = gs_error_ioerror;
                goto fail;
            }
            pdf_initialize_ids(pdev);
        }
    }
    
    pdev->CompatibilityLevel = (int)(cl * 10 + 0.5) / 10.0;
    if(pdev->OwnerPassword.size != save_dev->OwnerPassword.size ||
        (pdev->OwnerPassword.size != 0 &&
         memcmp(pdev->OwnerPassword.data, save_dev->OwnerPassword.data,
         pdev->OwnerPassword.size) != 0)) {
        if (pdev->is_open) {
            if (pdev->PageCount == 0) {
                gs_closedevice((gx_device *)save_dev);
                return 0;
            }
            else
                emprintf(pdev->memory, ""Owner Password changed mid-job, ignoring.\n"");
        }
    }

    if (pdev->Linearise && pdev->is_ps2write) {
        emprintf(pdev->memory, ""Can't linearise PostScript output, ignoring\n"");
        pdev->Linearise = false;
    }

    if (pdev->Linearise && pdev->OwnerPassword.size != 0) {
        emprintf(pdev->memory, ""Can't linearise encrypted PDF, ignoring\n"");
        pdev->Linearise = false;
    }

    if (pdev->FlattenFonts)
        pdev->PreserveTrMode = false;
    return 0;
 fail:
    
    pdev->version = save_dev->version;
    pdf_set_process_color_model(pdev, save_dev->pcm_color_info_index);
    pdev->saved_fill_color = save_dev->saved_fill_color;
    pdev->saved_stroke_color = save_dev->saved_fill_color;
    {
        const gs_param_item_t *ppi = pdf_param_items;

        for (; ppi->key; ++ppi)
            memcpy((char *)pdev + ppi->offset,
                   (char *)save_dev + ppi->offset,
                   gs_param_type_sizes[ppi->type]);
        pdev->ForOPDFRead = save_dev->ForOPDFRead;
    }
    return ecode;
}
","1. gs_param_string_array ppa;
2. if (code >= 0)
3. default:
4. if (code >= 0)
5. param_signal_error(plist, param_name, code);
6. return code;
7. int efo = 1;
8. case 0:
9. else if (cl < (float)1.65)
10. ecode = gs_error_rangecheck;
11. pdf_set_process_color_model(pdev, pcm);
rc_decrement(pdev->icc_struct, ""gdev_pdf_put_params_impl, ProcessColorModel changed"");
pdev->icc_struct = 0;
12. if (pdev->is_ps2write && (code = param_read_bool(plist, ""ProduceDSC"", &pdev->ProduceDSC)) < 0) {
13. if(pdev->PDFX && pdev->AbortPDFAX)
pdev->PDFX = 0;
14. ecode = gs_note_error(gs_error_rangecheck);
15. pdev->HavePDFWidths = true;
16. if (ecode < 0)
17. emprintf(pdev->memory, ""\nIt is not possible to preserve transfer functions in PDF 2.0\ntransfer functions will be applied instead\n"");
18. emprintf(pdev->memory, ""ConvertCMYKImagesToRGB is not compatible with ColorConversionStrategy of CMYK\n"");
19. } else {
20. ""reset default profile\n"");
21. goto fail;
22. ecode = gsicc_init_device_profile_struct((gx_device *)pdev, NULL, 0);
23. break;
24. !strcmp(pdev->params.ColorImage.Filter, ""JPXEncode"")) {
25. ecode = gs_note_error(gs_error_rangecheck);
26. pdev->CompatibilityLevel = (int)(cl * 10 + 0.5) / 10.0;
27. (pdev->OwnerPassword.size != 0 &&
28. emprintf(pdev->memory, ""Can't linearise PostScript output, ignoring\n"");
29. if (pdev->FlattenFonts)
30. memcpy((char *)pdev + ppi->offset,","16
26
29
43
47
65
91
114
130
182
200-202
208
226-227
234
270
278
283
288
292
295
320
328
331
350
353
383
385
399
408
421","CWE-362,CWE-120,CWE-401,CWE-787,CWE-119"
ptrace_check_attach-254710481452250,"static int ptrace_check_attach(struct task_struct *child, bool ignore_state)
{
	int ret = -ESRCH;

	
	read_lock(&tasklist_lock);
	if (child->ptrace && child->parent == current) {
		WARN_ON(child->state == __TASK_TRACED);
		
		if (ignore_state || ptrace_freeze_traced(child))
			ret = 0;
	}
	read_unlock(&tasklist_lock);

	if (!ret && !ignore_state) {
		if (!wait_task_inactive(child, __TASK_TRACED)) {
			
			WARN_ON(child->state == __TASK_TRACED);
			ret = -ESRCH;
		}
	}

	return ret;
}
","1. static int ptrace_check_attach(struct task_struct *child, bool ignore_state)
2. read_lock(&tasklist_lock);
if (child->ptrace && child->parent == current) {
3. if (ignore_state || ptrace_freeze_traced(child))
4. if (!ret && !ignore_state) {
if (!wait_task_inactive(child, __TASK_TRACED)) {
5. ret = -ESRCH;","1
12-13
19
24-25
32","CWE-362,CWE-264,CWE-476,CWE-404,CWE-415"
calc_coeff,"static void calc_coeff(double mu[4], const int index[4], int prefilter, double r2, double mul)
{
    double mul2 = mul * mul, mul3 = mul2 * mul;
    double kernel[] = {
        (5204 + 2520 * mul + 1092 * mul2 + 3280 * mul3) / 12096,
        (2943 -  210 * mul -  273 * mul2 - 2460 * mul3) / 12096,
        ( 486 -  924 * mul -  546 * mul2 +  984 * mul3) / 12096,
         (  17 -  126 * mul +  273 * mul2 -  164 * mul3) / 12096,
     };
 
    double mat_freq[14];
     memcpy(mat_freq, kernel, sizeof(kernel));
     memset(mat_freq + 4, 0, sizeof(mat_freq) - sizeof(kernel));
     int n = 6;
    coeff_filter(mat_freq, n, kernel);
    for (int k = 0; k < 2 * prefilter; ++k)
        coeff_blur121(mat_freq, ++n);

    double vec_freq[13];
    n = index[3] + prefilter + 3;
    calc_gauss(vec_freq, n, r2);
    memset(vec_freq + n + 1, 0, sizeof(vec_freq) - (n + 1) * sizeof(vec_freq[0]));
    n -= 3;
    coeff_filter(vec_freq, n, kernel);
    for (int k = 0; k < prefilter; ++k)
        coeff_blur121(vec_freq, --n);

    double mat[4][4];
    calc_matrix(mat, mat_freq, index);

    double vec[4];
    for (int i = 0; i < 4; ++i)
        vec[i] = mat_freq[0] - mat_freq[index[i]] - vec_freq[0] + vec_freq[index[i]];

    for (int i = 0; i < 4; ++i) {
        double res = 0;
        for (int j = 0; j < 4; ++j)
            res += mat[i][j] * vec[j];
        mu[i] = FFMAX(0, res);
    }
}
","1. double mul2 = mul * mul, mul3 = mul2 * mul;
2. (2943 -  210 * mul -  273 * mul2 - 2460 * mul3) / 12096,
3. (  17 -  126 * mul +  273 * mul2 -  164 * mul3) / 12096,
4. double mat_freq[14];
memcpy(mat_freq, kernel, sizeof(kernel));
5. int n = 6;
6. n = index[3] + prefilter + 3;
7. memset(vec_freq + n + 1, 0, sizeof(vec_freq) - (n + 1) * sizeof(vec_freq[0]));
8. coeff_filter(vec_freq, n, kernel);
9. calc_matrix(mat, mat_freq, index);
10. double vec[4];
11. vec[i] = mat_freq[0] - mat_freq[index[i]] - vec_freq[0] + vec_freq[index[i]];
12. res += mat[i][j] * vec[j];","3
6
8
11-12
14
20
22
24
29
31
33
38","CWE-190,CWE-20,CWE-125,CWE-189"
m_stop-189621141927057,"static void m_stop(struct seq_file *m, void *v)
{
	struct proc_maps_private *priv = m->private;
	struct vm_area_struct *vma = v;

	if (!IS_ERR(vma))
		vma_stop(priv, vma);
	if (priv->task)
		put_task_struct(priv->task);
}
","1. static void m_stop(struct seq_file *m, void *v)
2. struct proc_maps_private *priv = m->private;
3. vma_stop(priv, vma);
if (priv->task)
put_task_struct(priv->task);","1
3
7-9","CWE-20,CWE-416,CWE-190,CWE-200,CWE-400"
print_prefix,"print_prefix(netdissect_options *ndo, const u_char *prefix, u_int max_length)
{
    int plenbytes;
    char buf[sizeof(""xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx::/128"")];

    if (prefix[0] >= 96 && max_length >= IPV4_MAPPED_HEADING_LEN + 1 &&
        is_ipv4_mapped_address(&prefix[1])) {
        struct in_addr addr;
        u_int plen;

        plen = prefix[0]-96;
        if (32 < plen)
            return -1;
        max_length -= 1;

        memset(&addr, 0, sizeof(addr));
        plenbytes = (plen + 7) / 8;
        if (max_length < (u_int)plenbytes + IPV4_MAPPED_HEADING_LEN)
            return -3;
        memcpy(&addr, &prefix[1 + IPV4_MAPPED_HEADING_LEN], plenbytes);
        if (plen % 8) {
		((u_char *)&addr)[plenbytes - 1] &=
			((0xff00 >> (plen % 8)) & 0xff);
	}
	snprintf(buf, sizeof(buf), ""%s/%d"", ipaddr_string(ndo, &addr), plen);
         plenbytes += 1 + IPV4_MAPPED_HEADING_LEN;
     } else {
         plenbytes = decode_prefix6(ndo, prefix, max_length, buf, sizeof(buf));
        if (plenbytes < 0)
            return plenbytes;
     }
 
     ND_PRINT((ndo, ""%s"", buf));
    return plenbytes;
}
","1. print_prefix(netdissect_options *ndo, const u_char *prefix, u_int max_length)
2. int plenbytes;
3. if (prefix[0] >= 96 && max_length >= IPV4_MAPPED_HEADING_LEN + 1 &&
is_ipv4_mapped_address(&prefix[1])) {
struct in_addr addr;
4. plen = prefix[0]-96;
5. return -1;
max_length -= 1;
6. ((u_char *)&addr)[plenbytes - 1] &=
7. plenbytes = decode_prefix6(ndo, prefix, max_length, buf, sizeof(buf));
8. return plenbytes;","1
3
6-8
11
13-14
22
28
34","CWE-125,CWE-19,CWE-119"
ReadCALSImage,"
#define ExceptionInfo
#define ImageInfo

static Image *ReadCALSImage(const ImageInfo *image_info,
  ExceptionInfo *exception)
{
  char
    filename[MagickPathExtent],
    header[MagickPathExtent],
    message[MagickPathExtent];

  FILE
    *file;

  Image
    *image;

  ImageInfo
    *read_info;

  int
    c,
    unique_file;

  MagickBooleanType
    status;

  register ssize_t
    i;

  unsigned long
    density,
    direction,
    height,
    orientation,
    pel_path,
    type,
    width;

  
  assert(image_info != (const ImageInfo *) NULL);
  assert(image_info->signature == MagickCoreSignature);
  if (image_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
      image_info->filename);
  assert(exception != (ExceptionInfo *) NULL);
  assert(exception->signature == MagickCoreSignature);
  image=AcquireImage(image_info,exception);
  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);
  if (status == MagickFalse)
    {
      image=DestroyImageList(image);
      return((Image *) NULL);
    }
  
  (void) memset(header,0,sizeof(header));
  density=0;
  direction=0;
  orientation=1;
  pel_path=0;
  type=1;
  width=0;
  height=0;
  for (i=0; i < 16; i++)
  {
    if (ReadBlob(image,128,(unsigned char *) header) != 128)
      break;
    switch (*header)
    {
      case 'R':
      case 'r':
      {
        if (LocaleNCompare(header,""rdensty:"",8) == 0)
          {
            (void) sscanf(header+8,""%lu"",&density);
            break;
          }
        if (LocaleNCompare(header,""rpelcnt:"",8) == 0)
          {
            (void) sscanf(header+8,""%lu,%lu"",&width,&height);
            break;
          }
        if (LocaleNCompare(header,""rorient:"",8) == 0)
          {
            (void) sscanf(header+8,""%lu,%lu"",&pel_path,&direction);
            if (pel_path == 90)
              orientation=5;
            else
              if (pel_path == 180)
                orientation=3;
              else
                if (pel_path == 270)
                  orientation=7;
            if (direction == 90)
              orientation++;
            break;
          }
        if (LocaleNCompare(header,""rtype:"",6) == 0)
          {
            (void) sscanf(header+6,""%lu"",&type);
            break;
          }
        break;
      }
    }
  }
  
  file=(FILE *) NULL;
  unique_file=AcquireUniqueFileResource(filename);
  if (unique_file != -1)
    file=fdopen(unique_file,""wb"");
   if ((unique_file == -1) || (file == (FILE *) NULL))
     ThrowImageException(FileOpenError,""UnableToCreateTemporaryFile"");
   while ((c=ReadBlobByte(image)) != EOF)
    if (fputc(c,file) != c)
      break;
   (void) fclose(file);
   (void) CloseBlob(image);
   image=DestroyImage(image);
  read_info=CloneImageInfo(image_info);
  SetImageInfoBlob(read_info,(void *) NULL,0);
  (void) FormatLocaleString(read_info->filename,MagickPathExtent,""group4:%s"",
    filename);
  (void) FormatLocaleString(message,MagickPathExtent,""%lux%lu"",width,height);
  (void) CloneString(&read_info->size,message);
  (void) FormatLocaleString(message,MagickPathExtent,""%lu"",density);
  (void) CloneString(&read_info->density,message);
  read_info->orientation=(OrientationType) orientation;
  image=ReadImage(read_info,exception);
  if (image != (Image *) NULL)
    {
      (void) CopyMagickString(image->filename,image_info->filename,
        MagickPathExtent);
      (void) CopyMagickString(image->magick_filename,image_info->filename,
        MagickPathExtent);
      (void) CopyMagickString(image->magick,""CALS"",MagickPathExtent);
    }
  read_info=DestroyImageInfo(read_info);
  (void) RelinquishUniqueFileResource(filename);
  return(image);
}
","1. *read_info;
2. height,
3. image=AcquireImage(image_info,exception);
4. image=DestroyImageList(image);
return((Image *) NULL);
5. density=0;
direction=0;
6. pel_path=0;
7. width=0;
height=0;
8. if (LocaleNCompare(header,""rpelcnt:"",8) == 0)
9. if (pel_path == 270)
10. if (LocaleNCompare(header,""rtype:"",6) == 0)
11. SetImageInfoBlob(read_info,(void *) NULL,0);
12. (void) CopyMagickString(image->magick_filename,image_info->filename,","20
35
51
55-56
62-63
65
67-68
83
97
103
128
141","CWE-772,CWE-20,CWE-119"
WaitForCallback,"   void WaitForCallback() {
     if (!use_audio_thread_) {
       base::RunLoop().RunUntilIdle();
       return;
     }
    WaitableMessageLoopEvent event;
     audio_thread_.task_runner()->PostTaskAndReply(
         FROM_HERE, base::Bind(&base::DoNothing), event.GetClosure());
    event.RunAndWait();
    base::RunLoop().RunUntilIdle();
  }
","1. void WaitForCallback() {
2. WaitableMessageLoopEvent event;
3. event.RunAndWait();
base::RunLoop().RunUntilIdle();","1
6
9-10","CWE-354,CWE-189,CWE-119"
netscreen_read,"static gboolean netscreen_read(wtap *wth, int *err, gchar **err_info,
     gint64 *data_offset)
 {
 	gint64		offset;
 	char		line[NETSCREEN_LINE_LENGTH];
 
 	
 	offset = netscreen_seek_next_packet(wth, err, err_info, line);
 	if (offset < 0)
 		return FALSE;
 
	
	if (!parse_netscreen_packet(wth->fh, &wth->phdr,
	    wth->frame_buffer, line, err, err_info))
 		return FALSE;
 
 	
	if (wth->file_encap == WTAP_ENCAP_UNKNOWN)
		wth->file_encap = wth->phdr.pkt_encap;
	else {
		if (wth->file_encap != wth->phdr.pkt_encap)
			wth->file_encap = WTAP_ENCAP_PER_PACKET;
	}

	*data_offset = offset;
	return TRUE;
}
","1. static gboolean netscreen_read(wtap *wth, int *err, gchar **err_info,
2. gint64		offset;
3. offset = netscreen_seek_next_packet(wth, err, err_info, line);
if (offset < 0)
return FALSE;
4. wth->frame_buffer, line, err, err_info))
return FALSE;
5. if (wth->file_encap == WTAP_ENCAP_UNKNOWN)
6. wth->file_encap = WTAP_ENCAP_PER_PACKET;","1
4
8-10
14-15
25
29","CWE-264,CWE-119"
alias_for_import_name-199722912488726,"static alias_ty
alias_for_import_name(struct compiling *c, const node *n, int store)
{
    
    identifier str, name;

 loop:
    switch (TYPE(n)) {
        case import_as_name: {
            node *name_node = CHILD(n, 0);
            str = NULL;
            name = NEW_IDENTIFIER(name_node);
            if (!name)
                return NULL;
            if (NCH(n) == 3) {
                node *str_node = CHILD(n, 2);
                str = NEW_IDENTIFIER(str_node);
                if (!str)
                    return NULL;
                if (store && forbidden_name(c, str, str_node, 0))
                    return NULL;
            }
            else {
                if (forbidden_name(c, name, name_node, 0))
                    return NULL;
            }
            return alias(name, str, c->c_arena);
        }
        case dotted_as_name:
            if (NCH(n) == 1) {
                n = CHILD(n, 0);
                goto loop;
            }
            else {
                node *asname_node = CHILD(n, 2);
                alias_ty a = alias_for_import_name(c, CHILD(n, 0), 0);
                if (!a)
                    return NULL;
                assert(!a->asname);
                a->asname = NEW_IDENTIFIER(asname_node);
                if (!a->asname)
                    return NULL;
                if (forbidden_name(c, a->asname, asname_node, 0))
                    return NULL;
                return a;
            }
            break;
        case dotted_name:
            if (NCH(n) == 1) {
                node *name_node = CHILD(n, 0);
                name = NEW_IDENTIFIER(name_node);
                if (!name)
                    return NULL;
                if (store && forbidden_name(c, name, name_node, 0))
                    return NULL;
                return alias(name, NULL, c->c_arena);
            }
            else {
                
                int i;
                size_t len;
                char *s;
                PyObject *uni;

                len = 0;
                for (i = 0; i < NCH(n); i += 2)
                    
                    len += strlen(STR(CHILD(n, i))) + 1;
                len--; 
                str = PyBytes_FromStringAndSize(NULL, len);
                if (!str)
                    return NULL;
                s = PyBytes_AS_STRING(str);
                if (!s)
                    return NULL;
                for (i = 0; i < NCH(n); i += 2) {
                    char *sch = STR(CHILD(n, i));
                    strcpy(s, STR(CHILD(n, i)));
                    s += strlen(sch);
                    *s++ = '.';
                }
                --s;
                *s = '\0';
                uni = PyUnicode_DecodeUTF8(PyBytes_AS_STRING(str),
                                           PyBytes_GET_SIZE(str),
                                           NULL);
                Py_DECREF(str);
                if (!uni)
                    return NULL;
                str = uni;
                PyUnicode_InternInPlace(&str);
                if (PyArena_AddPyObject(c->c_arena, str) < 0) {
                    Py_DECREF(str);
                    return NULL;
                }
                return alias(str, NULL, c->c_arena);
            }
            break;
        case STAR:
            str = PyUnicode_InternFromString(""*"");
            if (!str)
                return NULL;
            if (PyArena_AddPyObject(c->c_arena, str) < 0) {
                Py_DECREF(str);
                return NULL;
            }
            return alias(str, NULL, c->c_arena);
        default:
            PyErr_Format(PyExc_SystemError,
                         ""unexpected import name: %d"", TYPE(n));
            return NULL;
    }

    PyErr_SetString(PyExc_SystemError, ""unhandled import name condition"");
    return NULL;
}
","1. alias_for_import_name(struct compiling *c, const node *n, int store)
2. loop:
3. name = NEW_IDENTIFIER(name_node);
4. return NULL;
5. else {
6. return NULL;
7. assert(!a->asname);
8. if (forbidden_name(c, a->asname, asname_node, 0))
9. return NULL;
10. return NULL;
return alias(name, NULL, c->c_arena);
11. len += strlen(STR(CHILD(n, i))) + 1;
len--;
12. return NULL;
13. NULL);
14. if (PyArena_AddPyObject(c->c_arena, str) < 0) {
15. return alias(str, NULL, c->c_arena);
16. ""unexpected import name: %d"", TYPE(n));","2
11
16
18
27
29
43
47
57
59-60
72-73
79
90
96
111
114","CWE-191,CWE-125,CWE-78,CWE-119"
image_transform_png_set_expand_gray_1_2_4_to_8_set," image_transform_png_set_expand_gray_1_2_4_to_8_set(
    const image_transform *this, transform_display *that, png_structp pp,
     png_infop pi)
 {
    png_set_expand_gray_1_2_4_to_8(pp);
   
    this->next->set(this->next, that, pp, pi);
 }
","1. image_transform_png_set_expand_gray_1_2_4_to_8_set(
const image_transform *this, transform_display *that, png_structp pp,
png_infop pi)
2. png_set_expand_gray_1_2_4_to_8(pp);
3. this->next->set(this->next, that, pp, pi);","1-3
5
7","CWE-189,CWE-119"
append_utf8_value,"append_utf8_value (const unsigned char *value, size_t length,
                   struct stringbuf *sb)
{
  unsigned char tmp[6];
  const unsigned char *s;
  size_t n;
  int i, nmore;

  if (length && (*value == ' ' || *value == '#'))
    {
      tmp[0] = '\\';
      tmp[1] = *value;
      put_stringbuf_mem (sb, tmp, 2);
      value++;
      length--;
    }
  if (length && value[length-1] == ' ')
    {
      tmp[0] = '\\';
      tmp[1] = ' ';
      put_stringbuf_mem (sb, tmp, 2);
       length--;
     }
 
   for (s=value, n=0;;)
     {
       for (value = s; n < length && !(*s & 0x80); n++, s++)
      for (value = s; n < length && !(*s & 0x80); n++, s++)
        ;
         append_quoted (sb, value, s-value, 0);
       if (n==length)
         return; 
      if (!(*s & 0x80))
        nmore = 0; 
      else if ( (*s & 0xe0) == 0xc0 ) 
         nmore = 1;
       else if ( (*s & 0xf0) == 0xe0 ) 
         nmore = 2;
      else if ( (*s & 0xf8) == 0xf0 ) 
        nmore = 3;
      else if ( (*s & 0xfc) == 0xf8 ) 
         nmore = 4;
       else if ( (*s & 0xfe) == 0xfc ) 
         nmore = 5;
      else 
        nmore = 0;
 
      if (!nmore)
         {
          
          snprintf (tmp, sizeof tmp, ""\\%02X"", *s);
          put_stringbuf_mem (sb, tmp, 3);
          s++; n++;
        }
      else
        {
          if (n+nmore > length)
            nmore = length - n; 

          tmp[0] = *s++; n++;
          for (i=1; i <= nmore; i++)
            {
              if ( (*s & 0xc0) != 0x80)
                break; 
              tmp[i] = *s++;
              n++;
            }
          put_stringbuf_mem (sb, tmp, i);
         }
     }
 }
","1. struct stringbuf *sb)
2. tmp[1] = *value;
3. value++;
4. if (length && value[length-1] == ' ')
5. put_stringbuf_mem (sb, tmp, 2);
6. for (value = s; n < length && !(*s & 0x80); n++, s++)
7. if (n==length)
return;
if (!(*s & 0x80))
8. nmore = 1;
9. nmore = 2;
else if ( (*s & 0xf8) == 0xf0 )
10. nmore = 5;
11. snprintf (tmp, sizeof tmp, ""\\%02X"", *s);
12. {
if (n+nmore > length)
nmore = length - n;
13. tmp[0] = *s++; n++;
14. if ( (*s & 0xc0) != 0x80)
15. n++;","2
12
14
17
21
28
31-33
36
38-39
44
51
56-58
60
63
66","CWE-190,CWE-189,CWE-119"
